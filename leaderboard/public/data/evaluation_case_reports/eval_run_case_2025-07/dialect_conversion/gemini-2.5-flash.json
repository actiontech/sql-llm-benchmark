[
    {
        "indicator_name": "big_sql_conversion.jsonl",
        "indicator_weight": 4,
        "evaluation_type": "hybrid",
        "case_pass_count": 9,
        "case_wrong_count": 6,
        "correct_rate": 0.6,
        "case_datas": [
            {
                "case_id": "1",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"1\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE OR REPLACE PROCEDURE \\\"UPLOAD_MULTISCAN_P\\\" as cursor c_data is select * from CNL_SYS.multiscan_data_load where nvl(status, 'NULL') != 'OK'; p_ok number; p_message varchar2(1000); begin for r_data in c_data loop cnl_multiscan_pck.proc_data_p(r_data.USERS, r_data.client_id, r_data.SKU_ID, r_data.NBR_TRCK_LVLS, r_data.pallet_type, r_data.track_level_1, r_data.each_depth, r_data.each_width, r_data.each_height, r_data.each_weight, r_data.track_level_2, r_data.ratio_1_to_2, r_data.depth_2, r_data.width_2, r_data.height_2, r_data.weight_2, r_data.track_level_3, r_data.ratio_2_to_3, r_data.depth_3, r_data.width_3, r_data.height_3, r_data.weight_3, r_data.track_level_4, r_data.ratio_3_to_4, r_data.depth_4, r_data.width_4, r_data.height_4, r_data.weight_4, r_data.track_level_5, r_data.ratio_4_to_5, r_data.depth_5, r_data.width_5, r_data.height_5, r_data.weight_5, r_data.track_level_6, r_data.ratio_5_to_6, r_data.depth_6, r_data.width_6, r_data.height_6, r_data.weight_6, r_data.track_level_7, r_data.ratio_6_to_7, r_data.depth_7, r_data.width_7, r_data.height_7, r_data.weight_7, r_data.track_level_8, r_data.ratio_7_to_8, r_data.depth_8, r_data.width_8, r_data.height_8, r_data.weight_8, r_data.layer_height, r_data.each_per_layer, r_data.num_layers, p_ok, p_message); update multiscan_data_load set status = case when p_ok = 1 then 'OK' when p_ok = 0 then 'Not OK' end, response_message = p_message where sku_id = r_data.SKU_ID; end loop; exception when others then null; end;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PROCEDURE \"UPLOAD_MULTISCAN_P\" as cursor c_data is select * from CNL_SYS.multiscan_data_load where nvl(status, 'NULL') != 'OK'; p_ok number; p_message varchar2(1000); begin for r_data in c_data loop cnl_multiscan_pck.proc_data_p(r_data.USERS, r_data.client_id, r_data.SKU_ID, r_data.NBR_TRCK_LVLS, r_data.pallet_type, r_data.track_level_1, r_data.each_depth, r_data.each_width, r_data.each_height, r_data.each_weight, r_data.track_level_2, r_data.ratio_1_to_2, r_data.depth_2, r_data.width_2, r_data.height_2, r_data.weight_2, r_data.track_level_3, r_data.ratio_2_to_3, r_data.depth_3, r_data.width_3, r_data.height_3, r_data.weight_3, r_data.track_level_4, r_data.ratio_3_to_4, r_data.depth_4, r_data.width_4, r_data.height_4, r_data.weight_4, r_data.track_level_5, r_data.ratio_4_to_5, r_data.depth_5, r_data.width_5, r_data.height_5, r_data.weight_5, r_data.track_level_6, r_data.ratio_5_to_6, r_data.depth_6, r_data.width_6, r_data.height_6, r_data.weight_6, r_data.track_level_7, r_data.ratio_6_to_7, r_data.depth_7, r_data.width_7, r_data.height_7, r_data.weight_7, r_data.track_level_8, r_data.ratio_7_to_8, r_data.depth_8, r_data.width_8, r_data.height_8, r_data.weight_8, r_data.layer_height, r_data.each_per_layer, r_data.num_layers, p_ok, p_message); update multiscan_data_load set status = case when p_ok = 1 then 'OK' when p_ok = 0 then 'Not OK' end, response_message = p_message where sku_id = r_data.SKU_ID; end loop; exception when others then null; end;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE \"UPLOAD_MULTISCAN_P\" as cursor c_data is select * from CNL_SYS.multiscan_data_load where nvl(status, 'NULL') != 'OK'; p_ok number; p_message varchar2(1000); begin for r_data in c_data loop cnl_multiscan_pck.proc_data_p(r_data.USERS, r_data.client_id, r_data.SKU_ID, r_data.NBR_TRCK_LVLS, r_data.pallet_type, r_data.track_level_1, r_data.each_depth, r_data.each_width, r_data.each_height, r_data.each_weight, r_data.track_level_2, r_data.ratio_1_to_2, r_data.depth_2, r_data.width_2, r_data.height_2, r_data.weight_2, r_data.track_level_3, r_data.ratio_2_to_3, r_data.depth_3, r_data.width_3, r_data.height_3, r_data.weight_3, r_data.track_level_4, r_data.ratio_3_to_4, r_data.depth_4, r_data.width_4, r_data.height_4, r_data.weight_4, r_data.track_level_5, r_data.ratio_4_to_5, r_data.depth_5, r_data.width_5, r_data.height_5, r_data.weight_5, r_data.track_level_6, r_data.ratio_5_to_6, r_data.depth_6, r_data.width_6, r_data.height_6, r_data.weight_6, r_data.track_level_7, r_data.ratio_6_to_7, r_data.depth_7, r_data.width_7, r_data.height_7, r_data.weight_7, r_data.track_level_8, r_data.ratio_7_to_8, r_data.depth_8, r_data.width_8, r_data.height_8, r_data.weight_8, r_data.layer_height, r_data.each_per_layer, r_data.num_layers, p_ok, p_message); update multiscan_data_load set status = case when p_ok = 1 then 'OK' when p_ok = 0 then 'Not OK' end, response_message = p_message where sku_id = r_data.SKU_ID; end loop; exception when others then null; end;"
                    }
                ]
            },
            {
                "case_id": "2",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"2\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"DELIMITER $$ CREATE OR REPLACE PROCEDURE \\\"SP_FEE_MAINTENANCE_DAILY_JOB\\\" IS V_FLAG varchar2(50); V_HOUR VARCHAR2(50); OUTCURSOR PKG_CURSOR.T_CURSOR; BEGIN select open_mode into V_FLAG from v$database; SELECT TO_CHAR(SYSDATE,'HH24') INTO V_HOUR FROM DUAL; IF V_FLAG = 'READ WRITE' AND (V_HOUR ='09' OR V_HOUR ='11' OR V_HOUR ='13' OR V_HOUR ='15' OR V_HOUR ='17') then P_LOG_EXCEPTION('开始时间:' || sysdate, 'SP_FEE_MAINTENANCE_DAILY_JOB'); update FMM_OPERATION_RELEVANCE f set f.relate_order_no = (select vcr.apply_no from VRM_COMPLETION_REPORT vcr where vcr.completion_report_id = f.related_id) where related_name = '修船' and relate_order_no is null; update FMM_OPERATION_RELEVANCE f set f.relate_order_no = (select vcr.apply_no from VRM_COMPLETION_REPORT vcr where vcr.completion_report_id = f.related_id) where related_name = '修船通导' and relate_order_no is null; update FMM_OPERATION_RELEVANCE f set f.relate_order_no = (select guide.ODDNUMBER from FMM_SHIP_GUIDE guide where guide.ship_guide_id = f.related_id) where related_name = '修船通导' and relate_order_no is null; update FMM_OPERATION_RELEVANCE f set f.relate_order_no = (select macm.apply_no from mtr_apply_confirm_mtr macm where macm.apply_confirm_mtr_id = nvl(f.apply_confirm_id, f.related_id)) where related_name = '物料' and relate_order_no is null; update FMM_OPERATION_RELEVANCE f set f.relate_order_no = (select sac.apply_no from sps_apply_confirm sac where sac.apply_confirm_id = nvl(f.apply_confirm_id, f.related_id)) where related_name = '备件' and relate_order_no is null; commit; UPDATE fmm_fee_invoice F SET F.SEND_SAP_DATE = (SELECT V.START_DATE FROM (select PI.START_DATE, N.PAYMENT_NO, N.SEND_DATE, i.fee_invoice_id, i.send_sap_date from wfl_process_instance pi inner join fmm_fee_payment_notice n on pi.business_id = n.payment_notice_id inner join fmm_fee_invoice i on n.payment_no = i.order_no where pi.state = 1) V WHERE F.FEE_INVOICE_ID = V.fee_invoice_id AND V.PAYMENT_NO LIKE 'F%') WHERE F.SEND_SAP_DATE IS NULL AND F.ORDER_NO LIKE 'F%'; UPDATE fmm_fee_invoice F SET F.Invoice_Status = '4' WHERE F.SEND_SAP_DATE IS NOT NULL AND F.INVOICE_STATUS = '3' AND F.ORDER_NO LIKE 'F%'; commit; delete from FMM_LUBE_CSBC_ESTI WHERE RELATED_ID IN (SELECT RELATED_ID FROM vw_FMM_LUBE_CSBC_ESTI0 where trunc(update_time) = trunc(sysdate)); insert into FMM_LUBE_CSBC_ESTI select * from vw_FMM_LUBE_CSBC_ESTI0 where trunc(update_time) = trunc(sysdate); delete from FMM_LUBE_CSBC_INVOICE where fee_invoice_id in (select fee_invoice_id from vw_FMM_LUBE_CSBC_INVOICE0 where trunc(update_time) = trunc(sysdate)); insert into FMM_LUBE_CSBC_INVOICE select * from vw_FMM_LUBE_CSBC_INVOICE0 where trunc(update_time) = trunc(sysdate); commit; delete from FEE_RELEVANCE_GET_ORDER where fee_invoice_id in (select fee_invoice_id from vw_fee_relevance_get_order0 where trunc(update_time) = trunc(sysdate)); insert into FEE_RELEVANCE_GET_ORDER select * from vw_fee_relevance_get_order0 where trunc(update_time) = trunc(sysdate); commit; delete from fmm_maintenance_expec_rpt WHERE RELATED_ID IN (SELECT RELATED_ID FROM vw_fmm_maintenance_expec_rp0 where trunc(update_time) = trunc(sysdate)); insert into fmm_maintenance_expec_rpt select * from vw_fmm_maintenance_expec_rp0 where trunc(update_time) = trunc(sysdate); commit; delete FROM FMM_MAINTENANCE_ESTI_RPT WHERE RELATED_ID IN (SELECT RELATED_ID FROM VW_FMM_MAINTENANCE_ESTI_RP0 where trunc(update_time) = trunc(sysdate)); insert into FMM_MAINTENANCE_ESTI_RPT select * from VW_FMM_MAINTENANCE_ESTI_RP0 where trunc(update_time) = trunc(sysdate); commit; delete from fmm_maintenance_fee_payee pay where (order_no,payee,vessel_code) in (select order_no,payee,vessel_code from vw_fmm_maintenance_fee_payee0 where trunc(updated_dtm_loc) = trunc(sysdate)); insert into fmm_maintenance_fee_payee select * from vw_fmm_maintenance_fee_payee0 where trunc(updated_dtm_loc) = trunc(sysdate); commit; delete from fmm_maintenance_fee_payee f where (NVL(F.ORDER_NO, 'AAA'),F.VESSEL_CODE) in (select apply_no,vessel_code from VW_FMM_MAINTENANCE_NO_PAYALL); delete from FMM_MAINTENANCE_INVOICE_DEL where fee_invoice_id in (select fee_invoice_id from VW_FMM_MAINTENANCE_INVOICE_DE0 where trunc(update_time) = trunc(sysdate)); insert into FMM_MAINTENANCE_INVOICE_DEL select * from VW_FMM_MAINTENANCE_INVOICE_DE0 where trunc(update_time) = trunc(sysdate); commit; delete from fmm_maintenance_invoice_rpt where fee_invoice_id in (select fee_invoice_id from vw_fmm_maintenance_invoice_rp0 where trunc(update_time) = trunc(sysdate)); insert into fmm_maintenance_invoice_rpt select * from vw_fmm_maintenance_invoice_rp0 where trunc(update_time) = trunc(sysdate); commit; delete from fmm_maintenance_invoice_rp5 where fee_invoice_id in (select fee_invoice_id from vw_fmm_maintenance_invoice_rp6 where trunc(update_time) = trunc(sysdate)); insert into fmm_maintenance_invoice_rp5 select * from vw_fmm_maintenance_invoice_rp6 where trunc(update_time) = trunc(sysdate); commit; delete from FMM_MAINTENANCE_ORDER_RPT where RELATED_ID in (select RELATED_ID from VW_FMM_MAINTENANCE_ORDER_RP0 where trunc(update_time) = trunc(sysdate)); insert into FMM_MAINTENANCE_ORDER_RPT select * from VW_FMM_MAINTENANCE_ORDER_RP0 where trunc(update_time) = trunc(sysdate); commit; delete from fmm_maintenance_supply_rpt where RELATED_ID in (select RELATED_ID from vw_fmm_maintenance_supply_rp0 where trunc(update_time) = trunc(sysdate)); insert into fmm_maintenance_supply_rpt select * from vw_fmm_maintenance_supply_rp0 where trunc(update_time) = trunc(sysdate); commit; DELETE FROM FMM_MAINTENANCE_ESTI_INV; INSERT INTO FMM_MAINTENANCE_ESTI_INV SELECT * FROM VW_FMM_MAINTENANCE_ESTI_INV VW; commit; BEGIN FOR CUR_BFM IN (select pi.business_id,pv.process_variable_id,pv.process_instance_id,pv.variable_value,case cc.IS_SHIP_ACTUAL_AFFIRM when '10' then '部分签收已完成' when '11' then '全部签收已完成' else '未签收' end as SHIP_ACTUAL_AFFIRM from wfl_process_variable pv left join wfl_process_instance pi on pi.process_instance_id = pv.process_instance_id left join bfm_purchase_order cc on cc.po_number=pi.business_id where pv.variable_name = 'display' and pi.business_id in (select t.po_number from bfm_purchase_order t where t.oil_type='002' and t.order_status in ('7','8') and t.created_dtm_loc > TO_DATE ('2018-01-01', 'YYYY-mm-dd'))) LOOP update wfl_process_variable tt set tt.variable_value = case when instr(tt.variable_value,'_',1) =0 then tt.variable_value else substr(tt.variable_value,1,instr(tt.variable_value,'_',1)-1) end where tt.process_variable_id=CUR_BFM.process_variable_id; commit; update wfl_process_variable tt set tt.variable_value = tt.variable_value || '_' || CUR_BFM.SHIP_ACTUAL_AFFIRM where tt.process_variable_id=CUR_BFM.process_variable_id; commit; END LOOP; END; P_LOG_EXCEPTION(SQLCODE || SQLERRM || 'insert 结束时间:' || sysdate, 'SP_FEE_MAINTENANCE_DAILY_JOB'); COMMIT; END IF; END SP_FEE_MAINTENANCE_DAILY_JOB; $$\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nDELIMITER $$ CREATE OR REPLACE PROCEDURE \"SP_FEE_MAINTENANCE_DAILY_JOB\" IS V_FLAG varchar2(50); V_HOUR VARCHAR2(50); OUTCURSOR PKG_CURSOR.T_CURSOR; BEGIN select open_mode into V_FLAG from v$database; SELECT TO_CHAR(SYSDATE,'HH24') INTO V_HOUR FROM DUAL; IF V_FLAG = 'READ WRITE' AND (V_HOUR ='09' OR V_HOUR ='11' OR V_HOUR ='13' OR V_HOUR ='15' OR V_HOUR ='17') then P_LOG_EXCEPTION('开始时间:' || sysdate, 'SP_FEE_MAINTENANCE_DAILY_JOB'); update FMM_OPERATION_RELEVANCE f set f.relate_order_no = (select vcr.apply_no from VRM_COMPLETION_REPORT vcr where vcr.completion_report_id = f.related_id) where related_name = '修船' and relate_order_no is null; update FMM_OPERATION_RELEVANCE f set f.relate_order_no = (select vcr.apply_no from VRM_COMPLETION_REPORT vcr where vcr.completion_report_id = f.related_id) where related_name = '修船通导' and relate_order_no is null; update FMM_OPERATION_RELEVANCE f set f.relate_order_no = (select guide.ODDNUMBER from FMM_SHIP_GUIDE guide where guide.ship_guide_id = f.related_id) where related_name = '修船通导' and relate_order_no is null; update FMM_OPERATION_RELEVANCE f set f.relate_order_no = (select macm.apply_no from mtr_apply_confirm_mtr macm where macm.apply_confirm_mtr_id = nvl(f.apply_confirm_id, f.related_id)) where related_name = '物料' and relate_order_no is null; update FMM_OPERATION_RELEVANCE f set f.relate_order_no = (select sac.apply_no from sps_apply_confirm sac where sac.apply_confirm_id = nvl(f.apply_confirm_id, f.related_id)) where related_name = '备件' and relate_order_no is null; commit; UPDATE fmm_fee_invoice F SET F.SEND_SAP_DATE = (SELECT V.START_DATE FROM (select PI.START_DATE, N.PAYMENT_NO, N.SEND_DATE, i.fee_invoice_id, i.send_sap_date from wfl_process_instance pi inner join fmm_fee_payment_notice n on pi.business_id = n.payment_notice_id inner join fmm_fee_invoice i on n.payment_no = i.order_no where pi.state = 1) V WHERE F.FEE_INVOICE_ID = V.fee_invoice_id AND V.PAYMENT_NO LIKE 'F%') WHERE F.SEND_SAP_DATE IS NULL AND F.ORDER_NO LIKE 'F%'; UPDATE fmm_fee_invoice F SET F.Invoice_Status = '4' WHERE F.SEND_SAP_DATE IS NOT NULL AND F.INVOICE_STATUS = '3' AND F.ORDER_NO LIKE 'F%'; commit; delete from FMM_LUBE_CSBC_ESTI WHERE RELATED_ID IN (SELECT RELATED_ID FROM vw_FMM_LUBE_CSBC_ESTI0 where trunc(update_time) = trunc(sysdate)); insert into FMM_LUBE_CSBC_ESTI select * from vw_FMM_LUBE_CSBC_ESTI0 where trunc(update_time) = trunc(sysdate); delete from FMM_LUBE_CSBC_INVOICE where fee_invoice_id in (select fee_invoice_id from vw_FMM_LUBE_CSBC_INVOICE0 where trunc(update_time) = trunc(sysdate)); insert into FMM_LUBE_CSBC_INVOICE select * from vw_FMM_LUBE_CSBC_INVOICE0 where trunc(update_time) = trunc(sysdate); commit; delete from FEE_RELEVANCE_GET_ORDER where fee_invoice_id in (select fee_invoice_id from vw_fee_relevance_get_order0 where trunc(update_time) = trunc(sysdate)); insert into FEE_RELEVANCE_GET_ORDER select * from vw_fee_relevance_get_order0 where trunc(update_time) = trunc(sysdate); commit; delete from fmm_maintenance_expec_rpt WHERE RELATED_ID IN (SELECT RELATED_ID FROM vw_fmm_maintenance_expec_rp0 where trunc(update_time) = trunc(sysdate)); insert into fmm_maintenance_expec_rpt select * from vw_fmm_maintenance_expec_rp0 where trunc(update_time) = trunc(sysdate); commit; delete FROM FMM_MAINTENANCE_ESTI_RPT WHERE RELATED_ID IN (SELECT RELATED_ID FROM VW_FMM_MAINTENANCE_ESTI_RP0 where trunc(update_time) = trunc(sysdate)); insert into FMM_MAINTENANCE_ESTI_RPT select * from VW_FMM_MAINTENANCE_ESTI_RP0 where trunc(update_time) = trunc(sysdate); commit; delete from fmm_maintenance_fee_payee pay where (order_no,payee,vessel_code) in (select order_no,payee,vessel_code from vw_fmm_maintenance_fee_payee0 where trunc(updated_dtm_loc) = trunc(sysdate)); insert into fmm_maintenance_fee_payee select * from vw_fmm_maintenance_fee_payee0 where trunc(updated_dtm_loc) = trunc(sysdate); commit; delete from fmm_maintenance_fee_payee f where (NVL(F.ORDER_NO, 'AAA'),F.VESSEL_CODE) in (select apply_no,vessel_code from VW_FMM_MAINTENANCE_NO_PAYALL); delete from FMM_MAINTENANCE_INVOICE_DEL where fee_invoice_id in (select fee_invoice_id from VW_FMM_MAINTENANCE_INVOICE_DE0 where trunc(update_time) = trunc(sysdate)); insert into FMM_MAINTENANCE_INVOICE_DEL select * from VW_FMM_MAINTENANCE_INVOICE_DE0 where trunc(update_time) = trunc(sysdate); commit; delete from fmm_maintenance_invoice_rpt where fee_invoice_id in (select fee_invoice_id from vw_fmm_maintenance_invoice_rp0 where trunc(update_time) = trunc(sysdate)); insert into fmm_maintenance_invoice_rpt select * from vw_fmm_maintenance_invoice_rp0 where trunc(update_time) = trunc(sysdate); commit; delete from fmm_maintenance_invoice_rp5 where fee_invoice_id in (select fee_invoice_id from vw_fmm_maintenance_invoice_rp6 where trunc(update_time) = trunc(sysdate)); insert into fmm_maintenance_invoice_rp5 select * from vw_fmm_maintenance_invoice_rp6 where trunc(update_time) = trunc(sysdate); commit; delete from FMM_MAINTENANCE_ORDER_RPT where RELATED_ID in (select RELATED_ID from VW_FMM_MAINTENANCE_ORDER_RP0 where trunc(update_time) = trunc(sysdate)); insert into FMM_MAINTENANCE_ORDER_RPT select * from VW_FMM_MAINTENANCE_ORDER_RP0 where trunc(update_time) = trunc(sysdate); commit; delete from fmm_maintenance_supply_rpt where RELATED_ID in (select RELATED_ID from vw_fmm_maintenance_supply_rp0 where trunc(update_time) = trunc(sysdate)); insert into fmm_maintenance_supply_rpt select * from vw_fmm_maintenance_supply_rp0 where trunc(update_time) = trunc(sysdate); commit; DELETE FROM FMM_MAINTENANCE_ESTI_INV; INSERT INTO FMM_MAINTENANCE_ESTI_INV SELECT * FROM VW_FMM_MAINTENANCE_ESTI_INV VW; commit; BEGIN FOR CUR_BFM IN (select pi.business_id,pv.process_variable_id,pv.process_instance_id,pv.variable_value,case cc.IS_SHIP_ACTUAL_AFFIRM when '10' then '部分签收已完成' when '11' then '全部签收已完成' else '未签收' end as SHIP_ACTUAL_AFFIRM from wfl_process_variable pv left join wfl_process_instance pi on pi.process_instance_id = pv.process_instance_id left join bfm_purchase_order cc on cc.po_number=pi.business_id where pv.variable_name = 'display' and pi.business_id in (select t.po_number from bfm_purchase_order t where t.oil_type='002' and t.order_status in ('7','8') and t.created_dtm_loc > TO_DATE ('2018-01-01', 'YYYY-mm-dd'))) LOOP update wfl_process_variable tt set tt.variable_value = case when instr(tt.variable_value,'_',1) =0 then tt.variable_value else substr(tt.variable_value,1,instr(tt.variable_value,'_',1)-1) end where tt.process_variable_id=CUR_BFM.process_variable_id; commit; update wfl_process_variable tt set tt.variable_value = tt.variable_value || '_' || CUR_BFM.SHIP_ACTUAL_AFFIRM where tt.process_variable_id=CUR_BFM.process_variable_id; commit; END LOOP; END; P_LOG_EXCEPTION(SQLCODE || SQLERRM || 'insert 结束时间:' || sysdate, 'SP_FEE_MAINTENANCE_DAILY_JOB'); COMMIT; END IF; END SP_FEE_MAINTENANCE_DAILY_JOB; $$\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE \"SP_FEE_MAINTENANCE_DAILY_JOB\" IS\n    V_FLAG      VARCHAR2(50);\n    V_HOUR      VARCHAR2(50);\n    OUTCURSOR   PKG_CURSOR.T_CURSOR;\nBEGIN\n    SELECT\n        open_mode\n    INTO V_FLAG\n    FROM\n        v$database;\n\n    SELECT\n        TO_CHAR(SYSDATE, 'HH24')\n    INTO V_HOUR\n    FROM\n        DUAL;\n\n    IF V_FLAG = 'READ WRITE' AND (V_HOUR = '09' OR V_HOUR = '11' OR V_HOUR = '13' OR V_HOUR = '15' OR V_HOUR = '17') THEN\n        P_LOG_EXCEPTION('开始时间:' || SYSDATE, 'SP_FEE_MAINTENANCE_DAILY_JOB');\n\n        UPDATE FMM_OPERATION_RELEVANCE f\n        SET\n            f.relate_order_no = (\n                SELECT\n                    vcr.apply_no\n                FROM\n                    VRM_COMPLETION_REPORT vcr\n                WHERE\n                    vcr.completion_report_id = f.related_id\n            )\n        WHERE\n                related_name = '修船'\n            AND relate_order_no IS NULL;\n\n        UPDATE FMM_OPERATION_RELEVANCE f\n        SET\n            f.relate_order_no = (\n                SELECT\n                    vcr.apply_no\n                FROM\n                    VRM_COMPLETION_REPORT vcr\n                WHERE\n                    vcr.completion_report_id = f.related_id\n            )\n        WHERE\n                related_name = '修船通导'\n            AND relate_order_no IS NULL;\n\n        UPDATE FMM_OPERATION_RELEVANCE f\n        SET\n            f.relate_order_no = (\n                SELECT\n                    guide.ODDNUMBER\n                FROM\n                    FMM_SHIP_GUIDE guide\n                WHERE\n                    guide.ship_guide_id = f.related_id\n            )\n        WHERE\n                related_name = '修船通导'\n            AND relate_order_no IS NULL;\n\n        UPDATE FMM_OPERATION_RELEVANCE f\n        SET\n            f.relate_order_no = (\n                SELECT\n                    macm.apply_no\n                FROM\n                    mtr_apply_confirm_mtr macm\n                WHERE\n                    macm.apply_confirm_mtr_id = NVL(f.apply_confirm_id, f.related_id)\n            )\n        WHERE\n                related_name = '物料'\n            AND relate_order_no IS NULL;\n\n        UPDATE FMM_OPERATION_RELEVANCE f\n        SET\n            f.relate_order_no = (\n                SELECT\n                    sac.apply_no\n                FROM\n                    sps_apply_confirm sac\n                WHERE\n                    sac.apply_confirm_id = NVL(f.apply_confirm_id, f.related_id)\n            )\n        WHERE\n                related_name = '备件'\n            AND relate_order_no IS NULL;\n\n        COMMIT;\n\n        UPDATE fmm_fee_invoice F\n        SET\n            F.SEND_SAP_DATE = (\n                SELECT\n                    V.START_DATE\n                FROM\n                    (\n                        SELECT\n                            PI.START_DATE,\n                            N.PAYMENT_NO,\n                            N.SEND_DATE,\n                            i.fee_invoice_id,\n                            i.send_sap_date\n                        FROM\n                            wfl_process_instance pi\n                            INNER JOIN fmm_fee_payment_notice n ON pi.business_id = n.payment_notice_id\n                            INNER JOIN fmm_fee_invoice      i ON n.payment_no = i.order_no\n                        WHERE\n                            pi.state = 1\n                    ) V\n                WHERE\n                        F.FEE_INVOICE_ID = V.fee_invoice_id\n                    AND V.PAYMENT_NO LIKE 'F%'\n            )\n        WHERE\n                F.SEND_SAP_DATE IS NULL\n            AND F.ORDER_NO LIKE 'F%';\n\n        UPDATE fmm_fee_invoice F\n        SET\n            F.Invoice_Status = '4'\n        WHERE\n                F.SEND_SAP_DATE IS NOT NULL\n            AND F.INVOICE_STATUS = '3'\n            AND F.ORDER_NO LIKE 'F%';\n\n        COMMIT;\n\n        DELETE FROM FMM_LUBE_CSBC_ESTI\n        WHERE\n            RELATED_ID IN (\n                SELECT\n                    RELATED_ID\n                FROM\n                    vw_FMM_LUBE_CSBC_ESTI0\n                WHERE\n                    TRUNC(update_time) = TRUNC(SYSDATE)\n            );\n\n        INSERT INTO FMM_LUBE_CSBC_ESTI\n            SELECT\n                *\n            FROM\n                vw_FMM_LUBE_CSBC_ESTI0\n            WHERE\n                TRUNC(update_time) = TRUNC(SYSDATE);\n\n        DELETE FROM FMM_LUBE_CSBC_INVOICE\n        WHERE\n            fee_invoice_id IN (\n                SELECT\n                    fee_invoice_id\n                FROM\n                    vw_FMM_LUBE_CSBC_INVOICE0\n                WHERE\n                    TRUNC(update_time) = TRUNC(SYSDATE)\n            );\n\n        INSERT INTO FMM_LUBE_CSBC_INVOICE\n            SELECT\n                *\n            FROM\n                vw_FMM_LUBE_CSBC_INVOICE0\n            WHERE\n                TRUNC(update_time) = TRUNC(SYSDATE);\n\n        COMMIT;\n\n        DELETE FROM FEE_RELEVANCE_GET_ORDER\n        WHERE\n            fee_invoice_id IN (\n                SELECT\n                    fee_invoice_id\n                FROM\n                    vw_fee_relevance_get_order0\n                WHERE\n                    TRUNC(update_time) = TRUNC(SYSDATE)\n            );\n\n        INSERT INTO FEE_RELEVANCE_GET_ORDER\n            SELECT\n                *\n            FROM\n                vw_fee_relevance_get_order0\n            WHERE\n                TRUNC(update_time) = TRUNC(SYSDATE);\n\n        COMMIT;\n\n        DELETE FROM fmm_maintenance_expec_rpt\n        WHERE\n            RELATED_ID IN (\n                SELECT\n                    RELATED_ID\n                FROM\n                    vw_fmm_maintenance_expec_rp0\n                WHERE\n                    TRUNC(update_time) = TRUNC(SYSDATE)\n            );\n\n        INSERT INTO fmm_maintenance_expec_rpt\n            SELECT\n                *\n            FROM\n                vw_fmm_maintenance_expec_rp0\n            WHERE\n                TRUNC(update_time) = TRUNC(SYSDATE);\n\n        COMMIT;\n\n        DELETE FROM FMM_MAINTENANCE_ESTI_RPT\n        WHERE\n            RELATED_ID IN (\n                SELECT\n                    RELATED_ID\n                FROM\n                    VW_FMM_MAINTENANCE_ESTI_RP0\n                WHERE\n                    TRUNC(update_time) = TRUNC(SYSDATE)\n            );\n\n        INSERT INTO FMM_MAINTENANCE_ESTI_RPT\n            SELECT\n                *\n            FROM\n                VW_FMM_MAINTENANCE_ESTI_RP0\n            WHERE\n                TRUNC(update_time) = TRUNC(SYSDATE);\n\n        COMMIT;\n\n        DELETE FROM fmm_maintenance_fee_payee pay\n        WHERE\n            (order_no, payee, vessel_code) IN (\n                SELECT\n                    order_no,\n                    payee,\n                    vessel_code\n                FROM\n                    vw_fmm_maintenance_fee_payee0\n                WHERE\n                    TRUNC(updated_dtm_loc) = TRUNC(SYSDATE)\n            );\n\n        INSERT INTO fmm_maintenance_fee_payee\n            SELECT\n                *\n            FROM\n                vw_fmm_maintenance_fee_payee0\n            WHERE\n                TRUNC(updated_dtm_loc) = TRUNC(SYSDATE);\n\n        COMMIT;\n\n        DELETE FROM fmm_maintenance_fee_payee f\n        WHERE\n            (NVL(F.ORDER_NO, 'AAA'), F.VESSEL_CODE) IN (\n                SELECT\n                    apply_no,\n                    vessel_code\n                FROM\n                    VW_FMM_MAINTENANCE_NO_PAYALL\n            );\n\n        DELETE FROM FMM_MAINTENANCE_INVOICE_DEL\n        WHERE\n            fee_invoice_id IN (\n                SELECT\n                    fee_invoice_id\n                FROM\n                    VW_FMM_MAINTENANCE_INVOICE_DE0\n                WHERE\n                    TRUNC(update_time) = TRUNC(SYSDATE)\n            );\n\n        INSERT INTO FMM_MAINTENANCE_INVOICE_DEL\n            SELECT\n                *\n            FROM\n                VW_FMM_MAINTENANCE_INVOICE_DE0\n            WHERE\n                TRUNC(update_time) = TRUNC(SYSDATE);\n\n        COMMIT;\n\n        DELETE FROM fmm_maintenance_invoice_rpt\n        WHERE\n            fee_invoice_id IN (\n                SELECT\n                    fee_invoice_id\n                FROM\n                    vw_fmm_maintenance_invoice_rp0\n                WHERE\n                    TRUNC(update_time) = TRUNC(SYSDATE)\n            );\n\n        INSERT INTO fmm_maintenance_invoice_rpt\n            SELECT\n                *\n            FROM\n                vw_fmm_maintenance_invoice_rp0\n            WHERE\n                TRUNC(update_time) = TRUNC(SYSDATE);\n\n        COMMIT;\n\n        DELETE FROM fmm_maintenance_invoice_rp5\n        WHERE\n            fee_invoice_id IN (\n                SELECT\n                    fee_invoice_id\n                FROM\n                    vw_fmm_maintenance_invoice_rp6\n                WHERE\n                    TRUNC(update_time) = TRUNC(SYSDATE)\n            );\n\n        INSERT INTO fmm_maintenance_invoice_rp5\n            SELECT\n                *\n            FROM\n                vw_fmm_maintenance_invoice_rp6\n            WHERE\n                TRUNC(update_time) = TRUNC(SYSDATE);\n\n        COMMIT;\n\n        DELETE FROM FMM_MAINTENANCE_ORDER_RPT\n        WHERE\n            RELATED_ID IN (\n                SELECT\n                    RELATED_ID\n                FROM\n                    VW_FMM_MAINTENANCE_ORDER_RP0\n                WHERE\n                    TRUNC(update_time) = TRUNC(SYSDATE)\n            );\n\n        INSERT INTO FMM_MAINTENANCE_ORDER_RPT\n            SELECT\n                *\n            FROM\n                VW_FMM_MAINTENANCE_ORDER_RP0\n            WHERE\n                TRUNC(update_time) = TRUNC(SYSDATE);\n\n        COMMIT;\n\n        DELETE FROM fmm_maintenance_supply_rpt\n        WHERE\n            RELATED_ID IN (\n                SELECT\n                    RELATED_ID\n                FROM\n                    vw_fmm_maintenance_supply_rp0\n                WHERE\n                    TRUNC(update_time) = TRUNC(SYSDATE)\n            );\n\n        INSERT INTO fmm_maintenance_supply_rpt\n            SELECT\n                *\n            FROM\n                vw_fmm_maintenance_supply_rp0\n            WHERE\n                TRUNC(update_time) = TRUNC(SYSDATE);\n\n        COMMIT;\n\n        DELETE FROM FMM_MAINTENANCE_ESTI_INV;\n\n        INSERT INTO FMM_MAINTENANCE_ESTI_INV\n            SELECT\n                *\n            FROM\n                VW_FMM_MAINTENANCE_ESTI_INV VW;\n\n        COMMIT;\n\n        BEGIN\n            FOR CUR_BFM IN (\n                SELECT\n                    pi.business_id,\n                    pv.process_variable_id,\n                    pv.process_instance_id,\n                    pv.variable_value,\n                    CASE cc.IS_SHIP_ACTUAL_AFFIRM\n                        WHEN '10' THEN\n                            '部分签收已完成'\n                        WHEN '11' THEN\n                            '全部签收已完成'\n                        ELSE\n                            '未签收'\n                    END AS SHIP_ACTUAL_AFFIRM\n                FROM\n                    wfl_process_variable pv\n                    LEFT JOIN wfl_process_instance pi ON pi.process_instance_id = pv.process_instance_id\n                    LEFT JOIN bfm_purchase_order   cc ON cc.po_number = pi.business_id\n                WHERE\n                        pv.variable_name = 'display'\n                    AND pi.business_id IN (\n                        SELECT\n                            t.po_number\n                        FROM\n                            bfm_purchase_order t\n                        WHERE\n                                t.oil_type = '002'\n                            AND t.order_status IN ('7', '8')\n                            AND t.created_dtm_loc > TO_DATE('2018-01-01', 'YYYY-mm-dd')\n                    )\n            ) LOOP\n                UPDATE wfl_process_variable tt\n                SET\n                    tt.variable_value = CASE\n                        WHEN INSTR(tt.variable_value, '_', 1) = 0 THEN\n                            tt.variable_value\n                        ELSE\n                            SUBSTR(tt.variable_value, 1, INSTR(tt.variable_value, '_', 1) - 1)\n                    END\n                WHERE\n                    tt.process_variable_id = CUR_BFM.process_variable_id;\n\n                COMMIT;\n\n                UPDATE wfl_process_variable tt\n                SET\n                    tt.variable_value = tt.variable_value || '_' || CUR_BFM.SHIP_ACTUAL_AFFIRM\n                WHERE\n                    tt.process_variable_id = CUR_BFM.process_variable_id;\n\n                COMMIT;\n            END LOOP;\n        END;\n\n        P_LOG_EXCEPTION(SQLCODE || SQLERRM || 'insert 结束时间:' || SYSDATE, 'SP_FEE_MAINTENANCE_DAILY_JOB');\n        COMMIT;\n    END IF;\nEND SP_FEE_MAINTENANCE_DAILY_JOB;"
                    }
                ]
            },
            {
                "case_id": "3",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"3\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE OR REPLACE PROCEDURE SP_OFFSET_INFORMATION_V2(V_COST_CONTROL_COMPANY IN VARCHAR2,V_CHARGE_DEPT IN VARCHAR2,V_FEE_TYPE IN VARCHAR2,V_DTLPROJECT IN VARCHAR2,V_APPLY_USER IN VARCHAR2,V_HOST_PERSON IN VARCHAR2,V_CLAIM_NO IN VARCHAR2,V_CLAIM_DATE_F IN VARCHAR2,V_CLAIM_DATE_T IN VARCHAR2,V_SUBMIT_IND IN VARCHAR2,V_AUDIT_PROGRESS IN VARCHAR2,V_INVOICE_TYPE IN VARCHAR2,V_INVOICE_CODE IN VARCHAR2,V_INVOICE_NO IN VARCHAR2,V_CURSOR_TJ OUT SYS_REFCURSOR) AS BEGIN OPEN V_CURSOR_TJ FOR WITH LS_CURSOR AS (SELECT REGEXP_SUBSTR (V_AUDIT_PROGRESS, '[^,]+', 1,ROWNUM) AS COLUMN_VALUE FROM DUAL CONNECT BY ROWNUM <= LENGTH (V_AUDIT_PROGRESS) - LENGTH (REPLACE (V_AUDIT_PROGRESS, ',', ''))+1), LS_CURSOR2 AS (SELECT REGEXP_SUBSTR (V_COST_CONTROL_COMPANY, '[^,]+', 1,ROWNUM) AS COLUMN_VALUE FROM DUAL CONNECT BY ROWNUM <= LENGTH (V_COST_CONTROL_COMPANY) - LENGTH (REPLACE (V_COST_CONTROL_COMPANY, ',', ''))+1 ) SELECT * FROM (SELECT MAX(FH.ORGAN_FEE_HEADER_ID) AS ORGAN_FEE_HEADER_ID,MAX(FH.CLAIM_NO),MAX(C.DISPLAY_VALUE_CN) AS COST_CONTROL_COMPANY,MAX(FR.REL_OFFICE_NAME),MAX(SU1.USR_NAME) AS APPLY_USER,MAX(FU.USR_NAME) AS HOST_PERSON,MAX(C1.DISPLAY_VALUE_CN) AS COST_BODY,MAX(OFF.OFFICE_NAME) AS HOST_DEPT,MAX(SU.POSITION_DESCRIBE) POSITION_DESCRIBE,MAX(C4.DISPLAY_VALUE_CN) AS SUBMIT_IND,MAX(C2.DISPLAY_VALUE_CN) AS AUDIT_PROGRESS,MAX(FH.AUDIT_DATE),MAX(SU2.USR_NAME),MAX(FH.APPROVE_IND2),MAX(FH.HIGHER_DEPT),LISTAGG(SU2.POSITION_DESCRIBE, ',') WITHIN GROUP(ORDER BY ROWNUM) SU_POSITION_DESCRIBE,MAX(FH.CLAIM_DATE),MAX(CC.CURRENCY_NAME) AS CURRENCY,MAX(FH.AMOUNT),MAX(FH.REAL_AMOUNT),MAX('银行转账') AS PAY_TYPE,MAX(FH.REMARK),MAX(C5.DISPLAY_VALUE_CN) AS FEE_TYPE FROM FC_ORGAN_FEE_HEADER FH LEFT JOIN CDM_CODEDICT C5 ON C5.CODE_TYPE = 'SFC_FEE_TYPE' AND C5.CODE_VALUE = FH.Project_Code LEFT JOIN SYS_USER SU ON SU.USR_CODE = FH.HOST_PERSON LEFT JOIN CDM_CODEDICT C ON C.CODE_TYPE = 'SFC_COST_BODY' AND C.CODE_VALUE = FH.COST_CONTROL_COMPANY LEFT JOIN FC_RELEVANT_OFFICE FR ON FR.REL_OFFICE_CODE = FH.CHARGE_DEPT LEFT JOIN SYS_USER SU1 ON SU1.USR_CODE = FH.APPLY_USER LEFT JOIN FC_USER_INFO FU ON FU.USR_CODE = FH.HOST_PERSON LEFT JOIN CDM_CODEDICT C1 ON C1.CODE_TYPE = 'SFC_COST_BODY' AND C1.CODE_VALUE = FH.COST_BODY LEFT JOIN SYS_OFFICE OFF ON OFF.OFFICE_CODE=FH.HOST_DEPT LEFT JOIN SYS_USER SU2 ON SU2.USR_CODE = FH.AUDIT_USER LEFT JOIN CDM_CURRENCY CC ON CC.CURRENCY = FH.CURRENCY LEFT JOIN CDM_CODEDICT C2 ON C2.CODE_TYPE = 'SFC_AUDIT_PROGRESS' AND C2.CODE_VALUE = FH.AUDIT_PROGRESS LEFT JOIN CDM_CODEDICT C4 ON C4.CODE_TYPE = 'SFC_SUBMIT_IND' AND C4.CODE_VALUE = FH.SUBMIT_IND LEFT JOIN WFL_TODO W ON W.BUSINESS_ID = FH.ORGAN_FEE_HEADER_ID LEFT JOIN SYS_USER SU2 ON W.USER_ID = SU2.USR_ID WHERE (FH.COST_CONTROL_COMPANY IN (SELECT COLUMN_VALUE FROM LS_CURSOR2) OR V_COST_CONTROL_COMPANY IS NULL) AND (FH.CHARGE_DEPT = V_CHARGE_DEPT OR V_CHARGE_DEPT IS NULL) AND (FH.PROJECT_CODE = V_FEE_TYPE OR V_FEE_TYPE IS NULL) AND (FH.APPLY_USER = V_APPLY_USER OR V_APPLY_USER IS NULL) AND (FH.HOST_PERSON = V_HOST_PERSON OR V_HOST_PERSON IS NULL) AND (FH.CLAIM_NO = V_CLAIM_NO OR V_CLAIM_NO IS NULL) AND (FH.CLAIM_DATE >= TO_DATE(V_CLAIM_DATE_F, 'YYYY-MM-DD') OR V_CLAIM_DATE_F IS NULL) AND (FH.CLAIM_DATE <= TO_DATE(V_CLAIM_DATE_T, 'YYYY-MM-DD') OR V_CLAIM_DATE_T IS NULL) AND (FH.SUBMIT_IND = V_SUBMIT_IND OR V_SUBMIT_IND IS NULL) AND (FH.AUDIT_PROGRESS in(SELECT COLUMN_VALUE FROM LS_CURSOR)OR V_AUDIT_PROGRESS IS NULL) AND EXISTS (SELECT 1 FROM FC_ORGAN_FEE_DTL FFD WHERE FH.ORGAN_FEE_HEADER_ID=FFD.ORGAN_FEE_HEADER_ID AND (FFD.INVOICE_CODE = V_INVOICE_CODE OR V_INVOICE_CODE IS NULL) AND (FFD.INVOICE_TYPE = V_INVOICE_TYPE OR V_INVOICE_TYPE IS NULL) AND (FFD.INVOICE_NO = V_INVOICE_NO OR V_INVOICE_NO IS NULL) AND (FFD.DTL_PROJECT_CODE = V_DTLPROJECT OR V_DTLPROJECT IS NULL)) GROUP BY FH.ORGAN_FEE_HEADER_ID ORDER BY MAX(FH.CLAIM_NO) DESC) T LEFT JOIN (SELECT FD.ORGAN_FEE_HEADER_ID,FF.FREIGHT_NAME,C3.DISPLAY_VALUE_CN AS INVOICE_TYPE,C4.DISPLAY_VALUE_CN AS FEE_PROPERTY,C5.DISPLAY_VALUE_CN AS CUSTOMER_TYPE,FD.AMOUNT,FD.AMOUNT_NO_TAX,FD.TAX_RATE,FD.TAX_AMOUNT,FD.INVOICE_NO,FD.INVOICE_CODE,FD.BILLING_DATE,FD.CHECKCODE_6,FD.HOUSE_INFO,FD.SERVED_PEOPLE_NUM,FD.ESCORT_PEOPLE_NUM,FD.TOTAL_PEOPLE_NUM,FD.TOTAL_WINE_AMOUNT,FD.TOTAL_WINE_AMOUNT_R,FD.TOTAL_WINE_AMOUNT_O,FD.TOTAL_ML,FD.TOTAL_ML_R,FD.TOTAL_ML_O,FD.TOTAL_BOTTLE_NUM,FD.TOTAL_BOTTLE_NUM_R,FD.TOTAL_BOTTLE_NUM_O FROM FC_ORGAN_FEE_DTL FD LEFT JOIN FC_FREIGHT FF ON FF.FREIGHT_CODE = FD.DTL_PROJECT_CODE LEFT JOIN CDM_CODEDICT C3 ON C3.CODE_TYPE = 'SFC_INVOICE_TYPE' AND C3.CODE_VALUE = FD.INVOICE_TYPE LEFT JOIN CDM_CODEDICT C4 ON C4.CODE_TYPE = 'SFC_FEE_PROPERTY' AND C4.CODE_VALUE = FD.FEE_PROPERTY LEFT JOIN CDM_CODEDICT C5 ON C5.CODE_TYPE = 'SFC_CUST_TYPE' AND C5.CODE_VALUE = FD.CUSTOMER_TYPE where (FD.INVOICE_TYPE = V_INVOICE_TYPE OR V_INVOICE_TYPE IS NULL) AND (FD.INVOICE_CODE = V_INVOICE_CODE OR V_INVOICE_CODE IS NULL) AND (FD.INVOICE_NO = V_INVOICE_NO OR V_INVOICE_NO IS NULL) AND (FD.DTL_PROJECT_CODE = V_DTLPROJECT OR V_DTLPROJECT IS NULL)) T2 ON T.ORGAN_FEE_HEADER_ID=T2.ORGAN_FEE_HEADER_ID LEFT JOIN (select wi.BUSINESS_ID,MAX(DECODE(wi.NODE_NAME, '开始', wi.USR_NAME, '')) AS 开始,MAX(DECODE(wi.NODE_NAME, '提交', wi.USR_NAME, '')) AS 提交,MAX(DECODE(wi.NODE_NAME, '总经理', wi.USR_NAME, '')) AS 总经理,MAX(DECODE(wi.NODE_NAME, '党委书记', wi.USR_NAME, '')) AS 党委书记,MAX(DECODE(wi.NODE_NAME, '部门负责人', wi.USR_NAME, '')) AS 部门负责人,MAX(DECODE(wi.NODE_NAME, '主管高管', wi.USR_NAME, '')) AS 主管高管,MAX(DECODE(wi.NODE_NAME, '副总经理（主持工作）', wi.USR_NAME, '')) AS 副总经理主持工作,MAX(DECODE(wi.NODE_NAME, '财务经办人', wi.USR_NAME, '')) AS 财务经办人 from VW_WFL_PROCESS_INSTANCE wi where wi.NODE_NAME not like '%node-%' and wi.BUSINESS_ID in (select fh.organ_fee_header_id from fc_organ_fee_header fh WHERE (FH.COST_CONTROL_COMPANY IN (SELECT COLUMN_VALUE FROM LS_CURSOR2) OR V_COST_CONTROL_COMPANY IS NULL) AND (FH.CHARGE_DEPT = V_CHARGE_DEPT OR V_CHARGE_DEPT IS NULL) AND (FH.PROJECT_CODE = V_FEE_TYPE OR V_FEE_TYPE IS NULL) AND (FH.APPLY_USER = V_APPLY_USER OR V_APPLY_USER IS NULL) AND (FH.HOST_PERSON = V_HOST_PERSON OR V_HOST_PERSON IS NULL) AND (FH.CLAIM_NO = V_CLAIM_NO OR V_CLAIM_NO IS NULL) AND (FH.CLAIM_DATE >= TO_DATE(V_CLAIM_DATE_F, 'YYYY-MM-DD') OR V_CLAIM_DATE_F IS NULL) AND (FH.CLAIM_DATE <= TO_DATE(V_CLAIM_DATE_T, 'YYYY-MM-DD') OR V_CLAIM_DATE_T IS NULL) AND (FH.SUBMIT_IND = V_SUBMIT_IND OR V_SUBMIT_IND IS NULL) AND (FH.AUDIT_PROGRESS in(SELECT COLUMN_VALUE FROM LS_CURSOR)OR V_AUDIT_PROGRESS IS NULL)) GROUP BY wi.BUSINESS_ID) T3 ON T3.BUSINESS_ID=T2.ORGAN_FEE_HEADER_ID; END SP_OFFSET_INFORMATION_V2;\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PROCEDURE SP_OFFSET_INFORMATION_V2(V_COST_CONTROL_COMPANY IN VARCHAR2,V_CHARGE_DEPT IN VARCHAR2,V_FEE_TYPE IN VARCHAR2,V_DTLPROJECT IN VARCHAR2,V_APPLY_USER IN VARCHAR2,V_HOST_PERSON IN VARCHAR2,V_CLAIM_NO IN VARCHAR2,V_CLAIM_DATE_F IN VARCHAR2,V_CLAIM_DATE_T IN VARCHAR2,V_SUBMIT_IND IN VARCHAR2,V_AUDIT_PROGRESS IN VARCHAR2,V_INVOICE_TYPE IN VARCHAR2,V_INVOICE_CODE IN VARCHAR2,V_INVOICE_NO IN VARCHAR2,V_CURSOR_TJ OUT SYS_REFCURSOR) AS BEGIN OPEN V_CURSOR_TJ FOR WITH LS_CURSOR AS (SELECT REGEXP_SUBSTR (V_AUDIT_PROGRESS, '[^,]+', 1,ROWNUM) AS COLUMN_VALUE FROM DUAL CONNECT BY ROWNUM <= LENGTH (V_AUDIT_PROGRESS) - LENGTH (REPLACE (V_AUDIT_PROGRESS, ',', ''))+1), LS_CURSOR2 AS (SELECT REGEXP_SUBSTR (V_COST_CONTROL_COMPANY, '[^,]+', 1,ROWNUM) AS COLUMN_VALUE FROM DUAL CONNECT BY ROWNUM <= LENGTH (V_COST_CONTROL_COMPANY) - LENGTH (REPLACE (V_COST_CONTROL_COMPANY, ',', ''))+1 ) SELECT * FROM (SELECT MAX(FH.ORGAN_FEE_HEADER_ID) AS ORGAN_FEE_HEADER_ID,MAX(FH.CLAIM_NO),MAX(C.DISPLAY_VALUE_CN) AS COST_CONTROL_COMPANY,MAX(FR.REL_OFFICE_NAME),MAX(SU1.USR_NAME) AS APPLY_USER,MAX(FU.USR_NAME) AS HOST_PERSON,MAX(C1.DISPLAY_VALUE_CN) AS COST_BODY,MAX(OFF.OFFICE_NAME) AS HOST_DEPT,MAX(SU.POSITION_DESCRIBE) POSITION_DESCRIBE,MAX(C4.DISPLAY_VALUE_CN) AS SUBMIT_IND,MAX(C2.DISPLAY_VALUE_CN) AS AUDIT_PROGRESS,MAX(FH.AUDIT_DATE),MAX(SU2.USR_NAME),MAX(FH.APPROVE_IND2),MAX(FH.HIGHER_DEPT),LISTAGG(SU2.POSITION_DESCRIBE, ',') WITHIN GROUP(ORDER BY ROWNUM) SU_POSITION_DESCRIBE,MAX(FH.CLAIM_DATE),MAX(CC.CURRENCY_NAME) AS CURRENCY,MAX(FH.AMOUNT),MAX(FH.REAL_AMOUNT),MAX('银行转账') AS PAY_TYPE,MAX(FH.REMARK),MAX(C5.DISPLAY_VALUE_CN) AS FEE_TYPE FROM FC_ORGAN_FEE_HEADER FH LEFT JOIN CDM_CODEDICT C5 ON C5.CODE_TYPE = 'SFC_FEE_TYPE' AND C5.CODE_VALUE = FH.Project_Code LEFT JOIN SYS_USER SU ON SU.USR_CODE = FH.HOST_PERSON LEFT JOIN CDM_CODEDICT C ON C.CODE_TYPE = 'SFC_COST_BODY' AND C.CODE_VALUE = FH.COST_CONTROL_COMPANY LEFT JOIN FC_RELEVANT_OFFICE FR ON FR.REL_OFFICE_CODE = FH.CHARGE_DEPT LEFT JOIN SYS_USER SU1 ON SU1.USR_CODE = FH.APPLY_USER LEFT JOIN FC_USER_INFO FU ON FU.USR_CODE = FH.HOST_PERSON LEFT JOIN CDM_CODEDICT C1 ON C1.CODE_TYPE = 'SFC_COST_BODY' AND C1.CODE_VALUE = FH.COST_BODY LEFT JOIN SYS_OFFICE OFF ON OFF.OFFICE_CODE=FH.HOST_DEPT LEFT JOIN SYS_USER SU2 ON SU2.USR_CODE = FH.AUDIT_USER LEFT JOIN CDM_CURRENCY CC ON CC.CURRENCY = FH.CURRENCY LEFT JOIN CDM_CODEDICT C2 ON C2.CODE_TYPE = 'SFC_AUDIT_PROGRESS' AND C2.CODE_VALUE = FH.AUDIT_PROGRESS LEFT JOIN CDM_CODEDICT C4 ON C4.CODE_TYPE = 'SFC_SUBMIT_IND' AND C4.CODE_VALUE = FH.SUBMIT_IND LEFT JOIN WFL_TODO W ON W.BUSINESS_ID = FH.ORGAN_FEE_HEADER_ID LEFT JOIN SYS_USER SU2 ON W.USER_ID = SU2.USR_ID WHERE (FH.COST_CONTROL_COMPANY IN (SELECT COLUMN_VALUE FROM LS_CURSOR2) OR V_COST_CONTROL_COMPANY IS NULL) AND (FH.CHARGE_DEPT = V_CHARGE_DEPT OR V_CHARGE_DEPT IS NULL) AND (FH.PROJECT_CODE = V_FEE_TYPE OR V_FEE_TYPE IS NULL) AND (FH.APPLY_USER = V_APPLY_USER OR V_APPLY_USER IS NULL) AND (FH.HOST_PERSON = V_HOST_PERSON OR V_HOST_PERSON IS NULL) AND (FH.CLAIM_NO = V_CLAIM_NO OR V_CLAIM_NO IS NULL) AND (FH.CLAIM_DATE >= TO_DATE(V_CLAIM_DATE_F, 'YYYY-MM-DD') OR V_CLAIM_DATE_F IS NULL) AND (FH.CLAIM_DATE <= TO_DATE(V_CLAIM_DATE_T, 'YYYY-MM-DD') OR V_CLAIM_DATE_T IS NULL) AND (FH.SUBMIT_IND = V_SUBMIT_IND OR V_SUBMIT_IND IS NULL) AND (FH.AUDIT_PROGRESS in(SELECT COLUMN_VALUE FROM LS_CURSOR)OR V_AUDIT_PROGRESS IS NULL) AND EXISTS (SELECT 1 FROM FC_ORGAN_FEE_DTL FFD WHERE FH.ORGAN_FEE_HEADER_ID=FFD.ORGAN_FEE_HEADER_ID AND (FFD.INVOICE_CODE = V_INVOICE_CODE OR V_INVOICE_CODE IS NULL) AND (FFD.INVOICE_TYPE = V_INVOICE_TYPE OR V_INVOICE_TYPE IS NULL) AND (FFD.INVOICE_NO = V_INVOICE_NO OR V_INVOICE_NO IS NULL) AND (FFD.DTL_PROJECT_CODE = V_DTLPROJECT OR V_DTLPROJECT IS NULL)) GROUP BY FH.ORGAN_FEE_HEADER_ID ORDER BY MAX(FH.CLAIM_NO) DESC) T LEFT JOIN (SELECT FD.ORGAN_FEE_HEADER_ID,FF.FREIGHT_NAME,C3.DISPLAY_VALUE_CN AS INVOICE_TYPE,C4.DISPLAY_VALUE_CN AS FEE_PROPERTY,C5.DISPLAY_VALUE_CN AS CUSTOMER_TYPE,FD.AMOUNT,FD.AMOUNT_NO_TAX,FD.TAX_RATE,FD.TAX_AMOUNT,FD.INVOICE_NO,FD.INVOICE_CODE,FD.BILLING_DATE,FD.CHECKCODE_6,FD.HOUSE_INFO,FD.SERVED_PEOPLE_NUM,FD.ESCORT_PEOPLE_NUM,FD.TOTAL_PEOPLE_NUM,FD.TOTAL_WINE_AMOUNT,FD.TOTAL_WINE_AMOUNT_R,FD.TOTAL_WINE_AMOUNT_O,FD.TOTAL_ML,FD.TOTAL_ML_R,FD.TOTAL_ML_O,FD.TOTAL_BOTTLE_NUM,FD.TOTAL_BOTTLE_NUM_R,FD.TOTAL_BOTTLE_NUM_O FROM FC_ORGAN_FEE_DTL FD LEFT JOIN FC_FREIGHT FF ON FF.FREIGHT_CODE = FD.DTL_PROJECT_CODE LEFT JOIN CDM_CODEDICT C3 ON C3.CODE_TYPE = 'SFC_INVOICE_TYPE' AND C3.CODE_VALUE = FD.INVOICE_TYPE LEFT JOIN CDM_CODEDICT C4 ON C4.CODE_TYPE = 'SFC_FEE_PROPERTY' AND C4.CODE_VALUE = FD.FEE_PROPERTY LEFT JOIN CDM_CODEDICT C5 ON C5.CODE_TYPE = 'SFC_CUST_TYPE' AND C5.CODE_VALUE = FD.CUSTOMER_TYPE where (FD.INVOICE_TYPE = V_INVOICE_TYPE OR V_INVOICE_TYPE IS NULL) AND (FD.INVOICE_CODE = V_INVOICE_CODE OR V_INVOICE_CODE IS NULL) AND (FD.INVOICE_NO = V_INVOICE_NO OR V_INVOICE_NO IS NULL) AND (FD.DTL_PROJECT_CODE = V_DTLPROJECT OR V_DTLPROJECT IS NULL)) T2 ON T.ORGAN_FEE_HEADER_ID=T2.ORGAN_FEE_HEADER_ID LEFT JOIN (select wi.BUSINESS_ID,MAX(DECODE(wi.NODE_NAME, '开始', wi.USR_NAME, '')) AS 开始,MAX(DECODE(wi.NODE_NAME, '提交', wi.USR_NAME, '')) AS 提交,MAX(DECODE(wi.NODE_NAME, '总经理', wi.USR_NAME, '')) AS 总经理,MAX(DECODE(wi.NODE_NAME, '党委书记', wi.USR_NAME, '')) AS 党委书记,MAX(DECODE(wi.NODE_NAME, '部门负责人', wi.USR_NAME, '')) AS 部门负责人,MAX(DECODE(wi.NODE_NAME, '主管高管', wi.USR_NAME, '')) AS 主管高管,MAX(DECODE(wi.NODE_NAME, '副总经理（主持工作）', wi.USR_NAME, '')) AS 副总经理主持工作,MAX(DECODE(wi.NODE_NAME, '财务经办人', wi.USR_NAME, '')) AS 财务经办人 from VW_WFL_PROCESS_INSTANCE wi where wi.NODE_NAME not like '%node-%' and wi.BUSINESS_ID in (select fh.organ_fee_header_id from fc_organ_fee_header fh WHERE (FH.COST_CONTROL_COMPANY IN (SELECT COLUMN_VALUE FROM LS_CURSOR2) OR V_COST_CONTROL_COMPANY IS NULL) AND (FH.CHARGE_DEPT = V_CHARGE_DEPT OR V_CHARGE_DEPT IS NULL) AND (FH.PROJECT_CODE = V_FEE_TYPE OR V_FEE_TYPE IS NULL) AND (FH.APPLY_USER = V_APPLY_USER OR V_APPLY_USER IS NULL) AND (FH.HOST_PERSON = V_HOST_PERSON OR V_HOST_PERSON IS NULL) AND (FH.CLAIM_NO = V_CLAIM_NO OR V_CLAIM_NO IS NULL) AND (FH.CLAIM_DATE >= TO_DATE(V_CLAIM_DATE_F, 'YYYY-MM-DD') OR V_CLAIM_DATE_F IS NULL) AND (FH.CLAIM_DATE <= TO_DATE(V_CLAIM_DATE_T, 'YYYY-MM-DD') OR V_CLAIM_DATE_T IS NULL) AND (FH.SUBMIT_IND = V_SUBMIT_IND OR V_SUBMIT_IND IS NULL) AND (FH.AUDIT_PROGRESS in(SELECT COLUMN_VALUE FROM LS_CURSOR)OR V_AUDIT_PROGRESS IS NULL)) GROUP BY wi.BUSINESS_ID) T3 ON T3.BUSINESS_ID=T2.ORGAN_FEE_HEADER_ID; END SP_OFFSET_INFORMATION_V2;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE SP_OFFSET_INFORMATION_V2(V_COST_CONTROL_COMPANY IN VARCHAR2,V_CHARGE_DEPT IN VARCHAR2,V_FEE_TYPE IN VARCHAR2,V_DTLPROJECT IN VARCHAR2,V_APPLY_USER IN VARCHAR2,V_HOST_PERSON IN VARCHAR2,V_CLAIM_NO IN VARCHAR2,V_CLAIM_DATE_F IN VARCHAR2,V_CLAIM_DATE_T IN VARCHAR2,V_SUBMIT_IND IN VARCHAR2,V_AUDIT_PROGRESS IN VARCHAR2,V_INVOICE_TYPE IN VARCHAR2,V_INVOICE_CODE IN VARCHAR2,V_INVOICE_NO IN VARCHAR2,V_CURSOR_TJ OUT SYS_REFCURSOR) AS BEGIN OPEN V_CURSOR_TJ FOR WITH LS_CURSOR AS (SELECT REGEXP_SUBSTR (V_AUDIT_PROGRESS, '[^,]+', 1,ROWNUM) AS COLUMN_VALUE FROM DUAL CONNECT BY ROWNUM <= LENGTH (V_AUDIT_PROGRESS) - LENGTH (REPLACE (V_AUDIT_PROGRESS, ',', ''))+1), LS_CURSOR2 AS (SELECT REGEXP_SUBSTR (V_COST_CONTROL_COMPANY, '[^,]+', 1,ROWNUM) AS COLUMN_VALUE FROM DUAL CONNECT BY ROWNUM <= LENGTH"
                    }
                ]
            },
            {
                "case_id": "4",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"4\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"DELIMITER $$ CREATE OR REPLACE PROCEDURE AO_FMS_AUTINV_CONTRAST_STATINV (S_PURCHASER_TAX_NO IN VARCHAR2, V_INVOICE_NUM IN VARCHAR2, V_INVOICE_CODE IN VARCHAR2, V_DEDU_PERIOD IN VARCHAR2, V_OPERATOR IN VARCHAR2, V_DEDU_DATE_FROM IN VARCHAR2, V_DEDU_DATE_TO IN VARCHAR2, V_PURCHASER_NAME IN VARCHAR2, OUTCURSOR OUT SYS_REFCURSOR) is BEGIN OPEN OUTCURSOR FOR select FAI.authed_invoice_id as CONTRAST_ID, FAI.PURCHASER_TAX_NO AS PURCHASER_TAX_NO_AUT, FAI.PURCHASER_NAME AS PURCHASER_NAME_AUT, FAI.INVOICE_CODE AS INVOICE_CODE_AUT, FAI.BILLING_DATE AS BILLING_DATE_AUT, FAI.INVOICE_NUM AS INVOICE_NUM_AUT, FAI.AMOUNT_TAX AS AMOUNT_TAX_AUT, FAI.TOTAL_AMOUNT AS TOTAL_AMOUNT_AUT, '' AS PURCHASER_TAX_NO_STAT, '' AS PURCHASER_NAME_STAT, '' AS INVOICE_CODE_STAT, NULL AS BILLING_DATE_STAT, '' AS INVOICE_NUM_STAT, NULL AS AMOUNT_TAX_STAT, NULL AS TOTAL_AMOUNT_STAT, '1' AS DIFFERENCE_CAUSE, FAI.DEDU_PERIOD AS DEDU_PERIOD_AUT, '' AS DEDU_PERIOD_STAT, SU.USR_NAME AS OPERATOR_AUT, '' AS OPERATOR_STAT, FAI.DEDU_DATE AS DEDU_DATE_AUT, NULL AS DEDU_DATE_STAT from FMM_AUTHED_INVOICE FAI LEFT JOIN sys_user su ON FAI.UPDATED_BY_USER = SU.USR_CODE AND FAI.COMPANY_CODE = SU.COMPANY_CODE WHERE 1=1 AND (S_PURCHASER_TAX_NO IS NULL OR FAI.PURCHASER_TAX_NO = S_PURCHASER_TAX_NO) AND (V_INVOICE_NUM IS NULL OR FAI.INVOICE_NUM = V_INVOICE_NUM) AND (V_INVOICE_CODE IS NULL OR FAI.INVOICE_CODE = V_INVOICE_CODE) AND (V_DEDU_PERIOD IS NULL OR FAI.DEDU_PERIOD = V_DEDU_PERIOD) AND (V_OPERATOR IS NULL OR SU.USR_NAME = V_OPERATOR) AND (V_DEDU_DATE_FROM IS NULL OR to_date(SUBSTR(FAI.DEDU_DATE,1,10),'yyyy-MM-dd') >= to_date(V_DEDU_DATE_FROM,'yyyy-MM-dd')) AND (V_DEDU_DATE_TO IS NULL OR to_date(SUBSTR(FAI.DEDU_DATE,1,10),'yyyy-MM-dd') <= to_date(V_DEDU_DATE_TO,'yyyy-MM-dd')) AND (V_PURCHASER_NAME IS NULL OR FAI.PURCHASER_NAME = V_PURCHASER_NAME) AND NOT EXISTS(select 1 from FMM_AUTHED_STAT_INV FASI WHERE FASI.PURCHASER_TAX_NO=FAI.PURCHASER_TAX_NO AND FASI.INVOICE_NUM=FAI.INVOICE_NUM AND FASI.INVOICE_CODE=FAI.INVOICE_CODE) UNION ALL select FASI.authed_stat_inv_id as CONTRAST_ID, '' AS PURCHASER_TAX_NO_AUT, '' AS PURCHASER_NAME_AUT, '' AS INVOICE_CODE_AUT, NULL AS BILLING_DATE_AUT, '' AS INVOICE_NUM_AUT, NULL AS AMOUNT_TAX_AUT, NULL AS TOTAL_AMOUNT_AUT, FASI.PURCHASER_TAX_NO AS PURCHASER_TAX_NO_STAT, FASI.PURCHASER_NAME AS PURCHASER_NAME_STAT, FASI.INVOICE_CODE AS INVOICE_CODE_STAT, FASI.BILLING_DATE AS BILLING_DATE_STAT, FASI.INVOICE_NUM AS INVOICE_NUM_STAT, FASI.Total_Taxt AS AMOUNT_TAX_STAT, FASI.TOTAL_AMOUNT AS TOTAL_AMOUNT_STAT, '2' AS DIFFERENCE_CAUSE, '' AS DEDU_PERIOD_AUT, FASI.DEDU_PERIOD AS DEDU_PERIOD_STAT, '' AS OPERATOR_AUT, FASI.OPERATOR_ACCOUNT AS OPERATOR_STAT, NULL AS DEDU_DATE_AUT, FASI.DEDU_DATE AS DEDU_DATE_STAT from FMM_AUTHED_STAT_INV FASI WHERE 1=1 AND (S_PURCHASER_TAX_NO IS NULL OR FASI.PURCHASER_TAX_NO = S_PURCHASER_TAX_NO) AND (V_INVOICE_NUM IS NULL OR FASI.INVOICE_NUM = V_INVOICE_NUM) AND (V_INVOICE_CODE IS NULL OR FASI.INVOICE_CODE = V_INVOICE_CODE) AND (V_DEDU_PERIOD IS NULL OR FASI.DEDU_PERIOD = V_DEDU_PERIOD) AND (V_OPERATOR IS NULL OR FASI.OPERATOR_ACCOUNT = V_OPERATOR) AND (V_DEDU_DATE_FROM IS NULL OR to_date(SUBSTR(FASI.DEDU_DATE,1,10),'yyyy-MM-dd') >= to_date(V_DEDU_DATE_FROM,'yyyy-MM-dd')) AND (V_DEDU_DATE_TO IS NULL OR to_date(SUBSTR(FASI.DEDU_DATE,1,10),'yyyy-MM-dd') <= to_date(V_DEDU_DATE_TO,'yyyy-MM-dd')) AND (V_PURCHASER_NAME IS NULL OR FASI.PURCHASER_NAME = V_PURCHASER_NAME) AND NOT EXISTS(select 1 from FMM_AUTHED_INVOICE FAI WHERE FAI.PURCHASER_TAX_NO=FASI.PURCHASER_TAX_NO AND FAI.INVOICE_NUM=FASI.INVOICE_NUM AND FAI.INVOICE_CODE=FASI.INVOICE_CODE) UNION ALL select FASI.authed_stat_inv_id as CONTRAST_ID, FAI.PURCHASER_TAX_NO AS PURCHASER_TAX_NO_AUT, FAI.PURCHASER_NAME AS PURCHASER_NAME_AUT, FAI.INVOICE_CODE AS INVOICE_CODE_AUT, FAI.BILLING_DATE AS BILLING_DATE_AUT, FAI.INVOICE_NUM AS INVOICE_NUM_AUT, FAI.AMOUNT_TAX AS AMOUNT_TAX_AUT, FAI.TOTAL_AMOUNT AS TOTAL_AMOUNT_AUT, FASI.PURCHASER_TAX_NO AS PURCHASER_TAX_NO_STAT, FASI.PURCHASER_NAME AS PURCHASER_NAME_STAT, FASI.INVOICE_CODE AS INVOICE_CODE_STAT, FASI.BILLING_DATE AS BILLING_DATE_STAT, FASI.INVOICE_NUM AS INVOICE_NUM_STAT, FASI.Total_Taxt AS AMOUNT_TAX_STAT, FASI.TOTAL_AMOUNT AS TOTAL_AMOUNT_STAT, '3' AS DIFFERENCE_CAUSE, FAI.DEDU_PERIOD AS DEDU_PERIOD_AUT, FASI.DEDU_PERIOD AS DEDU_PERIOD_STAT, SU.USR_NAME AS OPERATOR_AUT, FASI.OPERATOR_ACCOUNT AS OPERATOR_STAT, FAI.DEDU_DATE AS DEDU_DATE_AUT, FASI.DEDU_DATE AS DEDU_DATE_STAT from FMM_AUTHED_STAT_INV FASI inner join FMM_AUTHED_INVOICE FAI LEFT JOIN Sys_User su ON FAI.UPDATED_BY_USER = SU.USR_CODE AND FAI.COMPANY_CODE = SU.COMPANY_CODE on FAI.PURCHASER_TAX_NO=FASI.PURCHASER_TAX_NO and FAI.INVOICE_NUM=FASI.INVOICE_NUM and FAI.INVOICE_CODE=FASI.INVOICE_CODE WHERE 1=1 AND (S_PURCHASER_TAX_NO IS NULL OR FASI.PURCHASER_TAX_NO = S_PURCHASER_TAX_NO) AND (V_INVOICE_NUM IS NULL OR FASI.INVOICE_NUM = V_INVOICE_NUM) AND (V_INVOICE_CODE IS NULL OR FASI.INVOICE_CODE = V_INVOICE_CODE) AND (V_DEDU_PERIOD IS NULL OR FASI.DEDU_PERIOD = V_DEDU_PERIOD) AND (V_OPERATOR IS NULL OR FASI.OPERATOR_ACCOUNT = V_OPERATOR) AND (V_DEDU_DATE_FROM IS NULL OR to_date(SUBSTR(FASI.DEDU_DATE,1,10),'yyyy-MM-dd') >= to_date(V_DEDU_DATE_FROM,'yyyy-MM-dd')) AND (V_DEDU_DATE_TO IS NULL OR to_date(SUBSTR(FASI.DEDU_DATE,1,10),'yyyy-MM-dd') <= to_date(V_DEDU_DATE_TO,'yyyy-MM-dd')) AND (V_PURCHASER_NAME IS NULL OR FASI.PURCHASER_NAME = V_PURCHASER_NAME) AND (FASI.Total_Taxt <> FAI.Total_Taxt or FASI.Total_Amount <> FAI.Total_Amount); END AO_FMS_AUTINV_CONTRAST_STATINV; $$\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nDELIMITER $$ CREATE OR REPLACE PROCEDURE AO_FMS_AUTINV_CONTRAST_STATINV (S_PURCHASER_TAX_NO IN VARCHAR2, V_INVOICE_NUM IN VARCHAR2, V_INVOICE_CODE IN VARCHAR2, V_DEDU_PERIOD IN VARCHAR2, V_OPERATOR IN VARCHAR2, V_DEDU_DATE_FROM IN VARCHAR2, V_DEDU_DATE_TO IN VARCHAR2, V_PURCHASER_NAME IN VARCHAR2, OUTCURSOR OUT SYS_REFCURSOR) is BEGIN OPEN OUTCURSOR FOR select FAI.authed_invoice_id as CONTRAST_ID, FAI.PURCHASER_TAX_NO AS PURCHASER_TAX_NO_AUT, FAI.PURCHASER_NAME AS PURCHASER_NAME_AUT, FAI.INVOICE_CODE AS INVOICE_CODE_AUT, FAI.BILLING_DATE AS BILLING_DATE_AUT, FAI.INVOICE_NUM AS INVOICE_NUM_AUT, FAI.AMOUNT_TAX AS AMOUNT_TAX_AUT, FAI.TOTAL_AMOUNT AS TOTAL_AMOUNT_AUT, '' AS PURCHASER_TAX_NO_STAT, '' AS PURCHASER_NAME_STAT, '' AS INVOICE_CODE_STAT, NULL AS BILLING_DATE_STAT, '' AS INVOICE_NUM_STAT, NULL AS AMOUNT_TAX_STAT, NULL AS TOTAL_AMOUNT_STAT, '1' AS DIFFERENCE_CAUSE, FAI.DEDU_PERIOD AS DEDU_PERIOD_AUT, '' AS DEDU_PERIOD_STAT, SU.USR_NAME AS OPERATOR_AUT, '' AS OPERATOR_STAT, FAI.DEDU_DATE AS DEDU_DATE_AUT, NULL AS DEDU_DATE_STAT from FMM_AUTHED_INVOICE FAI LEFT JOIN sys_user su ON FAI.UPDATED_BY_USER = SU.USR_CODE AND FAI.COMPANY_CODE = SU.COMPANY_CODE WHERE 1=1 AND (S_PURCHASER_TAX_NO IS NULL OR FAI.PURCHASER_TAX_NO = S_PURCHASER_TAX_NO) AND (V_INVOICE_NUM IS NULL OR FAI.INVOICE_NUM = V_INVOICE_NUM) AND (V_INVOICE_CODE IS NULL OR FAI.INVOICE_CODE = V_INVOICE_CODE) AND (V_DEDU_PERIOD IS NULL OR FAI.DEDU_PERIOD = V_DEDU_PERIOD) AND (V_OPERATOR IS NULL OR SU.USR_NAME = V_OPERATOR) AND (V_DEDU_DATE_FROM IS NULL OR to_date(SUBSTR(FAI.DEDU_DATE,1,10),'yyyy-MM-dd') >= to_date(V_DEDU_DATE_FROM,'yyyy-MM-dd')) AND (V_DEDU_DATE_TO IS NULL OR to_date(SUBSTR(FAI.DEDU_DATE,1,10),'yyyy-MM-dd') <= to_date(V_DEDU_DATE_TO,'yyyy-MM-dd')) AND (V_PURCHASER_NAME IS NULL OR FAI.PURCHASER_NAME = V_PURCHASER_NAME) AND NOT EXISTS(select 1 from FMM_AUTHED_STAT_INV FASI WHERE FASI.PURCHASER_TAX_NO=FAI.PURCHASER_TAX_NO AND FASI.INVOICE_NUM=FAI.INVOICE_NUM AND FASI.INVOICE_CODE=FAI.INVOICE_CODE) UNION ALL select FASI.authed_stat_inv_id as CONTRAST_ID, '' AS PURCHASER_TAX_NO_AUT, '' AS PURCHASER_NAME_AUT, '' AS INVOICE_CODE_AUT, NULL AS BILLING_DATE_AUT, '' AS INVOICE_NUM_AUT, NULL AS AMOUNT_TAX_AUT, NULL AS TOTAL_AMOUNT_AUT, FASI.PURCHASER_TAX_NO AS PURCHASER_TAX_NO_STAT, FASI.PURCHASER_NAME AS PURCHASER_NAME_STAT, FASI.INVOICE_CODE AS INVOICE_CODE_STAT, FASI.BILLING_DATE AS BILLING_DATE_STAT, FASI.INVOICE_NUM AS INVOICE_NUM_STAT, FASI.Total_Taxt AS AMOUNT_TAX_STAT, FASI.TOTAL_AMOUNT AS TOTAL_AMOUNT_STAT, '2' AS DIFFERENCE_CAUSE, '' AS DEDU_PERIOD_AUT, FASI.DEDU_PERIOD AS DEDU_PERIOD_STAT, '' AS OPERATOR_AUT, FASI.OPERATOR_ACCOUNT AS OPERATOR_STAT, NULL AS DEDU_DATE_AUT, FASI.DEDU_DATE AS DEDU_DATE_STAT from FMM_AUTHED_STAT_INV FASI WHERE 1=1 AND (S_PURCHASER_TAX_NO IS NULL OR FASI.PURCHASER_TAX_NO = S_PURCHASER_TAX_NO) AND (V_INVOICE_NUM IS NULL OR FASI.INVOICE_NUM = V_INVOICE_NUM) AND (V_INVOICE_CODE IS NULL OR FASI.INVOICE_CODE = V_INVOICE_CODE) AND (V_DEDU_PERIOD IS NULL OR FASI.DEDU_PERIOD = V_DEDU_PERIOD) AND (V_OPERATOR IS NULL OR FASI.OPERATOR_ACCOUNT = V_OPERATOR) AND (V_DEDU_DATE_FROM IS NULL OR to_date(SUBSTR(FASI.DEDU_DATE,1,10),'yyyy-MM-dd') >= to_date(V_DEDU_DATE_FROM,'yyyy-MM-dd')) AND (V_DEDU_DATE_TO IS NULL OR to_date(SUBSTR(FASI.DEDU_DATE,1,10),'yyyy-MM-dd') <= to_date(V_DEDU_DATE_TO,'yyyy-MM-dd')) AND (V_PURCHASER_NAME IS NULL OR FASI.PURCHASER_NAME = V_PURCHASER_NAME) AND NOT EXISTS(select 1 from FMM_AUTHED_INVOICE FAI WHERE FAI.PURCHASER_TAX_NO=FASI.PURCHASER_TAX_NO AND FAI.INVOICE_NUM=FASI.INVOICE_NUM AND FAI.INVOICE_CODE=FASI.INVOICE_CODE) UNION ALL select FASI.authed_stat_inv_id as CONTRAST_ID, FAI.PURCHASER_TAX_NO AS PURCHASER_TAX_NO_AUT, FAI.PURCHASER_NAME AS PURCHASER_NAME_AUT, FAI.INVOICE_CODE AS INVOICE_CODE_AUT, FAI.BILLING_DATE AS BILLING_DATE_AUT, FAI.INVOICE_NUM AS INVOICE_NUM_AUT, FAI.AMOUNT_TAX AS AMOUNT_TAX_AUT, FAI.TOTAL_AMOUNT AS TOTAL_AMOUNT_AUT, FASI.PURCHASER_TAX_NO AS PURCHASER_TAX_NO_STAT, FASI.PURCHASER_NAME AS PURCHASER_NAME_STAT, FASI.INVOICE_CODE AS INVOICE_CODE_STAT, FASI.BILLING_DATE AS BILLING_DATE_STAT, FASI.INVOICE_NUM AS INVOICE_NUM_STAT, FASI.Total_Taxt AS AMOUNT_TAX_STAT, FASI.TOTAL_AMOUNT AS TOTAL_AMOUNT_STAT, '3' AS DIFFERENCE_CAUSE, FAI.DEDU_PERIOD AS DEDU_PERIOD_AUT, FASI.DEDU_PERIOD AS DEDU_PERIOD_STAT, SU.USR_NAME AS OPERATOR_AUT, FASI.OPERATOR_ACCOUNT AS OPERATOR_STAT, FAI.DEDU_DATE AS DEDU_DATE_AUT, FASI.DEDU_DATE AS DEDU_DATE_STAT from FMM_AUTHED_STAT_INV FASI inner join FMM_AUTHED_INVOICE FAI LEFT JOIN Sys_User su ON FAI.UPDATED_BY_USER = SU.USR_CODE AND FAI.COMPANY_CODE = SU.COMPANY_CODE on FAI.PURCHASER_TAX_NO=FASI.PURCHASER_TAX_NO and FAI.INVOICE_NUM=FASI.INVOICE_NUM and FAI.INVOICE_CODE=FASI.INVOICE_CODE WHERE 1=1 AND (S_PURCHASER_TAX_NO IS NULL OR FASI.PURCHASER_TAX_NO = S_PURCHASER_TAX_NO) AND (V_INVOICE_NUM IS NULL OR FASI.INVOICE_NUM = V_INVOICE_NUM) AND (V_INVOICE_CODE IS NULL OR FASI.INVOICE_CODE = V_INVOICE_CODE) AND (V_DEDU_PERIOD IS NULL OR FASI.DEDU_PERIOD = V_DEDU_PERIOD) AND (V_OPERATOR IS NULL OR FASI.OPERATOR_ACCOUNT = V_OPERATOR) AND (V_DEDU_DATE_FROM IS NULL OR to_date(SUBSTR(FASI.DEDU_DATE,1,10),'yyyy-MM-dd') >= to_date(V_DEDU_DATE_FROM,'yyyy-MM-dd')) AND (V_DEDU_DATE_TO IS NULL OR to_date(SUBSTR(FASI.DEDU_DATE,1,10),'yyyy-MM-dd') <= to_date(V_DEDU_DATE_TO,'yyyy-MM-dd')) AND (V_PURCHASER_NAME IS NULL OR FASI.PURCHASER_NAME = V_PURCHASER_NAME) AND (FASI.Total_Taxt <> FAI.Total_Taxt or FASI.Total_Amount <> FAI.Total_Amount); END AO_FMS_AUTINV_CONTRAST_STATINV; $$\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE AO_FMS_AUTINV_CONTRAST_STATINV (S_PURCHASER_TAX_NO IN VARCHAR2, V_INVOICE_NUM IN VARCHAR2, V_INVOICE_CODE IN VARCHAR2, V_DEDU_PERIOD IN VARCHAR2, V_OPERATOR IN VARCHAR2, V_DEDU_DATE_FROM IN VARCHAR2, V_DEDU_DATE_TO IN VARCHAR2, V_PURCHASER_NAME IN VARCHAR2, OUTCURSOR OUT SYS_REFCURSOR) is BEGIN OPEN OUTCURSOR FOR select FAI.authed_invoice_id as CONTRAST_ID, FAI.PURCHASER_TAX_NO AS PURCHASER_TAX_NO_AUT, FAI.PURCHASER_NAME AS PURCHASER_NAME_AUT, FAI.INVOICE_CODE AS INVOICE_CODE_AUT, FAI.BILLING_DATE AS BILLING_DATE_AUT, FAI.INVOICE_NUM AS INVOICE_NUM_AUT, FAI.AMOUNT_TAX AS AMOUNT_TAX_AUT, FAI.TOTAL_AMOUNT AS TOTAL_AMOUNT_AUT, '' AS PURCHASER_TAX_NO_STAT, '' AS PURCHASER_NAME_STAT, '' AS INVOICE_CODE_STAT, NULL AS BILLING_DATE_STAT, '' AS INVOICE_NUM_STAT, NULL AS AMOUNT_TAX_STAT, NULL AS TOTAL_AMOUNT_STAT, '1' AS DIFFERENCE_CAUSE, FAI.DEDU_PERIOD AS DEDU_PERIOD_AUT, '' AS DEDU_PERIOD_STAT, SU.USR_NAME AS OPERATOR_AUT, '' AS OPERATOR_STAT, FAI.DEDU_DATE AS DEDU_DATE_AUT, NULL AS DEDU_DATE_STAT from FMM_AUTHED_INVOICE FAI LEFT JOIN sys_user su ON FAI.UPDATED_BY_USER = SU.USR_CODE AND FAI.COMPANY_CODE = SU.COMPANY_CODE WHERE 1=1 AND (S_PURCHASER_TAX_NO IS NULL OR FAI.PURCHASER_TAX_NO = S_PURCHASER_TAX_NO) AND (V_INVOICE_NUM IS NULL OR FAI.INVOICE_NUM = V_INVOICE_NUM) AND (V_INVOICE_CODE IS NULL OR FAI.INVOICE_CODE = V_INVOICE_CODE) AND (V_DEDU_PERIOD IS NULL OR FAI.DEDU_PERIOD = V_DEDU_PERIOD) AND (V_OPERATOR IS NULL OR SU.USR_NAME = V_OPERATOR) AND (V_DEDU_DATE_FROM IS NULL OR to_date(SUBSTR(FAI.DEDU_DATE,1,10),'yyyy-MM-dd') >= to_date(V_DEDU_DATE_FROM,'yyyy-MM-dd')) AND (V_DEDU_DATE_TO IS NULL OR to_date(SUBSTR(FAI.DEDU_DATE,1,10),'yyyy-MM-dd') <= to_date(V_DEDU_DATE_TO,'yyyy-MM-dd')) AND (V_PURCHASER_NAME IS NULL OR FAI.PURCHASER_NAME = V_PURCHASER_NAME) AND NOT EXISTS(select 1 from FMM_AUTHED_STAT_INV FASI WHERE FASI.PURCHASER_TAX_NO=FAI.PURCHASER_TAX_NO AND FASI.INVOICE_NUM=FAI.INVOICE_NUM AND FASI.INVOICE_CODE=FAI.INVOICE_CODE) UNION ALL select FASI.authed_stat_inv_id as CONTRAST_ID, '' AS PURCHASER_TAX_NO_AUT, '' AS PURCHASER_NAME_AUT, '' AS INVOICE_CODE_AUT, NULL AS BILLING_DATE_AUT, '' AS INVOICE_NUM_AUT, NULL AS AMOUNT_TAX_AUT, NULL AS TOTAL_AMOUNT_AUT, FASI.PURCHASER_TAX_NO AS PURCHASER_TAX_NO_STAT, FASI.PURCHASER_NAME AS PURCHASER_NAME_STAT, FASI.INVOICE_CODE AS INVOICE_CODE_STAT, FASI.BILLING_DATE AS BILLING_DATE_STAT, FASI.INVOICE_NUM AS INVOICE_NUM_STAT, FASI.Total_Taxt AS AMOUNT_TAX_STAT, FASI.TOTAL_AMOUNT AS TOTAL_AMOUNT_STAT, '2' AS DIFFERENCE_CAUSE, '' AS DEDU_PERIOD_AUT, FASI.DEDU_PERIOD AS DEDU_PERIOD_STAT, '' AS OPERATOR_AUT, FASI.OPERATOR_ACCOUNT AS OPERATOR_STAT, NULL AS DEDU_DATE_AUT, FASI.DEDU_DATE AS DEDU_DATE_STAT from FMM_AUTHED_STAT_INV FASI WHERE 1=1 AND (S_PURCHASER_TAX_NO IS NULL OR FASI.PURCHASER_TAX_NO = S_PURCHASER_TAX_NO) AND (V_INVOICE_NUM IS NULL OR FASI.INVOICE_NUM = V_INVOICE_NUM) AND (V_INVOICE_CODE IS NULL OR FASI.INVOICE_CODE = V_INVOICE_CODE) AND (V_DEDU_PERIOD IS NULL OR FASI.DEDU_PERIOD = V_DEDU_PERIOD) AND (V_OPERATOR IS NULL OR FASI.OPERATOR_ACCOUNT = V_OPERATOR) AND (V_DEDU_DATE_FROM IS NULL OR to_date(SUBSTR(FASI.DEDU_DATE,1,10),'yyyy-MM-dd') >= to_date(V_DEDU_DATE_FROM,'yyyy-MM-dd')) AND (V_DEDU_DATE_TO IS NULL OR to_date(SUBSTR(FASI.DEDU_DATE,1,10),'yyyy-MM-dd') <= to_date(V_DEDU_DATE_TO,'yyyy-MM-dd')) AND (V_PURCHASER_NAME IS NULL OR FASI.PURCHASER_NAME = V_PURCHASER_NAME) AND NOT EXISTS(select 1 from FMM_AUTHED_INVOICE FAI WHERE FAI.PURCHASER_TAX_NO=FASI.PURCHASER_TAX_NO AND FAI.INVOICE_NUM=FASI.INVOICE_NUM AND FAI.INVOICE_CODE=FASI.INVOICE_CODE) UNION ALL select FASI.authed_stat_inv_id as CONTRAST_ID, FAI.PURCHASER_TAX_NO AS PURCHASER_TAX_NO_AUT, FAI.PURCHASER_NAME AS PURCHASER_NAME_AUT, FAI.INVOICE_CODE AS INVOICE_CODE_AUT, FAI.BILLING_DATE AS BILLING_DATE_AUT, FAI.INVOICE_NUM AS INVOICE_NUM_AUT, FAI.AMOUNT_TAX AS AMOUNT_TAX_AUT, FAI.TOTAL_AMOUNT AS TOTAL_AMOUNT_AUT, FASI.PURCHASER_TAX_NO AS PURCHASER_TAX_NO_STAT, FASI.PURCHASER_NAME AS PURCHASER_NAME_STAT, FASI.INVOICE_CODE AS INVOICE_CODE_STAT, FASI.BILLING_DATE AS BILLING_DATE_STAT, FASI.INVOICE_NUM AS INVOICE_NUM_STAT, FASI.Total_Taxt AS AMOUNT_TAX_STAT, FASI.TOTAL_AMOUNT AS TOTAL_AMOUNT_STAT, '3' AS DIFFERENCE_CAUSE, FAI.DEDU_PERIOD AS DEDU_PERIOD_AUT, FASI.DEDU_PERIOD AS DEDU_PERIOD_STAT, SU.USR_NAME AS OPERATOR_AUT, FASI.OPERATOR_ACCOUNT AS OPERATOR_STAT, FAI.DEDU_DATE AS DEDU_DATE_AUT, FASI.DEDU_DATE AS DEDU_DATE_STAT from FMM_AUTHED_STAT_INV FASI inner join FMM_AUTHED_INVOICE FAI LEFT JOIN Sys_User su ON FAI.UPDATED_BY_USER = SU.USR_CODE AND FAI.COMPANY_CODE = SU.COMPANY_CODE on FAI.PURCHASER_TAX_NO=FASI.PURCHASER_TAX_NO and FAI.INVOICE_NUM=FASI.INVOICE_NUM and FAI.INVOICE_CODE=FASI.INVOICE_CODE WHERE 1=1 AND (S_PURCHASER_TAX_NO IS NULL OR FASI.PURCHASER_TAX_NO = S_PURCHASER_TAX_NO) AND (V_INVOICE_NUM IS NULL OR FASI.INVOICE_NUM = V_INVOICE_NUM) AND (V_INVOICE_CODE IS NULL OR FASI.INVOICE_CODE = V_INVOICE_CODE) AND (V_DEDU_PERIOD IS NULL OR FASI.DEDU_PERIOD = V_DEDU_PERIOD) AND (V_OPERATOR IS NULL OR FASI.OPERATOR_ACCOUNT = V_OPERATOR) AND (V_DEDU_DATE_FROM IS NULL OR to_date(SUBSTR(FASI.DEDU_DATE,1,10),'yyyy-MM-dd') >= to_date(V_DEDU_DATE_FROM,'yyyy-MM-dd')) AND (V_DEDU_DATE_TO IS NULL OR to_date(SUBSTR(FASI.DEDU_DATE,1,10),'yyyy-MM-dd') <= to_date(V_DEDU_DATE_TO,'yyyy-MM-dd')) AND (V_PURCHASER_NAME IS NULL OR FASI.PURCHASER_NAME = V_PURCHASER_NAME) AND (FASI.Total_Taxt <> FAI.Total_Taxt or FASI.Total_Amount <> FAI.Total_Amount); END AO_FMS_AUTINV_CONTRAST_STATINV;"
                    }
                ]
            },
            {
                "case_id": "5",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"5\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE OR REPLACE PROCEDURE SP_UPDATE_PRODUCT_PRICING(p_category_id IN NUMBER DEFAULT NULL, p_price_adjustment_pct IN NUMBER, p_min_price IN NUMBER DEFAULT 0, p_max_price IN NUMBER DEFAULT 999999, p_effective_date IN DATE DEFAULT SYSDATE) AS CURSOR c_products IS SELECT p.product_id, p.product_name, p.current_price, p.cost_price, p.category_id, c.category_name, c.price_margin_min, c.price_margin_max FROM products p INNER JOIN categories c ON p.category_id = c.category_id WHERE p.active_flag = 'Y' AND (p.category_id = p_category_id OR p_category_id IS NULL) AND p.current_price BETWEEN p_min_price AND p_max_price ORDER BY p.category_id, p.product_id; TYPE t_price_update IS RECORD (product_id NUMBER, old_price NUMBER, new_price NUMBER, margin_pct NUMBER); TYPE t_price_updates IS TABLE OF t_price_update INDEX BY BINARY_INTEGER; v_price_updates t_price_updates; v_new_price NUMBER; v_margin_pct NUMBER; v_update_count NUMBER := 0; v_skip_count NUMBER := 0; v_batch_id NUMBER; v_idx NUMBER := 1; BEGIN SELECT price_batch_seq.NEXTVAL INTO v_batch_id FROM dual; INSERT INTO price_update_batch (batch_id, update_date, adjustment_percentage, category_id, status) VALUES (v_batch_id, SYSDATE, p_price_adjustment_pct, p_category_id, 'PROCESSING'); FOR rec IN c_products LOOP v_new_price := ROUND(rec.current_price * (1 + p_price_adjustment_pct / 100), 2); v_margin_pct := ((v_new_price - rec.cost_price) / rec.cost_price) * 100; IF v_margin_pct < rec.price_margin_min OR v_margin_pct > rec.price_margin_max THEN INSERT INTO price_update_log (batch_id, product_id, old_price, proposed_price, status, reason, log_date) VALUES (v_batch_id, rec.product_id, rec.current_price, v_new_price, 'REJECTED', 'Margin constraint violation: ' || ROUND(v_margin_pct, 2) || '% (Required: ' || rec.price_margin_min || '-' || rec.price_margin_max || '%)', SYSDATE); v_skip_count := v_skip_count + 1; ELSE v_price_updates(v_idx).product_id := rec.product_id; v_price_updates(v_idx).old_price := rec.current_price; v_price_updates(v_idx).new_price := v_new_price; v_price_updates(v_idx).margin_pct := v_margin_pct; v_idx := v_idx + 1; IF v_idx > 100 THEN FORALL i IN 1..v_price_updates.COUNT UPDATE products SET current_price = v_price_updates(i).new_price, last_price_update = p_effective_date, price_update_batch_id = v_batch_id WHERE product_id = v_price_updates(i).product_id; FORALL i IN 1..v_price_updates.COUNT INSERT INTO price_history (product_id, old_price, new_price, change_date, change_percentage, batch_id, margin_percentage) VALUES (v_price_updates(i).product_id, v_price_updates(i).old_price, v_price_updates(i).new_price, p_effective_date, p_price_adjustment_pct, v_batch_id, v_price_updates(i).margin_pct); v_update_count := v_update_count + v_price_updates.COUNT; v_price_updates.DELETE; v_idx := 1; END IF; END IF; END LOOP; IF v_price_updates.COUNT > 0 THEN FORALL i IN 1..v_price_updates.COUNT UPDATE products SET current_price = v_price_updates(i).new_price, last_price_update = p_effective_date, price_update_batch_id = v_batch_id WHERE product_id = v_price_updates(i).product_id; FORALL i IN 1..v_price_updates.COUNT INSERT INTO price_history (product_id, old_price, new_price, change_date, change_percentage, batch_id, margin_percentage) VALUES (v_price_updates(i).product_id, v_price_updates(i).old_price, v_price_updates(i).new_price, p_effective_date, p_price_adjustment_pct, v_batch_id, v_price_updates(i).margin_pct); v_update_count := v_update_count + v_price_updates.COUNT; END IF; UPDATE price_update_batch SET status = 'COMPLETED', products_updated = v_update_count, products_skipped = v_skip_count, completion_date = SYSDATE WHERE batch_id = v_batch_id; COMMIT; DBMS_OUTPUT.PUT_LINE('Price update completed. Batch ID: ' || v_batch_id); DBMS_OUTPUT.PUT_LINE('Updated: ' || v_update_count || ' products, Skipped: ' || v_skip_count || ' products'); EXCEPTION WHEN OTHERS THEN ROLLBACK; UPDATE price_update_batch SET status = 'FAILED', error_message = SQLERRM, completion_date = SYSDATE WHERE batch_id = v_batch_id; COMMIT; RAISE_APPLICATION_ERROR(-20006, 'Price update failed: ' || SQLERRM); END SP_UPDATE_PRODUCT_PRICING;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PROCEDURE SP_UPDATE_PRODUCT_PRICING(p_category_id IN NUMBER DEFAULT NULL, p_price_adjustment_pct IN NUMBER, p_min_price IN NUMBER DEFAULT 0, p_max_price IN NUMBER DEFAULT 999999, p_effective_date IN DATE DEFAULT SYSDATE) AS CURSOR c_products IS SELECT p.product_id, p.product_name, p.current_price, p.cost_price, p.category_id, c.category_name, c.price_margin_min, c.price_margin_max FROM products p INNER JOIN categories c ON p.category_id = c.category_id WHERE p.active_flag = 'Y' AND (p.category_id = p_category_id OR p_category_id IS NULL) AND p.current_price BETWEEN p_min_price AND p_max_price ORDER BY p.category_id, p.product_id; TYPE t_price_update IS RECORD (product_id NUMBER, old_price NUMBER, new_price NUMBER, margin_pct NUMBER); TYPE t_price_updates IS TABLE OF t_price_update INDEX BY BINARY_INTEGER; v_price_updates t_price_updates; v_new_price NUMBER; v_margin_pct NUMBER; v_update_count NUMBER := 0; v_skip_count NUMBER := 0; v_batch_id NUMBER; v_idx NUMBER := 1; BEGIN SELECT price_batch_seq.NEXTVAL INTO v_batch_id FROM dual; INSERT INTO price_update_batch (batch_id, update_date, adjustment_percentage, category_id, status) VALUES (v_batch_id, SYSDATE, p_price_adjustment_pct, p_category_id, 'PROCESSING'); FOR rec IN c_products LOOP v_new_price := ROUND(rec.current_price * (1 + p_price_adjustment_pct / 100), 2); v_margin_pct := ((v_new_price - rec.cost_price) / rec.cost_price) * 100; IF v_margin_pct < rec.price_margin_min OR v_margin_pct > rec.price_margin_max THEN INSERT INTO price_update_log (batch_id, product_id, old_price, proposed_price, status, reason, log_date) VALUES (v_batch_id, rec.product_id, rec.current_price, v_new_price, 'REJECTED', 'Margin constraint violation: ' || ROUND(v_margin_pct, 2) || '% (Required: ' || rec.price_margin_min || '-' || rec.price_margin_max || '%)', SYSDATE); v_skip_count := v_skip_count + 1; ELSE v_price_updates(v_idx).product_id := rec.product_id; v_price_updates(v_idx).old_price := rec.current_price; v_price_updates(v_idx).new_price := v_new_price; v_price_updates(v_idx).margin_pct := v_margin_pct; v_idx := v_idx + 1; IF v_idx > 100 THEN FORALL i IN 1..v_price_updates.COUNT UPDATE products SET current_price = v_price_updates(i).new_price, last_price_update = p_effective_date, price_update_batch_id = v_batch_id WHERE product_id = v_price_updates(i).product_id; FORALL i IN 1..v_price_updates.COUNT INSERT INTO price_history (product_id, old_price, new_price, change_date, change_percentage, batch_id, margin_percentage) VALUES (v_price_updates(i).product_id, v_price_updates(i).old_price, v_price_updates(i).new_price, p_effective_date, p_price_adjustment_pct, v_batch_id, v_price_updates(i).margin_pct); v_update_count := v_update_count + v_price_updates.COUNT; v_price_updates.DELETE; v_idx := 1; END IF; END IF; END LOOP; IF v_price_updates.COUNT > 0 THEN FORALL i IN 1..v_price_updates.COUNT UPDATE products SET current_price = v_price_updates(i).new_price, last_price_update = p_effective_date, price_update_batch_id = v_batch_id WHERE product_id = v_price_updates(i).product_id; FORALL i IN 1..v_price_updates.COUNT INSERT INTO price_history (product_id, old_price, new_price, change_date, change_percentage, batch_id, margin_percentage) VALUES (v_price_updates(i).product_id, v_price_updates(i).old_price, v_price_updates(i).new_price, p_effective_date, p_price_adjustment_pct, v_batch_id, v_price_updates(i).margin_pct); v_update_count := v_update_count + v_price_updates.COUNT; END IF; UPDATE price_update_batch SET status = 'COMPLETED', products_updated = v_update_count, products_skipped = v_skip_count, completion_date = SYSDATE WHERE batch_id = v_batch_id; COMMIT; DBMS_OUTPUT.PUT_LINE('Price update completed. Batch ID: ' || v_batch_id); DBMS_OUTPUT.PUT_LINE('Updated: ' || v_update_count || ' products, Skipped: ' || v_skip_count || ' products'); EXCEPTION WHEN OTHERS THEN ROLLBACK; UPDATE price_update_batch SET status = 'FAILED', error_message = SQLERRM, completion_date = SYSDATE WHERE batch_id = v_batch_id; COMMIT; RAISE_APPLICATION_ERROR(-20006, 'Price update failed: ' || SQLERRM); END SP_UPDATE_PRODUCT_PRICING;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE SP_UPDATE_PRODUCT_PRICING(p_category_id IN NUMBER DEFAULT NULL, p_price_adjustment_pct IN NUMBER, p_min_price IN NUMBER DEFAULT 0, p_max_price IN NUMBER DEFAULT 999999, p_effective_date IN DATE DEFAULT SYSDATE) AS CURSOR c_products IS SELECT p.product_id, p.product_name, p.current_price, p.cost_price, p.category_id, c.category_name, c.price_margin_min, c.price_margin_max FROM products p INNER JOIN categories c ON p.category_id = c.category_id WHERE p.active_flag = 'Y' AND (p.category_id = p_category_id OR p_category_id IS NULL) AND p.current_price BETWEEN p_min_price AND p_max_price ORDER BY p.category_id, p.product_id; TYPE t_price_update IS RECORD (product_id NUMBER, old_price NUMBER, new_price NUMBER, margin_pct NUMBER); TYPE t_price_updates IS TABLE OF t_price_update INDEX BY BINARY_INTEGER; v_price_updates t_price_updates; v_new_price NUMBER; v_margin_pct NUMBER; v_update_count NUMBER := 0; v_skip_count NUMBER := 0; v_batch_id NUMBER; v_idx NUMBER := 1; BEGIN SELECT price_batch_seq.NEXTVAL INTO v_batch_id FROM dual; INSERT INTO price_update_batch (batch_id, update_date, adjustment_percentage, category_id, status) VALUES (v_batch_id, SYSDATE, p_price_adjustment_pct, p_category_id, 'PROCESSING'); FOR rec IN c_products LOOP v_new_price := ROUND(rec.current_price * (1 + p_price_adjustment_pct / 100), 2); v_margin_pct := ((v_new_price - rec.cost_price) / rec.cost_price) * 100; IF v_margin_pct < rec.price_margin_min OR v_margin_pct > rec.price_margin_max THEN INSERT INTO price_update_log (batch_id, product_id, old_price, proposed_price, status, reason, log_date) VALUES (v_batch_id, rec.product_id, rec.current_price, v_new_price, 'REJECTED', 'Margin constraint violation: ' || ROUND(v_margin_pct, 2) || '% (Required: ' || rec.price_margin_min || '-' || rec.price_margin_max || '%)', SYSDATE); v_skip_count := v_skip_count + 1; ELSE v_price_updates(v_idx).product_id := rec.product_id; v_price_updates(v_idx).old_price := rec.current_price; v_price_updates(v_idx).new_price := v_new_price; v_price_updates(v_idx).margin_pct := v_margin_pct; v_idx := v_idx + 1; IF v_idx > 100 THEN FORALL i IN 1..v_price_updates.COUNT UPDATE products SET current_price = v_price_updates(i).new_price, last_price_update = p_effective_date, price_update_batch_id = v_batch_id WHERE product_id = v_price_updates(i).product_id; FORALL i IN 1..v_price_updates.COUNT INSERT INTO price_history (product_id, old_price, new_price, change_date, change_percentage, batch_id, margin_percentage) VALUES (v_price_updates(i).product_id, v_price_updates(i).old_price, v_price_updates(i).new_price, p_effective_date, p_price_adjustment_pct, v_batch_id, v_price_updates(i).margin_pct); v_update_count := v_update_count + v_price_updates.COUNT; v_price_updates.DELETE; v_idx := 1; END IF; END IF; END LOOP; IF v_price_updates.COUNT > 0 THEN FORALL i IN 1..v_price_updates.COUNT UPDATE products SET current_price = v_price_updates(i).new_price, last_price_update = p_effective_date, price_update_batch_id = v_batch_id WHERE product_id = v_price_updates(i).product_id; FORALL i IN 1..v_price_updates.COUNT INSERT INTO price_history (product_id, old_price, new_price, change_date, change_percentage, batch_id, margin_percentage) VALUES (v_price_updates(i).product_id, v_price_updates(i).old_price, v_price_updates(i).new_price, p_effective_date, p_price_adjustment_pct, v_batch_id, v_price_updates(i).margin_pct); v_update_count := v_update_count + v_price_updates.COUNT; END IF; UPDATE price_update_batch SET status = 'COMPLETED', products_updated = v_update_count, products_skipped = v_skip_count, completion_date = SYSDATE WHERE batch_id = v_batch_id; COMMIT; DBMS_OUTPUT.PUT_LINE('Price update completed. Batch ID: ' || v_batch_id); DBMS_OUTPUT.PUT_LINE('Updated: ' || v_update_count || ' products, Skipped: ' || v_skip_count || ' products'); EXCEPTION WHEN OTHERS THEN ROLLBACK; UPDATE price_update_batch SET status = 'FAILED', error_message = SQLERRM, completion_date = SYSDATE WHERE batch_id = v_batch_id; COMMIT; RAISE_APPLICATION_ERROR(-20006, 'Price update failed: ' || SQLERRM); END SP_UPDATE_PRODUCT_PRICING;"
                    }
                ]
            },
            {
                "case_id": "6",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"6\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"DELIMITER $$ CREATE OR REPLACE PROCEDURE CHECK_AND_UPDATE_SALARIES(p_dept_id IN NUMBER, w_result OUT CLOB, w_percent IN NUMBER, p_min_dept IN NUMBER DEFAULT NULL, p_max_dept IN NUMBER DEFAULT NULL) IS TYPE stats_rec IS RECORD (total_emp NUMBER, avg_salary NUMBER, max_salary NUMBER); TYPE w_result_rec IS RECORD (employee_id NUMBER, last_name VARCHAR2(50), salary NUMBER(8,2)); v_stats stats_rec; v_result w_result_rec; v_cursor SYS_REFCURSOR; v_sql VARCHAR2(1000); v_dept_name VARCHAR2(50); v_rows_updated NUMBER := 0; v_total_budget NUMBER := 0; CURSOR dept_cur IS SELECT department_id, budget FROM DEPARTMENTS WHERE (department_id >= p_min_dept OR p_min_dept IS NULL) AND (department_id <= p_max_dept OR p_max_dept IS NULL); BEGIN SELECT department_name INTO v_dept_name FROM DEPARTMENTS WHERE department_id = p_dept_id; SELECT COUNT(*), AVG(salary), MAX(salary) INTO v_stats.total_emp, v_stats.avg_salary, v_stats.max_salary FROM EMPLOYEES WHERE department_id = p_dept_id; v_sql := 'SELECT * FROM (SELECT employee_id, last_name, salary FROM employees ' || 'WHERE department_id = :1 ORDER BY salary DESC) WHERE ROWNUM <= 5'; OPEN v_cursor FOR v_sql USING p_dept_id; w_result := '{  \\\"department\\\": \\\"' || v_dept_name || '\\\",  \\\"total_employees\\\": ' || v_stats.total_emp || ',  \\\"salary_stats\\\": {    \\\"average\\\": ' || v_stats.avg_salary || ',    \\\"max\\\": ' || v_stats.max_salary || '  },  \\\"top_earners\\\": ['; LOOP FETCH v_cursor INTO v_result; EXIT WHEN v_cursor%NOTFOUND; w_result := w_result || '    {\\\"id\\\": ' || v_result.employee_id || ', \\\"name\\\": \\\"' || v_result.last_name || '\\\", \\\"salary\\\": ' || v_result.salary || '},'; END LOOP; w_result := RTRIM(w_result, ',') || '  ]}'; CLOSE v_cursor; FOR dept_rec IN dept_cur LOOP UPDATE EMPLOYEES SET salary = NVL(salary, 3000) * (1 + w_percent/100) WHERE department_id = dept_rec.department_id; v_rows_updated := v_rows_updated + SQL%ROWCOUNT; SELECT SUM(salary) INTO v_total_budget FROM EMPLOYEES WHERE department_id = dept_rec.department_id; IF v_total_budget > dept_rec.budget THEN RAISE_APPLICATION_ERROR(-20001, 'Budget exceeded in department ' || dept_rec.department_id); END IF; END LOOP; DBMS_OUTPUT.PUT_LINE('Updated ' || v_rows_updated || ' records, Time ' || SYSDATE); EXCEPTION WHEN NO_DATA_FOUND THEN w_result := '{\\\"error\\\": \\\"Department not found\\\"}'; WHEN OTHERS THEN w_result := '{\\\"error\\\": \\\"' || SQLERRM || '\\\"}'; END; $$\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nDELIMITER $$ CREATE OR REPLACE PROCEDURE CHECK_AND_UPDATE_SALARIES(p_dept_id IN NUMBER, w_result OUT CLOB, w_percent IN NUMBER, p_min_dept IN NUMBER DEFAULT NULL, p_max_dept IN NUMBER DEFAULT NULL) IS TYPE stats_rec IS RECORD (total_emp NUMBER, avg_salary NUMBER, max_salary NUMBER); TYPE w_result_rec IS RECORD (employee_id NUMBER, last_name VARCHAR2(50), salary NUMBER(8,2)); v_stats stats_rec; v_result w_result_rec; v_cursor SYS_REFCURSOR; v_sql VARCHAR2(1000); v_dept_name VARCHAR2(50); v_rows_updated NUMBER := 0; v_total_budget NUMBER := 0; CURSOR dept_cur IS SELECT department_id, budget FROM DEPARTMENTS WHERE (department_id >= p_min_dept OR p_min_dept IS NULL) AND (department_id <= p_max_dept OR p_max_dept IS NULL); BEGIN SELECT department_name INTO v_dept_name FROM DEPARTMENTS WHERE department_id = p_dept_id; SELECT COUNT(*), AVG(salary), MAX(salary) INTO v_stats.total_emp, v_stats.avg_salary, v_stats.max_salary FROM EMPLOYEES WHERE department_id = p_dept_id; v_sql := 'SELECT * FROM (SELECT employee_id, last_name, salary FROM employees ' || 'WHERE department_id = :1 ORDER BY salary DESC) WHERE ROWNUM <= 5'; OPEN v_cursor FOR v_sql USING p_dept_id; w_result := '{  \"department\": \"' || v_dept_name || '\",  \"total_employees\": ' || v_stats.total_emp || ',  \"salary_stats\": {    \"average\": ' || v_stats.avg_salary || ',    \"max\": ' || v_stats.max_salary || '  },  \"top_earners\": ['; LOOP FETCH v_cursor INTO v_result; EXIT WHEN v_cursor%NOTFOUND; w_result := w_result || '    {\"id\": ' || v_result.employee_id || ', \"name\": \"' || v_result.last_name || '\", \"salary\": ' || v_result.salary || '},'; END LOOP; w_result := RTRIM(w_result, ',') || '  ]}'; CLOSE v_cursor; FOR dept_rec IN dept_cur LOOP UPDATE EMPLOYEES SET salary = NVL(salary, 3000) * (1 + w_percent/100) WHERE department_id = dept_rec.department_id; v_rows_updated := v_rows_updated + SQL%ROWCOUNT; SELECT SUM(salary) INTO v_total_budget FROM EMPLOYEES WHERE department_id = dept_rec.department_id; IF v_total_budget > dept_rec.budget THEN RAISE_APPLICATION_ERROR(-20001, 'Budget exceeded in department ' || dept_rec.department_id); END IF; END LOOP; DBMS_OUTPUT.PUT_LINE('Updated ' || v_rows_updated || ' records, Time ' || SYSDATE); EXCEPTION WHEN NO_DATA_FOUND THEN w_result := '{\"error\": \"Department not found\"}'; WHEN OTHERS THEN w_result := '{\"error\": \"' || SQLERRM || '\"}'; END; $$\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE FUNCTION CHECK_AND_UPDATE_SALARIES(p_dept_id IN INTEGER, OUT w_result TEXT, w_percent IN NUMERIC, p_min_dept IN INTEGER DEFAULT NULL, p_max_dept IN INTEGER DEFAULT NULL) RETURNS TEXT AS $$\nDECLARE\n    v_stats RECORD;\n    v_result RECORD;\n    v_cursor REFCURSOR;\n    v_sql TEXT;\n    v_dept_name VARCHAR(50);\n    v_rows_updated INTEGER := 0;\n    v_total_budget NUMERIC := 0;\n    dept_cur CURSOR FOR\n        SELECT department_id, budget FROM DEPARTMENTS\n        WHERE (department_id >= p_min_dept OR p_min_dept IS NULL)\n          AND (department_id <= p_max_dept OR p_max_dept IS NULL);\nBEGIN\n    w_result := '';\n\n    SELECT department_name INTO v_dept_name FROM DEPARTMENTS WHERE department_id = p_dept_id;\n\n    SELECT COUNT(*), AVG(salary), MAX(salary)\n    INTO v_stats.total_emp, v_stats.avg_salary, v_stats.max_salary\n    FROM EMPLOYEES WHERE department_id = p_dept_id;\n\n    v_sql := 'SELECT employee_id, last_name, salary FROM employees ' ||\n             'WHERE department_id = $1 ORDER BY salary DESC LIMIT 5';\n\n    OPEN v_cursor FOR EXECUTE v_sql USING p_dept_id;\n\n    w_result := '{  \"department\": \"' || v_dept_name || '\",  \"total_employees\": ' || v_stats.total_emp || ',  \"salary_stats\": {    \"average\": ' || v_stats.avg_salary || ',    \"max\": ' || v_stats.max_salary || '  },  \"top_earners\": [';\n\n    LOOP\n        FETCH v_cursor INTO v_result;\n        EXIT WHEN NOT FOUND;\n        w_result := w_result || '    {\"id\": ' || v_result.employee_id || ', \"name\": \"' || v_result.last_name || '\", \"salary\": ' || v_result.salary || '},';\n    END LOOP;\n\n    w_result := RTRIM(w_result, ',') || '  ]}';\n\n    CLOSE v_cursor;\n\n    FOR dept_rec IN dept_cur LOOP\n        UPDATE EMPLOYEES SET salary = COALESCE(salary, 3000) * (1 + w_percent/100)\n        WHERE department_id = dept_rec.department_id;\n\n        GET DIAGNOSTICS v_rows_updated = ROW_COUNT;\n\n        SELECT SUM(salary) INTO v_total_budget FROM EMPLOYEES WHERE department_id = dept_rec.department_id;\n\n        IF v_total_budget > dept_rec.budget THEN\n            RAISE EXCEPTION 'Budget exceeded in department %', dept_rec.department_id USING ERRCODE = 'P0001';\n        END IF;\n    END LOOP;\n\n    RAISE NOTICE 'Updated % records, Time %', v_rows_updated, NOW();\n\nEXCEPTION\n    WHEN NO_DATA_FOUND THEN\n        w_result := '{\"error\": \"Department not found\"}';\n    WHEN OTHERS THEN\n        w_result := '{\"error\": \"' || SQLERRM || '\"}';\nEND;\n$$ LANGUAGE plpgsql;"
                    }
                ]
            },
            {
                "case_id": "7",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"7\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"CREATE OR REPLACE PROCEDURE SP_BULK_UPDATE_INVENTORY(p_warehouse_id IN NUMBER, p_adjustment_type IN VARCHAR2, p_adjustment_date IN DATE DEFAULT SYSDATE) AS TYPE t_inventory_rec IS RECORD (product_id NUMBER, current_qty NUMBER, adjustment_qty NUMBER, new_qty NUMBER); TYPE t_inventory_tab IS TABLE OF t_inventory_rec INDEX BY BINARY_INTEGER; v_inventory t_inventory_tab; v_batch_size CONSTANT NUMBER := 1000; v_total_processed NUMBER := 0; v_error_count NUMBER := 0; CURSOR c_inventory IS SELECT product_id, quantity_on_hand, CASE p_adjustment_type WHEN 'RECOUNT' THEN physical_count - quantity_on_hand WHEN 'DAMAGE' THEN -damaged_quantity WHEN 'RETURN' THEN returned_quantity ELSE 0 END AS adjustment_qty FROM inventory_staging WHERE warehouse_id = p_warehouse_id AND status = 'PENDING' ORDER BY product_id; BEGIN SAVEPOINT bulk_update_start; OPEN c_inventory; LOOP FETCH c_inventory BULK COLLECT INTO v_inventory LIMIT v_batch_size; EXIT WHEN v_inventory.COUNT = 0; FOR i IN 1..v_inventory.COUNT LOOP BEGIN MERGE INTO inventory inv USING (SELECT v_inventory(i).product_id AS product_id, p_warehouse_id AS warehouse_id, v_inventory(i).adjustment_qty AS adj_qty FROM dual) src ON (inv.product_id = src.product_id AND inv.warehouse_id = src.warehouse_id) WHEN MATCHED THEN UPDATE SET inv.quantity_on_hand = inv.quantity_on_hand + src.adj_qty, inv.last_adjustment_date = p_adjustment_date, inv.last_adjustment_type = p_adjustment_type WHEN NOT MATCHED THEN INSERT (product_id, warehouse_id, quantity_on_hand, last_adjustment_date, last_adjustment_type) VALUES (src.product_id, src.warehouse_id, GREATEST(0, src.adj_qty), p_adjustment_date, p_adjustment_type); INSERT INTO inventory_audit_log (product_id, warehouse_id, adjustment_date, adjustment_type, old_quantity, adjustment_quantity, new_quantity, created_by) VALUES (v_inventory(i).product_id, p_warehouse_id, p_adjustment_date, p_adjustment_type, v_inventory(i).current_qty, v_inventory(i).adjustment_qty, v_inventory(i).current_qty + v_inventory(i).adjustment_qty, USER); v_total_processed := v_total_processed + 1; EXCEPTION WHEN OTHERS THEN v_error_count := v_error_count + 1; INSERT INTO error_log (error_date, error_message, product_id) VALUES (SYSDATE, 'Inventory update failed: ' || SQLERRM, v_inventory(i).product_id); END; END LOOP; END LOOP; CLOSE c_inventory; UPDATE inventory_staging SET status = 'PROCESSED', processed_date = SYSDATE WHERE warehouse_id = p_warehouse_id AND status = 'PENDING'; COMMIT; DBMS_OUTPUT.PUT_LINE('Bulk inventory update completed. Processed: ' || v_total_processed || ', Errors: ' || v_error_count); EXCEPTION WHEN OTHERS THEN ROLLBACK TO bulk_update_start; RAISE_APPLICATION_ERROR(-20001, 'Bulk inventory update failed: ' || SQLERRM); END SP_BULK_UPDATE_INVENTORY;\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PROCEDURE SP_BULK_UPDATE_INVENTORY(p_warehouse_id IN NUMBER, p_adjustment_type IN VARCHAR2, p_adjustment_date IN DATE DEFAULT SYSDATE) AS TYPE t_inventory_rec IS RECORD (product_id NUMBER, current_qty NUMBER, adjustment_qty NUMBER, new_qty NUMBER); TYPE t_inventory_tab IS TABLE OF t_inventory_rec INDEX BY BINARY_INTEGER; v_inventory t_inventory_tab; v_batch_size CONSTANT NUMBER := 1000; v_total_processed NUMBER := 0; v_error_count NUMBER := 0; CURSOR c_inventory IS SELECT product_id, quantity_on_hand, CASE p_adjustment_type WHEN 'RECOUNT' THEN physical_count - quantity_on_hand WHEN 'DAMAGE' THEN -damaged_quantity WHEN 'RETURN' THEN returned_quantity ELSE 0 END AS adjustment_qty FROM inventory_staging WHERE warehouse_id = p_warehouse_id AND status = 'PENDING' ORDER BY product_id; BEGIN SAVEPOINT bulk_update_start; OPEN c_inventory; LOOP FETCH c_inventory BULK COLLECT INTO v_inventory LIMIT v_batch_size; EXIT WHEN v_inventory.COUNT = 0; FOR i IN 1..v_inventory.COUNT LOOP BEGIN MERGE INTO inventory inv USING (SELECT v_inventory(i).product_id AS product_id, p_warehouse_id AS warehouse_id, v_inventory(i).adjustment_qty AS adj_qty FROM dual) src ON (inv.product_id = src.product_id AND inv.warehouse_id = src.warehouse_id) WHEN MATCHED THEN UPDATE SET inv.quantity_on_hand = inv.quantity_on_hand + src.adj_qty, inv.last_adjustment_date = p_adjustment_date, inv.last_adjustment_type = p_adjustment_type WHEN NOT MATCHED THEN INSERT (product_id, warehouse_id, quantity_on_hand, last_adjustment_date, last_adjustment_type) VALUES (src.product_id, src.warehouse_id, GREATEST(0, src.adj_qty), p_adjustment_date, p_adjustment_type); INSERT INTO inventory_audit_log (product_id, warehouse_id, adjustment_date, adjustment_type, old_quantity, adjustment_quantity, new_quantity, created_by) VALUES (v_inventory(i).product_id, p_warehouse_id, p_adjustment_date, p_adjustment_type, v_inventory(i).current_qty, v_inventory(i).adjustment_qty, v_inventory(i).current_qty + v_inventory(i).adjustment_qty, USER); v_total_processed := v_total_processed + 1; EXCEPTION WHEN OTHERS THEN v_error_count := v_error_count + 1; INSERT INTO error_log (error_date, error_message, product_id) VALUES (SYSDATE, 'Inventory update failed: ' || SQLERRM, v_inventory(i).product_id); END; END LOOP; END LOOP; CLOSE c_inventory; UPDATE inventory_staging SET status = 'PROCESSED', processed_date = SYSDATE WHERE warehouse_id = p_warehouse_id AND status = 'PENDING'; COMMIT; DBMS_OUTPUT.PUT_LINE('Bulk inventory update completed. Processed: ' || v_total_processed || ', Errors: ' || v_error_count); EXCEPTION WHEN OTHERS THEN ROLLBACK TO bulk_update_start; RAISE_APPLICATION_ERROR(-20001, 'Bulk inventory update failed: ' || SQLERRM); END SP_BULK_UPDATE_INVENTORY;\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE FUNCTION SP_BULK_UPDATE_INVENTORY(\n    p_warehouse_id NUMERIC,\n    p_adjustment_type VARCHAR,\n    p_adjustment_date TIMESTAMP DEFAULT NOW()\n) RETURNS void AS $$\nDECLARE\n    v_total_processed NUMERIC := 0;\n    v_error_count NUMERIC := 0;\n    r_inventory RECORD; -- Record variable to hold current row from cursor\n    v_new_qty NUMERIC; -- To store calculated new quantity for audit log\n    v_existing_qty NUMERIC; -- To store quantity_on_hand if record exists for UPSERT\nBEGIN\n    SAVEPOINT bulk_update_start;\n\n    FOR r_inventory IN\n        SELECT\n            product_id,\n            quantity_on_hand,\n            CASE p_adjustment_type\n                WHEN 'RECOUNT' THEN physical_count - quantity_on_hand\n                WHEN 'DAMAGE' THEN -damaged_quantity\n                WHEN 'RETURN' THEN returned_quantity\n                ELSE 0\n            END AS adjustment_qty\n        FROM inventory_staging\n        WHERE warehouse_id = p_warehouse_id\n          AND status = 'PENDING'\n        ORDER BY product_id\n    LOOP\n        BEGIN\n            -- PostgreSQL 9.2 equivalent for MERGE (UPSERT logic)\n            SELECT quantity_on_hand INTO v_existing_qty\n            FROM inventory\n            WHERE product_id = r_inventory.product_id\n              AND warehouse_id = p_warehouse_id;\n\n            IF FOUND THEN\n                -- WHEN MATCHED THEN UPDATE\n                UPDATE inventory\n                SET\n                    quantity_on_hand = v_existing_qty + r_inventory.adjustment_qty,\n                    last_adjustment_date"
                    }
                ]
            },
            {
                "case_id": "8",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"8\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"CREATE OR REPLACE PROCEDURE SP_GENERATE_SALES_REPORT(p_year IN NUMBER, p_quarter IN NUMBER, p_sales_rep_id IN NUMBER DEFAULT NULL) AS v_report_id NUMBER; v_total_sales NUMBER := 0; v_total_commission NUMBER := 0; v_report_sql VARCHAR2(4000); TYPE t_sales_summary IS RECORD (sales_rep_id NUMBER, sales_rep_name VARCHAR2(100), total_sales NUMBER, commission_rate NUMBER, commission_amount NUMBER); TYPE t_sales_tab IS TABLE OF t_sales_summary; v_sales_data t_sales_tab; v_start_date DATE; v_end_date DATE; BEGIN v_start_date := TO_DATE(p_year || '-' || LPAD((p_quarter - 1) * 3 + 1, 2, '0') || '-01', 'YYYY-MM-DD'); v_end_date := LAST_DAY(ADD_MONTHS(v_start_date, 2)); SELECT sales_report_seq.NEXTVAL INTO v_report_id FROM dual; v_report_sql := 'SELECT sr.sales_rep_id, sr.sales_rep_name, NVL(SUM(s.sale_amount), 0) as total_sales, sr.commission_rate, NVL(SUM(s.sale_amount), 0) * sr.commission_rate as commission_amount FROM sales_representatives sr LEFT JOIN sales s ON sr.sales_rep_id = s.sales_rep_id AND s.sale_date BETWEEN :1 AND :2 WHERE (:3 IS NULL OR sr.sales_rep_id = :3) GROUP BY sr.sales_rep_id, sr.sales_rep_name, sr.commission_rate ORDER BY total_sales DESC'; EXECUTE IMMEDIATE v_report_sql BULK COLLECT INTO v_sales_data USING v_start_date, v_end_date, p_sales_rep_id, p_sales_rep_id; INSERT INTO sales_report_header (report_id, report_year, report_quarter, created_date, total_reps) VALUES (v_report_id, p_year, p_quarter, SYSDATE, v_sales_data.COUNT); FOR i IN 1..v_sales_data.COUNT LOOP INSERT INTO sales_report_detail (report_id, sales_rep_id, sales_rep_name, total_sales, commission_rate, commission_amount) VALUES (v_report_id, v_sales_data(i).sales_rep_id, v_sales_data(i).sales_rep_name, v_sales_data(i).total_sales, v_sales_data(i).commission_rate, v_sales_data(i).commission_amount); v_total_sales := v_total_sales + v_sales_data(i).total_sales; v_total_commission := v_total_commission + v_sales_data(i).commission_amount; END LOOP; UPDATE sales_report_header SET total_sales = v_total_sales, total_commission = v_total_commission WHERE report_id = v_report_id; COMMIT; DBMS_OUTPUT.PUT_LINE('Sales report generated successfully. Report ID: ' || v_report_id); EXCEPTION WHEN OTHERS THEN ROLLBACK; RAISE_APPLICATION_ERROR(-20002, 'Sales report generation failed: ' || SQLERRM); END SP_GENERATE_SALES_REPORT;\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PROCEDURE SP_GENERATE_SALES_REPORT(p_year IN NUMBER, p_quarter IN NUMBER, p_sales_rep_id IN NUMBER DEFAULT NULL) AS v_report_id NUMBER; v_total_sales NUMBER := 0; v_total_commission NUMBER := 0; v_report_sql VARCHAR2(4000); TYPE t_sales_summary IS RECORD (sales_rep_id NUMBER, sales_rep_name VARCHAR2(100), total_sales NUMBER, commission_rate NUMBER, commission_amount NUMBER); TYPE t_sales_tab IS TABLE OF t_sales_summary; v_sales_data t_sales_tab; v_start_date DATE; v_end_date DATE; BEGIN v_start_date := TO_DATE(p_year || '-' || LPAD((p_quarter - 1) * 3 + 1, 2, '0') || '-01', 'YYYY-MM-DD'); v_end_date := LAST_DAY(ADD_MONTHS(v_start_date, 2)); SELECT sales_report_seq.NEXTVAL INTO v_report_id FROM dual; v_report_sql := 'SELECT sr.sales_rep_id, sr.sales_rep_name, NVL(SUM(s.sale_amount), 0) as total_sales, sr.commission_rate, NVL(SUM(s.sale_amount), 0) * sr.commission_rate as commission_amount FROM sales_representatives sr LEFT JOIN sales s ON sr.sales_rep_id = s.sales_rep_id AND s.sale_date BETWEEN :1 AND :2 WHERE (:3 IS NULL OR sr.sales_rep_id = :3) GROUP BY sr.sales_rep_id, sr.sales_rep_name, sr.commission_rate ORDER BY total_sales DESC'; EXECUTE IMMEDIATE v_report_sql BULK COLLECT INTO v_sales_data USING v_start_date, v_end_date, p_sales_rep_id, p_sales_rep_id; INSERT INTO sales_report_header (report_id, report_year, report_quarter, created_date, total_reps) VALUES (v_report_id, p_year, p_quarter, SYSDATE, v_sales_data.COUNT); FOR i IN 1..v_sales_data.COUNT LOOP INSERT INTO sales_report_detail (report_id, sales_rep_id, sales_rep_name, total_sales, commission_rate, commission_amount) VALUES (v_report_id, v_sales_data(i).sales_rep_id, v_sales_data(i).sales_rep_name, v_sales_data(i).total_sales, v_sales_data(i).commission_rate, v_sales_data(i).commission_amount); v_total_sales := v_total_sales + v_sales_data(i).total_sales; v_total_commission := v_total_commission + v_sales_data(i).commission_amount; END LOOP; UPDATE sales_report_header SET total_sales = v_total_sales, total_commission = v_total_commission WHERE report_id = v_report_id; COMMIT; DBMS_OUTPUT.PUT_LINE('Sales report generated successfully. Report ID: ' || v_report_id); EXCEPTION WHEN OTHERS THEN ROLLBACK; RAISE_APPLICATION_ERROR(-20002, 'Sales report generation failed: ' || SQLERRM); END SP_GENERATE_SALES_REPORT;\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE FUNCTION SP_GENERATE_SALES_REPORT(p_year IN INTEGER, p_quarter IN INTEGER, p_sales_rep_id IN INTEGER DEFAULT NULL)\nRETURNS VOID AS $$\nDECLARE\n    v_report_id NUMERIC;\n    v_total_sales NUMERIC := 0;\n    v_total_commission NUMERIC := 0;\n    v_report_sql TEXT;\n    v_start_date DATE;\n    v_end_date DATE;\n    r_sales_data RECORD;\n    v_total_reps_count INTEGER;\nBEGIN\n    -- Create a temporary table to simulate the Oracle collection behavior\n    CREATE TEMPORARY TABLE temp_sales_summary (\n        sales_rep_id NUMERIC,\n        sales_rep_name VARCHAR(100),\n        total_sales NUMERIC,\n        commission_rate NUMERIC,\n        commission_amount NUMERIC\n    ) ON COMMIT DROP;\n\n    -- Calculate start and end dates for the quarter\n    v_start_date := TO_DATE(p_year || '-' || LPAD(((p_quarter - 1) * 3 + 1)::TEXT, 2, '0') || '-01', 'YYYY-MM-DD');\n    -- Calculate the last day of the third month of the quarter\n    v_end_date := (DATE_TRUNC('month', v_start_date) + INTERVAL '3 months' - INTERVAL '1 day')::DATE;\n\n    -- Get next sequence value\n    SELECT NEXTVAL('sales_report_seq') INTO v_report_id;\n\n    -- Construct the dynamic SQL statement\n    v_report_sql := 'INSERT INTO temp_sales_summary (sales_rep_id, sales_rep_name, total_sales, commission_rate, commission_amount)\n                      SELECT sr.sales_rep_id, sr.sales_rep_name, COALESCE(SUM(s.sale_amount), 0) as total_sales, sr.commission_rate, COALESCE(SUM(s.sale_amount), 0) * sr.commission_rate as commission_amount\n                      FROM sales_representatives sr\n                      LEFT JOIN sales s ON sr.sales_rep_id = s.sales_rep_id AND s.sale_date BETWEEN $1 AND $2\n                      WHERE ($3 IS NULL OR sr.sales_rep_id = $3)\n                      GROUP BY sr.sales_rep_id, sr.sales_rep_name, sr.commission_rate\n                      ORDER BY total_sales DESC';\n\n    -- Execute the dynamic SQL and insert results into the temporary table\n    EXECUTE v_report_sql USING v_start_date, v_end_date, p_sales_rep_id;\n\n    -- Get the count of sales representatives processed\n    SELECT COUNT(*) INTO v_total_reps_count FROM temp_sales_summary;\n\n    -- Insert into sales_report_header\n    INSERT INTO sales_report_header (report_id, report_year, report_quarter, created_date, total_reps)\n    VALUES (v_report_id, p_year, p_quarter, NOW(), v_total_reps_count);\n\n    -- Loop through the temporary table to insert details and calculate totals\n    FOR r_sales_data IN SELECT * FROM temp_sales_summary LOOP\n        INSERT INTO sales_report_detail (report_id, sales_rep_id, sales_rep_name, total_sales, commission_rate, commission_amount)\n        VALUES (v_report_id, r_sales_data.sales_rep_id, r_sales_data.sales_rep_name, r_sales_data.total_sales, r_sales_data.commission_rate, r_sales_data.commission_amount);\n\n        v_total_sales := v_total_sales + r_sales_data.total_sales;\n        v_total_commission := v_total_commission + r_sales_data.commission_amount;\n    END LOOP;\n\n    -- Update sales_report_header with calculated totals\n    UPDATE sales_report_header\n    SET total_sales = v_total_sales,\n        total_commission = v_total_commission\n    WHERE report_id = v_report_id;\n\n    -- PostgreSQL PL/pgSQL functions do not allow explicit COMMIT/ROLLBACK.\n    -- Transaction control is handled by the caller.\n\n    -- Output message (PostgreSQL equivalent of DBMS_OUTPUT.PUT_LINE)\n    RAISE NOTICE 'Sales report generated successfully. Report ID: %', v_report_id;\n\nEXCEPTION\n    WHEN OTHERS THEN\n        -- PostgreSQL PL/pgSQL functions do not allow explicit ROLLBACK.\n        -- Raise an exception (PostgreSQL equivalent of RAISE_APPLICATION_ERROR)\n        RAISE EXCEPTION 'Sales report generation failed: %', SQLERRM;\nEND;\n$$ LANGUAGE plpgsql;"
                    }
                ]
            },
            {
                "case_id": "9",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"9\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"CREATE OR REPLACE FUNCTION FN_GET_RUNNING_BALANCE(p_account_id IN NUMBER, p_transaction_date IN DATE) RETURN NUMBER AS v_balance NUMBER := 0; CURSOR c_transactions IS SELECT transaction_amount, transaction_type FROM account_transactions WHERE account_id = p_account_id AND transaction_date <= p_transaction_date ORDER BY transaction_date, transaction_id; BEGIN FOR txn IN c_transactions LOOP IF txn.transaction_type = 'CREDIT' THEN v_balance := v_balance + txn.transaction_amount; ELSE v_balance := v_balance - txn.transaction_amount; END IF; END LOOP; RETURN v_balance; EXCEPTION WHEN NO_DATA_FOUND THEN RETURN 0; WHEN OTHERS THEN RETURN NULL; END FN_GET_RUNNING_BALANCE;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE FUNCTION FN_GET_RUNNING_BALANCE(p_account_id IN NUMBER, p_transaction_date IN DATE) RETURN NUMBER AS v_balance NUMBER := 0; CURSOR c_transactions IS SELECT transaction_amount, transaction_type FROM account_transactions WHERE account_id = p_account_id AND transaction_date <= p_transaction_date ORDER BY transaction_date, transaction_id; BEGIN FOR txn IN c_transactions LOOP IF txn.transaction_type = 'CREDIT' THEN v_balance := v_balance + txn.transaction_amount; ELSE v_balance := v_balance - txn.transaction_amount; END IF; END LOOP; RETURN v_balance; EXCEPTION WHEN NO_DATA_FOUND THEN RETURN 0; WHEN OTHERS THEN RETURN NULL; END FN_GET_RUNNING_BALANCE;\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE FUNCTION fn_get_running_balance(p_account_id NUMERIC, p_transaction_date DATE) RETURNS NUMERIC AS $$\nDECLARE\n    v_balance NUMERIC := 0;\nBEGIN\n    FOR txn IN SELECT transaction_amount, transaction_type\n               FROM account_transactions\n               WHERE account_id = p_account_id\n                 AND transaction_date <= p_transaction_date\n               ORDER BY transaction_date, transaction_id\n    LOOP\n        IF txn.transaction_type = 'CREDIT' THEN\n            v_balance := v_balance + txn.transaction_amount;\n        ELSE\n            v_balance := v_balance - txn.transaction_amount;\n        END IF;\n    END LOOP;\n\n    RETURN v_balance;\n\nEXCEPTION\n    WHEN OTHERS THEN\n        RETURN NULL;\nEND;\n$$ LANGUAGE plpgsql;"
                    }
                ]
            },
            {
                "case_id": "10",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"10\", \"difficulty_level\": \"3\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"CREATE PROCEDURE SP_BulkInventoryUpdate @WarehouseID INT, @AdjustmentType NVARCHAR(50), @AdjustmentDate DATETIME = NULL AS BEGIN SET NOCOUNT ON; IF @AdjustmentDate IS NULL SET @AdjustmentDate = GETDATE(); DECLARE @ProductID INT, @CurrentQty INT, @AdjustmentQty INT, @NewQty INT; DECLARE @TotalProcessed INT = 0, @ErrorCount INT = 0; DECLARE @ErrorMessage NVARCHAR(4000); DECLARE inventory_cursor CURSOR FOR SELECT ProductID, QuantityOnHand, CASE @AdjustmentType WHEN 'RECOUNT' THEN PhysicalCount - QuantityOnHand WHEN 'DAMAGE' THEN -DamagedQuantity WHEN 'RETURN' THEN ReturnedQuantity ELSE 0 END AS AdjustmentQty FROM InventoryStaging WHERE WarehouseID = @WarehouseID AND Status = 'PENDING' ORDER BY ProductID; BEGIN TRANSACTION; BEGIN TRY OPEN inventory_cursor; FETCH NEXT FROM inventory_cursor INTO @ProductID, @CurrentQty, @AdjustmentQty; WHILE @@FETCH_STATUS = 0 BEGIN BEGIN TRY SET @NewQty = @CurrentQty + @AdjustmentQty; IF EXISTS (SELECT 1 FROM Inventory WHERE ProductID = @ProductID AND WarehouseID = @WarehouseID) UPDATE Inventory SET QuantityOnHand = @NewQty, LastAdjustmentDate = @AdjustmentDate, LastAdjustmentType = @AdjustmentType WHERE ProductID = @ProductID AND WarehouseID = @WarehouseID; ELSE INSERT INTO Inventory (ProductID, WarehouseID, QuantityOnHand, LastAdjustmentDate, LastAdjustmentType) VALUES (@ProductID, @WarehouseID, CASE WHEN @NewQty < 0 THEN 0 ELSE @NewQty END, @AdjustmentDate, @AdjustmentType); INSERT INTO InventoryAuditLog (ProductID, WarehouseID, AdjustmentDate, AdjustmentType, OldQuantity, AdjustmentQuantity, NewQuantity, CreatedBy) VALUES (@ProductID, @WarehouseID, @AdjustmentDate, @AdjustmentType, @CurrentQty, @AdjustmentQty, @NewQty, SUSER_SNAME()); SET @TotalProcessed = @TotalProcessed + 1; END TRY BEGIN CATCH SET @ErrorCount = @ErrorCount + 1; INSERT INTO ErrorLog (ErrorDate, ErrorMessage, ProductID) VALUES (GETDATE(), 'Inventory update failed: ' + ERROR_MESSAGE(), @ProductID); END CATCH; FETCH NEXT FROM inventory_cursor INTO @ProductID, @CurrentQty, @AdjustmentQty; END; CLOSE inventory_cursor; DEALLOCATE inventory_cursor; UPDATE InventoryStaging SET Status = 'PROCESSED', ProcessedDate = GETDATE() WHERE WarehouseID = @WarehouseID AND Status = 'PENDING'; COMMIT TRANSACTION; PRINT 'Bulk inventory update completed. Processed: ' + CAST(@TotalProcessed AS NVARCHAR(10)) + ', Errors: ' + CAST(@ErrorCount AS NVARCHAR(10)); END TRY BEGIN CATCH SET @ErrorMessage = ERROR_MESSAGE(); ROLLBACK TRANSACTION; IF CURSOR_STATUS('global', 'inventory_cursor') >= 0 BEGIN CLOSE inventory_cursor; DEALLOCATE inventory_cursor; END; RAISERROR('Bulk inventory update failed: %s', 16, 1, @ErrorMessage); END CATCH; END;\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE PROCEDURE SP_BulkInventoryUpdate @WarehouseID INT, @AdjustmentType NVARCHAR(50), @AdjustmentDate DATETIME = NULL AS BEGIN SET NOCOUNT ON; IF @AdjustmentDate IS NULL SET @AdjustmentDate = GETDATE(); DECLARE @ProductID INT, @CurrentQty INT, @AdjustmentQty INT, @NewQty INT; DECLARE @TotalProcessed INT = 0, @ErrorCount INT = 0; DECLARE @ErrorMessage NVARCHAR(4000); DECLARE inventory_cursor CURSOR FOR SELECT ProductID, QuantityOnHand, CASE @AdjustmentType WHEN 'RECOUNT' THEN PhysicalCount - QuantityOnHand WHEN 'DAMAGE' THEN -DamagedQuantity WHEN 'RETURN' THEN ReturnedQuantity ELSE 0 END AS AdjustmentQty FROM InventoryStaging WHERE WarehouseID = @WarehouseID AND Status = 'PENDING' ORDER BY ProductID; BEGIN TRANSACTION; BEGIN TRY OPEN inventory_cursor; FETCH NEXT FROM inventory_cursor INTO @ProductID, @CurrentQty, @AdjustmentQty; WHILE @@FETCH_STATUS = 0 BEGIN BEGIN TRY SET @NewQty = @CurrentQty + @AdjustmentQty; IF EXISTS (SELECT 1 FROM Inventory WHERE ProductID = @ProductID AND WarehouseID = @WarehouseID) UPDATE Inventory SET QuantityOnHand = @NewQty, LastAdjustmentDate = @AdjustmentDate, LastAdjustmentType = @AdjustmentType WHERE ProductID = @ProductID AND WarehouseID = @WarehouseID; ELSE INSERT INTO Inventory (ProductID, WarehouseID, QuantityOnHand, LastAdjustmentDate, LastAdjustmentType) VALUES (@ProductID, @WarehouseID, CASE WHEN @NewQty < 0 THEN 0 ELSE @NewQty END, @AdjustmentDate, @AdjustmentType); INSERT INTO InventoryAuditLog (ProductID, WarehouseID, AdjustmentDate, AdjustmentType, OldQuantity, AdjustmentQuantity, NewQuantity, CreatedBy) VALUES (@ProductID, @WarehouseID, @AdjustmentDate, @AdjustmentType, @CurrentQty, @AdjustmentQty, @NewQty, SUSER_SNAME()); SET @TotalProcessed = @TotalProcessed + 1; END TRY BEGIN CATCH SET @ErrorCount = @ErrorCount + 1; INSERT INTO ErrorLog (ErrorDate, ErrorMessage, ProductID) VALUES (GETDATE(), 'Inventory update failed: ' + ERROR_MESSAGE(), @ProductID); END CATCH; FETCH NEXT FROM inventory_cursor INTO @ProductID, @CurrentQty, @AdjustmentQty; END; CLOSE inventory_cursor; DEALLOCATE inventory_cursor; UPDATE InventoryStaging SET Status = 'PROCESSED', ProcessedDate = GETDATE() WHERE WarehouseID = @WarehouseID AND Status = 'PENDING'; COMMIT TRANSACTION; PRINT 'Bulk inventory update completed. Processed: ' + CAST(@TotalProcessed AS NVARCHAR(10)) + ', Errors: ' + CAST(@ErrorCount AS NVARCHAR(10)); END TRY BEGIN CATCH SET @ErrorMessage = ERROR_MESSAGE(); ROLLBACK TRANSACTION; IF CURSOR_STATUS('global', 'inventory_cursor') >= 0 BEGIN CLOSE inventory_cursor; DEALLOCATE inventory_cursor; END; RAISERROR('Bulk inventory update failed: %s', 16, 1, @ErrorMessage); END CATCH; END;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE SP_BulkInventoryUpdate(\n    p_WarehouseID INTEGER,\n    p_AdjustmentType VARCHAR(50),\n    p_AdjustmentDate TIMESTAMP DEFAULT NULL\n)\nAS $$\nDECLARE\n    v_ProductID INTEGER;\n    v_CurrentQty INTEGER;\n    v_AdjustmentQty INTEGER;\n    v_NewQty INTEGER;\n    v_TotalProcessed INTEGER DEFAULT 0;\n    v_ErrorCount INTEGER DEFAULT 0;\n    v_ErrorMessage VARCHAR(4000);\nBEGIN\n    IF p_AdjustmentDate IS NULL THEN\n        p_AdjustmentDate := NOW();\n    END IF;\n\n    BEGIN -- Outer block for transaction and main exception handling\n        BEGIN TRANSACTION;\n\n        FOR r_inventory IN (\n            SELECT\n                ProductID,\n                QuantityOnHand,\n                CASE p_AdjustmentType\n                    WHEN 'RECOUNT' THEN PhysicalCount - QuantityOnHand\n                    WHEN 'DAMAGE' THEN -DamagedQuantity\n                    WHEN 'RETURN' THEN ReturnedQuantity\n                    ELSE 0\n                END AS AdjustmentQty\n            FROM InventoryStaging\n            WHERE WarehouseID = p_WarehouseID AND Status = 'PENDING'\n            ORDER BY ProductID\n        ) LOOP\n            BEGIN -- Inner block for per-row exception handling\n                v_ProductID := r_inventory.ProductID;\n                v_CurrentQty := r_inventory.QuantityOnHand;\n                v_AdjustmentQty := r_inventory.AdjustmentQty;\n\n                v_NewQty := v_CurrentQty + v_AdjustmentQty;\n\n                IF EXISTS (SELECT 1 FROM Inventory WHERE ProductID = v_ProductID AND WarehouseID = p_WarehouseID) THEN\n                    UPDATE Inventory\n                    SET\n                        QuantityOnHand = v_NewQty,\n                        LastAdjustmentDate = p_AdjustmentDate,\n                        LastAdjustmentType = p_AdjustmentType\n                    WHERE ProductID = v_ProductID AND WarehouseID = p_WarehouseID;\n                ELSE\n                    INSERT INTO Inventory (ProductID, WarehouseID, QuantityOnHand, LastAdjustmentDate, LastAdjustmentType)\n                    VALUES (v_ProductID, p_WarehouseID, CASE WHEN v_NewQty < 0 THEN 0 ELSE v_NewQty END, p_AdjustmentDate, p_AdjustmentType);\n                END IF;\n\n                INSERT INTO InventoryAuditLog (ProductID, WarehouseID, AdjustmentDate, AdjustmentType, OldQuantity, AdjustmentQuantity, NewQuantity, CreatedBy)\n                VALUES (v_ProductID, p_WarehouseID, p_AdjustmentDate, p_AdjustmentType, v_CurrentQty, v_AdjustmentQty, v_NewQty, CURRENT_USER);\n\n                v_TotalProcessed := v_TotalProcessed + 1;\n\n            EXCEPTION\n                WHEN OTHERS THEN\n                    v_ErrorCount := v_ErrorCount + 1;\n                    INSERT INTO ErrorLog (ErrorDate, ErrorMessage, ProductID)\n                    VALUES (NOW(), 'Inventory update failed: ' || SQLERRM, v_ProductID);\n            END; -- End of inner BEGIN/EXCEPTION block\n        END LOOP; -- End of FOR loop\n\n        UPDATE InventoryStaging\n        SET Status = 'PROCESSED', ProcessedDate = NOW()\n        WHERE WarehouseID = p_WarehouseID AND Status = 'PENDING';\n\n        COMMIT TRANSACTION;\n\n        RAISE NOTICE 'Bulk inventory update completed. Processed: %, Errors: %', v_TotalProcessed::VARCHAR(10), v_ErrorCount::VARCHAR(10);\n\n    EXCEPTION\n        WHEN OTHERS THEN\n            v_ErrorMessage := SQLERRM;\n            ROLLBACK TRANSACTION;\n            RAISE EXCEPTION 'Bulk inventory update failed: %', v_ErrorMessage;\n    END; -- End of outer BEGIN/EXCEPTION block\nEND;\n$$ LANGUAGE plpgsql;"
                    }
                ]
            },
            {
                "case_id": "11",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"11\", \"difficulty_level\": \"3\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"CREATE PROCEDURE SP_GenerateFinancialReport @PeriodStart DATETIME, @PeriodEnd DATETIME, @ReportType NVARCHAR(50), @DepartmentID INT = NULL AS BEGIN SET NOCOUNT ON; DECLARE @ReportID INT; DECLARE @TotalRevenue DECIMAL(15,2) = 0; DECLARE @TotalExpenses DECIMAL(15,2) = 0; DECLARE @NetIncome DECIMAL(15,2) = 0; DECLARE @SQL NVARCHAR(MAX); DECLARE @Params NVARCHAR(500); BEGIN TRY INSERT INTO FinancialReportHeader (ReportType, PeriodStart, PeriodEnd, DepartmentID, CreatedDate, Status) VALUES (@ReportType, @PeriodStart, @PeriodEnd, @DepartmentID, GETDATE(), 'PROCESSING'); SET @ReportID = SCOPE_IDENTITY(); IF @ReportType = 'INCOME_STATEMENT' BEGIN WITH RevenueData AS ( SELECT AccountID, AccountName, SUM(Amount) AS TotalAmount FROM GeneralLedger gl INNER JOIN ChartOfAccounts coa ON gl.AccountID = coa.AccountID WHERE gl.TransactionDate BETWEEN @PeriodStart AND @PeriodEnd AND coa.AccountType = 'REVENUE' AND (@DepartmentID IS NULL OR gl.DepartmentID = @DepartmentID) GROUP BY AccountID, AccountName ), ExpenseData AS ( SELECT AccountID, AccountName, SUM(Amount) AS TotalAmount FROM GeneralLedger gl INNER JOIN ChartOfAccounts coa ON gl.AccountID = coa.AccountID WHERE gl.TransactionDate BETWEEN @PeriodStart AND @PeriodEnd AND coa.AccountType = 'EXPENSE' AND (@DepartmentID IS NULL OR gl.DepartmentID = @DepartmentID) GROUP BY AccountID, AccountName ) INSERT INTO FinancialReportDetail (ReportID, AccountID, AccountName, AccountType, Amount) SELECT @ReportID, AccountID, AccountName, 'REVENUE', TotalAmount FROM RevenueData UNION ALL SELECT @ReportID, AccountID, AccountName, 'EXPENSE', TotalAmount FROM ExpenseData; SELECT @TotalRevenue = ISNULL(SUM(Amount), 0) FROM FinancialReportDetail WHERE ReportID = @ReportID AND AccountType = 'REVENUE'; SELECT @TotalExpenses = ISNULL(SUM(Amount), 0) FROM FinancialReportDetail WHERE ReportID = @ReportID AND AccountType = 'EXPENSE'; SET @NetIncome = @TotalRevenue - @TotalExpenses; END ELSE IF @ReportType = 'BALANCE_SHEET' BEGIN WITH AssetData AS ( SELECT AccountID, AccountName, SUM(CASE WHEN DebitCredit = 'D' THEN Amount ELSE -Amount END) AS Balance FROM GeneralLedger gl INNER JOIN ChartOfAccounts coa ON gl.AccountID = coa.AccountID WHERE gl.TransactionDate <= @PeriodEnd AND coa.AccountType = 'ASSET' AND (@DepartmentID IS NULL OR gl.DepartmentID = @DepartmentID) GROUP BY AccountID, AccountName ), LiabilityData AS ( SELECT AccountID, AccountName, SUM(CASE WHEN DebitCredit = 'C' THEN Amount ELSE -Amount END) AS Balance FROM GeneralLedger gl INNER JOIN ChartOfAccounts coa ON gl.AccountID = coa.AccountID WHERE gl.TransactionDate <= @PeriodEnd AND coa.AccountType = 'LIABILITY' AND (@DepartmentID IS NULL OR gl.DepartmentID = @DepartmentID) GROUP BY AccountID, AccountName ) INSERT INTO FinancialReportDetail (ReportID, AccountID, AccountName, AccountType, Amount) SELECT @ReportID, AccountID, AccountName, 'ASSET', Balance FROM AssetData WHERE Balance != 0 UNION ALL SELECT @ReportID, AccountID, AccountName, 'LIABILITY', Balance FROM LiabilityData WHERE Balance != 0; END; UPDATE FinancialReportHeader SET TotalRevenue = @TotalRevenue, TotalExpenses = @TotalExpenses, NetIncome = @NetIncome, Status = 'COMPLETED', CompletedDate = GETDATE() WHERE ReportID = @ReportID; PRINT 'Financial report generated successfully. Report ID: ' + CAST(@ReportID AS NVARCHAR(10)); END TRY BEGIN CATCH UPDATE FinancialReportHeader SET Status = 'FAILED', ErrorMessage = ERROR_MESSAGE() WHERE ReportID = @ReportID; RAISERROR('Financial report generation failed: %s', 16, 1, ERROR_MESSAGE()); END CATCH; END;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE PROCEDURE SP_GenerateFinancialReport @PeriodStart DATETIME, @PeriodEnd DATETIME, @ReportType NVARCHAR(50), @DepartmentID INT = NULL AS BEGIN SET NOCOUNT ON; DECLARE @ReportID INT; DECLARE @TotalRevenue DECIMAL(15,2) = 0; DECLARE @TotalExpenses DECIMAL(15,2) = 0; DECLARE @NetIncome DECIMAL(15,2) = 0; DECLARE @SQL NVARCHAR(MAX); DECLARE @Params NVARCHAR(500); BEGIN TRY INSERT INTO FinancialReportHeader (ReportType, PeriodStart, PeriodEnd, DepartmentID, CreatedDate, Status) VALUES (@ReportType, @PeriodStart, @PeriodEnd, @DepartmentID, GETDATE(), 'PROCESSING'); SET @ReportID = SCOPE_IDENTITY(); IF @ReportType = 'INCOME_STATEMENT' BEGIN WITH RevenueData AS ( SELECT AccountID, AccountName, SUM(Amount) AS TotalAmount FROM GeneralLedger gl INNER JOIN ChartOfAccounts coa ON gl.AccountID = coa.AccountID WHERE gl.TransactionDate BETWEEN @PeriodStart AND @PeriodEnd AND coa.AccountType = 'REVENUE' AND (@DepartmentID IS NULL OR gl.DepartmentID = @DepartmentID) GROUP BY AccountID, AccountName ), ExpenseData AS ( SELECT AccountID, AccountName, SUM(Amount) AS TotalAmount FROM GeneralLedger gl INNER JOIN ChartOfAccounts coa ON gl.AccountID = coa.AccountID WHERE gl.TransactionDate BETWEEN @PeriodStart AND @PeriodEnd AND coa.AccountType = 'EXPENSE' AND (@DepartmentID IS NULL OR gl.DepartmentID = @DepartmentID) GROUP BY AccountID, AccountName ) INSERT INTO FinancialReportDetail (ReportID, AccountID, AccountName, AccountType, Amount) SELECT @ReportID, AccountID, AccountName, 'REVENUE', TotalAmount FROM RevenueData UNION ALL SELECT @ReportID, AccountID, AccountName, 'EXPENSE', TotalAmount FROM ExpenseData; SELECT @TotalRevenue = ISNULL(SUM(Amount), 0) FROM FinancialReportDetail WHERE ReportID = @ReportID AND AccountType = 'REVENUE'; SELECT @TotalExpenses = ISNULL(SUM(Amount), 0) FROM FinancialReportDetail WHERE ReportID = @ReportID AND AccountType = 'EXPENSE'; SET @NetIncome = @TotalRevenue - @TotalExpenses; END ELSE IF @ReportType = 'BALANCE_SHEET' BEGIN WITH AssetData AS ( SELECT AccountID, AccountName, SUM(CASE WHEN DebitCredit = 'D' THEN Amount ELSE -Amount END) AS Balance FROM GeneralLedger gl INNER JOIN ChartOfAccounts coa ON gl.AccountID = coa.AccountID WHERE gl.TransactionDate <= @PeriodEnd AND coa.AccountType = 'ASSET' AND (@DepartmentID IS NULL OR gl.DepartmentID = @DepartmentID) GROUP BY AccountID, AccountName ), LiabilityData AS ( SELECT AccountID, AccountName, SUM(CASE WHEN DebitCredit = 'C' THEN Amount ELSE -Amount END) AS Balance FROM GeneralLedger gl INNER JOIN ChartOfAccounts coa ON gl.AccountID = coa.AccountID WHERE gl.TransactionDate <= @PeriodEnd AND coa.AccountType = 'LIABILITY' AND (@DepartmentID IS NULL OR gl.DepartmentID = @DepartmentID) GROUP BY AccountID, AccountName ) INSERT INTO FinancialReportDetail (ReportID, AccountID, AccountName, AccountType, Amount) SELECT @ReportID, AccountID, AccountName, 'ASSET', Balance FROM AssetData WHERE Balance != 0 UNION ALL SELECT @ReportID, AccountID, AccountName, 'LIABILITY', Balance FROM LiabilityData WHERE Balance != 0; END; UPDATE FinancialReportHeader SET TotalRevenue = @TotalRevenue, TotalExpenses = @TotalExpenses, NetIncome = @NetIncome, Status = 'COMPLETED', CompletedDate = GETDATE() WHERE ReportID = @ReportID; PRINT 'Financial report generated successfully. Report ID: ' + CAST(@ReportID AS NVARCHAR(10)); END TRY BEGIN CATCH UPDATE FinancialReportHeader SET Status = 'FAILED', ErrorMessage = ERROR_MESSAGE() WHERE ReportID = @ReportID; RAISERROR('Financial report generation failed: %s', 16, 1, ERROR_MESSAGE()); END CATCH; END;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE sp_generatefinancialreport(\n    p_periodstart TIMESTAMP,\n    p_periodend TIMESTAMP,\n    p_reporttype VARCHAR(50),\n    p_departmentid INTEGER DEFAULT NULL\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_reportid INTEGER;\n    v_totalrevenue NUMERIC(15,2) := 0;\n    v_totalexpenses NUMERIC(15,2) := 0;\n    v_netincome NUMERIC(15,2) := 0;\n    -- @SQL NVARCHAR(MAX) and @Params NVARCHAR(500) were declared but not used in the original SQL Server code,\n    -- so they are omitted in the translation.\nBEGIN\n    -- SET NOCOUNT ON; -- Not applicable in PL/pgSQL, client-side setting\n    BEGIN\n        INSERT INTO FinancialReportHeader (ReportType, PeriodStart, PeriodEnd, DepartmentID, CreatedDate, Status)\n        VALUES (p_ReportType, p_PeriodStart, p_PeriodEnd, p_DepartmentID, NOW(), 'PROCESSING')\n        RETURNING ReportID INTO v_ReportID;\n\n        IF p_ReportType = 'INCOME_STATEMENT' THEN\n            WITH RevenueData AS (\n                SELECT AccountID, AccountName, SUM(Amount) AS TotalAmount\n                FROM GeneralLedger gl\n                INNER JOIN ChartOfAccounts coa ON gl.AccountID = coa.AccountID\n                WHERE gl.TransactionDate BETWEEN p_PeriodStart AND p_PeriodEnd\n                AND coa.AccountType = 'REVENUE'\n                AND (p_DepartmentID IS NULL OR gl.DepartmentID = p_DepartmentID)\n                GROUP BY AccountID, AccountName\n            ), ExpenseData AS (\n                SELECT AccountID, AccountName, SUM(Amount) AS TotalAmount\n                FROM GeneralLedger gl\n                INNER JOIN ChartOfAccounts coa ON gl.AccountID = coa.AccountID\n                WHERE gl.TransactionDate BETWEEN p_PeriodStart AND p_PeriodEnd\n                AND coa.AccountType = 'EXPENSE'\n                AND (p_DepartmentID IS NULL OR gl.DepartmentID = p_DepartmentID)\n                GROUP BY AccountID, AccountName\n            )\n            INSERT INTO FinancialReportDetail (ReportID, AccountID, AccountName, AccountType, Amount)\n            SELECT v_ReportID, AccountID, AccountName, 'REVENUE', TotalAmount FROM RevenueData\n            UNION ALL\n            SELECT v_ReportID, AccountID, AccountName, 'EXPENSE', TotalAmount FROM ExpenseData;\n\n            SELECT COALESCE(SUM(Amount), 0) INTO v_TotalRevenue FROM FinancialReportDetail WHERE ReportID = v_ReportID AND AccountType = 'REVENUE';\n            SELECT COALESCE(SUM(Amount), 0) INTO v_TotalExpenses FROM FinancialReportDetail WHERE ReportID = v_ReportID AND AccountType = 'EXPENSE';\n            v_NetIncome := v_TotalRevenue - v_TotalExpenses;\n\n        ELSIF p_ReportType = 'BALANCE_SHEET' THEN\n            WITH AssetData AS (\n                SELECT AccountID, AccountName, SUM(CASE WHEN DebitCredit = 'D' THEN Amount ELSE -Amount END) AS Balance\n                FROM GeneralLedger gl\n                INNER JOIN ChartOfAccounts coa ON gl.AccountID = coa.AccountID\n                WHERE gl.TransactionDate <= p_PeriodEnd\n                AND coa.AccountType = 'ASSET'\n                AND (p_DepartmentID IS NULL OR gl.DepartmentID = p_DepartmentID)\n                GROUP BY AccountID, AccountName\n            ), LiabilityData AS (\n                SELECT AccountID, AccountName, SUM(CASE WHEN DebitCredit = 'C' THEN Amount ELSE -Amount END) AS Balance\n                FROM GeneralLedger gl\n                INNER JOIN ChartOfAccounts coa ON gl.AccountID = coa.AccountID\n                WHERE gl.TransactionDate <= p_PeriodEnd\n                AND coa.AccountType = 'LIABILITY'\n                AND (p_DepartmentID IS NULL OR gl.DepartmentID = p_DepartmentID)\n                GROUP BY AccountID, AccountName\n            )\n            INSERT INTO FinancialReportDetail (ReportID, AccountID, AccountName, AccountType, Amount)\n            SELECT v_ReportID, AccountID, AccountName, 'ASSET', Balance FROM AssetData WHERE Balance != 0\n            UNION ALL\n            SELECT v_ReportID, AccountID, AccountName, 'LIABILITY', Balance FROM LiabilityData WHERE Balance != 0;\n        END IF;\n\n        UPDATE FinancialReportHeader\n        SET TotalRevenue = v_TotalRevenue,\n            TotalExpenses = v_TotalExpenses,\n            NetIncome = v_NetIncome,\n            Status = 'COMPLETED',\n            CompletedDate = NOW()\n        WHERE ReportID = v_ReportID;\n\n        RAISE NOTICE 'Financial report generated successfully. Report ID: %', v_ReportID;\n\n    EXCEPTION\n        WHEN OTHERS THEN\n            -- Only attempt to update if v_ReportID has been assigned\n            IF v_ReportID IS NOT NULL THEN\n                UPDATE FinancialReportHeader\n                SET Status = 'FAILED',\n                    ErrorMessage = SQLERRM\n                WHERE ReportID = v_ReportID;\n            END IF;\n            RAISE EXCEPTION 'Financial report generation failed: %', SQLERRM;\n    END;\nEND;\n$$;"
                    }
                ]
            },
            {
                "case_id": "12",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"12\", \"difficulty_level\": \"2\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"CREATE PROCEDURE SP_ProcessPayroll @PayPeriodStart DATETIME, @PayPeriodEnd DATETIME, @DepartmentID INT = NULL AS BEGIN SET NOCOUNT ON; DECLARE @PayrollID INT; DECLARE @EmployeeID INT, @HourlyRate DECIMAL(10,2), @RegularHours DECIMAL(5,2), @OvertimeHours DECIMAL(5,2); DECLARE @GrossPay DECIMAL(10,2), @TaxDeduction DECIMAL(10,2), @NetPay DECIMAL(10,2); DECLARE @TotalGross DECIMAL(15,2) = 0, @TotalNet DECIMAL(15,2) = 0; DECLARE employee_cursor CURSOR FOR SELECT e.EmployeeID, e.HourlyRate, ISNULL(SUM(CASE WHEN t.Hours <= 8 THEN t.Hours ELSE 8 END), 0) AS RegularHours, ISNULL(SUM(CASE WHEN t.Hours > 8 THEN t.Hours - 8 ELSE 0 END), 0) AS OvertimeHours FROM Employees e LEFT JOIN Timesheet t ON e.EmployeeID = t.EmployeeID AND t.WorkDate BETWEEN @PayPeriodStart AND @PayPeriodEnd WHERE e.Status = 'ACTIVE' AND (@DepartmentID IS NULL OR e.DepartmentID = @DepartmentID) GROUP BY e.EmployeeID, e.HourlyRate ORDER BY e.EmployeeID; BEGIN TRY INSERT INTO PayrollHeader (PayPeriodStart, PayPeriodEnd, DepartmentID, CreatedDate, Status) VALUES (@PayPeriodStart, @PayPeriodEnd, @DepartmentID, GETDATE(), 'PROCESSING'); SET @PayrollID = SCOPE_IDENTITY(); OPEN employee_cursor; FETCH NEXT FROM employee_cursor INTO @EmployeeID, @HourlyRate, @RegularHours, @OvertimeHours; WHILE @@FETCH_STATUS = 0 BEGIN SET @GrossPay = (@RegularHours * @HourlyRate) + (@OvertimeHours * @HourlyRate * 1.5); SET @TaxDeduction = @GrossPay * 0.20; -- 20% tax rate SET @NetPay = @GrossPay - @TaxDeduction; INSERT INTO PayrollDetail (PayrollID, EmployeeID, HourlyRate, RegularHours, OvertimeHours, GrossPay, TaxDeduction, NetPay) VALUES (@PayrollID, @EmployeeID, @HourlyRate, @RegularHours, @OvertimeHours, @GrossPay, @TaxDeduction, @NetPay); SET @TotalGross = @TotalGross + @GrossPay; SET @TotalNet = @TotalNet + @NetPay; FETCH NEXT FROM employee_cursor INTO @EmployeeID, @HourlyRate, @RegularHours, @OvertimeHours; END; CLOSE employee_cursor; DEALLOCATE employee_cursor; UPDATE PayrollHeader SET TotalGrossPay = @TotalGross, TotalNetPay = @TotalNet, Status = 'COMPLETED', CompletedDate = GETDATE() WHERE PayrollID = @PayrollID; PRINT 'Payroll processing completed. Payroll ID: ' + CAST(@PayrollID AS NVARCHAR(10)); END TRY BEGIN CATCH IF CURSOR_STATUS('global', 'employee_cursor') >= 0 BEGIN CLOSE employee_cursor; DEALLOCATE employee_cursor; END; UPDATE PayrollHeader SET Status = 'FAILED', ErrorMessage = ERROR_MESSAGE() WHERE PayrollID = @PayrollID; RAISERROR('Payroll processing failed: %s', 16, 1, ERROR_MESSAGE()); END CATCH; END;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE PROCEDURE SP_ProcessPayroll @PayPeriodStart DATETIME, @PayPeriodEnd DATETIME, @DepartmentID INT = NULL AS BEGIN SET NOCOUNT ON; DECLARE @PayrollID INT; DECLARE @EmployeeID INT, @HourlyRate DECIMAL(10,2), @RegularHours DECIMAL(5,2), @OvertimeHours DECIMAL(5,2); DECLARE @GrossPay DECIMAL(10,2), @TaxDeduction DECIMAL(10,2), @NetPay DECIMAL(10,2); DECLARE @TotalGross DECIMAL(15,2) = 0, @TotalNet DECIMAL(15,2) = 0; DECLARE employee_cursor CURSOR FOR SELECT e.EmployeeID, e.HourlyRate, ISNULL(SUM(CASE WHEN t.Hours <= 8 THEN t.Hours ELSE 8 END), 0) AS RegularHours, ISNULL(SUM(CASE WHEN t.Hours > 8 THEN t.Hours - 8 ELSE 0 END), 0) AS OvertimeHours FROM Employees e LEFT JOIN Timesheet t ON e.EmployeeID = t.EmployeeID AND t.WorkDate BETWEEN @PayPeriodStart AND @PayPeriodEnd WHERE e.Status = 'ACTIVE' AND (@DepartmentID IS NULL OR e.DepartmentID = @DepartmentID) GROUP BY e.EmployeeID, e.HourlyRate ORDER BY e.EmployeeID; BEGIN TRY INSERT INTO PayrollHeader (PayPeriodStart, PayPeriodEnd, DepartmentID, CreatedDate, Status) VALUES (@PayPeriodStart, @PayPeriodEnd, @DepartmentID, GETDATE(), 'PROCESSING'); SET @PayrollID = SCOPE_IDENTITY(); OPEN employee_cursor; FETCH NEXT FROM employee_cursor INTO @EmployeeID, @HourlyRate, @RegularHours, @OvertimeHours; WHILE @@FETCH_STATUS = 0 BEGIN SET @GrossPay = (@RegularHours * @HourlyRate) + (@OvertimeHours * @HourlyRate * 1.5); SET @TaxDeduction = @GrossPay * 0.20; -- 20% tax rate SET @NetPay = @GrossPay - @TaxDeduction; INSERT INTO PayrollDetail (PayrollID, EmployeeID, HourlyRate, RegularHours, OvertimeHours, GrossPay, TaxDeduction, NetPay) VALUES (@PayrollID, @EmployeeID, @HourlyRate, @RegularHours, @OvertimeHours, @GrossPay, @TaxDeduction, @NetPay); SET @TotalGross = @TotalGross + @GrossPay; SET @TotalNet = @TotalNet + @NetPay; FETCH NEXT FROM employee_cursor INTO @EmployeeID, @HourlyRate, @RegularHours, @OvertimeHours; END; CLOSE employee_cursor; DEALLOCATE employee_cursor; UPDATE PayrollHeader SET TotalGrossPay = @TotalGross, TotalNetPay = @TotalNet, Status = 'COMPLETED', CompletedDate = GETDATE() WHERE PayrollID = @PayrollID; PRINT 'Payroll processing completed. Payroll ID: ' + CAST(@PayrollID AS NVARCHAR(10)); END TRY BEGIN CATCH IF CURSOR_STATUS('global', 'employee_cursor') >= 0 BEGIN CLOSE employee_cursor; DEALLOCATE employee_cursor; END; UPDATE PayrollHeader SET Status = 'FAILED', ErrorMessage = ERROR_MESSAGE() WHERE PayrollID = @PayrollID; RAISERROR('Payroll processing failed: %s', 16, 1, ERROR_MESSAGE()); END CATCH; END;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE SP_ProcessPayroll(\n    PayPeriodStart TIMESTAMP,\n    PayPeriodEnd TIMESTAMP,\n    DepartmentID INT DEFAULT NULL\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_PayrollID INT;\n    v_EmployeeID INT;\n    v_HourlyRate DECIMAL(10,2);\n    v_RegularHours DECIMAL(5,2);\n    v_OvertimeHours DECIMAL(5,2);\n    v_GrossPay DECIMAL(10,2);\n    v_TaxDeduction DECIMAL(10,2);\n    v_NetPay DECIMAL(10,2);\n    v_TotalGross DECIMAL(15,2) := 0;\n    v_TotalNet DECIMAL(15,2) := 0;\nBEGIN\n    BEGIN\n        INSERT INTO PayrollHeader (PayPeriodStart, PayPeriodEnd, DepartmentID, CreatedDate, Status)\n        VALUES (PayPeriodStart, PayPeriodEnd, DepartmentID, NOW(), 'PROCESSING')\n        RETURNING PayrollID INTO v_PayrollID;\n\n        FOR r_employee IN (\n            SELECT\n                e.EmployeeID,\n                e.HourlyRate,\n                COALESCE(SUM(CASE WHEN t.Hours <= 8 THEN t.Hours ELSE 8 END), 0) AS RegularHours,\n                COALESCE(SUM(CASE WHEN t.Hours > 8 THEN t.Hours - 8 ELSE 0 END), 0) AS OvertimeHours\n            FROM Employees e\n            LEFT JOIN Timesheet t ON e.EmployeeID = t.EmployeeID AND t.WorkDate BETWEEN PayPeriodStart AND PayPeriodEnd\n            WHERE e.Status = 'ACTIVE' AND (DepartmentID IS NULL OR e.DepartmentID = DepartmentID)\n            GROUP BY e.EmployeeID, e.HourlyRate\n            ORDER BY e.EmployeeID\n        ) LOOP\n            v_EmployeeID := r_employee.EmployeeID;\n            v_HourlyRate := r_employee.HourlyRate;\n            v_RegularHours := r_employee.RegularHours;\n            v_OvertimeHours := r_employee.OvertimeHours;\n\n            v_GrossPay := (v_RegularHours * v_HourlyRate) + (v_OvertimeHours * v_HourlyRate * 1.5);\n            v_TaxDeduction := v_GrossPay * 0.20; -- 20% tax rate\n            v_NetPay := v_GrossPay - v_TaxDeduction;\n\n            INSERT INTO PayrollDetail (PayrollID, EmployeeID, HourlyRate, RegularHours, OvertimeHours, GrossPay, TaxDeduction, NetPay)\n            VALUES (v_PayrollID, v_EmployeeID, v_HourlyRate, v_RegularHours, v_OvertimeHours, v_GrossPay, v_TaxDeduction, v_NetPay);\n\n            v_TotalGross := v_TotalGross + v_GrossPay;\n            v_TotalNet := v_TotalNet + v_NetPay;\n        END LOOP;\n\n        UPDATE PayrollHeader\n        SET TotalGrossPay = v_TotalGross, TotalNetPay = v_TotalNet, Status = 'COMPLETED', CompletedDate = NOW()\n        WHERE PayrollID = v_PayrollID;\n\n        RAISE NOTICE 'Payroll processing completed. Payroll ID: %', v_PayrollID;\n\n    EXCEPTION\n        WHEN OTHERS THEN\n            IF v_PayrollID IS NOT NULL THEN\n                UPDATE PayrollHeader\n                SET Status = 'FAILED', ErrorMessage = SQLERRM\n                WHERE PayrollID = v_PayrollID;\n            END IF;\n            RAISE EXCEPTION 'Payroll processing failed: %', SQLERRM;\n    END;\nEND;\n$$;"
                    }
                ]
            },
            {
                "case_id": "13",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"13\", \"difficulty_level\": \"1\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"CREATE PROCEDURE SP_CleanupOldLogs @RetentionDays INT = 90 AS BEGIN SET NOCOUNT ON; DECLARE @CutoffDate DATETIME; DECLARE @DeletedCount INT; SET @CutoffDate = DATEADD(DAY, -@RetentionDays, GETDATE()); BEGIN TRY DELETE FROM ApplicationLogs WHERE LogDate < @CutoffDate; SET @DeletedCount = @@ROWCOUNT; DELETE FROM ErrorLogs WHERE ErrorDate < @CutoffDate; SET @DeletedCount = @DeletedCount + @@ROWCOUNT; DELETE FROM AuditLogs WHERE AuditDate < @CutoffDate; SET @DeletedCount = @DeletedCount + @@ROWCOUNT; INSERT INTO CleanupHistory (CleanupDate, TableName, RecordsDeleted, RetentionDays) VALUES (GETDATE(), 'MULTIPLE_LOG_TABLES', @DeletedCount, @RetentionDays); PRINT 'Cleanup completed. ' + CAST(@DeletedCount AS NVARCHAR(10)) + ' records deleted.'; END TRY BEGIN CATCH RAISERROR('Log cleanup failed: %s', 16, 1, ERROR_MESSAGE()); END CATCH; END;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE PROCEDURE SP_CleanupOldLogs @RetentionDays INT = 90 AS BEGIN SET NOCOUNT ON; DECLARE @CutoffDate DATETIME; DECLARE @DeletedCount INT; SET @CutoffDate = DATEADD(DAY, -@RetentionDays, GETDATE()); BEGIN TRY DELETE FROM ApplicationLogs WHERE LogDate < @CutoffDate; SET @DeletedCount = @@ROWCOUNT; DELETE FROM ErrorLogs WHERE ErrorDate < @CutoffDate; SET @DeletedCount = @DeletedCount + @@ROWCOUNT; DELETE FROM AuditLogs WHERE AuditDate < @CutoffDate; SET @DeletedCount = @DeletedCount + @@ROWCOUNT; INSERT INTO CleanupHistory (CleanupDate, TableName, RecordsDeleted, RetentionDays) VALUES (GETDATE(), 'MULTIPLE_LOG_TABLES', @DeletedCount, @RetentionDays); PRINT 'Cleanup completed. ' + CAST(@DeletedCount AS NVARCHAR(10)) + ' records deleted.'; END TRY BEGIN CATCH RAISERROR('Log cleanup failed: %s', 16, 1, ERROR_MESSAGE()); END CATCH; END;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE SP_CleanupOldLogs(p_retention_days IN INTEGER DEFAULT 90)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_cutoff_date   TIMESTAMP;\n    v_deleted_count INTEGER := 0;\n    v_rows_affected INTEGER;\nBEGIN\n    v_cutoff_date := NOW() - (p_retention_days || ' days')::INTERVAL;\n\n    BEGIN\n        DELETE FROM ApplicationLogs WHERE LogDate < v_cutoff_date;\n        GET DIAGNOSTICS v_rows_affected = ROW_COUNT;\n        v_deleted_count := v_deleted_count + v_rows_affected;\n\n        DELETE FROM ErrorLogs WHERE ErrorDate < v_cutoff_date;\n        GET DIAGNOSTICS v_rows_affected = ROW_COUNT;\n        v_deleted_count := v_deleted_count + v_rows_affected;\n\n        DELETE FROM AuditLogs WHERE AuditDate < v_cutoff_date;\n        GET DIAGNOSTICS v_rows_affected = ROW_COUNT;\n        v_deleted_count := v_deleted_count + v_rows_affected;\n\n        INSERT INTO CleanupHistory (CleanupDate, TableName, RecordsDeleted, RetentionDays)\n        VALUES (NOW(), 'MULTIPLE_LOG_TABLES', v_deleted_count, p_retention_days);\n\n        RAISE NOTICE 'Cleanup completed. % records deleted.', v_deleted_count;\n\n    EXCEPTION\n        WHEN OTHERS THEN\n            RAISE EXCEPTION 'Log cleanup failed: %', SQLERRM;\n    END;\nEND;\n$$;"
                    }
                ]
            },
            {
                "case_id": "14",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"14\", \"difficulty_level\": \"3\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"CREATE PROCEDURE SP_DataMigration @SourceTable NVARCHAR(128), @TargetTable NVARCHAR(128), @BatchSize INT = 10000 AS BEGIN SET NOCOUNT ON; DECLARE @SQL NVARCHAR(MAX); DECLARE @SourceCount INT, @TargetCount INT, @BatchCount INT = 0; DECLARE @MigrationID INT; DECLARE @ErrorMessage NVARCHAR(4000); BEGIN TRY INSERT INTO MigrationLog (SourceTable, TargetTable, StartTime, Status) VALUES (@SourceTable, @TargetTable, GETDATE(), 'RUNNING'); SET @MigrationID = SCOPE_IDENTITY(); SET @SQL = 'SELECT @Count = COUNT(*) FROM ' + @SourceTable; EXEC sp_executesql @SQL, N'@Count INT OUTPUT', @Count = @SourceCount OUTPUT; UPDATE MigrationLog SET SourceCount = @SourceCount WHERE MigrationID = @MigrationID; SET @SQL = 'DELETE FROM ' + @TargetTable; EXEC sp_executesql @SQL; WHILE @BatchCount < @SourceCount BEGIN SET @SQL = 'INSERT INTO ' + @TargetTable + ' SELECT TOP ' + CAST(@BatchSize AS NVARCHAR(10)) + ' * FROM ' + @SourceTable + ' WHERE NOT EXISTS (SELECT 1 FROM ' + @TargetTable + ' t WHERE t.ID = ' + @SourceTable + '.ID)'; EXEC sp_executesql @SQL; IF @@ROWCOUNT = 0 BREAK; SET @BatchCount = @BatchCount + @@ROWCOUNT; END; SET @SQL = 'SELECT @Count = COUNT(*) FROM ' + @TargetTable; EXEC sp_executesql @SQL, N'@Count INT OUTPUT', @Count = @TargetCount OUTPUT; UPDATE MigrationLog SET EndTime = GETDATE(), TargetCount = @TargetCount, Status = CASE WHEN @SourceCount = @TargetCount THEN 'SUCCESS' ELSE 'WARNING' END WHERE MigrationID = @MigrationID; PRINT 'Migration completed for ' + @SourceTable + '. Source: ' + CAST(@SourceCount AS NVARCHAR(10)) + ', Target: ' + CAST(@TargetCount AS NVARCHAR(10)); END TRY BEGIN CATCH SET @ErrorMessage = ERROR_MESSAGE(); UPDATE MigrationLog SET EndTime = GETDATE(), Status = 'FAILED', ErrorMessage = @ErrorMessage WHERE MigrationID = @MigrationID; RAISERROR('Data migration failed: %s', 16, 1, @ErrorMessage); END CATCH; END;\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE PROCEDURE SP_DataMigration @SourceTable NVARCHAR(128), @TargetTable NVARCHAR(128), @BatchSize INT = 10000 AS BEGIN SET NOCOUNT ON; DECLARE @SQL NVARCHAR(MAX); DECLARE @SourceCount INT, @TargetCount INT, @BatchCount INT = 0; DECLARE @MigrationID INT; DECLARE @ErrorMessage NVARCHAR(4000); BEGIN TRY INSERT INTO MigrationLog (SourceTable, TargetTable, StartTime, Status) VALUES (@SourceTable, @TargetTable, GETDATE(), 'RUNNING'); SET @MigrationID = SCOPE_IDENTITY(); SET @SQL = 'SELECT @Count = COUNT(*) FROM ' + @SourceTable; EXEC sp_executesql @SQL, N'@Count INT OUTPUT', @Count = @SourceCount OUTPUT; UPDATE MigrationLog SET SourceCount = @SourceCount WHERE MigrationID = @MigrationID; SET @SQL = 'DELETE FROM ' + @TargetTable; EXEC sp_executesql @SQL; WHILE @BatchCount < @SourceCount BEGIN SET @SQL = 'INSERT INTO ' + @TargetTable + ' SELECT TOP ' + CAST(@BatchSize AS NVARCHAR(10)) + ' * FROM ' + @SourceTable + ' WHERE NOT EXISTS (SELECT 1 FROM ' + @TargetTable + ' t WHERE t.ID = ' + @SourceTable + '.ID)'; EXEC sp_executesql @SQL; IF @@ROWCOUNT = 0 BREAK; SET @BatchCount = @BatchCount + @@ROWCOUNT; END; SET @SQL = 'SELECT @Count = COUNT(*) FROM ' + @TargetTable; EXEC sp_executesql @SQL, N'@Count INT OUTPUT', @Count = @TargetCount OUTPUT; UPDATE MigrationLog SET EndTime = GETDATE(), TargetCount = @TargetCount, Status = CASE WHEN @SourceCount = @TargetCount THEN 'SUCCESS' ELSE 'WARNING' END WHERE MigrationID = @MigrationID; PRINT 'Migration completed for ' + @SourceTable + '. Source: ' + CAST(@SourceCount AS NVARCHAR(10)) + ', Target: ' + CAST(@TargetCount AS NVARCHAR(10)); END TRY BEGIN CATCH SET @ErrorMessage = ERROR_MESSAGE(); UPDATE MigrationLog SET EndTime = GETDATE(), Status = 'FAILED', ErrorMessage = @ErrorMessage WHERE MigrationID = @MigrationID; RAISERROR('Data migration failed: %s', 16, 1, @ErrorMessage); END CATCH; END;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE SP_DataMigration(SourceTable VARCHAR(128), TargetTable VARCHAR(128), BatchSize INT DEFAULT 10000)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_sql TEXT;\n    v_source_count INT;\n    v_target_count INT;\n    v_batch_count INT := 0;\n    v_migration_id INT;\n    v_error_message TEXT;\n    v_row_count INT;\nBEGIN\n    -- SQL Server's SET NOCOUNT ON is not directly applicable in PL/pgSQL as it doesn't return row counts as messages by default.\n\n    INSERT INTO MigrationLog (SourceTable, TargetTable, StartTime, Status)\n    VALUES (SourceTable, TargetTable, NOW(), 'RUNNING')\n    RETURNING MigrationID INTO v_migration_id;\n\n    -- Get Source Count\n    v_sql := 'SELECT COUNT(*) FROM ' || SourceTable;\n    EXECUTE v_sql INTO v_source_count;\n\n    UPDATE MigrationLog SET SourceCount = v_source_count WHERE MigrationID = v_migration_id;\n\n    -- Clear Target Table\n    v_sql := 'DELETE FROM ' || TargetTable;\n    EXECUTE v_sql;\n\n    -- Batch Migration Loop\n    WHILE v_batch_count < v_source_count LOOP\n        -- Construct the batch insert statement\n        -- Assuming 'ID' is the common unique identifier column in both tables.\n        v_sql := 'INSERT INTO ' || TargetTable || ' SELECT * FROM ' || SourceTable ||\n                 ' WHERE NOT EXISTS (SELECT 1 FROM ' || TargetTable || ' t WHERE t.ID = ' || SourceTable || '.ID) LIMIT ' || BatchSize::TEXT;\n        EXECUTE v_sql;\n\n        GET DIAGNOSTICS v_row_count = ROW_COUNT;\n\n        IF v_row_count = 0 THEN\n            EXIT; -- No more rows to migrate or all remaining rows already exist in target\n        END IF;\n\n        v_batch_count := v_batch_count + v_row_count;\n    END LOOP;\n\n    -- Get Target Count\n    v_sql := 'SELECT COUNT(*) FROM ' || TargetTable;\n    EXECUTE v_sql INTO v_target_count;\n\n    -- Update Migration Log with results\n    UPDATE MigrationLog\n    SET EndTime = NOW(),\n        TargetCount = v_target_count,\n        Status = CASE WHEN v_source_count = v_target_count THEN 'SUCCESS' ELSE 'WARNING' END\n    WHERE MigrationID = v_migration_id;\n\n    RAISE NOTICE 'Migration completed for %. Source: %, Target: %', SourceTable, v_source_count, v_target_count;\n\nEXCEPTION\n    WHEN OTHERS THEN\n        v_error_message := SQLERRM;\n        UPDATE MigrationLog\n        SET EndTime = NOW(),\n            Status = 'FAILED',\n            ErrorMessage = v_error_message\n        WHERE MigrationID = v_migration_id;\n        RAISE EXCEPTION 'Data migration failed: %', v_error_message;\nEND;\n$$;"
                    }
                ]
            },
            {
                "case_id": "15",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"15\", \"difficulty_level\": \"2\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"CREATE PROCEDURE SP_UpdateProductCategories @OldCategoryID INT, @NewCategoryID INT, @EffectiveDate DATETIME = NULL AS BEGIN SET NOCOUNT ON; IF @EffectiveDate IS NULL SET @EffectiveDate = GETDATE(); DECLARE @ProductCount INT, @UpdatedCount INT = 0; DECLARE @ProductID INT, @ProductName NVARCHAR(100); DECLARE product_cursor CURSOR FOR SELECT ProductID, ProductName FROM Products WHERE CategoryID = @OldCategoryID AND Status = 'ACTIVE'; BEGIN TRY IF @OldCategoryID = @NewCategoryID RAISERROR('Old and new category IDs cannot be the same', 16, 1); SELECT @ProductCount = COUNT(*) FROM Products WHERE CategoryID = @OldCategoryID AND Status = 'ACTIVE'; IF @ProductCount = 0 BEGIN PRINT 'No active products found in category ' + CAST(@OldCategoryID AS NVARCHAR(10)); RETURN; END; OPEN product_cursor; FETCH NEXT FROM product_cursor INTO @ProductID, @ProductName; WHILE @@FETCH_STATUS = 0 BEGIN BEGIN TRY INSERT INTO ProductCategoryHistory (ProductID, OldCategoryID, NewCategoryID, ChangeDate, ChangedBy) VALUES (@ProductID, @OldCategoryID, @NewCategoryID, @EffectiveDate, SUSER_SNAME()); UPDATE Products SET CategoryID = @NewCategoryID, LastModifiedDate = @EffectiveDate, LastModifiedBy = SUSER_SNAME() WHERE ProductID = @ProductID; SET @UpdatedCount = @UpdatedCount + 1; END TRY BEGIN CATCH INSERT INTO CategoryUpdateErrors (ProductID, ErrorMessage, ErrorDate) VALUES (@ProductID, ERROR_MESSAGE(), GETDATE()); END CATCH; FETCH NEXT FROM product_cursor INTO @ProductID, @ProductName; END; CLOSE product_cursor; DEALLOCATE product_cursor; UPDATE ProductCategories SET LastUpdateDate = @EffectiveDate WHERE CategoryID IN (@OldCategoryID, @NewCategoryID); PRINT 'Category update completed. ' + CAST(@UpdatedCount AS NVARCHAR(10)) + ' products updated out of ' + CAST(@ProductCount AS NVARCHAR(10)) + ' total.'; END TRY BEGIN CATCH IF CURSOR_STATUS('global', 'product_cursor') >= 0 BEGIN CLOSE product_cursor; DEALLOCATE product_cursor; END; RAISERROR('Category update failed: %s', 16, 1, ERROR_MESSAGE()); END CATCH; END;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE PROCEDURE SP_UpdateProductCategories @OldCategoryID INT, @NewCategoryID INT, @EffectiveDate DATETIME = NULL AS BEGIN SET NOCOUNT ON; IF @EffectiveDate IS NULL SET @EffectiveDate = GETDATE(); DECLARE @ProductCount INT, @UpdatedCount INT = 0; DECLARE @ProductID INT, @ProductName NVARCHAR(100); DECLARE product_cursor CURSOR FOR SELECT ProductID, ProductName FROM Products WHERE CategoryID = @OldCategoryID AND Status = 'ACTIVE'; BEGIN TRY IF @OldCategoryID = @NewCategoryID RAISERROR('Old and new category IDs cannot be the same', 16, 1); SELECT @ProductCount = COUNT(*) FROM Products WHERE CategoryID = @OldCategoryID AND Status = 'ACTIVE'; IF @ProductCount = 0 BEGIN PRINT 'No active products found in category ' + CAST(@OldCategoryID AS NVARCHAR(10)); RETURN; END; OPEN product_cursor; FETCH NEXT FROM product_cursor INTO @ProductID, @ProductName; WHILE @@FETCH_STATUS = 0 BEGIN BEGIN TRY INSERT INTO ProductCategoryHistory (ProductID, OldCategoryID, NewCategoryID, ChangeDate, ChangedBy) VALUES (@ProductID, @OldCategoryID, @NewCategoryID, @EffectiveDate, SUSER_SNAME()); UPDATE Products SET CategoryID = @NewCategoryID, LastModifiedDate = @EffectiveDate, LastModifiedBy = SUSER_SNAME() WHERE ProductID = @ProductID; SET @UpdatedCount = @UpdatedCount + 1; END TRY BEGIN CATCH INSERT INTO CategoryUpdateErrors (ProductID, ErrorMessage, ErrorDate) VALUES (@ProductID, ERROR_MESSAGE(), GETDATE()); END CATCH; FETCH NEXT FROM product_cursor INTO @ProductID, @ProductName; END; CLOSE product_cursor; DEALLOCATE product_cursor; UPDATE ProductCategories SET LastUpdateDate = @EffectiveDate WHERE CategoryID IN (@OldCategoryID, @NewCategoryID); PRINT 'Category update completed. ' + CAST(@UpdatedCount AS NVARCHAR(10)) + ' products updated out of ' + CAST(@ProductCount AS NVARCHAR(10)) + ' total.'; END TRY BEGIN CATCH IF CURSOR_STATUS('global', 'product_cursor') >= 0 BEGIN CLOSE product_cursor; DEALLOCATE product_cursor; END; RAISERROR('Category update failed: %s', 16, 1, ERROR_MESSAGE()); END CATCH; END;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE SP_UpdateProductCategories (\n    IN p_OldCategoryID INT,\n    IN p_NewCategoryID INT,\n    IN p_EffectiveDate TIMESTAMP DEFAULT NULL\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_ProductCount INT;\n    v_UpdatedCount INT := 0;\n    r_product RECORD; -- Declare a record variable for the FOR loop\nBEGIN\n    -- SET NOCOUNT ON is not needed in PL/pgSQL\n\n    IF p_EffectiveDate IS NULL THEN\n        p_EffectiveDate := NOW(); -- GETDATE() -> NOW()\n    END IF;\n\n    BEGIN -- Outer TRY block equivalent\n        IF p_OldCategoryID = p_NewCategoryID THEN\n            RAISE EXCEPTION 'Old and new category IDs cannot be the same'; -- RAISERROR -> RAISE EXCEPTION\n        END IF;\n\n        SELECT COUNT(*) INTO v_ProductCount\n        FROM Products\n        WHERE CategoryID = p_OldCategoryID AND Status = 'ACTIVE';\n\n        IF v_ProductCount = 0 THEN\n            RAISE NOTICE 'No active products found in category %', p_OldCategoryID; -- PRINT -> RAISE NOTICE\n            RETURN;\n        END IF;\n\n        -- Cursor replacement: FOR loop\n        FOR r_product IN SELECT ProductID, ProductName FROM Products WHERE CategoryID = p_OldCategoryID AND Status = 'ACTIVE' LOOP\n            BEGIN -- Inner TRY block equivalent\n                INSERT INTO ProductCategoryHistory (ProductID, OldCategoryID, NewCategoryID, ChangeDate, ChangedBy)\n                VALUES (r_product.ProductID, p_OldCategoryID, p_NewCategoryID, p_EffectiveDate, CURRENT_USER); -- SUSER_SNAME() -> CURRENT_USER\n\n                UPDATE Products\n                SET CategoryID = p_NewCategoryID, LastModifiedDate = p_EffectiveDate, LastModifiedBy = CURRENT_USER\n                WHERE ProductID = r_product.ProductID;\n\n                v_UpdatedCount := v_UpdatedCount + 1; -- SET @Var = @Var + 1 -> Var := Var + 1\n            EXCEPTION WHEN OTHERS THEN -- Inner CATCH block equivalent\n                INSERT INTO CategoryUpdateErrors (ProductID, ErrorMessage, ErrorDate)\n                VALUES (r_product.ProductID, SQLERRM, NOW()); -- ERROR_MESSAGE() -> SQLERRM, GETDATE() -> NOW()\n            END;\n        END LOOP;\n\n        -- CLOSE product_cursor; DEALLOCATE product_cursor; are handled automatically by FOR loop\n\n        UPDATE ProductCategories\n        SET LastUpdateDate = p_EffectiveDate\n        WHERE CategoryID IN (p_OldCategoryID, p_NewCategoryID);\n\n        RAISE NOTICE 'Category update completed. % products updated out of % total.', v_UpdatedCount, v_ProductCount; -- PRINT -> RAISE NOTICE\n    EXCEPTION WHEN OTHERS THEN -- Outer CATCH block equivalent\n        -- IF CURSOR_STATUS('global', 'product_cursor') >= 0 ... is not needed with FOR loop\n        RAISE EXCEPTION 'Category update failed: %', SQLERRM; -- RAISERROR -> RAISE EXCEPTION, ERROR_MESSAGE() -> SQLERRM\n    END;\nEND;\n$$;"
                    }
                ]
            }
        ]
    },
    {
        "indicator_name": "China-made_database.jsonl",
        "indicator_weight": 3,
        "evaluation_type": "hybrid",
        "case_pass_count": 18,
        "case_wrong_count": 1,
        "correct_rate": 0.95,
        "case_datas": [
            {
                "case_id": "1",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"1\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE OR REPLACE PROCEDURE GETEMPLOYEESTATS(p_dept_id IN NUMBER, p_result OUT CLOB) IS TYPE stats_rec IS RECORD (total_emp NUMBER, avg_salary NUMBER, max_salary NUMBER, active_projects NUMBER); TYPE p_result_rec IS RECORD (employee_id NUMBER, last_name VARCHAR2(50), salary NUMBER(8,2)); v_stats stats_rec; v_result p_result_rec; v_cursor SYS_REFCURSOR; v_sql VARCHAR2(1000); v_dept_name VARCHAR2(50); BEGIN SELECT department_name INTO v_dept_name FROM DEPARTMENTS WHERE department_id = p_dept_id; SELECT COUNT(*), AVG(salary), MAX(salary) INTO v_stats.total_emp, v_stats.avg_salary, v_stats.max_salary FROM EMPLOYEES WHERE department_id = p_dept_id; SELECT COUNT(*) INTO v_stats.active_projects FROM PROJECTS WHERE department_id = p_dept_id AND status = 'ACTIVE'; v_sql := 'SELECT * FROM (SELECT employee_id, last_name, salary FROM employees WHERE department_id = :1 ORDER BY salary DESC) WHERE ROWNUM <= 5'; OPEN v_cursor FOR v_sql USING p_dept_id; p_result := '{  \\\"department\\\": \\\"' || v_dept_name || '\\\",  \\\"total_employees\\\": ' || v_stats.total_emp || ',  \\\"salary_stats\\\": {    \\\"average\\\": ' || v_stats.avg_salary || ',    \\\"max\\\": ' || v_stats.max_salary || '  },  \\\"active_projects\\\": ' || v_stats.active_projects || ',  \\\"top_earners\\\": ['; LOOP FETCH v_cursor INTO v_result; EXIT WHEN v_cursor%NOTFOUND; p_result := p_result || '    {\\\"id\\\": ' || v_result.employee_id || ', \\\"name\\\": \\\"' || v_result.last_name || '\\\", \\\"salary\\\": ' || v_result.salary || '},'; END LOOP; p_result := RTRIM(p_result, ',') || '  ]}'; CLOSE v_cursor; EXCEPTION WHEN NO_DATA_FOUND THEN p_result := '{\\\"error\\\": \\\"Department not found\\\"}'; WHEN OTHERS THEN p_result := '{\\\"error\\\": \\\"' || SQLERRM || '\\\"}'; END;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PROCEDURE GETEMPLOYEESTATS(p_dept_id IN NUMBER, p_result OUT CLOB) IS TYPE stats_rec IS RECORD (total_emp NUMBER, avg_salary NUMBER, max_salary NUMBER, active_projects NUMBER); TYPE p_result_rec IS RECORD (employee_id NUMBER, last_name VARCHAR2(50), salary NUMBER(8,2)); v_stats stats_rec; v_result p_result_rec; v_cursor SYS_REFCURSOR; v_sql VARCHAR2(1000); v_dept_name VARCHAR2(50); BEGIN SELECT department_name INTO v_dept_name FROM DEPARTMENTS WHERE department_id = p_dept_id; SELECT COUNT(*), AVG(salary), MAX(salary) INTO v_stats.total_emp, v_stats.avg_salary, v_stats.max_salary FROM EMPLOYEES WHERE department_id = p_dept_id; SELECT COUNT(*) INTO v_stats.active_projects FROM PROJECTS WHERE department_id = p_dept_id AND status = 'ACTIVE'; v_sql := 'SELECT * FROM (SELECT employee_id, last_name, salary FROM employees WHERE department_id = :1 ORDER BY salary DESC) WHERE ROWNUM <= 5'; OPEN v_cursor FOR v_sql USING p_dept_id; p_result := '{  \"department\": \"' || v_dept_name || '\",  \"total_employees\": ' || v_stats.total_emp || ',  \"salary_stats\": {    \"average\": ' || v_stats.avg_salary || ',    \"max\": ' || v_stats.max_salary || '  },  \"active_projects\": ' || v_stats.active_projects || ',  \"top_earners\": ['; LOOP FETCH v_cursor INTO v_result; EXIT WHEN v_cursor%NOTFOUND; p_result := p_result || '    {\"id\": ' || v_result.employee_id || ', \"name\": \"' || v_result.last_name || '\", \"salary\": ' || v_result.salary || '},'; END LOOP; p_result := RTRIM(p_result, ',') || '  ]}'; CLOSE v_cursor; EXCEPTION WHEN NO_DATA_FOUND THEN p_result := '{\"error\": \"Department not found\"}'; WHEN OTHERS THEN p_result := '{\"error\": \"' || SQLERRM || '\"}'; END;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE GETEMPLOYEESTATS(p_dept_id IN NUMBER, p_result OUT CLOB) IS TYPE stats_rec IS RECORD (total_emp NUMBER, avg_salary NUMBER, max_salary NUMBER, active_projects NUMBER); TYPE p_result_rec IS RECORD (employee_id NUMBER, last_name VARCHAR2(50), salary NUMBER(8,2)); v_stats stats_rec; v_result p_result_rec; v_cursor SYS_REFCURSOR; v_sql VARCHAR2(1000); v_dept_name VARCHAR2(50); BEGIN SELECT department_name INTO v_dept_name FROM DEPARTMENTS WHERE department_id = p_dept_id; SELECT COUNT(*), AVG(salary), MAX(salary) INTO v_stats.total_emp, v_stats.avg_salary, v_stats.max_salary FROM EMPLOYEES WHERE department_id = p_dept_id; SELECT COUNT(*) INTO v_stats.active_projects FROM PROJECTS WHERE department_id = p_dept_id AND status = 'ACTIVE'; v_sql := 'SELECT * FROM (SELECT employee_id, last_name, salary FROM employees WHERE department_id = :1 ORDER BY salary DESC) WHERE ROWNUM <= 5'; OPEN v_cursor FOR v_sql USING p_dept_id; p_result := '{  \"department\": \"' || v_dept_name || '\",  \"total_employees\": ' || v_stats.total_emp || ',  \"salary_stats\": {    \"average\": ' || v_stats.avg_salary || ',    \"max\": ' || v_stats.max_salary || '  },  \"active_projects\": ' || v_stats.active_projects || ',  \"top_earners\": ['; LOOP FETCH v_cursor INTO v_result; EXIT WHEN v_cursor%NOTFOUND; p_result := p_result || '    {\"id\": ' || v_result.employee_id || ', \"name\": \"' || v_result.last_name || '\", \"salary\": ' || v_result.salary || '},'; END LOOP; p_result := RTRIM(p_result, ',') || '  ]}'; CLOSE v_cursor; EXCEPTION WHEN NO_DATA_FOUND THEN p_result := '{\"error\": \"Department not found\"}'; WHEN OTHERS THEN p_result := '{\"error\": \"' || SQLERRM || '\"}'; END;"
                    }
                ]
            },
            {
                "case_id": "2",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"2\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE TABLE t1 (c1 NUMBER, c2 VARCHAR2(100), c3 DATE);\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE TABLE t1 (c1 NUMBER, c2 VARCHAR2(100), c3 DATE);\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE TABLE t1 (c1 NUMBER, c2 VARCHAR2(100), c3 DATE);"
                    }
                ]
            },
            {
                "case_id": "3",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"3\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"INSERT INTO t1 VALUES (1, 'Hello OceanBase', TO_DATE('2025-01-01', 'yyyy-mm-dd'));\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nINSERT INTO t1 VALUES (1, 'Hello OceanBase', TO_DATE('2025-01-01', 'yyyy-mm-dd'));\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "INSERT INTO t1 VALUES (1, 'Hello OceanBase', TO_DATE('2025-01-01', 'yyyy-mm-dd'));"
                    }
                ]
            },
            {
                "case_id": "4",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"4\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"SELECT c1, NVL(c2, 'is null') FROM t1;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT c1, NVL(c2, 'is null') FROM t1;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT c1, NVL(c2, 'is null') FROM t1;"
                    }
                ]
            },
            {
                "case_id": "5",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"5\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE USER ob_user IDENTIFIED BY \\\"Password123\\\";\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE USER ob_user IDENTIFIED BY \"Password123\";\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE USER ob_user IDENTIFIED BY \"Password123\";"
                    }
                ]
            },
            {
                "case_id": "6",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"6\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"SELECT ename, sal, RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) FROM emp;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT ename, sal, RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) FROM emp;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT ename, sal, RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) FROM emp;"
                    }
                ]
            },
            {
                "case_id": "7",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"7\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE OR REPLACE PROCEDURE p_test (p_id IN NUMBER, p_name OUT VARCHAR2) AS BEGIN SELECT ename INTO p_name FROM emp WHERE empno = p_id; END;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PROCEDURE p_test (p_id IN NUMBER, p_name OUT VARCHAR2) AS BEGIN SELECT ename INTO p_name FROM emp WHERE empno = p_id; END;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE p_test (p_id IN NUMBER, p_name OUT VARCHAR2) AS BEGIN SELECT ename INTO p_name FROM emp WHERE empno = p_id; END;"
                    }
                ]
            },
            {
                "case_id": "8",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"8\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"SELECT employee_id, start_date, end_date, job_id FROM job_history MINUS SELECT employee_id, hire_date, NULL, job_id FROM employees;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT employee_id, start_date, end_date, job_id FROM job_history MINUS SELECT employee_id, hire_date, NULL, job_id FROM employees;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT employee_id, start_date, end_date, job_id FROM job_history MINUS SELECT employee_id, hire_date, NULL, job_id FROM employees;"
                    }
                ]
            },
            {
                "case_id": "9",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"9\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE PUBLIC SYNONYM emp_synonym FOR scott.emp;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE PUBLIC SYNONYM emp_synonym FOR scott.emp;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE PUBLIC SYNONYM emp_synonym FOR scott.emp;"
                    }
                ]
            },
            {
                "case_id": "10",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"10\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"SELECT /*+ INDEX(employees emp_department_ix) */ * FROM employees WHERE department_id = 10;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT /*+ INDEX(employees emp_department_ix) */ * FROM employees WHERE department_id = 10;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT /*+ INDEX(employees emp_department_ix) */ * FROM employees WHERE department_id = 10;"
                    }
                ]
            },
            {
                "case_id": "11",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"11\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"DECLARE v_count NUMBER; BEGIN SELECT COUNT(*) INTO v_count FROM user_tables WHERE table_name = 'EMP'; DBMS_OUTPUT.PUT_LINE('Count is: ' || v_count); END;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nDECLARE v_count NUMBER; BEGIN SELECT COUNT(*) INTO v_count FROM user_tables WHERE table_name = 'EMP'; DBMS_OUTPUT.PUT_LINE('Count is: ' || v_count); END;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "DECLARE v_count NUMBER; BEGIN SELECT COUNT(*) INTO v_count FROM user_tables WHERE table_name = 'EMP'; DBMS_OUTPUT.PUT_LINE('Count is: ' || v_count); END;"
                    }
                ]
            },
            {
                "case_id": "12",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"12\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"SELECT listagg(ename, ';') WITHIN GROUP (ORDER BY hiredate) FROM emp WHERE deptno = 30;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT listagg(ename, ';') WITHIN GROUP (ORDER BY hiredate) FROM emp WHERE deptno = 30;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT listagg(ename, ';') WITHIN GROUP (ORDER BY hiredate) FROM emp WHERE deptno = 30;"
                    }
                ]
            },
            {
                "case_id": "13",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"13\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"SELECT LPAD(' ', 2 * (LEVEL - 1)) || ename FROM emp START WITH mgr IS NULL CONNECT BY PRIOR empno = mgr;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT LPAD(' ', 2 * (LEVEL - 1)) || ename FROM emp START WITH mgr IS NULL CONNECT BY PRIOR empno = mgr;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT LPAD(' ', 2 * (LEVEL - 1)) || ename FROM emp START WITH mgr IS NULL CONNECT BY PRIOR empno = mgr"
                    }
                ]
            },
            {
                "case_id": "14",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"14\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE OR REPLACE PROCEDURE autonomous_proc IS PRAGMA AUTONOMOUS_TRANSACTION; BEGIN INSERT INTO audit_log (log_msg) VALUES ('An autonomous action occurred'); COMMIT; END;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PROCEDURE autonomous_proc IS PRAGMA AUTONOMOUS_TRANSACTION; BEGIN INSERT INTO audit_log (log_msg) VALUES ('An autonomous action occurred'); COMMIT; END;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE autonomous_proc IS PRAGMA AUTONOMOUS_TRANSACTION; BEGIN INSERT INTO audit_log (log_msg) VALUES ('An autonomous action occurred'); COMMIT; END;"
                    }
                ]
            },
            {
                "case_id": "15",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"15\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE TABLE range_partitioned_sales (sale_id NUMBER, sale_date DATE) PARTITION BY RANGE (sale_date) (PARTITION p1 VALUES LESS THAN (TO_DATE('2024-01-01','YYYY-MM-DD')), PARTITION p2 VALUES LESS THAN (MAXVALUE));\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE TABLE range_partitioned_sales (sale_id NUMBER, sale_date DATE) PARTITION BY RANGE (sale_date) (PARTITION p1 VALUES LESS THAN (TO_DATE('2024-01-01','YYYY-MM-DD')), PARTITION p2 VALUES LESS THAN (MAXVALUE));\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE TABLE range_partitioned_sales (sale_id NUMBER, sale_date DATE) PARTITION BY RANGE (sale_date) (PARTITION p1 VALUES LESS THAN (TO_DATE('2024-01-01','YYYY-MM-DD')), PARTITION p2 VALUES LESS THAN (MAXVALUE))"
                    }
                ]
            },
            {
                "case_id": "16",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"16\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE OR REPLACE PACKAGE BODY emp_mgmt AS PROCEDURE hire(p_name VARCHAR2) IS BEGIN INSERT INTO emp(ename) VALUES(p_name); END; FUNCTION get_count RETURN NUMBER IS v_cnt NUMBER; BEGIN SELECT COUNT(*) INTO v_cnt FROM emp; RETURN v_cnt; END; END emp_mgmt;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PACKAGE BODY emp_mgmt AS PROCEDURE hire(p_name VARCHAR2) IS BEGIN INSERT INTO emp(ename) VALUES(p_name); END; FUNCTION get_count RETURN NUMBER IS v_cnt NUMBER; BEGIN SELECT COUNT(*) INTO v_cnt FROM emp; RETURN v_cnt; END; END emp_mgmt;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PACKAGE BODY emp_mgmt AS PROCEDURE hire(p_name VARCHAR2) IS BEGIN INSERT INTO emp(ename) VALUES(p_name); END; FUNCTION get_count RETURN NUMBER IS v_cnt NUMBER; BEGIN SELECT COUNT(*) INTO v_cnt FROM emp; RETURN v_cnt; END; END emp_mgmt;"
                    }
                ]
            },
            {
                "case_id": "17",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"17\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE MATERIALIZED VIEW mv_emp_summary BUILD IMMEDIATE REFRESH COMPLETE ON DEMAND AS SELECT deptno, COUNT(*) as emp_count FROM emp GROUP BY deptno;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE MATERIALIZED VIEW mv_emp_summary BUILD IMMEDIATE REFRESH COMPLETE ON DEMAND AS SELECT deptno, COUNT(*) as emp_count FROM emp GROUP BY deptno;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE MATERIALIZED VIEW mv_emp_summary BUILD IMMEDIATE REFRESH COMPLETE ON DEMAND AS SELECT deptno, COUNT(*) as emp_count FROM emp GROUP BY deptno;"
                    }
                ]
            },
            {
                "case_id": "18",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"18\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"SELECT CAST(MULTISET(SELECT ename FROM emp WHERE deptno = d.deptno) AS SYS.ODCIVARCHAR2LIST) as employees FROM dept d;\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT CAST(MULTISET(SELECT ename FROM emp WHERE deptno = d.deptno) AS SYS.ODCIVARCHAR2LIST) as employees FROM dept d;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT CAST(MULTISET(SELECT ename FROM emp WHERE deptno = d.deptno) AS SYS.ODCIVARCHAR2LIST) as employees FROM dept d"
                    }
                ]
            },
            {
                "case_id": "19",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"19\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"LOCK TABLE emp IN EXCLUSIVE MODE NOWAIT;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nLOCK TABLE emp IN EXCLUSIVE MODE NOWAIT;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "LOCK TABLE emp IN EXCLUSIVE MODE NOWAIT;"
                    }
                ]
            }
        ]
    },
    {
        "indicator_name": "logical_equivalence.jsonl",
        "indicator_weight": 4,
        "evaluation_type": "hybrid",
        "case_pass_count": 16,
        "case_wrong_count": 2,
        "correct_rate": 0.89,
        "case_datas": [
            {
                "case_id": "1",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"1\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"SELECT e.ename, d.dname, e.sal FROM emp e, dept d WHERE e.deptno = d.deptno(+) AND e.sal > 2000;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT e.ename, d.dname, e.sal FROM emp e, dept d WHERE e.deptno = d.deptno(+) AND e.sal > 2000;\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT e.ename, d.dname, e.sal FROM emp e LEFT OUTER JOIN dept d ON e.deptno = d.deptno WHERE e.sal > 2000;"
                    }
                ]
            },
            {
                "case_id": "2",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"2\", \"difficulty_level\": \"3\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"CREATE proc [dbo].[p_job_create_bond_info_all] as begin truncate table tmp_bond_info_all_20010; insert into tmp_bond_info_all_20010(f_val,def_id,id) select field_value,FIELD_DEFINITION_ID,t2.ID from T_OBJECT_FIELD_DATA t1 with(nolock),T_PJ_Bond_Info t2 with(nolock) where t1.OBJECT_NO = 20010 and t1.FIELD_VALUE is not null and t1.parent_id=t2.APPLY_ID ; truncate table tmp_bond_info_all_20020; insert into tmp_bond_info_all_20020(f_val,def_id,id) select field_value,FIELD_DEFINITION_ID,t2.id as bondId from T_OBJECT_FIELD_DATA t1 with(nolock),T_PJ_Bond_Info t2 with(nolock) where t1.OBJECT_NO = 20020 and t1.FIELD_VALUE is not null and t1.PARENT_ID=t2.TEMP_BONDID; truncate table t_pj_bond_info_all; insert into t_pj_bond_info_all(id,temp_bondid,apply_id) select t1.ID,t1.TEMP_BONDID,t1.APPLY_ID from T_PJ_Bond_Info t1 with(nolock) where 1=1; declare c_names cursor for select name from syscolumns where id=object_id('t_pj_bond_info_all') and name like 'def%'; declare @colname varchar(100),@sql varchar(2000) open c_names while 1=1 begin fetch next from c_names into @colname if @@FETCH_STATUS<>0 break; select @sql = 'update a set a.'+@colname+'=b.f_val from t_pj_bond_info_all a,tmp_bond_info_all_20020 b where a.id=b.id and b.def_id=' + replace(@colname,'def_',''); exec( @sql ); select @sql = 'update a set a.'+@colname+'=b.f_val from t_pj_bond_info_all a,tmp_bond_info_all_20010 b where a.id=b.id and a.'+@colname+' is null and b.def_id=' + replace(@colname,'def_',''); exec( @sql ); end close c_names deallocate c_names end\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE proc [dbo].[p_job_create_bond_info_all] as begin truncate table tmp_bond_info_all_20010; insert into tmp_bond_info_all_20010(f_val,def_id,id) select field_value,FIELD_DEFINITION_ID,t2.ID from T_OBJECT_FIELD_DATA t1 with(nolock),T_PJ_Bond_Info t2 with(nolock) where t1.OBJECT_NO = 20010 and t1.FIELD_VALUE is not null and t1.parent_id=t2.APPLY_ID ; truncate table tmp_bond_info_all_20020; insert into tmp_bond_info_all_20020(f_val,def_id,id) select field_value,FIELD_DEFINITION_ID,t2.id as bondId from T_OBJECT_FIELD_DATA t1 with(nolock),T_PJ_Bond_Info t2 with(nolock) where t1.OBJECT_NO = 20020 and t1.FIELD_VALUE is not null and t1.PARENT_ID=t2.TEMP_BONDID; truncate table t_pj_bond_info_all; insert into t_pj_bond_info_all(id,temp_bondid,apply_id) select t1.ID,t1.TEMP_BONDID,t1.APPLY_ID from T_PJ_Bond_Info t1 with(nolock) where 1=1; declare c_names cursor for select name from syscolumns where id=object_id('t_pj_bond_info_all') and name like 'def%'; declare @colname varchar(100),@sql varchar(2000) open c_names while 1=1 begin fetch next from c_names into @colname if @@FETCH_STATUS<>0 break; select @sql = 'update a set a.'+@colname+'=b.f_val from t_pj_bond_info_all a,tmp_bond_info_all_20020 b where a.id=b.id and b.def_id=' + replace(@colname,'def_',''); exec( @sql ); select @sql = 'update a set a.'+@colname+'=b.f_val from t_pj_bond_info_all a,tmp_bond_info_all_20010 b where a.id=b.id and a.'+@colname+' is null and b.def_id=' + replace(@colname,'def_',''); exec( @sql ); end close c_names deallocate c_names end\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE dbo.p_job_create_bond_info_all()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_colname VARCHAR(100);\n    v_sql TEXT;\n    c_names CURSOR FOR\n        SELECT column_name\n        FROM information_schema.columns\n        WHERE table_schema = 'dbo' -- Adjust 'dbo' to the actual schema if tables are in 'public' or another schema\n          AND table_name = 't_pj_bond_info_all'\n          AND column_name LIKE 'def%';\nBEGIN\n    TRUNCATE TABLE tmp_bond_info_all_20010;\n    INSERT INTO tmp_bond_info_all_20010(f_val, def_id, id)\n    SELECT field_value, FIELD_DEFINITION_ID, t2.ID\n    FROM T_OBJECT_FIELD_DATA t1, T_PJ_Bond_Info t2\n    WHERE t1.OBJECT_NO = 20010\n      AND t1.FIELD_VALUE IS NOT NULL\n      AND t1.parent_id = t2.APPLY_ID;\n\n    TRUNCATE TABLE tmp_bond_info_all_20020;\n    INSERT INTO tmp_bond_info_all_20020(f_val, def_id, id)\n    SELECT field_value, FIELD_DEFINITION_ID, t2.id AS bondId\n    FROM T_OBJECT_FIELD_DATA t1, T_PJ_Bond_Info t2\n    WHERE t1.OBJECT_NO = 20020\n      AND t1.FIELD_VALUE IS NOT NULL\n      AND t1.PARENT_ID = t2.TEMP_BONDID;\n\n    TRUNCATE TABLE t_pj_bond_info_all;\n    INSERT INTO t_pj_bond_info_all(id, temp_bondid, apply_id)\n    SELECT ID, TEMP_BONDID, APPLY_ID\n    FROM T_PJ_Bond_Info;\n\n    OPEN c_names;\n\n    LOOP\n        FETCH c_names INTO v_colname;\n\n        EXIT WHEN NOT FOUND;\n\n        -- Update from tmp_bond_info_all_20020\n        v_sql := 'UPDATE t_pj_bond_info_all SET ' || quote_ident(v_colname) || ' = b.f_val FROM tmp_bond_info_all_20020 b WHERE t_pj_bond_info_all.id = b.id AND b.def_id = ' || REPLACE(v_colname, 'def_', '') || '::int';\n        EXECUTE v_sql;\n\n        -- Update from tmp_bond_info_all_20010 where current column is null\n        v_sql := 'UPDATE t_pj_bond_info_all SET ' || quote_ident(v_colname) || ' = b.f_val FROM tmp_bond_info_all_20010 b WHERE t_pj_bond_info_all.id = b.id AND t_pj_bond_info_all.' || quote_ident(v_colname) || ' IS NULL AND b.def_id = ' || REPLACE(v_colname, 'def_', '') || '::int';\n        EXECUTE v_sql;\n\n    END LOOP;\n\n    CLOSE c_names;\n\nEND;\n$$;"
                    }
                ]
            },
            {
                "case_id": "3",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"3\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"UPDATE products SET price = price * 0.9 WHERE category_id = 101 AND NVL(stock_quantity, 0) > 0;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nUPDATE products SET price = price * 0.9 WHERE category_id = 101 AND NVL(stock_quantity, 0) > 0;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "UPDATE products SET price = price * 0.9 WHERE category_id = 101 AND NVL(stock_quantity, 0) > 0;"
                    }
                ]
            },
            {
                "case_id": "4",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"4\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"SELECT user_id, last_login_time FROM user_accounts WHERE TRUNC(last_login_time) = TO_DATE('2025-06-25', 'YYYY-MM-DD');\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT user_id, last_login_time FROM user_accounts WHERE TRUNC(last_login_time) = TO_DATE('2025-06-25', 'YYYY-MM-DD');\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT user_id, last_login_time FROM user_accounts WHERE last_login_time::DATE = '2025-06-25'::DATE;"
                    }
                ]
            },
            {
                "case_id": "5",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"5\", \"difficulty_level\": \"1\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"SELECT ProductID, Name, ISNULL(Color, 'N/A') AS ProductColor FROM Production.Product;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT ProductID, Name, ISNULL(Color, 'N/A') AS ProductColor FROM Production.Product;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT ProductID, Name, COALESCE(Color, 'N/A') AS ProductColor FROM Production.Product;"
                    }
                ]
            },
            {
                "case_id": "6",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"6\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"SELECT ename, sal, DENSE_RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) as rnk FROM emp;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT ename, sal, DENSE_RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) as rnk FROM emp;\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT ename, sal, DENSE_RANK() OVER (PARTITION BY deptno ORDER BY sal DESC) as rnk FROM emp;"
                    }
                ]
            },
            {
                "case_id": "7",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"7\", \"difficulty_level\": \"1\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"WITH Sales_CTE AS (SELECT SalesPersonID, SUM(TotalDue) AS TotalSales, YEAR(OrderDate) AS SalesYear FROM Sales.SalesOrderHeader GROUP BY SalesPersonID, YEAR(OrderDate)) SELECT * FROM Sales_CTE WHERE TotalSales > 100000;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nWITH Sales_CTE AS (SELECT SalesPersonID, SUM(TotalDue) AS TotalSales, YEAR(OrderDate) AS SalesYear FROM Sales.SalesOrderHeader GROUP BY SalesPersonID, YEAR(OrderDate)) SELECT * FROM Sales_CTE WHERE TotalSales > 100000;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH Sales_CTE AS (SELECT SalesPersonID, SUM(TotalDue) AS TotalSales, EXTRACT(YEAR FROM OrderDate) AS SalesYear FROM Sales.SalesOrderHeader GROUP BY SalesPersonID, EXTRACT(YEAR FROM OrderDate)) SELECT * FROM Sales_CTE WHERE TotalSales > 100000;"
                    }
                ]
            },
            {
                "case_id": "8",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"8\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"SELECT employee_id, last_name, salary FROM (SELECT employee_id, last_name, salary, ROW_NUMBER() OVER (ORDER BY salary DESC) as rn FROM employees) WHERE rn <= 5;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT employee_id, last_name, salary FROM (SELECT employee_id, last_name, salary, ROW_NUMBER() OVER (ORDER BY salary DESC) as rn FROM employees) WHERE rn <= 5;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT employee_id, last_name, salary FROM (SELECT employee_id, last_name, salary, ROW_NUMBER() OVER (ORDER BY salary DESC) as rn FROM employees) WHERE rn <= 5;"
                    }
                ]
            },
            {
                "case_id": "9",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"9\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"CREATE OR REPLACE PROCEDURE bulk_delete_by_ids(p_id_list IN VARCHAR2) IS v_sql VARCHAR2(1000); BEGIN v_sql := 'DELETE FROM logs WHERE log_id IN (' || p_id_list || ')'; EXECUTE IMMEDIATE v_sql; COMMIT; END;\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PROCEDURE bulk_delete_by_ids(p_id_list IN VARCHAR2) IS v_sql VARCHAR2(1000); BEGIN v_sql := 'DELETE FROM logs WHERE log_id IN (' || p_id_list || ')'; EXECUTE IMMEDIATE v_sql; COMMIT; END;\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE FUNCTION bulk_delete_by_ids(p_id_list TEXT) RETURNS VOID AS $$\nDECLARE\n    v_sql TEXT;\nBEGIN\n    v_sql := 'DELETE FROM logs WHERE log_id IN (' || p_id_list || ')';\n    EXECUTE v_sql;\nEND;\n$$ LANGUAGE plpgsql;"
                    }
                ]
            },
            {
                "case_id": "10",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"10\", \"difficulty_level\": \"1\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"SELECT p.Name AS ProductName, v.Name AS VendorName FROM Purchasing.ProductVendor pv JOIN Production.Product p ON pv.ProductID = p.BusinessEntityID JOIN Purchasing.Vendor v ON pv.BusinessEntityID = v.BusinessEntityID WHERE pv.AverageLeadTime > 10;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT p.Name AS ProductName, v.Name AS VendorName FROM Purchasing.ProductVendor pv JOIN Production.Product p ON pv.ProductID = p.BusinessEntityID JOIN Purchasing.Vendor v ON pv.BusinessEntityID = v.BusinessEntityID WHERE pv.AverageLeadTime > 10;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT p.Name AS ProductName, v.Name AS VendorName FROM Purchasing.ProductVendor pv JOIN Production.Product p ON pv.ProductID = p.BusinessEntityID JOIN Purchasing.Vendor v ON pv.BusinessEntityID = v.BusinessEntityID WHERE pv.AverageLeadTime > 10;"
                    }
                ]
            },
            {
                "case_id": "11",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"11\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"DELETE FROM job_history WHERE (employee_id, start_date) IN (SELECT employee_id, MIN(start_date) FROM job_history GROUP BY employee_id HAVING COUNT(*) > 1);\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nDELETE FROM job_history WHERE (employee_id, start_date) IN (SELECT employee_id, MIN(start_date) FROM job_history GROUP BY employee_id HAVING COUNT(*) > 1);\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "DELETE FROM job_history WHERE (employee_id, start_date) IN (SELECT employee_id, MIN(start_date) FROM job_history GROUP BY employee_id HAVING COUNT(*) > 1);"
                    }
                ]
            },
            {
                "case_id": "12",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"12\", \"difficulty_level\": \"2\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"UPDATE Production.Product SET ListPrice = ListPrice * 1.10 WHERE ProductSubcategoryID IN (SELECT ProductSubcategoryID FROM Production.ProductSubcategory WHERE Name LIKE 'Mountain%');\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nUPDATE Production.Product SET ListPrice = ListPrice * 1.10 WHERE ProductSubcategoryID IN (SELECT ProductSubcategoryID FROM Production.ProductSubcategory WHERE Name LIKE 'Mountain%');\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "UPDATE Production.Product SET ListPrice = ListPrice * 1.10 WHERE ProductSubcategoryID IN (SELECT ProductSubcategoryID FROM Production.ProductSubcategory WHERE Name LIKE 'Mountain%');"
                    }
                ]
            },
            {
                "case_id": "13",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"13\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"SELECT LEVEL, LPAD(' ', 2 * (LEVEL - 1)) || ename as name, empno, mgr FROM emp START WITH mgr IS NULL CONNECT BY PRIOR empno = mgr;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT LEVEL, LPAD(' ', 2 * (LEVEL - 1)) || ename as name, empno, mgr FROM emp START WITH mgr IS NULL CONNECT BY PRIOR empno = mgr;\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH RECURSIVE emp_hierarchy AS (\n    SELECT\n        empno,\n        ename,\n        mgr,\n        1 as level\n    FROM\n        emp\n    WHERE\n        mgr IS NULL\n    UNION ALL\n    SELECT\n        e.empno,\n        e.ename,\n        e.mgr,\n        eh.level + 1 as level\n    FROM\n        emp e\n    JOIN\n        emp_hierarchy eh ON e.mgr = eh.empno\n)\nSELECT\n    level,\n    REPEAT(' ', 2 * (level - 1)) || ename as name,\n    empno,\n    mgr\nFROM\n    emp_hierarchy;"
                    }
                ]
            },
            {
                "case_id": "14",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"14\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"CREATE OR REPLACE PROCEDURE archive_old_records(p_archive_date IN DATE) IS v_deleted_rows NUMBER; BEGIN DELETE FROM active_data WHERE record_date < p_archive_date RETURNING record_id, record_data INTO (SELECT record_id, record_data FROM DUAL); -- Simplified for example, real logic would bulk insert. INSERT INTO archive_table (record_id, record_data) SELECT record_id, record_data FROM active_data WHERE record_date < p_archive_date; GET DIAGNOSTICS v_deleted_rows = ROW_COUNT; INSERT INTO audit_log (log_message) VALUES (v_deleted_rows || ' rows archived.'); COMMIT; END;\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PROCEDURE archive_old_records(p_archive_date IN DATE) IS v_deleted_rows NUMBER; BEGIN DELETE FROM active_data WHERE record_date < p_archive_date RETURNING record_id, record_data INTO (SELECT record_id, record_data FROM DUAL); -- Simplified for example, real logic would bulk insert. INSERT INTO archive_table (record_id, record_data) SELECT record_id, record_data FROM active_data WHERE record_date < p_archive_date; GET DIAGNOSTICS v_deleted_rows = ROW_COUNT; INSERT INTO audit_log (log_message) VALUES (v_deleted_rows || ' rows archived.'); COMMIT; END;\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE FUNCTION archive_old_records(p_archive_date DATE) RETURNS void AS $$\nDECLARE\n    v_deleted_rows INTEGER;\nBEGIN\n    DELETE FROM active_data WHERE record_date < p_archive_date;\n    GET DIAGNOSTICS v_deleted_rows = ROW_COUNT;\n\n    -- Note: The original Oracle logic performs a DELETE, then a separate INSERT\n    -- by re-selecting from the original table. This can lead to race conditions\n    -- if other transactions modify active_data between the DELETE and INSERT.\n    -- A more robust approach in PostgreSQL would be to use a CTE with DELETE ... RETURNING\n    -- to atomically move the data. However, this translation preserves the original\n    -- order of operations.\n    INSERT INTO archive_table (record_id, record_data)\n    SELECT record_id, record_data FROM active_data WHERE record_date < p_archive_date;\n\n    INSERT INTO audit_log (log_message)\n    VALUES (v_deleted_rows || ' rows archived.');\n\n    -- COMMIT is not allowed within PL/pgSQL functions in PostgreSQL 9.2.\n    -- Transaction management is handled by the calling environment.\nEND;\n$$ LANGUAGE plpgsql;"
                    }
                ]
            },
            {
                "case_id": "15",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"15\", \"difficulty_level\": \"3\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"SELECT [1] AS AvgCost_DTM_1, [2] AS AvgCost_DTM_2, [3] AS AvgCost_DTM_3, [4] AS AvgCost_DTM_4 FROM (SELECT DaysToManufacture, StandardCost FROM Production.Product WHERE DaysToManufacture > 0) AS src PIVOT (AVG(StandardCost) FOR DaysToManufacture IN ([1], [2], [3], [4])) AS PivotTable;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT [1] AS AvgCost_DTM_1, [2] AS AvgCost_DTM_2, [3] AS AvgCost_DTM_3, [4] AS AvgCost_DTM_4 FROM (SELECT DaysToManufacture, StandardCost FROM Production.Product WHERE DaysToManufacture > 0) AS src PIVOT (AVG(StandardCost) FOR DaysToManufacture IN ([1], [2], [3], [4])) AS PivotTable;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT AVG(CASE WHEN DaysToManufacture = 1 THEN StandardCost ELSE NULL END) AS AvgCost_DTM_1, AVG(CASE WHEN DaysToManufacture = 2 THEN StandardCost ELSE NULL END) AS AvgCost_DTM_2, AVG(CASE WHEN DaysToManufacture = 3 THEN StandardCost ELSE NULL END) AS AvgCost_DTM_3, AVG(CASE WHEN DaysToManufacture = 4 THEN StandardCost ELSE NULL END) AS AvgCost_DTM_4 FROM Production.Product WHERE DaysToManufacture IN (1, 2, 3, 4);"
                    }
                ]
            },
            {
                "case_id": "16",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"16\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"SELECT dep_name, (SELECT MAX(salary) FROM emps e WHERE e.dep_id = d.dep_id) AS max_salary FROM departments d WHERE 3 <= (SELECT COUNT(*) FROM emps e2 WHERE e2.dep_id = d.dep_id);\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT dep_name, (SELECT MAX(salary) FROM emps e WHERE e.dep_id = d.dep_id) AS max_salary FROM departments d WHERE 3 <= (SELECT COUNT(*) FROM emps e2 WHERE e2.dep_id = d.dep_id);\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT dep_name, (SELECT MAX(salary) FROM emps e WHERE e.dep_id = d.dep_id) AS max_salary FROM departments d WHERE 3 <= (SELECT COUNT(*) FROM emps e2 WHERE e2.dep_id = d.dep_id);"
                    }
                ]
            },
            {
                "case_id": "17",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"17\", \"difficulty_level\": \"1\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"SELECT c.CustomerID, c.PersonID, p.FirstName, p.LastName FROM Sales.Customer c CROSS APPLY (SELECT * FROM Person.Person p WHERE p.BusinessEntityID = c.PersonID AND p.EmailPromotion = 1) AS p;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT c.CustomerID, c.PersonID, p.FirstName, p.LastName FROM Sales.Customer c CROSS APPLY (SELECT * FROM Person.Person p WHERE p.BusinessEntityID = c.PersonID AND p.EmailPromotion = 1) AS p;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT c.CustomerID, c.PersonID, p.FirstName, p.LastName FROM Sales.Customer c CROSS JOIN LATERAL (SELECT * FROM Person.Person p WHERE p.BusinessEntityID = c.PersonID AND p.EmailPromotion = 1) AS p;"
                    }
                ]
            },
            {
                "case_id": "18",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"18\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"CREATE OR REPLACE PROCEDURE GETEMPLOYEESTATS(p_dept_id IN NUMBER, p_result OUT CLOB) IS TYPE stats_rec IS RECORD (total_emp NUMBER, avg_salary NUMBER, max_salary NUMBER, active_projects NUMBER); TYPE p_result_rec IS RECORD (employee_id NUMBER, last_name VARCHAR2(50), salary NUMBER(8,2)); v_stats stats_rec; v_result p_result_rec; v_cursor SYS_REFCURSOR; v_sql VARCHAR2(1000); v_dept_name VARCHAR2(50); BEGIN SELECT department_name INTO v_dept_name FROM DEPARTMENTS WHERE department_id = p_dept_id; SELECT COUNT(*), AVG(salary), MAX(salary) INTO v_stats.total_emp, v_stats.avg_salary, v_stats.max_salary FROM EMPLOYEES WHERE department_id = p_dept_id; SELECT COUNT(*) INTO v_stats.active_projects FROM PROJECTS WHERE department_id = p_dept_id AND status = 'ACTIVE'; v_sql := 'SELECT * FROM (SELECT employee_id, last_name, salary FROM employees WHERE department_id = :1 ORDER BY salary DESC) WHERE ROWNUM <= 5'; OPEN v_cursor FOR v_sql USING p_dept_id; p_result := '{  \\\"department\\\": \\\"' || v_dept_name || '\\\",  \\\"total_employees\\\": ' || v_stats.total_emp || ',  \\\"salary_stats\\\": {    \\\"average\\\": ' || v_stats.avg_salary || ',    \\\"max\\\": ' || v_stats.max_salary || '  },  \\\"active_projects\\\": ' || v_stats.active_projects || ',  \\\"top_earners\\\": ['; LOOP FETCH v_cursor INTO v_result; EXIT WHEN v_cursor%NOTFOUND; p_result := p_result || '    {\\\"id\\\": ' || v_result.employee_id || ', \\\"name\\\": \\\"' || v_result.last_name || '\\\", \\\"salary\\\": ' || v_result.salary || '},'; END LOOP; p_result := RTRIM(p_result, ',') || '  ]}'; CLOSE v_cursor; EXCEPTION WHEN NO_DATA_FOUND THEN p_result := '{\\\"error\\\": \\\"Department not found\\\"}'; WHEN OTHERS THEN p_result := '{\\\"error\\\": \\\"' || SQLERRM || '\\\"}'; END;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PROCEDURE GETEMPLOYEESTATS(p_dept_id IN NUMBER, p_result OUT CLOB) IS TYPE stats_rec IS RECORD (total_emp NUMBER, avg_salary NUMBER, max_salary NUMBER, active_projects NUMBER); TYPE p_result_rec IS RECORD (employee_id NUMBER, last_name VARCHAR2(50), salary NUMBER(8,2)); v_stats stats_rec; v_result p_result_rec; v_cursor SYS_REFCURSOR; v_sql VARCHAR2(1000); v_dept_name VARCHAR2(50); BEGIN SELECT department_name INTO v_dept_name FROM DEPARTMENTS WHERE department_id = p_dept_id; SELECT COUNT(*), AVG(salary), MAX(salary) INTO v_stats.total_emp, v_stats.avg_salary, v_stats.max_salary FROM EMPLOYEES WHERE department_id = p_dept_id; SELECT COUNT(*) INTO v_stats.active_projects FROM PROJECTS WHERE department_id = p_dept_id AND status = 'ACTIVE'; v_sql := 'SELECT * FROM (SELECT employee_id, last_name, salary FROM employees WHERE department_id = :1 ORDER BY salary DESC) WHERE ROWNUM <= 5'; OPEN v_cursor FOR v_sql USING p_dept_id; p_result := '{  \"department\": \"' || v_dept_name || '\",  \"total_employees\": ' || v_stats.total_emp || ',  \"salary_stats\": {    \"average\": ' || v_stats.avg_salary || ',    \"max\": ' || v_stats.max_salary || '  },  \"active_projects\": ' || v_stats.active_projects || ',  \"top_earners\": ['; LOOP FETCH v_cursor INTO v_result; EXIT WHEN v_cursor%NOTFOUND; p_result := p_result || '    {\"id\": ' || v_result.employee_id || ', \"name\": \"' || v_result.last_name || '\", \"salary\": ' || v_result.salary || '},'; END LOOP; p_result := RTRIM(p_result, ',') || '  ]}'; CLOSE v_cursor; EXCEPTION WHEN NO_DATA_FOUND THEN p_result := '{\"error\": \"Department not found\"}'; WHEN OTHERS THEN p_result := '{\"error\": \"' || SQLERRM || '\"}'; END;\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE FUNCTION GETEMPLOYEESTATS(p_dept_id IN INTEGER, OUT p_result TEXT)\nAS $$\nDECLARE\n  v_stats_total_emp INTEGER;\n  v_stats_avg_salary NUMERIC;\n  v_stats_max_salary NUMERIC;\n  v_stats_active_projects INTEGER;\n  v_result RECORD; -- To hold the fetched row from the cursor\n  v_cursor REFCURSOR;\n  v_sql TEXT;\n  v_dept_name VARCHAR(50);\nBEGIN\n  SELECT department_name INTO v_dept_name\n  FROM DEPARTMENTS\n  WHERE department_id = p_dept_id;\n\n  SELECT COUNT(*), AVG(salary), MAX(salary)\n  INTO v_stats_total_emp, v_stats_avg_salary, v_stats_max_salary\n  FROM EMPLOYEES\n  WHERE department_id = p_dept_id;\n\n  SELECT COUNT(*)\n  INTO v_stats_active_projects\n  FROM PROJECTS\n  WHERE department_id = p_dept_id AND status = 'ACTIVE';\n\n  v_sql := 'SELECT employee_id, last_name, salary FROM employees WHERE department_id = $1 ORDER BY salary DESC LIMIT 5';\n  OPEN v_cursor FOR EXECUTE v_sql USING p_dept_id;\n\n  p_result := '{  \"department\": \"' || v_dept_name || '\",  \"total_employees\": ' || v_stats_total_emp::TEXT || ',  \"salary_stats\": {    \"average\": ' || v_stats_avg_salary::TEXT || ',    \"max\": ' || v_stats_max_salary::TEXT || '  },  \"active_projects\": ' || v_stats_active_projects::TEXT || ',  \"top_earners\": [';\n\n  LOOP\n    FETCH v_cursor INTO v_result;\n    EXIT WHEN NOT FOUND;\n    p_result := p_result || '    {\"id\": ' || v_result.employee_id::TEXT || ', \"name\": \"' || v_result.last_name || '\", \"salary\": ' || v_result.salary::NUMERIC(8,2)::TEXT || '},';\n  END LOOP;\n\n  p_result := RTRIM(p_result, ',') || '  ]}';\n\n  CLOSE v_cursor;\n\nEXCEPTION\n  WHEN NO_DATA_FOUND THEN\n    p_result := '{\"error\": \"Department not found\"}';\n  WHEN OTHERS THEN\n    p_result := '{\"error\": \"' || SQLERRM || '\"}';\nEND;\n$$ LANGUAGE plpgsql;"
                    }
                ]
            }
        ]
    },
    {
        "indicator_name": "syntax_error_detection.jsonl",
        "indicator_weight": 2,
        "evaluation_type": "hybrid",
        "case_pass_count": 15,
        "case_wrong_count": 5,
        "correct_rate": 0.75,
        "case_datas": [
            {
                "case_id": "1",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"1\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"CREATE TABLE employees (employee_id NUMBER(6) NOT NULL, first_name VARCHAR2(20), hire_date DATE DEFAULT SYSDATE);\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE TABLE employees (employee_id NUMBER(6) NOT NULL, first_name VARCHAR2(20), hire_date DATE DEFAULT SYSDATE);\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE TABLE employees (employee_id INTEGER NOT NULL, first_name VARCHAR(20), hire_date TIMESTAMP DEFAULT NOW());"
                    }
                ]
            },
            {
                "case_id": "2",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"2\", \"difficulty_level\": \"3\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"CREATE PROCEDURE usp_UpdateOrderStatus @CustomerID INT, @OldStatus VARCHAR(20), @NewStatus VARCHAR(20), @RowsUpdated INT OUTPUT, @ErrorMessage VARCHAR(200) OUTPUT AS BEGIN SET NOCOUNT ON; DECLARE @OrderCount INT, @TranCount INT = @@TRANCOUNT; IF @OldStatus = @NewStatus BEGIN SET @ErrorMessage = '新旧状态不能相同'; RETURN 400; END BEGIN TRY IF @TranCount = 0 BEGIN TRANSACTION; UPDATE Orders SET Status = @NewStatus, LastUpdated = GETDATE() WHERE CustomerID = @CustomerID AND Status = @OldStatus AND OrderDate > DATEADD(month, -3, GETDATE()); SET @RowsUpdated = @@ROWCOUNT; IF @RowsUpdated = 0 BEGIN SET @ErrorMessage = '未找到符合条件的订单'; RETURN 404; END INSERT INTO OrderLog (OrderID, OldStatus, NewStatus, ChangeDate) SELECT OrderID, @OldStatus, @NewStatus, GETDATE() FROM Orders WHERE CustomerID = @CustomerID AND Status = @NewStatus; DECLARE @ProcessingFee DECIMAL(10,2) = 0; DECLARE fee_cursor CURSOR FOR SELECT Fee FROM OrderDetails WHERE OrderID IN (SELECT OrderID FROM Orders WHERE CustomerID = @CustomerID AND Status = @NewStatus); OPEN fee_cursor; FETCH NEXT FROM fee_cursor INTO @ProcessingFee; WHILE @@FETCH_STATUS = 0 BEGIN SET @ProcessingFee = @ProcessingFee * 0.95; FETCH NEXT FROM fee_cursor INTO @ProcessingFee; END CLOSE fee_cursor; DEALLOCATE fee_cursor; IF @TranCount = 0 COMMIT TRANSACTION; SET @ErrorMessage = '更新成功'; RETURN 200; END TRY BEGIN CATCH IF @TranCount = 0 AND @@TRANCOUNT > 0 ROLLBACK TRANSACTION; SET @ErrorMessage = ERROR_MESSAGE() + ' (Line:' + CAST(ERROR_LINE() AS VARCHAR) + ')'; RETURN 500; END CATCH END\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE PROCEDURE usp_UpdateOrderStatus @CustomerID INT, @OldStatus VARCHAR(20), @NewStatus VARCHAR(20), @RowsUpdated INT OUTPUT, @ErrorMessage VARCHAR(200) OUTPUT AS BEGIN SET NOCOUNT ON; DECLARE @OrderCount INT, @TranCount INT = @@TRANCOUNT; IF @OldStatus = @NewStatus BEGIN SET @ErrorMessage = '新旧状态不能相同'; RETURN 400; END BEGIN TRY IF @TranCount = 0 BEGIN TRANSACTION; UPDATE Orders SET Status = @NewStatus, LastUpdated = GETDATE() WHERE CustomerID = @CustomerID AND Status = @OldStatus AND OrderDate > DATEADD(month, -3, GETDATE()); SET @RowsUpdated = @@ROWCOUNT; IF @RowsUpdated = 0 BEGIN SET @ErrorMessage = '未找到符合条件的订单'; RETURN 404; END INSERT INTO OrderLog (OrderID, OldStatus, NewStatus, ChangeDate) SELECT OrderID, @OldStatus, @NewStatus, GETDATE() FROM Orders WHERE CustomerID = @CustomerID AND Status = @NewStatus; DECLARE @ProcessingFee DECIMAL(10,2) = 0; DECLARE fee_cursor CURSOR FOR SELECT Fee FROM OrderDetails WHERE OrderID IN (SELECT OrderID FROM Orders WHERE CustomerID = @CustomerID AND Status = @NewStatus); OPEN fee_cursor; FETCH NEXT FROM fee_cursor INTO @ProcessingFee; WHILE @@FETCH_STATUS = 0 BEGIN SET @ProcessingFee = @ProcessingFee * 0.95; FETCH NEXT FROM fee_cursor INTO @ProcessingFee; END CLOSE fee_cursor; DEALLOCATE fee_cursor; IF @TranCount = 0 COMMIT TRANSACTION; SET @ErrorMessage = '更新成功'; RETURN 200; END TRY BEGIN CATCH IF @TranCount = 0 AND @@TRANCOUNT > 0 ROLLBACK TRANSACTION; SET @ErrorMessage = ERROR_MESSAGE() + ' (Line:' + CAST(ERROR_LINE() AS VARCHAR) + ')'; RETURN 500; END CATCH END\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE usp_UpdateOrderStatus(\n    p_CustomerID INT,\n    p_OldStatus VARCHAR(20),\n    p_NewStatus VARCHAR(20),\n    OUT p_RowsUpdated INT,\n    OUT p_ErrorMessage VARCHAR(200),\n    OUT p_StatusCode INT\n)\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    v_in_transaction_at_start BOOLEAN;\n    v_ProcessingFee DECIMAL(10,2) := 0;\n    fee_cursor CURSOR FOR\n        SELECT Fee\n        FROM OrderDetails\n        WHERE OrderID IN (\n            SELECT OrderID\n            FROM Orders\n            WHERE CustomerID = p_CustomerID\n              AND Status = p_NewStatus\n        );\nBEGIN\n    p_RowsUpdated := 0;\n    p_ErrorMessage := '';\n    p_StatusCode := 0;\n\n    SELECT pg_current_xact_id() IS NOT NULL INTO v_in_transaction_at_start;\n\n    IF p_OldStatus = p_NewStatus THEN\n        p_ErrorMessage := '新旧状态不能相同';\n        p_StatusCode := 400;\n        RETURN;\n    END IF;\n\n    BEGIN\n        IF NOT v_in_transaction_at_start THEN\n            EXECUTE 'START TRANSACTION';\n        END IF;\n\n        UPDATE Orders\n        SET Status = p_NewStatus, LastUpdated = NOW()\n        WHERE CustomerID = p_CustomerID"
                    }
                ]
            },
            {
                "case_id": "3",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"3\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE SEQUENCE emp_seq START WITH 1000 INCREMENT BY 1 CACHE 20;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE SEQUENCE emp_seq START WITH 1000 INCREMENT BY 1 CACHE 20;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE SEQUENCE emp_seq START WITH 1000 INCREMENT BY 1 CACHE 20;"
                    }
                ]
            },
            {
                "case_id": "4",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"4\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"DELIMITER $$ CREATE OR REPLACE PROCEDURE \\\"SP_KSH_PERSON_DESC\\\" (V_USER_ID IN VARCHAR2, OUTCURSOR OUT SYS_REFCURSOR) IS BEGIN OPEN OUTCURSOR FOR SELECT SYS_GUID() AS UUID, v0.usr_name AS user_name, v0.dept_name, v0.position_describe AS post_name, NVL(v1.ves_cnt,0) AS ves_cnt, NVL(v1.jw_num,0) AS jw_num, NVL(v1.hw_num,0) AS hw_num FROM (SELECT su.usr_id, su.usr_name, so.office_name || so2.office_name AS dept_name, su.position_describe FROM sys_user su LEFT JOIN sys_office so ON su.department_id = so.office_id LEFT JOIN sys_office so2 ON su.dept = so2.office_code WHERE su.usr_id = V_USER_ID) v0 LEFT JOIN (SELECT COUNT(um.vessel_code) AS ves_cnt, COUNT(DISTINCT fn_get_vessel_manager_bc(um.VESSEL_CODE, SYSDATE, '1')) AS jw_num, COUNT(DISTINCT fn_get_vessel_manager_bc(um.VESSEL_CODE, SYSDATE, '2')) AS hw_num FROM ksh_user_manage_ship um WHERE um.user_id = V_USER_ID) v1 ON 1=1; END SP_KSH_PERSON_DESC; $$\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nDELIMITER $$ CREATE OR REPLACE PROCEDURE \"SP_KSH_PERSON_DESC\" (V_USER_ID IN VARCHAR2, OUTCURSOR OUT SYS_REFCURSOR) IS BEGIN OPEN OUTCURSOR FOR SELECT SYS_GUID() AS UUID, v0.usr_name AS user_name, v0.dept_name, v0.position_describe AS post_name, NVL(v1.ves_cnt,0) AS ves_cnt, NVL(v1.jw_num,0) AS jw_num, NVL(v1.hw_num,0) AS hw_num FROM (SELECT su.usr_id, su.usr_name, so.office_name || so2.office_name AS dept_name, su.position_describe FROM sys_user su LEFT JOIN sys_office so ON su.department_id = so.office_id LEFT JOIN sys_office so2 ON su.dept = so2.office_code WHERE su.usr_id = V_USER_ID) v0 LEFT JOIN (SELECT COUNT(um.vessel_code) AS ves_cnt, COUNT(DISTINCT fn_get_vessel_manager_bc(um.VESSEL_CODE, SYSDATE, '1')) AS jw_num, COUNT(DISTINCT fn_get_vessel_manager_bc(um.VESSEL_CODE, SYSDATE, '2')) AS hw_num FROM ksh_user_manage_ship um WHERE um.user_id = V_USER_ID) v1 ON 1=1; END SP_KSH_PERSON_DESC; $$\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE FUNCTION SP_KSH_PERSON_DESC(V_USER_ID VARCHAR, OUT OUTCURSOR REFCURSOR)\nRETURNS REFCURSOR AS $$\nBEGIN\n    OPEN OUTCURSOR FOR\n    SELECT\n        uuid_generate_v4() AS UUID,\n        v0.usr_name AS user_name,\n        v0.dept_name,\n        v0.position_describe AS post_name,\n        COALESCE(v1.ves_cnt, 0) AS ves_cnt,\n        COALESCE(v1.jw_num, 0) AS jw_num,\n        COALESCE(v1.hw_num, 0) AS hw_num\n    FROM\n        (SELECT\n            su.usr_id,\n            su.usr_name,\n            so.office_name || so2.office_name AS dept_name,\n            su.position_describe\n        FROM\n            sys_user su\n        LEFT JOIN sys_office so ON su.department_id = so.office_id\n        LEFT JOIN sys_office so2 ON su.dept = so2.office_code\n        WHERE\n            su.usr_id = V_USER_ID\n        ) v0\n    LEFT JOIN\n        (SELECT\n            COUNT(um.vessel_code) AS ves_cnt,\n            COUNT(DISTINCT fn_get_vessel_manager_bc(um.VESSEL_CODE, NOW(), '1')) AS jw_num,\n            COUNT(DISTINCT fn_get_vessel_manager_bc(um.VESSEL_CODE, NOW(), '2')) AS hw_num\n        FROM\n            ksh_user_manage_ship um\n        WHERE\n            um.user_id = V_USER_ID\n        ) v1 ON 1=1;\nEND;\n$$ LANGUAGE plpgsql;"
                    }
                ]
            },
            {
                "case_id": "5",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"5\", \"difficulty_level\": \"1\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'Logs') CREATE TABLE Logs (LogID int, LogMessage nvarchar(max));\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nIF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'Logs') CREATE TABLE Logs (LogID int, LogMessage nvarchar(max));\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE TABLE IF NOT EXISTS Logs (LogID INT, LogMessage TEXT);"
                    }
                ]
            },
            {
                "case_id": "6",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"6\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"CREATE OR REPLACE VIEW v_emp_dept AS SELECT e.ename, d.dname FROM emp e JOIN dept d ON e.deptno = d.deptno WITH READ ONLY;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE VIEW v_emp_dept AS SELECT e.ename, d.dname FROM emp e JOIN dept d ON e.deptno = d.deptno WITH READ ONLY;\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE VIEW v_emp_dept AS SELECT e.ename, d.dname FROM emp e JOIN dept d ON e.deptno = d.deptno;"
                    }
                ]
            },
            {
                "case_id": "7",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"7\", \"difficulty_level\": \"1\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"CREATE PROCEDURE sp_GetCustomerOrders @CustomerID nchar(5) AS BEGIN SELECT * FROM Orders WHERE CustomerID = @CustomerID; END;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE PROCEDURE sp_GetCustomerOrders @CustomerID nchar(5) AS BEGIN SELECT * FROM Orders WHERE CustomerID = @CustomerID; END;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE sp_GetCustomerOrders(p_CustomerID IN CHARACTER(5))\nAS $$\nBEGIN\n    SELECT * FROM Orders WHERE CustomerID = p_CustomerID;\nEND;\n$$ LANGUAGE plpgsql;"
                    }
                ]
            },
            {
                "case_id": "8",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"8\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE INDEX idx_emp_name ON emp(LOWER(ename));\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE INDEX idx_emp_name ON emp(LOWER(ename));\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_emp_name ON emp(LOWER(ename));"
                    }
                ]
            },
            {
                "case_id": "9",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"9\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"CREATE OR REPLACE TRIGGER trg_audit_emp_sal BEFORE UPDATE OF sal ON emp FOR EACH ROW BEGIN INSERT INTO emp_audit(emp_id, old_sal, new_sal) VALUES (:OLD.empno, :OLD.sal, :NEW.sal); END;\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE TRIGGER trg_audit_emp_sal BEFORE UPDATE OF sal ON emp FOR EACH ROW BEGIN INSERT INTO emp_audit(emp_id, old_sal, new_sal) VALUES (:OLD.empno, :OLD.sal, :NEW.sal); END;\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE FUNCTION trg_audit_emp_sal_func()\nRETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO emp_audit(emp_id, old_sal, new_sal)\n    VALUES (OLD.empno, OLD.sal, NEW.sal);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE OR REPLACE TRIGGER trg_audit_emp_sal\nBEFORE UPDATE OF sal ON emp\nFOR EACH ROW\nEXECUTE FUNCTION trg_audit_emp_sal_func();"
                    }
                ]
            },
            {
                "case_id": "10",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"10\", \"difficulty_level\": \"2\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"DECLARE @MyCursor CURSOR; DECLARE @LastName varchar(50); SET @MyCursor = CURSOR FOR SELECT LastName FROM Person.Person; OPEN @MyCursor; FETCH NEXT FROM @MyCursor INTO @LastName; CLOSE @MyCursor; DEALLOCATE @MyCursor;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nDECLARE @MyCursor CURSOR; DECLARE @LastName varchar(50); SET @MyCursor = CURSOR FOR SELECT LastName FROM Person.Person; OPEN @MyCursor; FETCH NEXT FROM @MyCursor INTO @LastName; CLOSE @MyCursor; DEALLOCATE @MyCursor;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "DO $$\nDECLARE\n    my_cursor CURSOR FOR SELECT LastName FROM Person.Person;\n    last_name VARCHAR(50);\nBEGIN\n    OPEN my_cursor;\n    FETCH NEXT FROM my_cursor INTO last_name;\n    CLOSE my_cursor;\nEND $$;"
                    }
                ]
            },
            {
                "case_id": "11",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"11\", \"difficulty_level\": \"2\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"ALTER TABLE sales ADD CONSTRAINT sales_time_fk FOREIGN KEY (time_id) REFERENCES times(time_id) ENABLE NOVALIDATE;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nALTER TABLE sales ADD CONSTRAINT sales_time_fk FOREIGN KEY (time_id) REFERENCES times(time_id) ENABLE NOVALIDATE;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "ALTER TABLE sales ADD CONSTRAINT sales_time_fk FOREIGN KEY (time_id) REFERENCES times(time_id) ENABLE NOVALIDATE;"
                    }
                ]
            },
            {
                "case_id": "12",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"12\", \"difficulty_level\": \"3\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"CREATE TYPE [dbo].[AccountNumber] FROM [nvarchar](15) NOT NULL;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE TYPE [dbo].[AccountNumber] FROM [nvarchar](15) NOT NULL;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE DOMAIN AccountNumber AS VARCHAR(15) NOT NULL;"
                    }
                ]
            },
            {
                "case_id": "13",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"13\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"CREATE OR REPLACE PACKAGE emp_actions AS PROCEDURE hire_employee(p_name VARCHAR2, p_job VARCHAR2); FUNCTION get_salary(p_emp_id NUMBER) RETURN NUMBER; END emp_actions;\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PACKAGE emp_actions AS PROCEDURE hire_employee(p_name VARCHAR2, p_job VARCHAR2); FUNCTION get_salary(p_emp_id NUMBER) RETURN NUMBER; END emp_actions;\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE SCHEMA IF NOT EXISTS emp_actions;\nCREATE OR REPLACE FUNCTION emp_actions.hire_employee(p_name TEXT, p_job TEXT) RETURNS void AS $$\nBEGIN\n    -- Placeholder for the actual procedure logic from the Oracle package body.\n    -- In PostgreSQL 9.2, procedures are implemented as functions returning void.\n    RAISE NOTICE 'Placeholder: Employee % (Job: %) would be hired here.', p_name, p_job;\nEND;\n$$ LANGUAGE plpgsql;\nCREATE OR REPLACE FUNCTION emp_actions.get_salary(p_emp_id INTEGER) RETURNS NUMERIC AS $$\nBEGIN\n    -- Placeholder for the actual function logic from the Oracle package body.\n    -- Example: RETURN (SELECT salary FROM employees WHERE emp_id = p_emp_id);\n    RAISE NOTICE 'Placeholder: Fetching salary for employee ID %', p_emp_id;\n    RETURN 0.0; -- Return a placeholder value\nEND;\n$$ LANGUAGE plpgsql;"
                    }
                ]
            },
            {
                "case_id": "14",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"14\", \"difficulty_level\": \"1\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"CREATE PROCEDURE [HumanResources].[uspUpdateEmployeePersonalInfo] @BusinessEntityID [int], @NationalIDNumber [nvarchar](15), @BirthDate [datetime] AS BEGIN SET NOCOUNT ON; BEGIN TRY UPDATE [HumanResources].[Employee] SET [NationalIDNumber] = @NationalIDNumber, [BirthDate] = @BirthDate WHERE [BusinessEntityID] = @BusinessEntityID; END TRY BEGIN CATCH EXECUTE [dbo].[uspLogError]; END CATCH; END;\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE PROCEDURE [HumanResources].[uspUpdateEmployeePersonalInfo] @BusinessEntityID [int], @NationalIDNumber [nvarchar](15), @BirthDate [datetime] AS BEGIN SET NOCOUNT ON; BEGIN TRY UPDATE [HumanResources].[Employee] SET [NationalIDNumber] = @NationalIDNumber, [BirthDate] = @BirthDate WHERE [BusinessEntityID] = @BusinessEntityID; END TRY BEGIN CATCH EXECUTE [dbo].[uspLogError]; END CATCH; END;\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE HumanResources.uspUpdateEmployeePersonalInfo(\n    p_BusinessEntityID INT,\n    p_NationalIDNumber NVARCHAR(15),\n    p_BirthDate TIMESTAMP\n)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    BEGIN\n        UPDATE HumanResources.Employee\n        SET\n            NationalIDNumber = p_NationalIDNumber,\n            BirthDate = p_BirthDate\n        WHERE\n            BusinessEntityID = p_BusinessEntityID;\n    EXCEPTION\n        WHEN OTHERS THEN\n            CALL dbo.uspLogError();\n    END;\nEND;\n$$;"
                    }
                ]
            },
            {
                "case_id": "15",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"15\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"CREATE OR REPLACE PROCEDURE process_orders IS PRAGMA AUTONOMOUS_TRANSACTION; BEGIN INSERT INTO order_logs (log_date, log_msg) VALUES (SYSDATE, 'Processing started'); DELETE FROM new_orders; COMMIT; END;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE OR REPLACE PROCEDURE process_orders IS PRAGMA AUTONOMOUS_TRANSACTION; BEGIN INSERT INTO order_logs (log_date, log_msg) VALUES (SYSDATE, 'Processing started'); DELETE FROM new_orders; COMMIT; END;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE OR REPLACE PROCEDURE process_orders IS PRAGMA AUTONOMOUS_TRANSACTION; BEGIN INSERT INTO order_logs (log_date, log_msg) VALUES (SYSDATE, 'Processing started'); DELETE FROM new_orders; COMMIT; END;"
                    }
                ]
            },
            {
                "case_id": "16",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"16\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"DECLARE TYPE emp_cur_type IS REF CURSOR; v_cur emp_cur_type; BEGIN OPEN v_cur FOR SELECT * FROM emp; END;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nDECLARE TYPE emp_cur_type IS REF CURSOR; v_cur emp_cur_type; BEGIN OPEN v_cur FOR SELECT * FROM emp; END;\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "DO $$\nDECLARE\n    v_cur refcursor;\nBEGIN\n    OPEN v_cur FOR SELECT * FROM emp;\nEND;\n$$;"
                    }
                ]
            },
            {
                "case_id": "17",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"17\", \"difficulty_level\": \"1\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"SELECT OrderID, CustomerID, OrderDate FROM Orders FOR XML PATH('Order'), ROOT('Orders');\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT OrderID, CustomerID, OrderDate FROM Orders FOR XML PATH('Order'), ROOT('Orders');\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT xmlelement(NAME \"Orders\", xmlagg(xmlelement(NAME \"Order\", xmlelement(NAME \"OrderID\", OrderID), xmlelement(NAME \"CustomerID\", CustomerID), xmlelement(NAME \"OrderDate\", OrderDate)))) FROM Orders"
                    }
                ]
            },
            {
                "case_id": "18",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"18\", \"difficulty_level\": \"1\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"Postgresql-9.2\", \"sql\": \"ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to Postgresql-9.2 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';\n\nTranslated SQL (Postgresql-9.2):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SET datestyle = 'ISO';"
                    }
                ]
            },
            {
                "case_id": "19",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"19\", \"difficulty_level\": \"3\", \"source_dialect\": \"ORACLE\", \"target_dialect\": \"OceanBase的Oracle模式-4.2.5\", \"sql\": \"SELECT /*+ FULL(e) PARALLEL(e, 4) */ e.ename, d.dname FROM emp e, dept d WHERE e.deptno = d.deptno;\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from ORACLE syntax to OceanBase的Oracle模式-4.2.5 syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nSELECT /*+ FULL(e) PARALLEL(e, 4) */ e.ename, d.dname FROM emp e, dept d WHERE e.deptno = d.deptno;\n\nTranslated SQL (OceanBase的Oracle模式-4.2.5):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT /*+ FULL(e) PARALLEL(e, 4) */ e.ename, d.dname FROM emp e, dept d WHERE e.deptno = d.deptno;"
                    }
                ]
            },
            {
                "case_id": "20",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"20\", \"difficulty_level\": \"1\", \"source_dialect\": \"SQLServer\", \"target_dialect\": \"GaussDB-v2.0_3.x\", \"sql\": \"CREATE PARTITION FUNCTION myRangePF1 (int) AS RANGE LEFT FOR VALUES (1, 100, 1000);\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are an expert in SQL dialect translation.\nPlease convert the following SQL statement from SQLServer syntax to GaussDB-v2.0_3.x syntax.\nReturn **only** the translated SQL statement(no extra text, no markdown fences, need directly executable sql), with no additional commentary or text.\n\nSource SQL:\nCREATE PARTITION FUNCTION myRangePF1 (int) AS RANGE LEFT FOR VALUES (1, 100, 1000);\n\nTranslated SQL (GaussDB-v2.0_3.x):\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE TABLE my_partitioned_table (id INT, partition_column INT) PARTITION BY RANGE (partition_column) (PARTITION p1 VALUES FROM (MINVALUE) TO (2), PARTITION p2 VALUES FROM (2) TO (101), PARTITION p3 VALUES FROM (101) TO (1001), PARTITION p4 VALUES FROM (1001) TO (MAXVALUE));"
                    }
                ]
            }
        ]
    }
]