[
    {
        "indicator_name": "index_advice.jsonl",
        "indicator_weight": 1,
        "evaluation_type": "hybrid",
        "case_pass_count": 54,
        "case_wrong_count": 34,
        "correct_rate": 0.61,
        "case_datas": [
            {
                "case_id": "1",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"1\", \"difficulty_level\": \"3\", \"description\": \"业务case-测试联合索引字段顺序\", \"create_table_statements\": \"CREATE TABLE `gs_order_inn` (\\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\\n  `order_code` varchar(20) DEFAULT NULL COMMENT '订单编号',\\n  `third_order_code` varchar(300) DEFAULT NULL COMMENT '第三方订单编码',\\n  `inn_id` varchar(20) DEFAULT NULL,\\n  `inn_name` varchar(100) DEFAULT NULL COMMENT '酒店名称',\\n  `chain_id` varchar(20) DEFAULT NULL,\\n  `room_type_id` varchar(20) DEFAULT NULL,\\n  `room_type_name` varchar(100) DEFAULT NULL COMMENT '房间类型名称',\\n  `third_roomtype_id` varchar(20) DEFAULT NULL,\\n  `bk_meb_id` int(11) DEFAULT NULL COMMENT '预订人会员id',\\n  `bk_name` varchar(300) DEFAULT NULL COMMENT '预订人姓名',\\n  `bk_mobile` varchar(300) DEFAULT NULL COMMENT '预订人手机',\\n  `bk_email` varchar(300) DEFAULT NULL COMMENT '预订人电子邮箱',\\n  `bk_meb_type` int(6) DEFAULT NULL COMMENT '预订人会员类型',\\n  `bk_card_no` varchar(50) DEFAULT NULL COMMENT '预订人卡号',\\n  `bk_property_id` int(11) DEFAULT NULL COMMENT '预订人属性id',\\n  `bk_protype_id` int(11) DEFAULT NULL COMMENT '预订人属性类型id',\\n  `contact_name` varchar(100) DEFAULT NULL COMMENT '联系人姓名',\\n  `contact_phone` varchar(100) DEFAULT NULL COMMENT '联系人电话号码',\\n  `contact_email` varchar(100) DEFAULT NULL COMMENT '联系人电子邮箱',\\n  `guests_name` varchar(500) DEFAULT NULL,\\n  `guests_num` int(5) DEFAULT NULL COMMENT '客人数量',\\n  `bk_ip` varchar(100) DEFAULT NULL COMMENT '预订人ip地址',\\n  `supplier_id` int(5) DEFAULT NULL COMMENT '供应商信息id',\\n  `assure_type` int(2) DEFAULT NULL COMMENT '担保类型',\\n  `assure_meb_point` int(2) DEFAULT NULL COMMENT '会员担保积分',\\n  `source_type` int(2) DEFAULT NULL COMMENT '预订来源，app，官网，M站，微信等',\\n  `inner_remarks` varchar(1024) DEFAULT NULL COMMENT '员工内部备注',\\n  `remarks` varchar(1024) DEFAULT NULL COMMENT '备注',\\n  `order_state` int(2) unsigned DEFAULT NULL COMMENT '订单状态 （0待确认，1预订成功，2已取消，3预订未到，4已入住，5已完成，6确认失败）',\\n  `activity_code` varchar(20) DEFAULT NULL,\\n  `seller_id` int(11) DEFAULT NULL COMMENT '业绩销售员',\\n  `pay_state` int(5) unsigned DEFAULT NULL COMMENT '支付状态 0未付款 1已付款 2退款处理中 3已退款',\\n  `can_cancel` int(5) DEFAULT NULL COMMENT '是否可以取消',\\n  `need_invoice` int(5) DEFAULT NULL COMMENT '是否需要发票',\\n  `pay_type` int(2) DEFAULT NULL COMMENT '支付方式(0到付；1线上预付；2信用住)',\\n  `orig_rate` double(10,2) DEFAULT NULL COMMENT '原价',\\n  `total_rate` double(10,2) DEFAULT NULL COMMENT '总价',\\n  `pay_rate` double(10,2) DEFAULT NULL COMMENT '支付价',\\n  `disc_price` double(10,2) DEFAULT NULL COMMENT '优惠金额（根据资产子表）',\\n  `rate_code` varchar(20) DEFAULT NULL COMMENT '价格代码',\\n  `orig_arr_date` datetime DEFAULT NULL COMMENT '预计抵店时间',\\n  `orig_dep_date` datetime DEFAULT NULL COMMENT '预计离店时间',\\n  `arr_date` datetime DEFAULT NULL COMMENT '实际到店时间',\\n  `dep_date` datetime DEFAULT NULL COMMENT '实际离店时间',\\n  `day_length` int(5) DEFAULT NULL COMMENT '入住天数',\\n  `room_qty` int(6) DEFAULT NULL COMMENT '房间数',\\n  `can_cancel_time` datetime DEFAULT NULL COMMENT '取消截止时间',\\n  `keep_date` datetime DEFAULT NULL COMMENT '保留时间',\\n  `flag` int(6) DEFAULT NULL COMMENT '订单标志位 1可用 0不可用',\\n  `create_time` datetime DEFAULT NULL COMMENT '创建时间',\\n  `create_oprt` int(6) DEFAULT NULL COMMENT '创建人',\\n  `update_time` datetime DEFAULT NULL COMMENT '修改时间',\\n  `update_oprt` int(6) DEFAULT NULL COMMENT '修改人',\\n  `channel_source_type` int(5) DEFAULT NULL COMMENT '订单渠道来源',\\n  `external_id` varchar(100) DEFAULT NULL COMMENT '外部跟踪号',\\n  `brand_id` varchar(20) DEFAULT NULL COMMENT '品牌编码',\\n  `room_source_type` varchar(255) DEFAULT '7days' COMMENT '房源编码',\\n  `city_code` varchar(255) DEFAULT NULL COMMENT '城市编码',\\n  `charged_rate` decimal(10,2) DEFAULT NULL COMMENT '后付订单实扣金额',\\n  `time_zone` varchar(16) DEFAULT NULL COMMENT '酒店时区',\\n  `inn_eng_name` varchar(100) DEFAULT NULL COMMENT '酒店英文名称',\\n  `room_type_eng_name` varchar(100) DEFAULT NULL COMMENT '房型英文名称',\\n  `bk_last_name` varchar(100) DEFAULT NULL COMMENT '预订人英文姓（中文拼音姓）',\\n  `bk_first_name` varchar(100) DEFAULT NULL COMMENT '预订人英文名（中文拼音名）',\\n  `country_code` varchar(30) DEFAULT NULL COMMENT '国家编码',\\n  `preference` varchar(255) DEFAULT NULL COMMENT '客户偏好（逗号隔开）',\\n  `currency` varchar(30) DEFAULT 'CNY' COMMENT '币种：CNY-人民币',\\n  `overtime_state` int(3) DEFAULT NULL COMMENT '超时状态（0无,1下单超时,2取消超时）',\\n  `acc_state` int(3) DEFAULT NULL COMMENT '账单状态',\\n  `concat_last_name` varchar(100) DEFAULT NULL COMMENT '联系人英文姓（中文拼音姓）',\\n  `concat_first_name` varchar(100) DEFAULT NULL COMMENT '联系人英文名（中文拼音名）',\\n  `channel_code` varchar(30) DEFAULT NULL COMMENT '酒店房态渠道来源',\\n  `business_meb_id` int(11) DEFAULT NULL COMMENT '企业会员id',\\n  `business_meb_type` int(11) DEFAULT NULL COMMENT '企业会员类型',\\n  `min_pay_rate` decimal(10,2) DEFAULT NULL COMMENT '订单最低消费金额',\\n  `min_live_days` int(5) DEFAULT NULL COMMENT '订单最低连住天数',\\n  `order_type` int(5) DEFAULT '3' COMMENT '订单业务类型（2酒+景 3酒店 4酒+机）',\\n  `sale_type` int(5) DEFAULT '1' COMMENT '销售类型（1单独销售 2捆绑礼包销售）',\\n  `change_state` char(1) DEFAULT '0' COMMENT '变更状态',\\n  `state1` char(1) DEFAULT NULL COMMENT '状态1',\\n  `state2` char(1) DEFAULT NULL COMMENT '状态2',\\n  `ext1` varchar(20) DEFAULT NULL COMMENT '扩展字段1',\\n  `ext2` varchar(30) DEFAULT NULL COMMENT '扩展字段2',\\n  `ext3` varchar(50) DEFAULT NULL COMMENT '扩展字段3',\\n  `breakfast` json DEFAULT NULL COMMENT '早餐信息',\\n  `ext4` varchar(80) DEFAULT NULL COMMENT '扩展信息4',\\n  `ext5` json DEFAULT NULL COMMENT '扩展信息5',\\n  `balance_ext` json DEFAULT NULL COMMENT '用于结算通扩展信息',\\n  PRIMARY KEY (`id`),\\n  UNIQUE KEY `order_inn_code_ind` (`order_code`) USING BTREE,\\n  KEY `order_inn_meb_id_ind` (`bk_meb_id`) USING BTREE,\\n  KEY `order_inn_chain_id_ind` (`chain_id`),\\n  KEY `order_inn_order_state_ind` (`order_state`) USING BTREE,\\n  KEY `order_inn_create_time_ind` (`create_time`),\\n  KEY `order_inn_orig_arr_date_ind` (`orig_arr_date`),\\n  KEY `order_inn_room_type_id` (`room_type_id`),\\n  KEY `order_inn_source_type` (`source_type`),\\n  KEY `IX_bk_meb_id` (`bk_meb_id`,`room_type_id`,`source_type`),\\n  KEY `order_inn_channel_source_type` (`channel_source_type`),\\n  KEY `order_inn_city_code` (`city_code`),\\n  KEY `order_inn_sid` (`seller_id`),\\n  KEY `order_inn_overtime_state` (`overtime_state`),\\n  KEY `idx_gs_order_inn` (`update_time`),\\n  KEY `order_inn_external_id` (`external_id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=20659802 DEFAULT CHARSET=utf8 COMMENT='酒店订单主表（数据基本以客户提交内容）'\", \"sql\": \"select\\n  COUNT(*)\\nfrom\\n  gs_order_inn  \\nWHERE\\n  (\\n    bk_meb_id = 1000492\\n    and flag = 0\\n    and create_time >= '2023-02-29 00:00:00.0'\\n    and source_type not in (129, 345)\\n    and channel_source_type in (1, 2, 4)\\n    and country_code = 'LT'\\n    and sale_type <> 3\\n    and (\\n      ext1 is null\\n      or ext1 not in ('02', '03')\\n    )\\n    and create_oprt = 1200\\n  );\", \"columns_selectivity\": \"{\\n    \\\"gs_order_inn\\\": {\\n        \\\"bk_meb_id\\\": 60.0000%,\\n        \\\"flag\\\": 0.2000%,\\n        \\\"create_time\\\": 0.4000%,\\n        \\\"source_type\\\": 1.2000%,\\n        \\\"channel_source_type\\\": 2.0000%,\\n        \\\"country_code\\\": 12.6000%,\\n        \\\"sale_type\\\": 0.2000%,\\n        \\\"ext1\\\": 0.0000%,\\n        \\\"create_oprt\\\": 0.2000%\\n    }\\n}\", \"explain\": \"|id |select_type|table       |partitions|type|possible_keys                                                                                                  |key                 |key_len|ref  |rows|filtered|Extra      |\\n|---|-----------|------------|----------|----|---------------------------------------------------------------------------------------------------------------|--------------------|-------|-----|----|--------|-----------|\\n|1  |SIMPLE     |gs_order_inn|          |ref |order_inn_meb_id_ind,order_inn_create_time_ind,order_inn_source_type,IX_bk_meb_id,order_inn_channel_source_type|order_inn_meb_id_ind|5      |const|1   |5       |Using where|\", \"expected\": \"以下三种情况均可：\\n1. 无性能问题，无索引建议\\n2. 执行计划显示过滤率（filtere）过低，在gs_order_inn表的bk_meb_id，country_code，channel_source_type，flag，create_time列创建复合索引，以减少会表次数，要求左列顺序为bk_meb_id，country_code，channel_source_type\\n3. 在gs_order_inn表的bk_meb_id, country_code, channel_source_type, create_oprt或flag, create_time列创建复合索引，要求左列顺序为bk_meb_id，country_code，channel_source_type\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE `gs_order_inn` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `order_code` varchar(20) DEFAULT NULL COMMENT '订单编号',\n  `third_order_code` varchar(300) DEFAULT NULL COMMENT '第三方订单编码',\n  `inn_id` varchar(20) DEFAULT NULL,\n  `inn_name` varchar(100) DEFAULT NULL COMMENT '酒店名称',\n  `chain_id` varchar(20) DEFAULT NULL,\n  `room_type_id` varchar(20) DEFAULT NULL,\n  `room_type_name` varchar(100) DEFAULT NULL COMMENT '房间类型名称',\n  `third_roomtype_id` varchar(20) DEFAULT NULL,\n  `bk_meb_id` int(11) DEFAULT NULL COMMENT '预订人会员id',\n  `bk_name` varchar(300) DEFAULT NULL COMMENT '预订人姓名',\n  `bk_mobile` varchar(300) DEFAULT NULL COMMENT '预订人手机',\n  `bk_email` varchar(300) DEFAULT NULL COMMENT '预订人电子邮箱',\n  `bk_meb_type` int(6) DEFAULT NULL COMMENT '预订人会员类型',\n  `bk_card_no` varchar(50) DEFAULT NULL COMMENT '预订人卡号',\n  `bk_property_id` int(11) DEFAULT NULL COMMENT '预订人属性id',\n  `bk_protype_id` int(11) DEFAULT NULL COMMENT '预订人属性类型id',\n  `contact_name` varchar(100) DEFAULT NULL COMMENT '联系人姓名',\n  `contact_phone` varchar(100) DEFAULT NULL COMMENT '联系人电话号码',\n  `contact_email` varchar(100) DEFAULT NULL COMMENT '联系人电子邮箱',\n  `guests_name` varchar(500) DEFAULT NULL,\n  `guests_num` int(5) DEFAULT NULL COMMENT '客人数量',\n  `bk_ip` varchar(100) DEFAULT NULL COMMENT '预订人ip地址',\n  `supplier_id` int(5) DEFAULT NULL COMMENT '供应商信息id',\n  `assure_type` int(2) DEFAULT NULL COMMENT '担保类型',\n  `assure_meb_point` int(2) DEFAULT NULL COMMENT '会员担保积分',\n  `source_type` int(2) DEFAULT NULL COMMENT '预订来源，app，官网，M站，微信等',\n  `inner_remarks` varchar(1024) DEFAULT NULL COMMENT '员工内部备注',\n  `remarks` varchar(1024) DEFAULT NULL COMMENT '备注',\n  `order_state` int(2) unsigned DEFAULT NULL COMMENT '订单状态 （0待确认，1预订成功，2已取消，3预订未到，4已入住，5已完成，6确认失败）',\n  `activity_code` varchar(20) DEFAULT NULL,\n  `seller_id` int(11) DEFAULT NULL COMMENT '业绩销售员',\n  `pay_state` int(5) unsigned DEFAULT NULL COMMENT '支付状态 0未付款 1已付款 2退款处理中 3已退款',\n  `can_cancel` int(5) DEFAULT NULL COMMENT '是否可以取消',\n  `need_invoice` int(5) DEFAULT NULL COMMENT '是否需要发票',\n  `pay_type` int(2) DEFAULT NULL COMMENT '支付方式(0到付；1线上预付；2信用住)',\n  `orig_rate` double(10,2) DEFAULT NULL COMMENT '原价',\n  `total_rate` double(10,2) DEFAULT NULL COMMENT '总价',\n  `pay_rate` double(10,2) DEFAULT NULL COMMENT '支付价',\n  `disc_price` double(10,2) DEFAULT NULL COMMENT '优惠金额（根据资产子表）',\n  `rate_code` varchar(20) DEFAULT NULL COMMENT '价格代码',\n  `orig_arr_date` datetime DEFAULT NULL COMMENT '预计抵店时间',\n  `orig_dep_date` datetime DEFAULT NULL COMMENT '预计离店时间',\n  `arr_date` datetime DEFAULT NULL COMMENT '实际到店时间',\n  `dep_date` datetime DEFAULT NULL COMMENT '实际离店时间',\n  `day_length` int(5) DEFAULT NULL COMMENT '入住天数',\n  `room_qty` int(6) DEFAULT NULL COMMENT '房间数',\n  `can_cancel_time` datetime DEFAULT NULL COMMENT '取消截止时间',\n  `keep_date` datetime DEFAULT NULL COMMENT '保留时间',\n  `flag` int(6) DEFAULT NULL COMMENT '订单标志位 1可用 0不可用',\n  `create_time` datetime DEFAULT NULL COMMENT '创建时间',\n  `create_oprt` int(6) DEFAULT NULL COMMENT '创建人',\n  `update_time` datetime DEFAULT NULL COMMENT '修改时间',\n  `update_oprt` int(6) DEFAULT NULL COMMENT '修改人',\n  `channel_source_type` int(5) DEFAULT NULL COMMENT '订单渠道来源',\n  `external_id` varchar(100) DEFAULT NULL COMMENT '外部跟踪号',\n  `brand_id` varchar(20) DEFAULT NULL COMMENT '品牌编码',\n  `room_source_type` varchar(255) DEFAULT '7days' COMMENT '房源编码',\n  `city_code` varchar(255) DEFAULT NULL COMMENT '城市编码',\n  `charged_rate` decimal(10,2) DEFAULT NULL COMMENT '后付订单实扣金额',\n  `time_zone` varchar(16) DEFAULT NULL COMMENT '酒店时区',\n  `inn_eng_name` varchar(100) DEFAULT NULL COMMENT '酒店英文名称',\n  `room_type_eng_name` varchar(100) DEFAULT NULL COMMENT '房型英文名称',\n  `bk_last_name` varchar(100) DEFAULT NULL COMMENT '预订人英文姓（中文拼音姓）',\n  `bk_first_name` varchar(100) DEFAULT NULL COMMENT '预订人英文名（中文拼音名）',\n  `country_code` varchar(30) DEFAULT NULL COMMENT '国家编码',\n  `preference` varchar(255) DEFAULT NULL COMMENT '客户偏好（逗号隔开）',\n  `currency` varchar(30) DEFAULT 'CNY' COMMENT '币种：CNY-人民币',\n  `overtime_state` int(3) DEFAULT NULL COMMENT '超时状态（0无,1下单超时,2取消超时）',\n  `acc_state` int(3) DEFAULT NULL COMMENT '账单状态',\n  `concat_last_name` varchar(100) DEFAULT NULL COMMENT '联系人英文姓（中文拼音姓）',\n  `concat_first_name` varchar(100) DEFAULT NULL COMMENT '联系人英文名（中文拼音名）',\n  `channel_code` varchar(30) DEFAULT NULL COMMENT '酒店房态渠道来源',\n  `business_meb_id` int(11) DEFAULT NULL COMMENT '企业会员id',\n  `business_meb_type` int(11) DEFAULT NULL COMMENT '企业会员类型',\n  `min_pay_rate` decimal(10,2) DEFAULT NULL COMMENT '订单最低消费金额',\n  `min_live_days` int(5) DEFAULT NULL COMMENT '订单最低连住天数',\n  `order_type` int(5) DEFAULT '3' COMMENT '订单业务类型（2酒+景 3酒店 4酒+机）',\n  `sale_type` int(5) DEFAULT '1' COMMENT '销售类型（1单独销售 2捆绑礼包销售）',\n  `change_state` char(1) DEFAULT '0' COMMENT '变更状态',\n  `state1` char(1) DEFAULT NULL COMMENT '状态1',\n  `state2` char(1) DEFAULT NULL COMMENT '状态2',\n  `ext1` varchar(20) DEFAULT NULL COMMENT '扩展字段1',\n  `ext2` varchar(30) DEFAULT NULL COMMENT '扩展字段2',\n  `ext3` varchar(50) DEFAULT NULL COMMENT '扩展字段3',\n  `breakfast` json DEFAULT NULL COMMENT '早餐信息',\n  `ext4` varchar(80) DEFAULT NULL COMMENT '扩展信息4',\n  `ext5` json DEFAULT NULL COMMENT '扩展信息5',\n  `balance_ext` json DEFAULT NULL COMMENT '用于结算通扩展信息',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `order_inn_code_ind` (`order_code`) USING BTREE,\n  KEY `order_inn_meb_id_ind` (`bk_meb_id`) USING BTREE,\n  KEY `order_inn_chain_id_ind` (`chain_id`),\n  KEY `order_inn_order_state_ind` (`order_state`) USING BTREE,\n  KEY `order_inn_create_time_ind` (`create_time`),\n  KEY `order_inn_orig_arr_date_ind` (`orig_arr_date`),\n  KEY `order_inn_room_type_id` (`room_type_id`),\n  KEY `order_inn_source_type` (`source_type`),\n  KEY `IX_bk_meb_id` (`bk_meb_id`,`room_type_id`,`source_type`),\n  KEY `order_inn_channel_source_type` (`channel_source_type`),\n  KEY `order_inn_city_code` (`city_code`),\n  KEY `order_inn_sid` (`seller_id`),\n  KEY `order_inn_overtime_state` (`overtime_state`),\n  KEY `idx_gs_order_inn` (`update_time`),\n  KEY `order_inn_external_id` (`external_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=20659802 DEFAULT CHARSET=utf8 COMMENT='酒店订单主表（数据基本以客户提交内容）'\n\n## EXPLAIN:\n|id |select_type|table       |partitions|type|possible_keys                                                                                                  |key                 |key_len|ref  |rows|filtered|Extra      |\n|---|-----------|------------|----------|----|---------------------------------------------------------------------------------------------------------------|--------------------|-------|-----|----|--------|-----------|\n|1  |SIMPLE     |gs_order_inn|          |ref |order_inn_meb_id_ind,order_inn_create_time_ind,order_inn_source_type,IX_bk_meb_id,order_inn_channel_source_type|order_inn_meb_id_ind|5      |const|1   |5       |Using where|\n\n## Column Selectivity:\n{\n    \"gs_order_inn\": {\n        \"bk_meb_id\": 60.0000%,\n        \"flag\": 0.2000%,\n        \"create_time\": 0.4000%,\n        \"source_type\": 1.2000%,\n        \"channel_source_type\": 2.0000%,\n        \"country_code\": 12.6000%,\n        \"sale_type\": 0.2000%,\n        \"ext1\": 0.0000%,\n        \"create_oprt\": 0.2000%\n    }\n}\n\n## Original SQL:\nselect\n  COUNT(*)\nfrom\n  gs_order_inn  \nWHERE\n  (\n    bk_meb_id = 1000492\n    and flag = 0\n    and create_time >= '2023-02-29 00:00:00.0'\n    and source_type not in (129, 345)\n    and channel_source_type in (1, 2, 4)\n    and country_code = 'LT'\n    and sale_type <> 3\n    and (\n      ext1 is null\n      or ext1 not in ('02', '03')\n    )\n    and create_oprt = 1200\n  );\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "No performance issues; no indexes need to be created.\n\n**Reasoning:**\nThe EXPLAIN shows the query is already using an appropriate index (`order_inn_meb_id_ind` on `bk_meb_id`) and achieving excellent performance:\n- Type: `ref` indicates efficient index usage\n- Rows: 1 (minimal rows examined)\n- Filtered: 5% (very restrictive WHERE conditions are being applied effectively)\n\nThe query examines only 1 row using the index, then efficiently applies the remaining WHERE clause filters. For a COUNT(*) query, the overhead is minimal as no data retrieval is needed. While some individual columns have low selectivity (flag, create_oprt, sale_type at 0.2%), they don't warrant additional indexing given the already-minimal rows examined. Creating additional composite or covering indexes would add maintenance overhead without meaningful performance gains."
                    }
                ]
            },
            {
                "case_id": "2",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"2\", \"difficulty_level\": \"3\", \"description\": \"业务case-测试深分页\", \"create_table_statements\": \"CREATE TABLE T_DERIVED_RULE (\\n  DRID BIGINT NOT NULL AUTO_INCREMENT COMMENT '派生规则ID',\\n  PROP VARCHAR(100) COMMENT '属性',\\n  RATE_CODE VARCHAR(50) COMMENT '费率代码',\\n  OFFSET1 INT COMMENT '偏移量1',\\n  OFFSET2 INT COMMENT '偏移量2',\\n  UNIT VARCHAR(50) COMMENT '单位',\\n  RADIXPOINT INT COMMENT '小数点',\\n  COUNTRULE VARCHAR(200) COMMENT '计数规则1',\\n  RADIXPOINT2 INT COMMENT '小数点2',\\n  COUNTRULE2 VARCHAR(200) COMMENT '计数规则2',\\n  BASECODE VARCHAR(50) COMMENT '基准代码',\\n  UNIT2 VARCHAR(50) COMMENT '单位2',\\n  FIXEDTAIL2 VARCHAR(50) COMMENT '固定尾部2',\\n  derivative_level INT COMMENT '派生层级',\\n  PRIMARY KEY (DRID)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"sql\": \"select \\n  t1.DRID, \\n  t1.PROP, \\n  t1.RATE_CODE, \\n  t1.OFFSET1, \\n  t1.OFFSET2, \\n  t1.UNIT, \\n  t1.RADIXPOINT, \\n  t1.COUNTRULE, \\n  t1.RADIXPOINT2, \\n  t1.COUNTRULE2, \\n  t1.BASECODE, \\n  t1.UNIT2, \\n  t1.FIXEDTAIL2, \\n  t1.derivative_level \\nfrom \\n  T_DERIVED_RULE t1\\ninner join (\\n  select DRID\\n  from T_DERIVED_RULE\\n  limit 2284000, 500\\n) t2 on t1.DRID = t2.DRID;\", \"columns_selectivity\": \"{\\n    \\\"T_DERIVED_RULE\\\": [\\n        {\\n            \\\"DRID\\\": 100.0000%,\\n            \\\"PROP\\\": 0.0160%,\\n            \\\"RATE_CODE\\\": 0.0160%,\\n            \\\"OFFSET1\\\": 0.5020%,\\n            \\\"OFFSET2\\\": 0.2820%,\\n            \\\"UNIT\\\": 0.0100%,\\n            \\\"RADIXPOINT\\\": 0.0100%,\\n            \\\"COUNTRULE\\\": 0.0120%,\\n            \\\"RADIXPOINT2\\\": 0.0100%,\\n            \\\"COUNTRULE2\\\": 0.0120%,\\n            \\\"BASECODE\\\": 0.0120%,\\n            \\\"UNIT2\\\": 0.0080%,\\n            \\\"FIXEDTAIL2\\\": 0.0100%,\\n            \\\"derivative_level\\\": 0.0100%\\n        }\\n    ]\\n}\", \"explain\": \"|id |select_type|table         |partitions|type  |possible_keys|key    |key_len|ref    |rows   |filtered|Extra      |\\n|---|-----------|--------------|----------|------|-------------|-------|-------|-------|-------|--------|-----------|\\n|1  |PRIMARY    |<derived2>    |          |ALL   |             |       |       |       |895,504|100     |           |\\n|1  |PRIMARY    |t1            |          |eq_ref|PRIMARY      |PRIMARY|8      |t2.DRID|1      |100     |           |\\n|2  |DERIVED    |T_DERIVED_RULE|          |index |             |PRIMARY|8      |       |895,504|100     |Using index|\", \"expected\": \"无法通过创建索引解决SQL性能问题\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE T_DERIVED_RULE (\n  DRID BIGINT NOT NULL AUTO_INCREMENT COMMENT '派生规则ID',\n  PROP VARCHAR(100) COMMENT '属性',\n  RATE_CODE VARCHAR(50) COMMENT '费率代码',\n  OFFSET1 INT COMMENT '偏移量1',\n  OFFSET2 INT COMMENT '偏移量2',\n  UNIT VARCHAR(50) COMMENT '单位',\n  RADIXPOINT INT COMMENT '小数点',\n  COUNTRULE VARCHAR(200) COMMENT '计数规则1',\n  RADIXPOINT2 INT COMMENT '小数点2',\n  COUNTRULE2 VARCHAR(200) COMMENT '计数规则2',\n  BASECODE VARCHAR(50) COMMENT '基准代码',\n  UNIT2 VARCHAR(50) COMMENT '单位2',\n  FIXEDTAIL2 VARCHAR(50) COMMENT '固定尾部2',\n  derivative_level INT COMMENT '派生层级',\n  PRIMARY KEY (DRID)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n## EXPLAIN:\n|id |select_type|table         |partitions|type  |possible_keys|key    |key_len|ref    |rows   |filtered|Extra      |\n|---|-----------|--------------|----------|------|-------------|-------|-------|-------|-------|--------|-----------|\n|1  |PRIMARY    |<derived2>    |          |ALL   |             |       |       |       |895,504|100     |           |\n|1  |PRIMARY    |t1            |          |eq_ref|PRIMARY      |PRIMARY|8      |t2.DRID|1      |100     |           |\n|2  |DERIVED    |T_DERIVED_RULE|          |index |             |PRIMARY|8      |       |895,504|100     |Using index|\n\n## Column Selectivity:\n{\n    \"T_DERIVED_RULE\": [\n        {\n            \"DRID\": 100.0000%,\n            \"PROP\": 0.0160%,\n            \"RATE_CODE\": 0.0160%,\n            \"OFFSET1\": 0.5020%,\n            \"OFFSET2\": 0.2820%,\n            \"UNIT\": 0.0100%,\n            \"RADIXPOINT\": 0.0100%,\n            \"COUNTRULE\": 0.0120%,\n            \"RADIXPOINT2\": 0.0100%,\n            \"COUNTRULE2\": 0.0120%,\n            \"BASECODE\": 0.0120%,\n            \"UNIT2\": 0.0080%,\n            \"FIXEDTAIL2\": 0.0100%,\n            \"derivative_level\": 0.0100%\n        }\n    ]\n}\n\n## Original SQL:\nselect \n  t1.DRID, \n  t1.PROP, \n  t1.RATE_CODE, \n  t1.OFFSET1, \n  t1.OFFSET2, \n  t1.UNIT, \n  t1.RADIXPOINT, \n  t1.COUNTRULE, \n  t1.RADIXPOINT2, \n  t1.COUNTRULE2, \n  t1.BASECODE, \n  t1.UNIT2, \n  t1.FIXEDTAIL2, \n  t1.derivative_level \nfrom \n  T_DERIVED_RULE t1\ninner join (\n  select DRID\n  from T_DERIVED_RULE\n  limit 2284000, 500\n) t2 on t1.DRID = t2.DRID;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "Unable to solve SQL performance issues by creating indexes. Reason: The subquery uses LIMIT with a large offset (2284000, 500) and no WHERE clause or ORDER BY clause, requiring a full table scan that indexes cannot optimize. This is a query design issue requiring pagination logic redesign rather than an indexing solution."
                    }
                ]
            },
            {
                "case_id": "3",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"3\", \"difficulty_level\": \"3\", \"description\": \"业务case-函数列测试\", \"create_table_statements\": \"CREATE TABLE `t_org_architecture` (\\n  `ID` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键-自增长，组织id/部门id',\\n  `EXTERNAL_DEPT_ID` int(11) DEFAULT NULL COMMENT '外部系统的部门id',\\n  `external_code` varchar(64) DEFAULT NULL COMMENT '外部编码',\\n  `code` varchar(64) DEFAULT NULL COMMENT '部门编码: 根据节点所处的层级来生成值，层级调整之后编码会参照上级编码而变;1 2 2 4 4 4 4 4 4 4 (共10级)规则',\\n  `GRADE` varchar(32) DEFAULT NULL COMMENT '层级数: 不同层级数使用不同的规则; 1 2 2 4 4 规则',\\n  `PARENT_ID` int(11) DEFAULT NULL COMMENT '上级节点id，根节点此值为null',\\n  `NAME` varchar(64) DEFAULT NULL COMMENT '名称',\\n  `SEQUENCE` int(11) DEFAULT NULL COMMENT '顺序值，从1开始',\\n  `ROOT` bit(1) DEFAULT b'0' COMMENT '是否是根节点',\\n  `LEAF` bit(1) DEFAULT b'0' COMMENT '是否是(叶节点)末节点',\\n  `STATUS` tinyint(4) DEFAULT '1' COMMENT '状态, 0-无效，1-有效',\\n  `BUSINESS` bit(1) DEFAULT NULL COMMENT '是否开业，0-未开业，1-开业',\\n  `STORE_STATUS` tinyint(4) DEFAULT NULL COMMENT '状态: -1 开发 0 筹建中 1开业  2开业后退筹建  3 开业后解约 5 下线整改 6 售出未下线',\\n  `SOURCE` tinyint(4) DEFAULT NULL COMMENT '1-铂涛，2-锦江，3-维也纳, 4-WeHotel',\\n  `SYNC_OUT` bit(1) DEFAULT b'0' COMMENT '是否从其他系统同步，默认是当前系统维护',\\n  `TYPE` tinyint(4) DEFAULT '0' COMMENT '类型: 1-部门(总部部门) | 2-区域分公司, 3-事业群 | 4-事业部 | 5-分店 6-外部企业 | 7-其他 | 8-战区 | 9-负责人 | 10-品牌BU',\\n  `STORE_ID` varchar(256) DEFAULT NULL COMMENT '分店id，若该节点不是分店则为空',\\n  `STORE_CODE` varchar(32) DEFAULT NULL COMMENT '分店编码，若该节点不是分店则为空',\\n  `BRAND_ID` varchar(16) DEFAULT NULL COMMENT '品牌id',\\n  `BRAND_NAME` varchar(32) DEFAULT NULL COMMENT '品牌名称',\\n  `CITY_CODE` varchar(16) DEFAULT NULL COMMENT '(分店)所在的城市编码',\\n  `CITY_NAME` varchar(32) DEFAULT NULL COMMENT '(分店)所在的城市名称',\\n  `OPERATOR` varchar(64) DEFAULT NULL COMMENT '操作者: 实际用户id或者系统同步更新等',\\n  `principal` varchar(32) DEFAULT NULL COMMENT '负责人',\\n  `REMARK` varchar(256) DEFAULT NULL COMMENT '备注',\\n  `UPDATE_DT` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',\\n  `CREATE_DT` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\\n  `CATEGORY` tinyint(4) unsigned DEFAULT '0' COMMENT '组织分类，0-内部组织，1-外部组织，2-业务组织',\\n  `VIENNA_PMS_CODE` varchar(64) DEFAULT NULL COMMENT '维也纳组织的PMSCODE',\\n  `EXTERNAL_PARENT_DEPT_ID` int(11) DEFAULT NULL COMMENT '外部系统的父部门id',\\n  `external_parent_code` varchar(64) DEFAULT NULL COMMENT '外部父编码',\\n  `FULL_PATH` varchar(512) DEFAULT NULL COMMENT '全路径',\\n  `parent_ids` varchar(512) DEFAULT NULL COMMENT '父ids',\\n  `org_type_id` varchar(64) DEFAULT NULL COMMENT '中国区的组织类型id;中国区ehr同步透传。S000013:BG总部;S000014:BU矩阵;S000015:品牌BU;S000016:BU职能;S000017:门店;S000163:片区;S000164:总部[职能一级部门(中心)];S000165:总部;S000166:区域本部[区域];S000202:储备池;S000214:门店部门;S000255:省区;S000573:区域本部;',\\n  `code_length` int(11) GENERATED ALWAYS AS (length(`code`)) STORED,\\n  PRIMARY KEY (`ID`),\\n  KEY `T_ORG_ARCHITECTURE_IDX_PARENT_ID` (`PARENT_ID`) USING BTREE,\\n  KEY `T_ORG_ARCHITECTURE_IDX_STORE_ID` (`STORE_ID`) USING BTREE,\\n  KEY `T_ORG_ARCHITECTURE_IDX_CODE` (`code`) USING BTREE,\\n  KEY `IDX_EXTERNAL_DEPT_ID` (`EXTERNAL_DEPT_ID`) USING BTREE,\\n  KEY `IDX_EXTERNAL_CODE` (`external_code`) USING BTREE,\\n  KEY `idx_code_length_code` (`code_length`,`code`)\\n) ENGINE=InnoDB AUTO_INCREMENT=10239565 DEFAULT CHARSET=utf8 COMMENT='组织架构表'\", \"sql\": \"SELECT\\n          ID,\\n          `NAME`,\\n          `CODE`,\\n          `TYPE`,\\n          principal,\\n          CATEGORY\\n        FROM\\n          t_org_architecture\\n        WHERE\\n          LEFT('745070056000500070090',  LENGTH(`CODE`)) = `CODE`\\n        GROUP BY\\n          LENGTH(`CODE`);\", \"columns_selectivity\": \"{\\n    \\\"t_org_architecture\\\": [\\n        {\\n            \\\"ID\\\": 100.0000%,\\n            \\\"NAME\\\": 100.0000%,\\n            \\\"CODE\\\": 100.0000%,\\n            \\\"TYPE\\\": 0.0080%,\\n            \\\"principal\\\": 1.6000%,\\n            \\\"CATEGORY\\\": 0.0040%\\n        }\\n    ]\\n}\", \"explain\": \"|id |select_type|table             |partitions|type |possible_keys       |key                 |key_len|ref|rows  |filtered|Extra      |\\n|---|-----------|------------------|----------|-----|--------------------|--------------------|-------|---|------|--------|-----------|\\n|1  |SIMPLE     |t_org_architecture|          |index|idx_code_length_code|idx_code_length_code|200    |   |99,963|10      |Using where|\", \"expected\": \"以下两种情况均可：\\n1. 无法通过索引解决SQL性能问题，函数导致索引失效\\n2. 针对于全索引扫描问题，可以创建覆盖索引，在t_org_architecture表的code_length, code, NAME, TYPE, principal, CATEGORY列添加索引，且要求code_length、code列为左列\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE `t_org_architecture` (\n  `ID` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键-自增长，组织id/部门id',\n  `EXTERNAL_DEPT_ID` int(11) DEFAULT NULL COMMENT '外部系统的部门id',\n  `external_code` varchar(64) DEFAULT NULL COMMENT '外部编码',\n  `code` varchar(64) DEFAULT NULL COMMENT '部门编码: 根据节点所处的层级来生成值，层级调整之后编码会参照上级编码而变;1 2 2 4 4 4 4 4 4 4 (共10级)规则',\n  `GRADE` varchar(32) DEFAULT NULL COMMENT '层级数: 不同层级数使用不同的规则; 1 2 2 4 4 规则',\n  `PARENT_ID` int(11) DEFAULT NULL COMMENT '上级节点id，根节点此值为null',\n  `NAME` varchar(64) DEFAULT NULL COMMENT '名称',\n  `SEQUENCE` int(11) DEFAULT NULL COMMENT '顺序值，从1开始',\n  `ROOT` bit(1) DEFAULT b'0' COMMENT '是否是根节点',\n  `LEAF` bit(1) DEFAULT b'0' COMMENT '是否是(叶节点)末节点',\n  `STATUS` tinyint(4) DEFAULT '1' COMMENT '状态, 0-无效，1-有效',\n  `BUSINESS` bit(1) DEFAULT NULL COMMENT '是否开业，0-未开业，1-开业',\n  `STORE_STATUS` tinyint(4) DEFAULT NULL COMMENT '状态: -1 开发 0 筹建中 1开业  2开业后退筹建  3 开业后解约 5 下线整改 6 售出未下线',\n  `SOURCE` tinyint(4) DEFAULT NULL COMMENT '1-铂涛，2-锦江，3-维也纳, 4-WeHotel',\n  `SYNC_OUT` bit(1) DEFAULT b'0' COMMENT '是否从其他系统同步，默认是当前系统维护',\n  `TYPE` tinyint(4) DEFAULT '0' COMMENT '类型: 1-部门(总部部门) | 2-区域分公司, 3-事业群 | 4-事业部 | 5-分店 6-外部企业 | 7-其他 | 8-战区 | 9-负责人 | 10-品牌BU',\n  `STORE_ID` varchar(256) DEFAULT NULL COMMENT '分店id，若该节点不是分店则为空',\n  `STORE_CODE` varchar(32) DEFAULT NULL COMMENT '分店编码，若该节点不是分店则为空',\n  `BRAND_ID` varchar(16) DEFAULT NULL COMMENT '品牌id',\n  `BRAND_NAME` varchar(32) DEFAULT NULL COMMENT '品牌名称',\n  `CITY_CODE` varchar(16) DEFAULT NULL COMMENT '(分店)所在的城市编码',\n  `CITY_NAME` varchar(32) DEFAULT NULL COMMENT '(分店)所在的城市名称',\n  `OPERATOR` varchar(64) DEFAULT NULL COMMENT '操作者: 实际用户id或者系统同步更新等',\n  `principal` varchar(32) DEFAULT NULL COMMENT '负责人',\n  `REMARK` varchar(256) DEFAULT NULL COMMENT '备注',\n  `UPDATE_DT` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',\n  `CREATE_DT` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `CATEGORY` tinyint(4) unsigned DEFAULT '0' COMMENT '组织分类，0-内部组织，1-外部组织，2-业务组织',\n  `VIENNA_PMS_CODE` varchar(64) DEFAULT NULL COMMENT '维也纳组织的PMSCODE',\n  `EXTERNAL_PARENT_DEPT_ID` int(11) DEFAULT NULL COMMENT '外部系统的父部门id',\n  `external_parent_code` varchar(64) DEFAULT NULL COMMENT '外部父编码',\n  `FULL_PATH` varchar(512) DEFAULT NULL COMMENT '全路径',\n  `parent_ids` varchar(512) DEFAULT NULL COMMENT '父ids',\n  `org_type_id` varchar(64) DEFAULT NULL COMMENT '中国区的组织类型id;中国区ehr同步透传。S000013:BG总部;S000014:BU矩阵;S000015:品牌BU;S000016:BU职能;S000017:门店;S000163:片区;S000164:总部[职能一级部门(中心)];S000165:总部;S000166:区域本部[区域];S000202:储备池;S000214:门店部门;S000255:省区;S000573:区域本部;',\n  `code_length` int(11) GENERATED ALWAYS AS (length(`code`)) STORED,\n  PRIMARY KEY (`ID`),\n  KEY `T_ORG_ARCHITECTURE_IDX_PARENT_ID` (`PARENT_ID`) USING BTREE,\n  KEY `T_ORG_ARCHITECTURE_IDX_STORE_ID` (`STORE_ID`) USING BTREE,\n  KEY `T_ORG_ARCHITECTURE_IDX_CODE` (`code`) USING BTREE,\n  KEY `IDX_EXTERNAL_DEPT_ID` (`EXTERNAL_DEPT_ID`) USING BTREE,\n  KEY `IDX_EXTERNAL_CODE` (`external_code`) USING BTREE,\n  KEY `idx_code_length_code` (`code_length`,`code`)\n) ENGINE=InnoDB AUTO_INCREMENT=10239565 DEFAULT CHARSET=utf8 COMMENT='组织架构表'\n\n## EXPLAIN:\n|id |select_type|table             |partitions|type |possible_keys       |key                 |key_len|ref|rows  |filtered|Extra      |\n|---|-----------|------------------|----------|-----|--------------------|--------------------|-------|---|------|--------|-----------|\n|1  |SIMPLE     |t_org_architecture|          |index|idx_code_length_code|idx_code_length_code|200    |   |99,963|10      |Using where|\n\n## Column Selectivity:\n{\n    \"t_org_architecture\": [\n        {\n            \"ID\": 100.0000%,\n            \"NAME\": 100.0000%,\n            \"CODE\": 100.0000%,\n            \"TYPE\": 0.0080%,\n            \"principal\": 1.6000%,\n            \"CATEGORY\": 0.0040%\n        }\n    ]\n}\n\n## Original SQL:\nSELECT\n          ID,\n          `NAME`,\n          `CODE`,\n          `TYPE`,\n          principal,\n          CATEGORY\n        FROM\n          t_org_architecture\n        WHERE\n          LEFT('745070056000500070090',  LENGTH(`CODE`)) = `CODE`\n        GROUP BY\n          LENGTH(`CODE`);\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "Unable to solve SQL performance issues by creating indexes. Reason: The WHERE clause contains non-sargable function-based conditions (LEFT and LENGTH functions) that cannot be optimized by indexes; the query must evaluate these expressions on every row, requiring a full table/index scan regardless of indexing strategy."
                    }
                ]
            },
            {
                "case_id": "4",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"4\", \"difficulty_level\": \"3\", \"description\": \"业务case-范围列测试\", \"create_table_statements\": \"CREATE TABLE `m_membermain` (\\n  `MebID` int(11) NOT NULL AUTO_INCREMENT,\\n  `MebName` varchar(100) NOT NULL,\\n  `Sex` varchar(20) DEFAULT NULL,\\n  `Birthday` datetime(3) DEFAULT NULL,\\n  `SaleGroupID` int(11) NOT NULL,\\n  `SellerID` int(11) NOT NULL,\\n  `MebType` int(11) DEFAULT NULL,\\n  `Password` varchar(500) DEFAULT NULL,\\n  `State` bit(1) DEFAULT NULL,\\n  `MarkOperation` int(11) DEFAULT NULL,\\n  `MarkOprtionHis` int(11) DEFAULT NULL,\\n  `RegSource` int(11) DEFAULT NULL,\\n  `Remark` varchar(1024) DEFAULT NULL,\\n  `Flag` bit(1) DEFAULT NULL,\\n  `CreateTime` datetime(3) DEFAULT NULL,\\n  `CreateOprt` int(11) DEFAULT NULL,\\n  `LastAccessTime` datetime(3) DEFAULT NULL,\\n  `LastModifyTime` datetime(3) DEFAULT NULL,\\n  `LastModifyOprt` int(11) DEFAULT NULL,\\n  `ActiveCode` varchar(50) DEFAULT NULL,\\n  `FeeFlag` int(11) DEFAULT NULL,\\n  `FirstConsDate` datetime(3) DEFAULT NULL,\\n  `First77ConsDate` datetime(3) DEFAULT NULL,\\n  `ActivityRange` int(11) DEFAULT NULL,\\n  `Photo` mediumblob,\\n  `Auditing` int(11) DEFAULT NULL,\\n  `Freeze` int(11) DEFAULT NULL,\\n  `RecommendMebID` int(11) DEFAULT NULL,\\n  `GiftBoxCount` int(11) DEFAULT NULL,\\n  `Rights` int(11) DEFAULT NULL,\\n  `OwnCorpMebID` int(11) DEFAULT NULL,\\n  `JoinCorpMebTime` datetime(3) DEFAULT NULL,\\n  `CorpMebFlag` int(11) DEFAULT NULL,\\n  `JoinCorpMebOprtID` int(11) DEFAULT NULL,\\n  `_PointFlag` int(11) DEFAULT NULL,\\n  `GroupTypeID` tinyint(3) unsigned DEFAULT NULL,\\n  `CertificateType` smallint(2) DEFAULT NULL,\\n  `CertificateNo` varchar(100) DEFAULT NULL,\\n  `Mobile` varchar(30) DEFAULT NULL,\\n  `Email` varchar(100) DEFAULT NULL,\\n  `JJ_MCCODE` int(11) DEFAULT NULL,\\n  `PT_MEBID` int(11) DEFAULT NULL,\\n  `LastNameEn` varchar(100) DEFAULT NULL,\\n  `FirstNameEn` varchar(100) DEFAULT NULL,\\n  `Nationality` varchar(10) DEFAULT NULL,\\n  `Status` smallint(2) DEFAULT NULL,\\n  `NickName` varchar(100) DEFAULT NULL,\\n  `Avatar` varchar(100) DEFAULT NULL,\\n  `RegistChainId` varchar(50) DEFAULT NULL,\\n  `RegistChainName` varchar(255) DEFAULT NULL,\\n  `RegistBranch` varchar(255) DEFAULT NULL,\\n  `PartnerCardNo` varchar(64) DEFAULT NULL,\\n  `PartnerCardType` int(11) DEFAULT NULL,\\n  `Pioneer` varchar(100) DEFAULT NULL,\\n  `MebLevelStart` date DEFAULT NULL,\\n  `MebLevelEnd` date DEFAULT NULL,\\n  `MebNameNew` varchar(255) DEFAULT NULL COMMENT '会员姓名，UTF-8编码加密',\\n  `authState` smallint(2) DEFAULT NULL,\\n  `primeLevel` int(11) DEFAULT NULL,\\n  `primeLevelStart` datetime(3) DEFAULT NULL,\\n  `primeLevelEnd` datetime(3) DEFAULT NULL,\\n  `viennaLevel` int(11) DEFAULT NULL COMMENT '维也纳等级信息',\\n  `CertificateNoNew` varchar(255) DEFAULT NULL COMMENT '加密证件号',\\n  `idcardAndNotCertified` int(11) DEFAULT NULL COMMENT '维也纳合并会员,存在证件且非实名',\\n  `mebNameSM4` varchar(255) DEFAULT NULL COMMENT '会员姓名SM4加密',\\n  `mobileSM3` varchar(255) DEFAULT NULL COMMENT '会员手机SM3加密,用于检索',\\n  `mobileSM4` varchar(255) DEFAULT NULL COMMENT '会员手机SM4加密',\\n  `certificateNoSM3` varchar(255) DEFAULT NULL COMMENT '会员证件SM3加密',\\n  `certificateNoSM4` varchar(255) DEFAULT NULL COMMENT '会员证件SM4加密',\\n  PRIMARY KEY (`MebID`),\\n  KEY `IX_m_membermain_Mobile` (`Mobile`),\\n  KEY `IX_membermain_CertificateNoNew` (`CertificateNoNew`),\\n  KEY `IX_membermain_CreateTime` (`CreateTime`),\\n  KEY `IX_membermain_JJ_MCCODE` (`JJ_MCCODE`),\\n  KEY `IX_MemberMain_Lastmodifytime` (`LastModifyTime`,`MebType`),\\n  KEY `IX_membermain_Mail` (`Email`),\\n  KEY `IX_membermain_NickName` (`NickName`),\\n  KEY `IX_MemberMain_OwnCorpMebID` (`OwnCorpMebID`,`CorpMebFlag`),\\n  KEY `IX_MemberMain_Seller` (`SellerID`,`SaleGroupID`),\\n  KEY `IX_m_membermain_MobileSM3` (`mobileSM3`),\\n  KEY `IX_m_membermain_MobileSM4` (`mobileSM4`),\\n  KEY `IX_m_membermain_CertificateNoSM3` (`certificateNoSM3`),\\n  KEY `IX_m_membermain_CertificateNoSM4` (`certificateNoSM4`),\\n  KEY `ix_m_membermain_flag` (`Flag`)\\n) ENGINE=InnoDB AUTO_INCREMENT=285380964 DEFAULT CHARSET=utf8mb4\", \"sql\": \"SELECT \\n  count(DISTINCT MebID) \\nFROM \\n  m_membermain mm \\nWHERE \\n  mm.Flag <> 0 \\n  AND mm.MebType IN (1, 2, 5, 6, 8) \\n  AND MebID IS NOT NULL \\n  AND CreateTime >= '2018-01-01 00:00:00' \\n  AND CreateTime < '2018-01-02 00:00:00' \\nLIMIT \\n  1000;\", \"columns_selectivity\": \"{\\n            \\\"CreateTime\\\" : 99.0820%,\\n            \\\"Flag\\\" : 0.0040%,\\n            \\\"MebType\\\" : 0.0120%,\\n            \\\"MebID\\\" : 100.0000%\\n          }\", \"explain\": \"|id |select_type|table|partitions|type |possible_keys                                                                                                                                                                                                                                                                                                                                                                   |key                     |key_len|ref|rows|filtered|Extra                             |\\n|---|-----------|-----|----------|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------|-------|---|----|--------|----------------------------------|\\n|1  |SIMPLE     |mm   |          |range|PRIMARY,IX_m_membermain_Mobile,IX_membermain_CertificateNoNew,IX_membermain_CreateTime,IX_membermain_JJ_MCCODE,IX_MemberMain_Lastmodifytime,IX_membermain_Mail,IX_membermain_NickName,IX_MemberMain_OwnCorpMebID,IX_MemberMain_Seller,IX_m_membermain_MobileSM3,IX_m_membermain_MobileSM4,IX_m_membermain_CertificateNoSM3,IX_m_membermain_CertificateNoSM4,ix_m_membermain_flag|IX_membermain_CreateTime|8      |   |195 |22.5    |Using index condition; Using where|\", \"expected\": \"以下两种情况均可：\\n1. 当前查询性能满足要求，无需创建新索引\\n2. 在m_membermain表的CreateTime，MebType，Flag列创建覆盖索引，要求 CreateTime为最做列，且提示替换现有的IX_membermain_CreateTime索引或提示出与现有索引存在冗余。\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE `m_membermain` (\n  `MebID` int(11) NOT NULL AUTO_INCREMENT,\n  `MebName` varchar(100) NOT NULL,\n  `Sex` varchar(20) DEFAULT NULL,\n  `Birthday` datetime(3) DEFAULT NULL,\n  `SaleGroupID` int(11) NOT NULL,\n  `SellerID` int(11) NOT NULL,\n  `MebType` int(11) DEFAULT NULL,\n  `Password` varchar(500) DEFAULT NULL,\n  `State` bit(1) DEFAULT NULL,\n  `MarkOperation` int(11) DEFAULT NULL,\n  `MarkOprtionHis` int(11) DEFAULT NULL,\n  `RegSource` int(11) DEFAULT NULL,\n  `Remark` varchar(1024) DEFAULT NULL,\n  `Flag` bit(1) DEFAULT NULL,\n  `CreateTime` datetime(3) DEFAULT NULL,\n  `CreateOprt` int(11) DEFAULT NULL,\n  `LastAccessTime` datetime(3) DEFAULT NULL,\n  `LastModifyTime` datetime(3) DEFAULT NULL,\n  `LastModifyOprt` int(11) DEFAULT NULL,\n  `ActiveCode` varchar(50) DEFAULT NULL,\n  `FeeFlag` int(11) DEFAULT NULL,\n  `FirstConsDate` datetime(3) DEFAULT NULL,\n  `First77ConsDate` datetime(3) DEFAULT NULL,\n  `ActivityRange` int(11) DEFAULT NULL,\n  `Photo` mediumblob,\n  `Auditing` int(11) DEFAULT NULL,\n  `Freeze` int(11) DEFAULT NULL,\n  `RecommendMebID` int(11) DEFAULT NULL,\n  `GiftBoxCount` int(11) DEFAULT NULL,\n  `Rights` int(11) DEFAULT NULL,\n  `OwnCorpMebID` int(11) DEFAULT NULL,\n  `JoinCorpMebTime` datetime(3) DEFAULT NULL,\n  `CorpMebFlag` int(11) DEFAULT NULL,\n  `JoinCorpMebOprtID` int(11) DEFAULT NULL,\n  `_PointFlag` int(11) DEFAULT NULL,\n  `GroupTypeID` tinyint(3) unsigned DEFAULT NULL,\n  `CertificateType` smallint(2) DEFAULT NULL,\n  `CertificateNo` varchar(100) DEFAULT NULL,\n  `Mobile` varchar(30) DEFAULT NULL,\n  `Email` varchar(100) DEFAULT NULL,\n  `JJ_MCCODE` int(11) DEFAULT NULL,\n  `PT_MEBID` int(11) DEFAULT NULL,\n  `LastNameEn` varchar(100) DEFAULT NULL,\n  `FirstNameEn` varchar(100) DEFAULT NULL,\n  `Nationality` varchar(10) DEFAULT NULL,\n  `Status` smallint(2) DEFAULT NULL,\n  `NickName` varchar(100) DEFAULT NULL,\n  `Avatar` varchar(100) DEFAULT NULL,\n  `RegistChainId` varchar(50) DEFAULT NULL,\n  `RegistChainName` varchar(255) DEFAULT NULL,\n  `RegistBranch` varchar(255) DEFAULT NULL,\n  `PartnerCardNo` varchar(64) DEFAULT NULL,\n  `PartnerCardType` int(11) DEFAULT NULL,\n  `Pioneer` varchar(100) DEFAULT NULL,\n  `MebLevelStart` date DEFAULT NULL,\n  `MebLevelEnd` date DEFAULT NULL,\n  `MebNameNew` varchar(255) DEFAULT NULL COMMENT '会员姓名，UTF-8编码加密',\n  `authState` smallint(2) DEFAULT NULL,\n  `primeLevel` int(11) DEFAULT NULL,\n  `primeLevelStart` datetime(3) DEFAULT NULL,\n  `primeLevelEnd` datetime(3) DEFAULT NULL,\n  `viennaLevel` int(11) DEFAULT NULL COMMENT '维也纳等级信息',\n  `CertificateNoNew` varchar(255) DEFAULT NULL COMMENT '加密证件号',\n  `idcardAndNotCertified` int(11) DEFAULT NULL COMMENT '维也纳合并会员,存在证件且非实名',\n  `mebNameSM4` varchar(255) DEFAULT NULL COMMENT '会员姓名SM4加密',\n  `mobileSM3` varchar(255) DEFAULT NULL COMMENT '会员手机SM3加密,用于检索',\n  `mobileSM4` varchar(255) DEFAULT NULL COMMENT '会员手机SM4加密',\n  `certificateNoSM3` varchar(255) DEFAULT NULL COMMENT '会员证件SM3加密',\n  `certificateNoSM4` varchar(255) DEFAULT NULL COMMENT '会员证件SM4加密',\n  PRIMARY KEY (`MebID`),\n  KEY `IX_m_membermain_Mobile` (`Mobile`),\n  KEY `IX_membermain_CertificateNoNew` (`CertificateNoNew`),\n  KEY `IX_membermain_CreateTime` (`CreateTime`),\n  KEY `IX_membermain_JJ_MCCODE` (`JJ_MCCODE`),\n  KEY `IX_MemberMain_Lastmodifytime` (`LastModifyTime`,`MebType`),\n  KEY `IX_membermain_Mail` (`Email`),\n  KEY `IX_membermain_NickName` (`NickName`),\n  KEY `IX_MemberMain_OwnCorpMebID` (`OwnCorpMebID`,`CorpMebFlag`),\n  KEY `IX_MemberMain_Seller` (`SellerID`,`SaleGroupID`),\n  KEY `IX_m_membermain_MobileSM3` (`mobileSM3`),\n  KEY `IX_m_membermain_MobileSM4` (`mobileSM4`),\n  KEY `IX_m_membermain_CertificateNoSM3` (`certificateNoSM3`),\n  KEY `IX_m_membermain_CertificateNoSM4` (`certificateNoSM4`),\n  KEY `ix_m_membermain_flag` (`Flag`)\n) ENGINE=InnoDB AUTO_INCREMENT=285380964 DEFAULT CHARSET=utf8mb4\n\n## EXPLAIN:\n|id |select_type|table|partitions|type |possible_keys                                                                                                                                                                                                                                                                                                                                                                   |key                     |key_len|ref|rows|filtered|Extra                             |\n|---|-----------|-----|----------|-----|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------|-------|---|----|--------|----------------------------------|\n|1  |SIMPLE     |mm   |          |range|PRIMARY,IX_m_membermain_Mobile,IX_membermain_CertificateNoNew,IX_membermain_CreateTime,IX_membermain_JJ_MCCODE,IX_MemberMain_Lastmodifytime,IX_membermain_Mail,IX_membermain_NickName,IX_MemberMain_OwnCorpMebID,IX_MemberMain_Seller,IX_m_membermain_MobileSM3,IX_m_membermain_MobileSM4,IX_m_membermain_CertificateNoSM3,IX_m_membermain_CertificateNoSM4,ix_m_membermain_flag|IX_membermain_CreateTime|8      |   |195 |22.5    |Using index condition; Using where|\n\n## Column Selectivity:\n{\n            \"CreateTime\" : 99.0820%,\n            \"Flag\" : 0.0040%,\n            \"MebType\" : 0.0120%,\n            \"MebID\" : 100.0000%\n          }\n\n## Original SQL:\nSELECT \n  count(DISTINCT MebID) \nFROM \n  m_membermain mm \nWHERE \n  mm.Flag <> 0 \n  AND mm.MebType IN (1, 2, 5, 6, 8) \n  AND MebID IS NOT NULL \n  AND CreateTime >= '2018-01-01 00:00:00' \n  AND CreateTime < '2018-01-02 00:00:00' \nLIMIT \n  1000;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX IX_membermain_CreateTime_Flag_MebType_MebID ON m_membermain(CreateTime, Flag, MebType, MebID); Reason: Covering index - Includes all columns needed for filtering (CreateTime, Flag, MebType) and the result column (MebID), enabling the query to be entirely satisfied by the index without table row access. This eliminates row lookups and allows all WHERE conditions to be evaluated within the index structure, reducing I/O operations and improving performance."
                    }
                ]
            },
            {
                "case_id": "5",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"5\", \"difficulty_level\": \"3\", \"description\": \"业务case-索引重复测试\", \"create_table_statements\": \"CREATE TABLE `hotel_price_adjustment` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键自增ID',\\n  `apply_id` varchar(50) DEFAULT NULL COMMENT '申请ID',\\n  `brand_code` varchar(50) DEFAULT NULL COMMENT '品牌编码',\\n  `brand_name` varchar(255) DEFAULT NULL COMMENT '品牌名称',\\n  `hotel_code` varchar(50) DEFAULT NULL COMMENT '酒店编码',\\n  `hotel_name` varchar(255) DEFAULT NULL COMMENT '酒店名称',\\n  `currency` varchar(50) DEFAULT NULL COMMENT '货币编码',\\n  `category` varchar(50) DEFAULT NULL COMMENT '房价码分类',\\n  `rate_code` varchar(50) DEFAULT NULL COMMENT '房价码编码',\\n  `rate_name` varchar(255) DEFAULT NULL COMMENT '房价码名称',\\n  `price_array_type` varchar(50) DEFAULT NULL COMMENT '价格序列类别,P:百分比,A:固定值,V:固定加减值(只针对priceArray2进行计算)',\\n  `price_array_code` varchar(50) DEFAULT '' COMMENT '价格序列对应的基础房价代码',\\n  `price_array_sequence` varchar(50) DEFAULT '' COMMENT '价格序列计算方式,1:先算百分比,后算加法,2:先算加法,后算百分比(1:先乘后加,2:先加后乘)',\\n  `price_array` decimal(10,4) DEFAULT NULL COMMENT '价格序列,百分比房价序列数值',\\n  `price_array2` decimal(10,4) DEFAULT NULL COMMENT '价格序列,加法数值',\\n  `date_segment` varchar(500) DEFAULT NULL COMMENT '[开始日期,结束日期],多个日期段',\\n  `weeks` varchar(50) DEFAULT NULL COMMENT '适用星期[\\\"1\\\"星期天;\\\"2\\\"星期一;\\\"3\\\"星期二;\\\"4\\\"星期三;\\\"5\\\"星期四;\\\"6\\\"星期五;\\\"7\\\"星期六]',\\n  `brand_maximum_price` decimal(20,4) DEFAULT NULL,\\n  `brand_minimum_price` decimal(20,4) DEFAULT NULL,\\n  `room_code` varchar(50) DEFAULT NULL COMMENT '房型编码',\\n  `room_name` varchar(255) DEFAULT NULL COMMENT '房型名称',\\n  `room_standard_price` decimal(20,4) DEFAULT NULL,\\n  `pre_adjustment_price` decimal(20,4) DEFAULT NULL,\\n  `adjusted_price` decimal(20,4) DEFAULT NULL,\\n  `price_adjustment_range` decimal(20,4) DEFAULT NULL,\\n  `occupancy` int(255) DEFAULT NULL COMMENT '计划级房量',\\n  `status` varchar(10) DEFAULT NULL COMMENT '计划级房态',\\n  `reason` varchar(500) DEFAULT NULL COMMENT '调价原因',\\n  `approve_status` char(2) DEFAULT NULL COMMENT '审批状态,0:免审,1:待审核,2:审核中,3:通过,4:驳回,5关闭',\\n  `approve_reason` varchar(500) DEFAULT NULL COMMENT '审批原因',\\n  `operator` varchar(50) DEFAULT NULL COMMENT '操作人',\\n  `create_time` datetime DEFAULT NULL COMMENT '创建时间',\\n  `update_time` datetime DEFAULT NULL COMMENT '更新时间',\\n  `CREATE_USER_ID` varchar(16) DEFAULT NULL COMMENT '创建人ID(统一认证的userId)',\\n  `ROOM_CODES` text COMMENT '申请的所有房型代码,使用英文逗号分割',\\n  `extra_rate` decimal(10,4) DEFAULT NULL COMMENT '统一加价',\\n  PRIMARY KEY (`id`),\\n  KEY `ix_hotel_price_adjustment_01` (`brand_code`,`hotel_code`,`rate_code`,`room_code`,`approve_status`),\\n  KEY `ix_hotel_price_adjustment_04` (`CREATE_USER_ID`,`hotel_code`,`apply_id`),\\n  KEY `ix_hotel_price_adjustment_05` (`apply_id`),\\n  KEY `ix_hotel_price_adjustment_06` (`update_time`,`hotel_code`,`CREATE_USER_ID`,`apply_id`),\\n  KEY `ix_hotel_price_adjustment_07` (`hotel_code`,`create_time`,`apply_id`),\\n  KEY `ix_hotel_price_adjustment_08` (`CREATE_USER_ID`,`create_time`,`apply_id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=9143968 DEFAULT CHARSET=utf8mb4 COMMENT='调价-审批流程主表';\\n\\nCREATE TABLE `price_adjustment_audit_job` (\\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\\n  `apply_id` varchar(50) DEFAULT NULL COMMENT '申请ID',\\n  `sequence` tinyint(4) DEFAULT NULL COMMENT '审批阶段1：一审，2：二审，3：三审，4：四审',\\n  `stage_Type` tinyint(4) DEFAULT NULL COMMENT '触发类型，1：必须审核，2：满足条件审核,3：创建人审核',\\n  `stage_status` tinyint(4) DEFAULT NULL COMMENT '当前审批阶段状态，0:免审，1：待审核，2：审核中，3：通过，4：驳回，5关闭',\\n  `audit_Type` tinyint(4) DEFAULT NULL COMMENT '审核类型，1：所有人都需要审核，2：只需一人审核，3：所有岗位审核，4：只需一个岗位审核',\\n  `job_id` varchar(32) DEFAULT NULL COMMENT '岗位ID',\\n  `create_time` datetime DEFAULT NULL COMMENT '创建时间',\\n  `update_time` datetime DEFAULT NULL COMMENT '更新时间',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  KEY `IX_APPLY_ID` (`apply_id`) USING BTREE,\\n  KEY `ix_price_adjustment_audit_job_01` (`job_id`,`apply_id`)\\n) ENGINE=InnoDB AUTO_INCREMENT=489715 DEFAULT CHARSET=utf8mb4 COMMENT='审批记录与用户岗位关系表';\", \"sql\": \"SELECT \\n  COUNT(DISTINCT id) \\nFROM \\n  ( \\n    SELECT id \\n    FROM hotel_price_adjustment pa1 \\n    WHERE HOTEL_CODE IN ('6199', 'JJXRSEH802967') \\n    UNION \\n    SELECT id \\n    FROM hotel_price_adjustment pa1 \\n    WHERE CREATE_USER_ID = '289865' \\n  ) AS temp;\", \"columns_selectivity\": \"{\\n    \\\"hotel_price_adjustment\\\": [\\n        {\\n            \\\"HOTEL_CODE\\\": 5.0000%,\\n            \\\"id\\\": 100.0000%,\\n            \\\"CREATE_USER_ID\\\": 2.5020%\\n        }\\n    ]\\n}\", \"explain\": \"|id |select_type |table     |partitions|type |possible_keys                                            |key                         |key_len|ref  |rows|filtered|Extra                   |\\n|---|------------|----------|----------|-----|---------------------------------------------------------|----------------------------|-------|-----|----|--------|------------------------|\\n|1  |PRIMARY     |<derived2>|          |ALL  |                                                         |                            |       |     |70  |100     |                        |\\n|2  |DERIVED     |pa1       |          |range|ix_hotel_price_adjustment_07                             |ix_hotel_price_adjustment_07|203    |     |41  |100     |Using where; Using index|\\n|3  |UNION       |pa1       |          |ref  |ix_hotel_price_adjustment_04,ix_hotel_price_adjustment_08|ix_hotel_price_adjustment_08|67     |const|29  |100     |Using index             |\\n|   |UNION RESULT|<union2,3>|          |ALL  |                                                         |                            |       |     |    |        |Using temporary         |\", \"expected\": \"当前查询性能满足要求，无需创建新索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE `hotel_price_adjustment` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键自增ID',\n  `apply_id` varchar(50) DEFAULT NULL COMMENT '申请ID',\n  `brand_code` varchar(50) DEFAULT NULL COMMENT '品牌编码',\n  `brand_name` varchar(255) DEFAULT NULL COMMENT '品牌名称',\n  `hotel_code` varchar(50) DEFAULT NULL COMMENT '酒店编码',\n  `hotel_name` varchar(255) DEFAULT NULL COMMENT '酒店名称',\n  `currency` varchar(50) DEFAULT NULL COMMENT '货币编码',\n  `category` varchar(50) DEFAULT NULL COMMENT '房价码分类',\n  `rate_code` varchar(50) DEFAULT NULL COMMENT '房价码编码',\n  `rate_name` varchar(255) DEFAULT NULL COMMENT '房价码名称',\n  `price_array_type` varchar(50) DEFAULT NULL COMMENT '价格序列类别,P:百分比,A:固定值,V:固定加减值(只针对priceArray2进行计算)',\n  `price_array_code` varchar(50) DEFAULT '' COMMENT '价格序列对应的基础房价代码',\n  `price_array_sequence` varchar(50) DEFAULT '' COMMENT '价格序列计算方式,1:先算百分比,后算加法,2:先算加法,后算百分比(1:先乘后加,2:先加后乘)',\n  `price_array` decimal(10,4) DEFAULT NULL COMMENT '价格序列,百分比房价序列数值',\n  `price_array2` decimal(10,4) DEFAULT NULL COMMENT '价格序列,加法数值',\n  `date_segment` varchar(500) DEFAULT NULL COMMENT '[开始日期,结束日期],多个日期段',\n  `weeks` varchar(50) DEFAULT NULL COMMENT '适用星期[\"1\"星期天;\"2\"星期一;\"3\"星期二;\"4\"星期三;\"5\"星期四;\"6\"星期五;\"7\"星期六]',\n  `brand_maximum_price` decimal(20,4) DEFAULT NULL,\n  `brand_minimum_price` decimal(20,4) DEFAULT NULL,\n  `room_code` varchar(50) DEFAULT NULL COMMENT '房型编码',\n  `room_name` varchar(255) DEFAULT NULL COMMENT '房型名称',\n  `room_standard_price` decimal(20,4) DEFAULT NULL,\n  `pre_adjustment_price` decimal(20,4) DEFAULT NULL,\n  `adjusted_price` decimal(20,4) DEFAULT NULL,\n  `price_adjustment_range` decimal(20,4) DEFAULT NULL,\n  `occupancy` int(255) DEFAULT NULL COMMENT '计划级房量',\n  `status` varchar(10) DEFAULT NULL COMMENT '计划级房态',\n  `reason` varchar(500) DEFAULT NULL COMMENT '调价原因',\n  `approve_status` char(2) DEFAULT NULL COMMENT '审批状态,0:免审,1:待审核,2:审核中,3:通过,4:驳回,5关闭',\n  `approve_reason` varchar(500) DEFAULT NULL COMMENT '审批原因',\n  `operator` varchar(50) DEFAULT NULL COMMENT '操作人',\n  `create_time` datetime DEFAULT NULL COMMENT '创建时间',\n  `update_time` datetime DEFAULT NULL COMMENT '更新时间',\n  `CREATE_USER_ID` varchar(16) DEFAULT NULL COMMENT '创建人ID(统一认证的userId)',\n  `ROOM_CODES` text COMMENT '申请的所有房型代码,使用英文逗号分割',\n  `extra_rate` decimal(10,4) DEFAULT NULL COMMENT '统一加价',\n  PRIMARY KEY (`id`),\n  KEY `ix_hotel_price_adjustment_01` (`brand_code`,`hotel_code`,`rate_code`,`room_code`,`approve_status`),\n  KEY `ix_hotel_price_adjustment_04` (`CREATE_USER_ID`,`hotel_code`,`apply_id`),\n  KEY `ix_hotel_price_adjustment_05` (`apply_id`),\n  KEY `ix_hotel_price_adjustment_06` (`update_time`,`hotel_code`,`CREATE_USER_ID`,`apply_id`),\n  KEY `ix_hotel_price_adjustment_07` (`hotel_code`,`create_time`,`apply_id`),\n  KEY `ix_hotel_price_adjustment_08` (`CREATE_USER_ID`,`create_time`,`apply_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=9143968 DEFAULT CHARSET=utf8mb4 COMMENT='调价-审批流程主表';\n\nCREATE TABLE `price_adjustment_audit_job` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `apply_id` varchar(50) DEFAULT NULL COMMENT '申请ID',\n  `sequence` tinyint(4) DEFAULT NULL COMMENT '审批阶段1：一审，2：二审，3：三审，4：四审',\n  `stage_Type` tinyint(4) DEFAULT NULL COMMENT '触发类型，1：必须审核，2：满足条件审核,3：创建人审核',\n  `stage_status` tinyint(4) DEFAULT NULL COMMENT '当前审批阶段状态，0:免审，1：待审核，2：审核中，3：通过，4：驳回，5关闭',\n  `audit_Type` tinyint(4) DEFAULT NULL COMMENT '审核类型，1：所有人都需要审核，2：只需一人审核，3：所有岗位审核，4：只需一个岗位审核',\n  `job_id` varchar(32) DEFAULT NULL COMMENT '岗位ID',\n  `create_time` datetime DEFAULT NULL COMMENT '创建时间',\n  `update_time` datetime DEFAULT NULL COMMENT '更新时间',\n  PRIMARY KEY (`id`) USING BTREE,\n  KEY `IX_APPLY_ID` (`apply_id`) USING BTREE,\n  KEY `ix_price_adjustment_audit_job_01` (`job_id`,`apply_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=489715 DEFAULT CHARSET=utf8mb4 COMMENT='审批记录与用户岗位关系表';\n\n## EXPLAIN:\n|id |select_type |table     |partitions|type |possible_keys                                            |key                         |key_len|ref  |rows|filtered|Extra                   |\n|---|------------|----------|----------|-----|---------------------------------------------------------|----------------------------|-------|-----|----|--------|------------------------|\n|1  |PRIMARY     |<derived2>|          |ALL  |                                                         |                            |       |     |70  |100     |                        |\n|2  |DERIVED     |pa1       |          |range|ix_hotel_price_adjustment_07                             |ix_hotel_price_adjustment_07|203    |     |41  |100     |Using where; Using index|\n|3  |UNION       |pa1       |          |ref  |ix_hotel_price_adjustment_04,ix_hotel_price_adjustment_08|ix_hotel_price_adjustment_08|67     |const|29  |100     |Using index             |\n|   |UNION RESULT|<union2,3>|          |ALL  |                                                         |                            |       |     |    |        |Using temporary         |\n\n## Column Selectivity:\n{\n    \"hotel_price_adjustment\": [\n        {\n            \"HOTEL_CODE\": 5.0000%,\n            \"id\": 100.0000%,\n            \"CREATE_USER_ID\": 2.5020%\n        }\n    ]\n}\n\n## Original SQL:\nSELECT \n  COUNT(DISTINCT id) \nFROM \n  ( \n    SELECT id \n    FROM hotel_price_adjustment pa1 \n    WHERE HOTEL_CODE IN ('6199', 'JJXRSEH802967') \n    UNION \n    SELECT id \n    FROM hotel_price_adjustment pa1 \n    WHERE CREATE_USER_ID = '289865' \n  ) AS temp;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "No performance issues; no indexes need to be created.\n\n**Reasoning:** The EXPLAIN plan shows efficient index usage for both subqueries: the first subquery uses a range scan on `ix_hotel_price_adjustment_07` (hotel_code indexed, 41 rows), and the second uses a ref lookup on `ix_hotel_price_adjustment_08` (CREATE_USER_ID indexed, 29 rows). Both queries return small result sets and are already using appropriate composite indexes. The UNION result of 70 rows is scanned with ALL type, but this is negligible overhead given the small size. The existing index strategy is optimal for this query structure, and no additional indexes would meaningfully improve performance."
                    }
                ]
            },
            {
                "case_id": "6",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"6\", \"difficulty_level\": \"3\", \"description\": \"业务case-关联列隐式转换测试（字符集）\", \"create_table_statements\": \"CREATE TABLE `inn_inns` (\\n  `ID` varchar(64) NOT NULL COMMENT ' 酒店ID和第三方酒店ID',\\n  `CHAIN_CODE` varchar(64) DEFAULT NULL COMMENT '用于兼容7天酒店ID,所以保留',\\n  `S_CODE` varchar(32) DEFAULT NULL COMMENT '系统自维护酒店编码，格式：品牌编号+0000001，例如：7770000001(待定),通过编号表生成',\\n  `BUSINESS_TYPE` tinyint(4) DEFAULT NULL COMMENT '[BUSSINIESS_TYPE] 0自营店，1管理店，2加盟店，3标准店  4合作店',\\n  `OFFICE_CENTER_TYPE` tinyint(4) DEFAULT NULL,\\n  `SUPPORT_PAYMENT_MODE` varchar(512) DEFAULT NULL,\\n  `COMPANY_NAME` varchar(128) DEFAULT NULL COMMENT '针对合作酒店',\\n  `FORENSIC_CODE` varchar(128) DEFAULT NULL,\\n  `STATUS` tinyint(4) DEFAULT NULL COMMENT '0 营业中 1 停业 2 筹建',\\n  `INN_TYPE` varchar(32) DEFAULT NULL COMMENT '[INN_TYPE] 100经济型酒店 101精品商务酒店 102景区度假酒店 103主题特色酒店 104民俗风情酒店 ',\\n  `STAR_TYPE` tinyint(4) DEFAULT NULL COMMENT '[STAR_TYPE] 0 一星 1 二星 3 三星',\\n  `RECOMMAND_STAR_TYPE` tinyint(4) DEFAULT NULL,\\n  `MEDAL_TYPE` tinyint(4) DEFAULT NULL,\\n  `START_FLOOR` varchar(32) DEFAULT NULL,\\n  `END_FLOOR` varchar(32) DEFAULT NULL,\\n  `TOTAL_ROOM` int(11) DEFAULT NULL,\\n  `SYS_COUNTRY_ID` varchar(64) DEFAULT NULL,\\n  `SYS_CITY_ID` varchar(64) DEFAULT NULL,\\n  `SECOND_SYS_CITY_ID` varchar(64) DEFAULT NULL,\\n  `SYS_DISTRICT_ID` varchar(64) DEFAULT NULL,\\n  `SYS_BRAND_ID` varchar(64) DEFAULT NULL,\\n  `HOTEL_MANAGE` varchar(256) DEFAULT NULL,\\n  `INN_PHONE` varchar(128) DEFAULT NULL,\\n  `INN_EMAIL` varchar(256) DEFAULT NULL,\\n  `INN_FAX` varchar(128) DEFAULT NULL,\\n  `SUPPORT_PAY_ONLINE` tinyint(4) DEFAULT NULL COMMENT '[YES_OR_NO] 1 是 0 否',\\n  `PULL_ROOM_FLAG` tinyint(4) DEFAULT NULL COMMENT '是否拉取PMS房间信息[0 否  1是]',\\n  `BOOK_FLAG` tinyint(4) DEFAULT '0' COMMENT '[YES_OR_NO] 1 是 0 否',\\n  `SUPPORT_FOREIGN_GUEST` tinyint(4) DEFAULT NULL,\\n  `VALUE_ADDED_INVOICE` tinyint(4) DEFAULT NULL,\\n  `OPEN_DATE` date DEFAULT NULL,\\n  `CLOSE_DATE` date DEFAULT NULL,\\n  `IFSYNC` tinyint(4) DEFAULT '0' COMMENT '1不同步，其他同步',\\n  `SALE_DEPART_ID` varchar(32) DEFAULT NULL,\\n  `MAIN_PERSON` varchar(64) DEFAULT NULL,\\n  `CHINESE_INFO_FULL` tinyint(4) DEFAULT '0',\\n  `ENGLISH_INFO_FULL` tinyint(4) DEFAULT '0',\\n  `AUDIT_STATUS` tinyint(4) DEFAULT '0',\\n  `MAIN_PHONE` varchar(64) DEFAULT NULL,\\n  `MAIN_EMAIL` varchar(255) DEFAULT NULL,\\n  `DECORATION_DATE` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '装修日期',\\n  `ELEVATOR_NUM` int(11) DEFAULT NULL COMMENT '电梯数量',\\n  `MEETING_ROOM_NUM` int(11) DEFAULT NULL COMMENT '会议室数量',\\n  `MEETING_ROOM_ACCOMMODATES` int(11) DEFAULT NULL COMMENT '会议室可容纳人数',\\n  `NON_SMOKING_ROOMS_NUM` int(11) DEFAULT NULL COMMENT '无烟房数量',\\n  `MAX_CHECK_IN` int(11) DEFAULT NULL COMMENT '酒店最大入住人数',\\n  `LAST_RETENTION_TIME` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '酒店最晚保留时间(非担保)',\\n  `SETTLEMENT_CURRENCY` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '酒店结算货币',\\n  `PANORAMA_IMAGE` varchar(512) CHARACTER SET utf8 DEFAULT NULL COMMENT '全景图地址',\\n  `ZIP_CODE` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '酒店邮编',\\n  `CHECK_IN_TIME` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '最早入住时间',\\n  `CHECK_OUT_TIME` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '最晚离店时间',\\n  `TIME_ZONE` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '时区',\\n  `PETS` tinyint(4) DEFAULT '0' COMMENT '是否允许携带宠物 0 否  1是',\\n  `ALLOW_MINORS` tinyint(4) DEFAULT '0' COMMENT '是否允许未成年人人单独入住 0 否  1是',\\n  `INN_LEVEL` int(11) DEFAULT NULL COMMENT '酒店级别',\\n  `VALID` tinyint(4) DEFAULT '1' COMMENT '[YES_OR_NO] 1 是 0 否',\\n  `EXTEND` longtext,\\n  `CREATE_DATE_TIME` datetime DEFAULT NULL,\\n  `UPDATE_DATE_TIME` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n  `CHOOSE_ROOM_SWITCH` tinyint(4) DEFAULT '0' COMMENT '选房开关[0否 1是]',\\n  `SMART_HOTEL` tinyint(4) DEFAULT '0' COMMENT '智能酒店标签 0 否 1是',\\n  `BOOKING_INVOICE` tinyint(4) DEFAULT '0' COMMENT '预约发票 0关 1开',\\n  `INVOICE_TYPE` varchar(64) DEFAULT '0' COMMENT '发票类型 0普通发票 1增值税普通发票 2增值税专用发票，可以多选，通过逗号分隔',\\n  `HOME_LINK` varchar(256) DEFAULT NULL COMMENT '主页链接',\\n  `SMOKING` varchar(32) DEFAULT '0',\\n  `CRS_CODE` varchar(64) DEFAULT NULL COMMENT 'wehotel酒店编号在第三方酒店系统中的编号',\\n  `PMS_CODE` varchar(64) DEFAULT NULL COMMENT 'JREZ系统中对接的PMS编码，仅供BI使用',\\n  `ROOM_SWITCH_FLAG` tinyint(4) DEFAULT '0' COMMENT '选房开关标识 0自动 1手动',\\n  `MORNING_ROOM` tinyint(4) DEFAULT '1' COMMENT '是否可预订凌晨房 0否 1是',\\n  `SCAN_CHECK_IN` tinyint(4) DEFAULT '0' COMMENT '是否支持扫码入住 0 否 1是',\\n  `IS_SUPPORT_GUIDE_DOG_POLICY` tinyint(4) DEFAULT '0' COMMENT '是否支持导盲犬政策[0 不支持，1 支持]',\\n  `DIAMOND_RATING` tinyint(4) DEFAULT NULL COMMENT '准星级：0 无星 1 准一星；2 准二星；3 准三星；4 准四星；5 准五星',\\n  `VIDEO_URL` varchar(256) DEFAULT NULL COMMENT '酒店介绍视频链接',\\n  `IS_PRIVILEGE_MEMBER_HOTEL` tinyint(4) DEFAULT '0' COMMENT '是否尊享会会员酒店 0否 1是',\\n  `REGIONAL_COMPANY` varchar(64) DEFAULT NULL COMMENT '区域公司',\\n  `MANAGEMENT_COMPANY` varchar(64) DEFAULT NULL COMMENT '管理公司',\\n  `IS_PERFECT_ENGLISH` tinyint(4) DEFAULT '0' COMMENT '是否完善英文要素：0 否 1 是',\\n  `IS_BREAKFAST` tinyint(4) DEFAULT '0' COMMENT '是否提供早餐[0 否,1 是]',\\n  `INN_INFO_INTEGRITY` varchar(64) DEFAULT NULL COMMENT '酒店信息完整度',\\n  `IS_SESAME_CREDIT` tinyint(4) DEFAULT '0' COMMENT '是否支持芝麻信用支付[0 否，1 是] ',\\n  `IS_DEPOSIT` tinyint(4) DEFAULT '0' COMMENT '是否收押金[0 否，1 是]',\\n  `DEPOSIT_AMOUNT` varchar(64) DEFAULT '0' COMMENT '押金的金额',\\n  `UPGRADE_TYPE` tinyint(4) DEFAULT '0' COMMENT '升级类型[0 无，1 新优品，2 新IU]',\\n  `TRANSFER_PROJECT_ID` varchar(128) DEFAULT NULL COMMENT '关联项目编码（转品牌转前项目编码）',\\n  `TRANSFER_INN_ID` varchar(128) DEFAULT NULL COMMENT '酒店编码（转品牌转前酒店编码）',\\n  `TRANSFER_INN_NAME_CN` varchar(512) DEFAULT NULL COMMENT '酒店名称（转品牌转前酒店名称）',\\n  `PROJECT_ID` varchar(128) DEFAULT NULL COMMENT '项目编码(铂涛酒店)',\\n  `e_key` varchar(8) DEFAULT 'off' COMMENT '智能钥匙开关：on/off',\\n  `IS_JIN_REWARDS` tinyint(4) DEFAULT '0' COMMENT '是否豪华经典酒店标识(原 锦好客酒店标识)[0 否；1 是]',\\n  `PMS_PIPE` varchar(64) DEFAULT NULL COMMENT 'pms通道',\\n  `PMS_FLAG` tinyint(4) DEFAULT NULL COMMENT '是否pms接口酒店',\\n  `PMS_STATUS` tinyint(4) DEFAULT NULL COMMENT 'pms状态',\\n  `PMS_VERSION` varchar(64) DEFAULT NULL COMMENT 'pms版本',\\n  `CONTACT_NAME` varchar(64) DEFAULT '' COMMENT '联系人姓名',\\n  `CONTACT_PHONE` varchar(64) DEFAULT '' COMMENT '联系人电话',\\n  `ORG_ARCH_ID` varchar(64) DEFAULT '' COMMENT '公司区域标签(组织ID)',\\n  `ONLINE_TIME` datetime DEFAULT NULL COMMENT '直连上线时间',\\n  `DOWNLINE_TIME` datetime DEFAULT NULL COMMENT '直连下线时间',\\n  `LOW_LIMIT` varchar(32) DEFAULT NULL COMMENT '最低价格，安全性保护，防止设置房价过低，而遭受损失',\\n  `IS_CHINA_ZONE_HOTEL` tinyint(4) DEFAULT '0' COMMENT '是否中国区酒店标识[0 否；1 是]',\\n  `POINT_CHARGING_MODE` tinyint(4) DEFAULT NULL COMMENT '积分收费模式[1=积分收费、2=以房抵费、0=无]',\\n  `POINT_CHARGING_MODE_UPDATE_DATE` datetime DEFAULT NULL COMMENT '积分收费模式修改日期',\\n  `POINT_CHARGING_MODE_VALID_DATE` datetime DEFAULT NULL COMMENT '积分收费模式生效日期 ',\\n  `CHILD_FREE_AGE` varchar(32) DEFAULT NULL COMMENT '儿童免费年龄',\\n  `HOTEL_THEME_TYPE` varchar(32) DEFAULT NULL COMMENT '酒店主题类型',\\n  `MEETING_ROOM` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否有会议室  1-有  0-无',\\n  PRIMARY KEY (`ID`),\\n  KEY `idx_sys_brand_code` (`SYS_BRAND_ID`),\\n  KEY `IX_inn_inns_SYS_COUNTRY_ID` (`SYS_COUNTRY_ID`,`STATUS`,`BOOK_FLAG`,`VALID`),\\n  KEY `IX_inn_inns_SYS_CITY_ID` (`SYS_CITY_ID`,`STATUS`,`BOOK_FLAG`,`VALID`),\\n  KEY `IX_inn_inns_SYS_DISTRICT_ID` (`SYS_DISTRICT_ID`,`STATUS`,`BOOK_FLAG`,`VALID`),\\n  KEY `IX_inn_inns_SECOND_SYS_CITY_ID` (`SECOND_SYS_CITY_ID`,`STATUS`,`BOOK_FLAG`,`VALID`),\\n  KEY `ix_inn_inns_1` (`STATUS`,`BOOK_FLAG`,`SYS_BRAND_ID`),\\n  KEY `inn_inns_UPDATE_DATE_TIME_index` (`UPDATE_DATE_TIME`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4\\n\\nCREATE TABLE `inn_inns_language` (\\n  `ID` varchar(64) NOT NULL,\\n  `INN_ID` varchar(64) DEFAULT NULL,\\n  `INN_NAME` varchar(512) DEFAULT NULL,\\n  `INN_SHORT_NAME` varchar(512) DEFAULT NULL,\\n  `INN_NAME_PINYIN` varchar(512) DEFAULT NULL COMMENT '用于列表搜索输入拼音',\\n  `ADDRESS` text,\\n  `LEGAL_ADDRESS` text,\\n  `SHORT_DESCRIPTION` varchar(512) DEFAULT NULL,\\n  `DESCRIPTION` longtext,\\n  `DESCRIPTION_TEXT` longtext,\\n  `SPECIAL_POLICY` longtext,\\n  `SALUTATORY` longtext,\\n  `EXTEND` longtext,\\n  `LANG_TYPE` int(11) DEFAULT NULL COMMENT '[LANG_TYPE] 0 中文 1 英文 2 法文',\\n  `REMARK` longtext,\\n  `GUIDE` longtext COMMENT '到店指引',\\n  `CREATE_DATE_TIME` datetime DEFAULT NULL,\\n  `UPDATE_DATE_TIME` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n  PRIMARY KEY (`ID`),\\n  KEY `INDEX_INN_ID` (`INN_ID`) USING BTREE\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\\n\\nCREATE TABLE `sys_brand` (\\n  `ID` varchar(64) NOT NULL,\\n  `BRAND_CODE` varchar(64) DEFAULT NULL,\\n  `GROUP_ID` varchar(64) DEFAULT NULL,\\n  `BRAND_TYPE` tinyint(4) DEFAULT NULL COMMENT '[BRAND_TYPE] 0 自有品牌 1 合作品牌',\\n  `STAR_TYPE` tinyint(4) DEFAULT NULL,\\n  `SORT` int(11) DEFAULT NULL,\\n  `DESCRIPTION` longtext,\\n  `DESCRIPTION_TEXT` longtext,\\n  `CREATE_DATE_TIME` datetime DEFAULT NULL,\\n  `UPDATE_DATE_TIME` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n  `BT_BRAND_CODE` varchar(64) DEFAULT NULL,\\n  `CRS_BRAND_CODE` varchar(64) DEFAULT NULL COMMENT '第三方酒店品牌编号',\\n  `BUSINESS_CATEGORY` tinyint(4) DEFAULT NULL COMMENT '业务类别：0酒店  1公寓  2咖啡',\\n  `JREZ_BRAND_CODE` varchar(64) DEFAULT NULL COMMENT 'JREZ系统的品牌编号',\\n  `EMAIL` varchar(128) DEFAULT NULL COMMENT '加盟邮箱',\\n  `PHONE` varchar(128) DEFAULT NULL COMMENT '加盟热线',\\n  `NAVIGATION_STATUS` tinyint(4) DEFAULT '0' COMMENT '导航状态 0关闭，1开启',\\n  `BRAND_NAME_CN` varchar(128) DEFAULT NULL COMMENT '品牌名称，冗余字段，方便查询',\\n  `BRAND_COLOR` varchar(64) DEFAULT NULL COMMENT '品牌馆皮肤色值',\\n  `BRAND_SLOGAN` varchar(64) DEFAULT NULL COMMENT '品牌slogan',\\n  `MOS_TYPE` tinyint(4) DEFAULT '0' COMMENT '品牌MOS归类 【0—A类；1—B类；2—C类；3—D类；4 —E类；5—F类；6—G类】',\\n  `PARENT_CODE` varchar(64) DEFAULT '0' COMMENT '主品牌设置 【RHGB 丽笙；141 非繁；JJINN 锦江之星；wy2 维也纳酒店】',\\n  PRIMARY KEY (`ID`),\\n  KEY `sysBrandCode` (`BRAND_CODE`) USING BTREE\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4\\n\\nCREATE TABLE `sys_brand_language` (\\n  `ID` varchar(64) NOT NULL,\\n  `BRAND_ID` varchar(64) DEFAULT NULL,\\n  `BRAND_NAME` varchar(256) DEFAULT NULL,\\n  `LANG_TYPE` int(11) DEFAULT NULL COMMENT '[LANG_TYPE] 0 中文 1 英文 2 法文',\\n  `CREATE_DATE_TIME` datetime DEFAULT NULL,\\n  `UPDATE_DATE_TIME` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n  `BRAND_ADDRESS` varchar(256) DEFAULT NULL COMMENT '品牌的公司地址',\\n  `BRAND_SPECIALITY` varchar(1000) DEFAULT NULL COMMENT '品牌特色',\\n  `BRAND_STORY` varchar(2000) DEFAULT NULL COMMENT '品牌故事',\\n  `BRAND_INTRODUCTION` varchar(256) DEFAULT NULL COMMENT '品牌信息介绍',\\n  PRIMARY KEY (`ID`),\\n  KEY `sbl_b1` (`BRAND_ID`) USING BTREE\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4\\n\\n\\nCREATE TABLE `sys_group` (\\n  `ID` varchar(64) NOT NULL,\\n  `GROUP_NAME` varchar(128) DEFAULT NULL,\\n  `GROUP_ADDRESS` varchar(512) DEFAULT NULL,\\n  `TELEPHONE` varchar(128) DEFAULT NULL,\\n  `CREATE_DATE_TIME` datetime DEFAULT NULL,\\n  `UPDATE_DATE_TIME` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\\n  PRIMARY KEY (`ID`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4\\n\\n\\nCREATE TABLE `inn_china_org_region` (\\n  `id` bigint(16) NOT NULL AUTO_INCREMENT COMMENT '主键',\\n  `INN_ID` varchar(64) NOT NULL COMMENT '酒店ID',\\n  `REGION_ID` int(11) DEFAULT NULL COMMENT '大区id,对应统一认证组织表的id字段',\\n  `REGION_CODE` varchar(64) DEFAULT NULL COMMENT '大区code,对应应统一认证组织表的code字段',\\n  `REGION_NAME` varchar(64) DEFAULT NULL COMMENT '大区名称,对应应统一认证组织表的name字段',\\n  `PROVINCE_ID` int(11) DEFAULT NULL COMMENT '省区id,对应应统一认证组织表的id字段',\\n  `PROVINCE_CODE` varchar(64) DEFAULT NULL COMMENT '省区code,对应应统一认证组织表的code字段',\\n  `PROVINCE_NAME` varchar(64) DEFAULT NULL COMMENT '省区名称,对应应统一认证组织表的name字段',\\n  `AREA_ID` int(11) DEFAULT NULL COMMENT '片区id,对应应统一认证组织表的id字段',\\n  `AREA_CODE` varchar(64) DEFAULT NULL COMMENT '片区code,对应应统一认证组织表的code字段',\\n  `AREA_NAME` varchar(64) DEFAULT NULL COMMENT '片区名称,对应应统一认证组织表的name字段',\\n  `TYPE` tinyint(4) NOT NULL COMMENT '类型模式: 1,大区模式;2,独立品牌模式；当为大区模式时，AREA_*字段对应的是省区、PROVINCE_*字段对应的是总部、REGION_*字段对应的是总部、',\\n  `STATUS` tinyint(4) DEFAULT NULL COMMENT '状态: 0,失效;1,有效',\\n  `REMARK` varchar(2048) DEFAULT NULL COMMENT '备注',\\n  `CREATE_USER_ID` int(11) DEFAULT NULL COMMENT '创建人ID',\\n  `CREATE_DATE_TIME` datetime DEFAULT NULL COMMENT '创建日期时间',\\n  `UPDATE_DATE_TIME` datetime DEFAULT NULL COMMENT '更新日期时间',\\n  PRIMARY KEY (`id`),\\n  UNIQUE KEY `INN_ID` (`INN_ID`),\\n  KEY `ix_inn_china_org_region_1` (`REGION_ID`) USING BTREE,\\n  KEY `ix_inn_china_org_region_2` (`PROVINCE_ID`) USING BTREE,\\n  KEY `ix_inn_china_org_region_3` (`AREA_ID`) USING BTREE\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT COMMENT='酒店与中国区组织区域信息表'\", \"sql\": \"select\\n ii.ID,\\n iil.INN_NAME,\\n ii.SYS_BRAND_ID,\\n sbl.BRAND_NAME,\\n sb.GROUP_ID,\\n sg.GROUP_NAME,\\n ii.CONTACT_NAME,\\n ii.CONTACT_PHONE,\\n ii.INN_FAX,\\n ii.MANAGEMENT_COMPANY,\\n ii.PMS_PIPE,\\n ii.ORG_ARCH_ID,\\n ii.IS_PRIVILEGE_MEMBER_HOTEL,\\n ii.IS_JIN_REWARDS,\\n ii.UPDATE_DATE_TIME,\\n ico.REGION_ID,\\n ico.REGION_NAME,\\n ico.PROVINCE_ID,\\n ico.PROVINCE_NAME,\\n ico.AREA_ID,\\n ico.AREA_NAME\\nfrom inn_inns ii\\n left join inn_inns_language iil on iil.inn_id = ii.id and iil.LANG_TYPE = 0\\n left join sys_brand sb on sb.brand_code = ii.sys_brand_id\\n LEFT JOIN sys_brand_language sbl ON sbl.BRAND_ID = sb.id  AND sbl.LANG_TYPE = 0\\n left join sys_group sg on sg.id = sb.GROUP_ID\\n LEFT JOIN inn_china_org_region ico ON ico.inn_id = ii.ID\\nORDER BY ii.ID ASC\\nlimit 0, 200\", \"columns_selectivity\": \"\", \"explain\": \"|id |select_type|table|partitions|type  |possible_keys|key         |key_len|ref                          |rows|filtered|Extra                                             |\\n|---|-----------|-----|----------|------|-------------|------------|-------|-----------------------------|----|--------|--------------------------------------------------|\\n|1  |SIMPLE     |ii   |          |ALL   |             |            |       |                             |1   |100     |Using temporary; Using filesort                   |\\n|1  |SIMPLE     |iil  |          |ref   |INDEX_INN_ID |INDEX_INN_ID|259    |sqlflash_test.ii.ID          |1   |100     |Using where                                       |\\n|1  |SIMPLE     |sb   |          |ref   |sysBrandCode |sysBrandCode|259    |sqlflash_test.ii.SYS_BRAND_ID|1   |100     |                                                  |\\n|1  |SIMPLE     |sbl  |          |ref   |sbl_b1       |sbl_b1      |259    |sqlflash_test.sb.ID          |1   |100     |Using where                                       |\\n|1  |SIMPLE     |sg   |          |eq_ref|PRIMARY      |PRIMARY     |258    |sqlflash_test.sb.GROUP_ID    |1   |100     |                                                  |\\n|1  |SIMPLE     |ico  |          |ALL   |             |            |       |                             |1   |100     |Using where; Using join buffer (Block Nested Loop)|\", \"expected\": \"以下两种方式均可：\\n1. 无法通过索引解决SQL性能问题。ii表与ico两表字符集不一致，建议将两表或其关联列的关联列修改为相同字符集\\n2.SQL无性能问题\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE `inn_inns` (\n  `ID` varchar(64) NOT NULL COMMENT ' 酒店ID和第三方酒店ID',\n  `CHAIN_CODE` varchar(64) DEFAULT NULL COMMENT '用于兼容7天酒店ID,所以保留',\n  `S_CODE` varchar(32) DEFAULT NULL COMMENT '系统自维护酒店编码，格式：品牌编号+0000001，例如：7770000001(待定),通过编号表生成',\n  `BUSINESS_TYPE` tinyint(4) DEFAULT NULL COMMENT '[BUSSINIESS_TYPE] 0自营店，1管理店，2加盟店，3标准店  4合作店',\n  `OFFICE_CENTER_TYPE` tinyint(4) DEFAULT NULL,\n  `SUPPORT_PAYMENT_MODE` varchar(512) DEFAULT NULL,\n  `COMPANY_NAME` varchar(128) DEFAULT NULL COMMENT '针对合作酒店',\n  `FORENSIC_CODE` varchar(128) DEFAULT NULL,\n  `STATUS` tinyint(4) DEFAULT NULL COMMENT '0 营业中 1 停业 2 筹建',\n  `INN_TYPE` varchar(32) DEFAULT NULL COMMENT '[INN_TYPE] 100经济型酒店 101精品商务酒店 102景区度假酒店 103主题特色酒店 104民俗风情酒店 ',\n  `STAR_TYPE` tinyint(4) DEFAULT NULL COMMENT '[STAR_TYPE] 0 一星 1 二星 3 三星',\n  `RECOMMAND_STAR_TYPE` tinyint(4) DEFAULT NULL,\n  `MEDAL_TYPE` tinyint(4) DEFAULT NULL,\n  `START_FLOOR` varchar(32) DEFAULT NULL,\n  `END_FLOOR` varchar(32) DEFAULT NULL,\n  `TOTAL_ROOM` int(11) DEFAULT NULL,\n  `SYS_COUNTRY_ID` varchar(64) DEFAULT NULL,\n  `SYS_CITY_ID` varchar(64) DEFAULT NULL,\n  `SECOND_SYS_CITY_ID` varchar(64) DEFAULT NULL,\n  `SYS_DISTRICT_ID` varchar(64) DEFAULT NULL,\n  `SYS_BRAND_ID` varchar(64) DEFAULT NULL,\n  `HOTEL_MANAGE` varchar(256) DEFAULT NULL,\n  `INN_PHONE` varchar(128) DEFAULT NULL,\n  `INN_EMAIL` varchar(256) DEFAULT NULL,\n  `INN_FAX` varchar(128) DEFAULT NULL,\n  `SUPPORT_PAY_ONLINE` tinyint(4) DEFAULT NULL COMMENT '[YES_OR_NO] 1 是 0 否',\n  `PULL_ROOM_FLAG` tinyint(4) DEFAULT NULL COMMENT '是否拉取PMS房间信息[0 否  1是]',\n  `BOOK_FLAG` tinyint(4) DEFAULT '0' COMMENT '[YES_OR_NO] 1 是 0 否',\n  `SUPPORT_FOREIGN_GUEST` tinyint(4) DEFAULT NULL,\n  `VALUE_ADDED_INVOICE` tinyint(4) DEFAULT NULL,\n  `OPEN_DATE` date DEFAULT NULL,\n  `CLOSE_DATE` date DEFAULT NULL,\n  `IFSYNC` tinyint(4) DEFAULT '0' COMMENT '1不同步，其他同步',\n  `SALE_DEPART_ID` varchar(32) DEFAULT NULL,\n  `MAIN_PERSON` varchar(64) DEFAULT NULL,\n  `CHINESE_INFO_FULL` tinyint(4) DEFAULT '0',\n  `ENGLISH_INFO_FULL` tinyint(4) DEFAULT '0',\n  `AUDIT_STATUS` tinyint(4) DEFAULT '0',\n  `MAIN_PHONE` varchar(64) DEFAULT NULL,\n  `MAIN_EMAIL` varchar(255) DEFAULT NULL,\n  `DECORATION_DATE` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '装修日期',\n  `ELEVATOR_NUM` int(11) DEFAULT NULL COMMENT '电梯数量',\n  `MEETING_ROOM_NUM` int(11) DEFAULT NULL COMMENT '会议室数量',\n  `MEETING_ROOM_ACCOMMODATES` int(11) DEFAULT NULL COMMENT '会议室可容纳人数',\n  `NON_SMOKING_ROOMS_NUM` int(11) DEFAULT NULL COMMENT '无烟房数量',\n  `MAX_CHECK_IN` int(11) DEFAULT NULL COMMENT '酒店最大入住人数',\n  `LAST_RETENTION_TIME` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '酒店最晚保留时间(非担保)',\n  `SETTLEMENT_CURRENCY` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '酒店结算货币',\n  `PANORAMA_IMAGE` varchar(512) CHARACTER SET utf8 DEFAULT NULL COMMENT '全景图地址',\n  `ZIP_CODE` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '酒店邮编',\n  `CHECK_IN_TIME` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '最早入住时间',\n  `CHECK_OUT_TIME` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '最晚离店时间',\n  `TIME_ZONE` varchar(64) CHARACTER SET utf8 DEFAULT NULL COMMENT '时区',\n  `PETS` tinyint(4) DEFAULT '0' COMMENT '是否允许携带宠物 0 否  1是',\n  `ALLOW_MINORS` tinyint(4) DEFAULT '0' COMMENT '是否允许未成年人人单独入住 0 否  1是',\n  `INN_LEVEL` int(11) DEFAULT NULL COMMENT '酒店级别',\n  `VALID` tinyint(4) DEFAULT '1' COMMENT '[YES_OR_NO] 1 是 0 否',\n  `EXTEND` longtext,\n  `CREATE_DATE_TIME` datetime DEFAULT NULL,\n  `UPDATE_DATE_TIME` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  `CHOOSE_ROOM_SWITCH` tinyint(4) DEFAULT '0' COMMENT '选房开关[0否 1是]',\n  `SMART_HOTEL` tinyint(4) DEFAULT '0' COMMENT '智能酒店标签 0 否 1是',\n  `BOOKING_INVOICE` tinyint(4) DEFAULT '0' COMMENT '预约发票 0关 1开',\n  `INVOICE_TYPE` varchar(64) DEFAULT '0' COMMENT '发票类型 0普通发票 1增值税普通发票 2增值税专用发票，可以多选，通过逗号分隔',\n  `HOME_LINK` varchar(256) DEFAULT NULL COMMENT '主页链接',\n  `SMOKING` varchar(32) DEFAULT '0',\n  `CRS_CODE` varchar(64) DEFAULT NULL COMMENT 'wehotel酒店编号在第三方酒店系统中的编号',\n  `PMS_CODE` varchar(64) DEFAULT NULL COMMENT 'JREZ系统中对接的PMS编码，仅供BI使用',\n  `ROOM_SWITCH_FLAG` tinyint(4) DEFAULT '0' COMMENT '选房开关标识 0自动 1手动',\n  `MORNING_ROOM` tinyint(4) DEFAULT '1' COMMENT '是否可预订凌晨房 0否 1是',\n  `SCAN_CHECK_IN` tinyint(4) DEFAULT '0' COMMENT '是否支持扫码入住 0 否 1是',\n  `IS_SUPPORT_GUIDE_DOG_POLICY` tinyint(4) DEFAULT '0' COMMENT '是否支持导盲犬政策[0 不支持，1 支持]',\n  `DIAMOND_RATING` tinyint(4) DEFAULT NULL COMMENT '准星级：0 无星 1 准一星；2 准二星；3 准三星；4 准四星；5 准五星',\n  `VIDEO_URL` varchar(256) DEFAULT NULL COMMENT '酒店介绍视频链接',\n  `IS_PRIVILEGE_MEMBER_HOTEL` tinyint(4) DEFAULT '0' COMMENT '是否尊享会会员酒店 0否 1是',\n  `REGIONAL_COMPANY` varchar(64) DEFAULT NULL COMMENT '区域公司',\n  `MANAGEMENT_COMPANY` varchar(64) DEFAULT NULL COMMENT '管理公司',\n  `IS_PERFECT_ENGLISH` tinyint(4) DEFAULT '0' COMMENT '是否完善英文要素：0 否 1 是',\n  `IS_BREAKFAST` tinyint(4) DEFAULT '0' COMMENT '是否提供早餐[0 否,1 是]',\n  `INN_INFO_INTEGRITY` varchar(64) DEFAULT NULL COMMENT '酒店信息完整度',\n  `IS_SESAME_CREDIT` tinyint(4) DEFAULT '0' COMMENT '是否支持芝麻信用支付[0 否，1 是] ',\n  `IS_DEPOSIT` tinyint(4) DEFAULT '0' COMMENT '是否收押金[0 否，1 是]',\n  `DEPOSIT_AMOUNT` varchar(64) DEFAULT '0' COMMENT '押金的金额',\n  `UPGRADE_TYPE` tinyint(4) DEFAULT '0' COMMENT '升级类型[0 无，1 新优品，2 新IU]',\n  `TRANSFER_PROJECT_ID` varchar(128) DEFAULT NULL COMMENT '关联项目编码（转品牌转前项目编码）',\n  `TRANSFER_INN_ID` varchar(128) DEFAULT NULL COMMENT '酒店编码（转品牌转前酒店编码）',\n  `TRANSFER_INN_NAME_CN` varchar(512) DEFAULT NULL COMMENT '酒店名称（转品牌转前酒店名称）',\n  `PROJECT_ID` varchar(128) DEFAULT NULL COMMENT '项目编码(铂涛酒店)',\n  `e_key` varchar(8) DEFAULT 'off' COMMENT '智能钥匙开关：on/off',\n  `IS_JIN_REWARDS` tinyint(4) DEFAULT '0' COMMENT '是否豪华经典酒店标识(原 锦好客酒店标识)[0 否；1 是]',\n  `PMS_PIPE` varchar(64) DEFAULT NULL COMMENT 'pms通道',\n  `PMS_FLAG` tinyint(4) DEFAULT NULL COMMENT '是否pms接口酒店',\n  `PMS_STATUS` tinyint(4) DEFAULT NULL COMMENT 'pms状态',\n  `PMS_VERSION` varchar(64) DEFAULT NULL COMMENT 'pms版本',\n  `CONTACT_NAME` varchar(64) DEFAULT '' COMMENT '联系人姓名',\n  `CONTACT_PHONE` varchar(64) DEFAULT '' COMMENT '联系人电话',\n  `ORG_ARCH_ID` varchar(64) DEFAULT '' COMMENT '公司区域标签(组织ID)',\n  `ONLINE_TIME` datetime DEFAULT NULL COMMENT '直连上线时间',\n  `DOWNLINE_TIME` datetime DEFAULT NULL COMMENT '直连下线时间',\n  `LOW_LIMIT` varchar(32) DEFAULT NULL COMMENT '最低价格，安全性保护，防止设置房价过低，而遭受损失',\n  `IS_CHINA_ZONE_HOTEL` tinyint(4) DEFAULT '0' COMMENT '是否中国区酒店标识[0 否；1 是]',\n  `POINT_CHARGING_MODE` tinyint(4) DEFAULT NULL COMMENT '积分收费模式[1=积分收费、2=以房抵费、0=无]',\n  `POINT_CHARGING_MODE_UPDATE_DATE` datetime DEFAULT NULL COMMENT '积分收费模式修改日期',\n  `POINT_CHARGING_MODE_VALID_DATE` datetime DEFAULT NULL COMMENT '积分收费模式生效日期 ',\n  `CHILD_FREE_AGE` varchar(32) DEFAULT NULL COMMENT '儿童免费年龄',\n  `HOTEL_THEME_TYPE` varchar(32) DEFAULT NULL COMMENT '酒店主题类型',\n  `MEETING_ROOM` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否有会议室  1-有  0-无',\n  PRIMARY KEY (`ID`),\n  KEY `idx_sys_brand_code` (`SYS_BRAND_ID`),\n  KEY `IX_inn_inns_SYS_COUNTRY_ID` (`SYS_COUNTRY_ID`,`STATUS`,`BOOK_FLAG`,`VALID`),\n  KEY `IX_inn_inns_SYS_CITY_ID` (`SYS_CITY_ID`,`STATUS`,`BOOK_FLAG`,`VALID`),\n  KEY `IX_inn_inns_SYS_DISTRICT_ID` (`SYS_DISTRICT_ID`,`STATUS`,`BOOK_FLAG`,`VALID`),\n  KEY `IX_inn_inns_SECOND_SYS_CITY_ID` (`SECOND_SYS_CITY_ID`,`STATUS`,`BOOK_FLAG`,`VALID`),\n  KEY `ix_inn_inns_1` (`STATUS`,`BOOK_FLAG`,`SYS_BRAND_ID`),\n  KEY `inn_inns_UPDATE_DATE_TIME_index` (`UPDATE_DATE_TIME`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4\n\nCREATE TABLE `inn_inns_language` (\n  `ID` varchar(64) NOT NULL,\n  `INN_ID` varchar(64) DEFAULT NULL,\n  `INN_NAME` varchar(512) DEFAULT NULL,\n  `INN_SHORT_NAME` varchar(512) DEFAULT NULL,\n  `INN_NAME_PINYIN` varchar(512) DEFAULT NULL COMMENT '用于列表搜索输入拼音',\n  `ADDRESS` text,\n  `LEGAL_ADDRESS` text,\n  `SHORT_DESCRIPTION` varchar(512) DEFAULT NULL,\n  `DESCRIPTION` longtext,\n  `DESCRIPTION_TEXT` longtext,\n  `SPECIAL_POLICY` longtext,\n  `SALUTATORY` longtext,\n  `EXTEND` longtext,\n  `LANG_TYPE` int(11) DEFAULT NULL COMMENT '[LANG_TYPE] 0 中文 1 英文 2 法文',\n  `REMARK` longtext,\n  `GUIDE` longtext COMMENT '到店指引',\n  `CREATE_DATE_TIME` datetime DEFAULT NULL,\n  `UPDATE_DATE_TIME` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (`ID`),\n  KEY `INDEX_INN_ID` (`INN_ID`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\nCREATE TABLE `sys_brand` (\n  `ID` varchar(64) NOT NULL,\n  `BRAND_CODE` varchar(64) DEFAULT NULL,\n  `GROUP_ID` varchar(64) DEFAULT NULL,\n  `BRAND_TYPE` tinyint(4) DEFAULT NULL COMMENT '[BRAND_TYPE] 0 自有品牌 1 合作品牌',\n  `STAR_TYPE` tinyint(4) DEFAULT NULL,\n  `SORT` int(11) DEFAULT NULL,\n  `DESCRIPTION` longtext,\n  `DESCRIPTION_TEXT` longtext,\n  `CREATE_DATE_TIME` datetime DEFAULT NULL,\n  `UPDATE_DATE_TIME` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  `BT_BRAND_CODE` varchar(64) DEFAULT NULL,\n  `CRS_BRAND_CODE` varchar(64) DEFAULT NULL COMMENT '第三方酒店品牌编号',\n  `BUSINESS_CATEGORY` tinyint(4) DEFAULT NULL COMMENT '业务类别：0酒店  1公寓  2咖啡',\n  `JREZ_BRAND_CODE` varchar(64) DEFAULT NULL COMMENT 'JREZ系统的品牌编号',\n  `EMAIL` varchar(128) DEFAULT NULL COMMENT '加盟邮箱',\n  `PHONE` varchar(128) DEFAULT NULL COMMENT '加盟热线',\n  `NAVIGATION_STATUS` tinyint(4) DEFAULT '0' COMMENT '导航状态 0关闭，1开启',\n  `BRAND_NAME_CN` varchar(128) DEFAULT NULL COMMENT '品牌名称，冗余字段，方便查询',\n  `BRAND_COLOR` varchar(64) DEFAULT NULL COMMENT '品牌馆皮肤色值',\n  `BRAND_SLOGAN` varchar(64) DEFAULT NULL COMMENT '品牌slogan',\n  `MOS_TYPE` tinyint(4) DEFAULT '0' COMMENT '品牌MOS归类 【0—A类；1—B类；2—C类；3—D类；4 —E类；5—F类；6—G类】',\n  `PARENT_CODE` varchar(64) DEFAULT '0' COMMENT '主品牌设置 【RHGB 丽笙；141 非繁；JJINN 锦江之星；wy2 维也纳酒店】',\n  PRIMARY KEY (`ID`),\n  KEY `sysBrandCode` (`BRAND_CODE`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4\n\nCREATE TABLE `sys_brand_language` (\n  `ID` varchar(64) NOT NULL,\n  `BRAND_ID` varchar(64) DEFAULT NULL,\n  `BRAND_NAME` varchar(256) DEFAULT NULL,\n  `LANG_TYPE` int(11) DEFAULT NULL COMMENT '[LANG_TYPE] 0 中文 1 英文 2 法文',\n  `CREATE_DATE_TIME` datetime DEFAULT NULL,\n  `UPDATE_DATE_TIME` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  `BRAND_ADDRESS` varchar(256) DEFAULT NULL COMMENT '品牌的公司地址',\n  `BRAND_SPECIALITY` varchar(1000) DEFAULT NULL COMMENT '品牌特色',\n  `BRAND_STORY` varchar(2000) DEFAULT NULL COMMENT '品牌故事',\n  `BRAND_INTRODUCTION` varchar(256) DEFAULT NULL COMMENT '品牌信息介绍',\n  PRIMARY KEY (`ID`),\n  KEY `sbl_b1` (`BRAND_ID`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4\n\n\nCREATE TABLE `sys_group` (\n  `ID` varchar(64) NOT NULL,\n  `GROUP_NAME` varchar(128) DEFAULT NULL,\n  `GROUP_ADDRESS` varchar(512) DEFAULT NULL,\n  `TELEPHONE` varchar(128) DEFAULT NULL,\n  `CREATE_DATE_TIME` datetime DEFAULT NULL,\n  `UPDATE_DATE_TIME` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (`ID`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4\n\n\nCREATE TABLE `inn_china_org_region` (\n  `id` bigint(16) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `INN_ID` varchar(64) NOT NULL COMMENT '酒店ID',\n  `REGION_ID` int(11) DEFAULT NULL COMMENT '大区id,对应统一认证组织表的id字段',\n  `REGION_CODE` varchar(64) DEFAULT NULL COMMENT '大区code,对应应统一认证组织表的code字段',\n  `REGION_NAME` varchar(64) DEFAULT NULL COMMENT '大区名称,对应应统一认证组织表的name字段',\n  `PROVINCE_ID` int(11) DEFAULT NULL COMMENT '省区id,对应应统一认证组织表的id字段',\n  `PROVINCE_CODE` varchar(64) DEFAULT NULL COMMENT '省区code,对应应统一认证组织表的code字段',\n  `PROVINCE_NAME` varchar(64) DEFAULT NULL COMMENT '省区名称,对应应统一认证组织表的name字段',\n  `AREA_ID` int(11) DEFAULT NULL COMMENT '片区id,对应应统一认证组织表的id字段',\n  `AREA_CODE` varchar(64) DEFAULT NULL COMMENT '片区code,对应应统一认证组织表的code字段',\n  `AREA_NAME` varchar(64) DEFAULT NULL COMMENT '片区名称,对应应统一认证组织表的name字段',\n  `TYPE` tinyint(4) NOT NULL COMMENT '类型模式: 1,大区模式;2,独立品牌模式；当为大区模式时，AREA_*字段对应的是省区、PROVINCE_*字段对应的是总部、REGION_*字段对应的是总部、',\n  `STATUS` tinyint(4) DEFAULT NULL COMMENT '状态: 0,失效;1,有效',\n  `REMARK` varchar(2048) DEFAULT NULL COMMENT '备注',\n  `CREATE_USER_ID` int(11) DEFAULT NULL COMMENT '创建人ID',\n  `CREATE_DATE_TIME` datetime DEFAULT NULL COMMENT '创建日期时间',\n  `UPDATE_DATE_TIME` datetime DEFAULT NULL COMMENT '更新日期时间',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `INN_ID` (`INN_ID`),\n  KEY `ix_inn_china_org_region_1` (`REGION_ID`) USING BTREE,\n  KEY `ix_inn_china_org_region_2` (`PROVINCE_ID`) USING BTREE,\n  KEY `ix_inn_china_org_region_3` (`AREA_ID`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT COMMENT='酒店与中国区组织区域信息表'\n\n## EXPLAIN:\n|id |select_type|table|partitions|type  |possible_keys|key         |key_len|ref                          |rows|filtered|Extra                                             |\n|---|-----------|-----|----------|------|-------------|------------|-------|-----------------------------|----|--------|--------------------------------------------------|\n|1  |SIMPLE     |ii   |          |ALL   |             |            |       |                             |1   |100     |Using temporary; Using filesort                   |\n|1  |SIMPLE     |iil  |          |ref   |INDEX_INN_ID |INDEX_INN_ID|259    |sqlflash_test.ii.ID          |1   |100     |Using where                                       |\n|1  |SIMPLE     |sb   |          |ref   |sysBrandCode |sysBrandCode|259    |sqlflash_test.ii.SYS_BRAND_ID|1   |100     |                                                  |\n|1  |SIMPLE     |sbl  |          |ref   |sbl_b1       |sbl_b1      |259    |sqlflash_test.sb.ID          |1   |100     |Using where                                       |\n|1  |SIMPLE     |sg   |          |eq_ref|PRIMARY      |PRIMARY     |258    |sqlflash_test.sb.GROUP_ID    |1   |100     |                                                  |\n|1  |SIMPLE     |ico  |          |ALL   |             |            |       |                             |1   |100     |Using where; Using join buffer (Block Nested Loop)|\n\n## Column Selectivity:\n\n\n## Original SQL:\nselect\n ii.ID,\n iil.INN_NAME,\n ii.SYS_BRAND_ID,\n sbl.BRAND_NAME,\n sb.GROUP_ID,\n sg.GROUP_NAME,\n ii.CONTACT_NAME,\n ii.CONTACT_PHONE,\n ii.INN_FAX,\n ii.MANAGEMENT_COMPANY,\n ii.PMS_PIPE,\n ii.ORG_ARCH_ID,\n ii.IS_PRIVILEGE_MEMBER_HOTEL,\n ii.IS_JIN_REWARDS,\n ii.UPDATE_DATE_TIME,\n ico.REGION_ID,\n ico.REGION_NAME,\n ico.PROVINCE_ID,\n ico.PROVINCE_NAME,\n ico.AREA_ID,\n ico.AREA_NAME\nfrom inn_inns ii\n left join inn_inns_language iil on iil.inn_id = ii.id and iil.LANG_TYPE = 0\n left join sys_brand sb on sb.brand_code = ii.sys_brand_id\n LEFT JOIN sys_brand_language sbl ON sbl.BRAND_ID = sb.id  AND sbl.LANG_TYPE = 0\n left join sys_group sg on sg.id = sb.GROUP_ID\n LEFT JOIN inn_china_org_region ico ON ico.inn_id = ii.ID\nORDER BY ii.ID ASC\nlimit 0, 200\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "Unable to solve SQL performance issues by creating indexes. Reason: Query lacks WHERE clause filtering on the main table (inn_inns), forcing a full table scan. The ORDER BY combined with no row filtering requires materialization and filesort of all rows before LIMIT is applied, which cannot be eliminated by indexes. Fundamental query design changes (e.g., adding WHERE clause filters or redesigning pagination logic) are needed to resolve this performance issue."
                    }
                ]
            },
            {
                "case_id": "7",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"7\", \"difficulty_level\": \"3\", \"description\": \"业务case-缺失索引和索引列选择测试\", \"create_table_statements\": \"CREATE TABLE `batch` (\\n  `id` BIGINT NOT NULL AUTO_INCREMENT,\\n  `app_id` VARCHAR(50) NOT NULL,\\n  `template` VARCHAR(255) DEFAULT NULL,\\n  `param_array` TEXT,\\n  `vendor` VARCHAR(100) DEFAULT NULL,\\n  `render` VARCHAR(255) DEFAULT NULL,\\n  `remark` TEXT,\\n  `create_time` DATETIME NOT NULL,\\n  `update_time` DATETIME DEFAULT NULL,\\n  `quantity_note` VARCHAR(255) DEFAULT NULL,\\n  `signature` VARCHAR(255) DEFAULT NULL,\\n  PRIMARY KEY (`id`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"sql\": \"select\\n  id,\\n  app_id,\\n  template,\\n  param_array,\\n  vendor,\\n  render,\\n  remark,\\n  create_time,\\n  update_time,\\n  quantity_note,\\n  signature\\nfrom  batch\\nWHERE \\napp_id = 'ops_console' and\\ncreate_time between '2025-09-01 00:00:00'  and '2025-09-01 23:59:59';\", \"columns_selectivity\": \"{\\n            \\\"create_time\\\" : 95.9000%,\\n            \\\"app_id\\\" : 0.0100%\\n          }\", \"explain\": \"|id |select_type|table|partitions|type|possible_keys|key|key_len|ref|rows   |filtered|Extra      |\\n|---|-----------|-----|----------|----|-------------|---|-------|---|-------|--------|-----------|\\n|1  |SIMPLE     |batch|          |ALL |             |   |       |   |196,593|1.11    |Using where|\", \"expected\": \"以下两种情况均可：\\n1. 在batch表的create_time列创建单列索引。\\n2. 在batch表的app_id和create_time列创建符合索引，要求app_id列在前。\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE `batch` (\n  `id` BIGINT NOT NULL AUTO_INCREMENT,\n  `app_id` VARCHAR(50) NOT NULL,\n  `template` VARCHAR(255) DEFAULT NULL,\n  `param_array` TEXT,\n  `vendor` VARCHAR(100) DEFAULT NULL,\n  `render` VARCHAR(255) DEFAULT NULL,\n  `remark` TEXT,\n  `create_time` DATETIME NOT NULL,\n  `update_time` DATETIME DEFAULT NULL,\n  `quantity_note` VARCHAR(255) DEFAULT NULL,\n  `signature` VARCHAR(255) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n## EXPLAIN:\n|id |select_type|table|partitions|type|possible_keys|key|key_len|ref|rows   |filtered|Extra      |\n|---|-----------|-----|----------|----|-------------|---|-------|---|-------|--------|-----------|\n|1  |SIMPLE     |batch|          |ALL |             |   |       |   |196,593|1.11    |Using where|\n\n## Column Selectivity:\n{\n            \"create_time\" : 95.9000%,\n            \"app_id\" : 0.0100%\n          }\n\n## Original SQL:\nselect\n  id,\n  app_id,\n  template,\n  param_array,\n  vendor,\n  render,\n  remark,\n  create_time,\n  update_time,\n  quantity_note,\n  signature\nfrom  batch\nWHERE \napp_id = 'ops_console' and\ncreate_time between '2025-09-01 00:00:00'  and '2025-09-01 23:59:59';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_app_id_create_time ON batch(app_id, create_time); Reason: Composite index - The query filters on both app_id and create_time; ordering by app_id (0.01% selectivity) as the leading column enables efficient range scans instead of the current full table scan of 196,593 rows, significantly reducing rows examined."
                    }
                ]
            },
            {
                "case_id": "8",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"8\", \"difficulty_level\": \"3\", \"description\": \"业务case-测试模糊匹配-后模糊\", \"create_table_statements\": \"CREATE TABLE `benefit_acticvate_record` (\\n  `ID` int(11) NOT NULL AUTO_INCREMENT COMMENT '记录id',\\n  `jjid` bigint(20) NOT NULL DEFAULT '0' COMMENT '会员用户id',\\n  `mebId` int(11) NOT NULL DEFAULT '0' COMMENT '会员ID',\\n  `foreignKey` varchar(200) NOT NULL DEFAULT '0' COMMENT '外键',\\n  `benefitId` int(11) NOT NULL DEFAULT '0' COMMENT '权益ID',\\n  `appId` int(11) NOT NULL DEFAULT '0' COMMENT '应用appId',\\n  `reqArgs` varchar(500) NOT NULL DEFAULT '0' COMMENT '请求外部权益参数，用于重试',\\n  `coupon` varchar(300) DEFAULT NULL COMMENT '外部返回券码',\\n  `msg` varchar(100) DEFAULT NULL COMMENT '外部接口返回信息',\\n  `status` tinyint(4) DEFAULT '0' COMMENT '0:未处理或者失败;1:成功;2:明确失败(不重试);3:业务明确成功;4:异常退款;5:退款成功;6:退款失败;7:已使用',\\n  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '记录创建时间',\\n  `lastModifyTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '记录更改时间',\\n  `reqNum` int(11) DEFAULT '0' COMMENT '请求次数',\\n  `queryNum` int(11) DEFAULT '0' COMMENT '查询次数',\\n  `orderNo` varchar(255) DEFAULT NULL COMMENT '外部权益服务订单号',\\n  `mobile` varchar(25) DEFAULT NULL COMMENT '手机号',\\n  `thirdOrderNo` varchar(30) DEFAULT NULL COMMENT '第三方订单号（海威版本加的）',\\n  `url` varchar(700) DEFAULT NULL COMMENT '链接',\\n  `notifyUrl` varchar(255) DEFAULT NULL COMMENT '回调通知地址',\\n  `refundMsg` varchar(255) DEFAULT NULL COMMENT '退款返回信息',\\n  `refundSuccessTime` datetime DEFAULT NULL COMMENT '退款成功时间',\\n  PRIMARY KEY (`ID`),\\n  KEY `record_mebId_index` (`mebId`),\\n  KEY `record_foreignKey_index` (`foreignKey`),\\n  KEY `create_time_index` (`createTime`),\\n  KEY `index_status` (`status`) USING BTREE,\\n  KEY `index_jjid` (`jjid`) USING BTREE,\\n  KEY `index_benefitId_app_id` (`benefitId`,`appId`) USING BTREE,\\n  KEY `ix_moblie` (`mobile`),\\n  KEY `ix_thirdOrderNo` (`thirdOrderNo`)\\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8 COMMENT='权益激活记录'\", \"sql\": \"SELECT\\n  *\\nFROM\\n  `benefit_acticvate_record`\\nWHERE\\n  `reqArgs` LIKE 'Wehotel171450540847226847533%'\\nLIMIT\\n  0, 1000;\", \"columns_selectivity\": \"{\\n    \\\"benefit_acticvate_record\\\": [\\n        {\\n            \\\"reqArgs\\\": 43.0000%\\n        }\\n    ]\\n}\", \"explain\": \"{\\n  \\\"ClassicResult\\\" : {\\n    \\\"Columns\\\" : [ {\\n      \\\"Name\\\" : \\\"id\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"select_type\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"table\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"partitions\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"type\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"possible_keys\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"key\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"key_len\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"ref\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"rows\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"filtered\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"Extra\\\",\\n      \\\"I18nDesc\\\" : null\\n    } ],\\n    \\\"Rows\\\" : [ [ \\\"1\\\", \\\"SIMPLE\\\", \\\"benefit_acticvate_record\\\", \\\"\\\", \\\"ALL\\\", \\\"\\\", \\\"\\\", \\\"\\\", \\\"\\\", \\\"987588\\\", \\\"11.11\\\", \\\"Using where\\\" ]]\\n  }\\n}\", \"expected\": \"like后模糊可以走索引，在benefit_acticvate_record表的reqArgs列添加索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE `benefit_acticvate_record` (\n  `ID` int(11) NOT NULL AUTO_INCREMENT COMMENT '记录id',\n  `jjid` bigint(20) NOT NULL DEFAULT '0' COMMENT '会员用户id',\n  `mebId` int(11) NOT NULL DEFAULT '0' COMMENT '会员ID',\n  `foreignKey` varchar(200) NOT NULL DEFAULT '0' COMMENT '外键',\n  `benefitId` int(11) NOT NULL DEFAULT '0' COMMENT '权益ID',\n  `appId` int(11) NOT NULL DEFAULT '0' COMMENT '应用appId',\n  `reqArgs` varchar(500) NOT NULL DEFAULT '0' COMMENT '请求外部权益参数，用于重试',\n  `coupon` varchar(300) DEFAULT NULL COMMENT '外部返回券码',\n  `msg` varchar(100) DEFAULT NULL COMMENT '外部接口返回信息',\n  `status` tinyint(4) DEFAULT '0' COMMENT '0:未处理或者失败;1:成功;2:明确失败(不重试);3:业务明确成功;4:异常退款;5:退款成功;6:退款失败;7:已使用',\n  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '记录创建时间',\n  `lastModifyTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '记录更改时间',\n  `reqNum` int(11) DEFAULT '0' COMMENT '请求次数',\n  `queryNum` int(11) DEFAULT '0' COMMENT '查询次数',\n  `orderNo` varchar(255) DEFAULT NULL COMMENT '外部权益服务订单号',\n  `mobile` varchar(25) DEFAULT NULL COMMENT '手机号',\n  `thirdOrderNo` varchar(30) DEFAULT NULL COMMENT '第三方订单号（海威版本加的）',\n  `url` varchar(700) DEFAULT NULL COMMENT '链接',\n  `notifyUrl` varchar(255) DEFAULT NULL COMMENT '回调通知地址',\n  `refundMsg` varchar(255) DEFAULT NULL COMMENT '退款返回信息',\n  `refundSuccessTime` datetime DEFAULT NULL COMMENT '退款成功时间',\n  PRIMARY KEY (`ID`),\n  KEY `record_mebId_index` (`mebId`),\n  KEY `record_foreignKey_index` (`foreignKey`),\n  KEY `create_time_index` (`createTime`),\n  KEY `index_status` (`status`) USING BTREE,\n  KEY `index_jjid` (`jjid`) USING BTREE,\n  KEY `index_benefitId_app_id` (`benefitId`,`appId`) USING BTREE,\n  KEY `ix_moblie` (`mobile`),\n  KEY `ix_thirdOrderNo` (`thirdOrderNo`)\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8 COMMENT='权益激活记录'\n\n## EXPLAIN:\n{\n  \"ClassicResult\" : {\n    \"Columns\" : [ {\n      \"Name\" : \"id\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"select_type\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"table\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"partitions\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"type\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"possible_keys\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"key\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"key_len\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"ref\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"rows\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"filtered\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"Extra\",\n      \"I18nDesc\" : null\n    } ],\n    \"Rows\" : [ [ \"1\", \"SIMPLE\", \"benefit_acticvate_record\", \"\", \"ALL\", \"\", \"\", \"\", \"\", \"987588\", \"11.11\", \"Using where\" ]]\n  }\n}\n\n## Column Selectivity:\n{\n    \"benefit_acticvate_record\": [\n        {\n            \"reqArgs\": 43.0000%\n        }\n    ]\n}\n\n## Original SQL:\nSELECT\n  *\nFROM\n  `benefit_acticvate_record`\nWHERE\n  `reqArgs` LIKE 'Wehotel171450540847226847533%'\nLIMIT\n  0, 1000;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_reqArgs ON benefit_acticvate_record(reqArgs); Reason: Single-column index - Enables efficient index range scan for LIKE prefix pattern matching, converting the current full table scan (987,588 rows) into an indexed range lookup."
                    }
                ]
            },
            {
                "case_id": "9",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"9\", \"difficulty_level\": \"3\", \"description\": \"业务case-测试模糊匹配-前模糊\", \"create_table_statements\": \"CREATE TABLE `benefit_acticvate_record` (\\n  `ID` int(11) NOT NULL AUTO_INCREMENT COMMENT '记录id',\\n  `jjid` bigint(20) NOT NULL DEFAULT '0' COMMENT '会员用户id',\\n  `mebId` int(11) NOT NULL DEFAULT '0' COMMENT '会员ID',\\n  `foreignKey` varchar(200) NOT NULL DEFAULT '0' COMMENT '外键',\\n  `benefitId` int(11) NOT NULL DEFAULT '0' COMMENT '权益ID',\\n  `appId` int(11) NOT NULL DEFAULT '0' COMMENT '应用appId',\\n  `reqArgs` varchar(500) NOT NULL DEFAULT '0' COMMENT '请求外部权益参数，用于重试',\\n  `coupon` varchar(300) DEFAULT NULL COMMENT '外部返回券码',\\n  `msg` varchar(100) DEFAULT NULL COMMENT '外部接口返回信息',\\n  `status` tinyint(4) DEFAULT '0' COMMENT '0:未处理或者失败;1:成功;2:明确失败(不重试);3:业务明确成功;4:异常退款;5:退款成功;6:退款失败;7:已使用',\\n  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '记录创建时间',\\n  `lastModifyTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '记录更改时间',\\n  `reqNum` int(11) DEFAULT '0' COMMENT '请求次数',\\n  `queryNum` int(11) DEFAULT '0' COMMENT '查询次数',\\n  `orderNo` varchar(255) DEFAULT NULL COMMENT '外部权益服务订单号',\\n  `mobile` varchar(25) DEFAULT NULL COMMENT '手机号',\\n  `thirdOrderNo` varchar(30) DEFAULT NULL COMMENT '第三方订单号（海威版本加的）',\\n  `url` varchar(700) DEFAULT NULL COMMENT '链接',\\n  `notifyUrl` varchar(255) DEFAULT NULL COMMENT '回调通知地址',\\n  `refundMsg` varchar(255) DEFAULT NULL COMMENT '退款返回信息',\\n  `refundSuccessTime` datetime DEFAULT NULL COMMENT '退款成功时间',\\n  PRIMARY KEY (`ID`),\\n  KEY `record_mebId_index` (`mebId`),\\n  KEY `record_foreignKey_index` (`foreignKey`),\\n  KEY `create_time_index` (`createTime`),\\n  KEY `index_status` (`status`) USING BTREE,\\n  KEY `index_jjid` (`jjid`) USING BTREE,\\n  KEY `index_benefitId_app_id` (`benefitId`,`appId`) USING BTREE,\\n  KEY `ix_moblie` (`mobile`),\\n  KEY `ix_thirdOrderNo` (`thirdOrderNo`)\\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8 COMMENT='权益激活记录'\", \"sql\": \"SELECT\\n  *\\nFROM\\n  `benefit_acticvate_record`\\nWHERE\\n  `reqArgs` LIKE '%Wehotel171450540847226847533'\\nLIMIT\\n  0, 1000;\", \"columns_selectivity\": \"{\\n    \\\"benefit_acticvate_record\\\": [\\n        {\\n            \\\"reqArgs\\\": 43.0000%\\n        }\\n    ]\\n}\", \"explain\": \"{\\n  \\\"ClassicResult\\\" : {\\n    \\\"Columns\\\" : [ {\\n      \\\"Name\\\" : \\\"id\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"select_type\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"table\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"partitions\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"type\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"possible_keys\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"key\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"key_len\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"ref\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"rows\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"filtered\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"Extra\\\",\\n      \\\"I18nDesc\\\" : null\\n    } ],\\n    \\\"Rows\\\" : [ [ \\\"1\\\", \\\"SIMPLE\\\", \\\"benefit_acticvate_record\\\", \\\"\\\", \\\"ALL\\\", \\\"\\\", \\\"\\\", \\\"\\\", \\\"\\\", \\\"987588\\\", \\\"11.11\\\", \\\"Using where\\\" ]]\\n  }\\n}\", \"expected\": \"like前模糊无法走索引，无法通过索引解决SQL性能问题，可以考虑全文索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE `benefit_acticvate_record` (\n  `ID` int(11) NOT NULL AUTO_INCREMENT COMMENT '记录id',\n  `jjid` bigint(20) NOT NULL DEFAULT '0' COMMENT '会员用户id',\n  `mebId` int(11) NOT NULL DEFAULT '0' COMMENT '会员ID',\n  `foreignKey` varchar(200) NOT NULL DEFAULT '0' COMMENT '外键',\n  `benefitId` int(11) NOT NULL DEFAULT '0' COMMENT '权益ID',\n  `appId` int(11) NOT NULL DEFAULT '0' COMMENT '应用appId',\n  `reqArgs` varchar(500) NOT NULL DEFAULT '0' COMMENT '请求外部权益参数，用于重试',\n  `coupon` varchar(300) DEFAULT NULL COMMENT '外部返回券码',\n  `msg` varchar(100) DEFAULT NULL COMMENT '外部接口返回信息',\n  `status` tinyint(4) DEFAULT '0' COMMENT '0:未处理或者失败;1:成功;2:明确失败(不重试);3:业务明确成功;4:异常退款;5:退款成功;6:退款失败;7:已使用',\n  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '记录创建时间',\n  `lastModifyTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '记录更改时间',\n  `reqNum` int(11) DEFAULT '0' COMMENT '请求次数',\n  `queryNum` int(11) DEFAULT '0' COMMENT '查询次数',\n  `orderNo` varchar(255) DEFAULT NULL COMMENT '外部权益服务订单号',\n  `mobile` varchar(25) DEFAULT NULL COMMENT '手机号',\n  `thirdOrderNo` varchar(30) DEFAULT NULL COMMENT '第三方订单号（海威版本加的）',\n  `url` varchar(700) DEFAULT NULL COMMENT '链接',\n  `notifyUrl` varchar(255) DEFAULT NULL COMMENT '回调通知地址',\n  `refundMsg` varchar(255) DEFAULT NULL COMMENT '退款返回信息',\n  `refundSuccessTime` datetime DEFAULT NULL COMMENT '退款成功时间',\n  PRIMARY KEY (`ID`),\n  KEY `record_mebId_index` (`mebId`),\n  KEY `record_foreignKey_index` (`foreignKey`),\n  KEY `create_time_index` (`createTime`),\n  KEY `index_status` (`status`) USING BTREE,\n  KEY `index_jjid` (`jjid`) USING BTREE,\n  KEY `index_benefitId_app_id` (`benefitId`,`appId`) USING BTREE,\n  KEY `ix_moblie` (`mobile`),\n  KEY `ix_thirdOrderNo` (`thirdOrderNo`)\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8 COMMENT='权益激活记录'\n\n## EXPLAIN:\n{\n  \"ClassicResult\" : {\n    \"Columns\" : [ {\n      \"Name\" : \"id\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"select_type\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"table\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"partitions\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"type\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"possible_keys\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"key\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"key_len\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"ref\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"rows\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"filtered\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"Extra\",\n      \"I18nDesc\" : null\n    } ],\n    \"Rows\" : [ [ \"1\", \"SIMPLE\", \"benefit_acticvate_record\", \"\", \"ALL\", \"\", \"\", \"\", \"\", \"987588\", \"11.11\", \"Using where\" ]]\n  }\n}\n\n## Column Selectivity:\n{\n    \"benefit_acticvate_record\": [\n        {\n            \"reqArgs\": 43.0000%\n        }\n    ]\n}\n\n## Original SQL:\nSELECT\n  *\nFROM\n  `benefit_acticvate_record`\nWHERE\n  `reqArgs` LIKE '%Wehotel171450540847226847533'\nLIMIT\n  0, 1000;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "Unable to solve SQL performance issues by creating indexes. Reason: LIKE queries with leading wildcards cannot be optimized with standard B-tree indexes."
                    }
                ]
            },
            {
                "case_id": "10",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"10\", \"difficulty_level\": \"3\", \"description\": \"业务case-测试模糊匹配-前后模糊\", \"create_table_statements\": \"CREATE TABLE `benefit_acticvate_record` (\\n  `ID` int(11) NOT NULL AUTO_INCREMENT COMMENT '记录id',\\n  `jjid` bigint(20) NOT NULL DEFAULT '0' COMMENT '会员用户id',\\n  `mebId` int(11) NOT NULL DEFAULT '0' COMMENT '会员ID',\\n  `foreignKey` varchar(200) NOT NULL DEFAULT '0' COMMENT '外键',\\n  `benefitId` int(11) NOT NULL DEFAULT '0' COMMENT '权益ID',\\n  `appId` int(11) NOT NULL DEFAULT '0' COMMENT '应用appId',\\n  `reqArgs` varchar(500) NOT NULL DEFAULT '0' COMMENT '请求外部权益参数，用于重试',\\n  `coupon` varchar(300) DEFAULT NULL COMMENT '外部返回券码',\\n  `msg` varchar(100) DEFAULT NULL COMMENT '外部接口返回信息',\\n  `status` tinyint(4) DEFAULT '0' COMMENT '0:未处理或者失败;1:成功;2:明确失败(不重试);3:业务明确成功;4:异常退款;5:退款成功;6:退款失败;7:已使用',\\n  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '记录创建时间',\\n  `lastModifyTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '记录更改时间',\\n  `reqNum` int(11) DEFAULT '0' COMMENT '请求次数',\\n  `queryNum` int(11) DEFAULT '0' COMMENT '查询次数',\\n  `orderNo` varchar(255) DEFAULT NULL COMMENT '外部权益服务订单号',\\n  `mobile` varchar(25) DEFAULT NULL COMMENT '手机号',\\n  `thirdOrderNo` varchar(30) DEFAULT NULL COMMENT '第三方订单号（海威版本加的）',\\n  `url` varchar(700) DEFAULT NULL COMMENT '链接',\\n  `notifyUrl` varchar(255) DEFAULT NULL COMMENT '回调通知地址',\\n  `refundMsg` varchar(255) DEFAULT NULL COMMENT '退款返回信息',\\n  `refundSuccessTime` datetime DEFAULT NULL COMMENT '退款成功时间',\\n  PRIMARY KEY (`ID`),\\n  KEY `record_mebId_index` (`mebId`),\\n  KEY `record_foreignKey_index` (`foreignKey`),\\n  KEY `create_time_index` (`createTime`),\\n  KEY `index_status` (`status`) USING BTREE,\\n  KEY `index_jjid` (`jjid`) USING BTREE,\\n  KEY `index_benefitId_app_id` (`benefitId`,`appId`) USING BTREE,\\n  KEY `ix_moblie` (`mobile`),\\n  KEY `ix_thirdOrderNo` (`thirdOrderNo`)\\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8 COMMENT='权益激活记录'\", \"sql\": \"SELECT\\n  *\\nFROM\\n  `benefit_acticvate_record`\\nWHERE\\n  `reqArgs` LIKE '%Wehotel171450540847226847533%'\\nLIMIT\\n  0, 1000;\", \"columns_selectivity\": \"{\\n    \\\"benefit_acticvate_record\\\": [\\n        {\\n            \\\"reqArgs\\\": 43.0000%\\n        }\\n    ]\\n}\", \"explain\": \"{\\n  \\\"ClassicResult\\\" : {\\n    \\\"Columns\\\" : [ {\\n      \\\"Name\\\" : \\\"id\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"select_type\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"table\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"partitions\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"type\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"possible_keys\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"key\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"key_len\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"ref\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"rows\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"filtered\\\",\\n      \\\"I18nDesc\\\" : null\\n    }, {\\n      \\\"Name\\\" : \\\"Extra\\\",\\n      \\\"I18nDesc\\\" : null\\n    } ],\\n    \\\"Rows\\\" : [ [ \\\"1\\\", \\\"SIMPLE\\\", \\\"benefit_acticvate_record\\\", \\\"\\\", \\\"ALL\\\", \\\"\\\", \\\"\\\", \\\"\\\", \\\"\\\", \\\"987588\\\", \\\"11.11\\\", \\\"Using where\\\" ]]\\n  }\\n}\", \"expected\": \"like前后模糊无法走索引，无法通过索引解决SQL性能问题，可以考虑全文索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE `benefit_acticvate_record` (\n  `ID` int(11) NOT NULL AUTO_INCREMENT COMMENT '记录id',\n  `jjid` bigint(20) NOT NULL DEFAULT '0' COMMENT '会员用户id',\n  `mebId` int(11) NOT NULL DEFAULT '0' COMMENT '会员ID',\n  `foreignKey` varchar(200) NOT NULL DEFAULT '0' COMMENT '外键',\n  `benefitId` int(11) NOT NULL DEFAULT '0' COMMENT '权益ID',\n  `appId` int(11) NOT NULL DEFAULT '0' COMMENT '应用appId',\n  `reqArgs` varchar(500) NOT NULL DEFAULT '0' COMMENT '请求外部权益参数，用于重试',\n  `coupon` varchar(300) DEFAULT NULL COMMENT '外部返回券码',\n  `msg` varchar(100) DEFAULT NULL COMMENT '外部接口返回信息',\n  `status` tinyint(4) DEFAULT '0' COMMENT '0:未处理或者失败;1:成功;2:明确失败(不重试);3:业务明确成功;4:异常退款;5:退款成功;6:退款失败;7:已使用',\n  `createTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '记录创建时间',\n  `lastModifyTime` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '记录更改时间',\n  `reqNum` int(11) DEFAULT '0' COMMENT '请求次数',\n  `queryNum` int(11) DEFAULT '0' COMMENT '查询次数',\n  `orderNo` varchar(255) DEFAULT NULL COMMENT '外部权益服务订单号',\n  `mobile` varchar(25) DEFAULT NULL COMMENT '手机号',\n  `thirdOrderNo` varchar(30) DEFAULT NULL COMMENT '第三方订单号（海威版本加的）',\n  `url` varchar(700) DEFAULT NULL COMMENT '链接',\n  `notifyUrl` varchar(255) DEFAULT NULL COMMENT '回调通知地址',\n  `refundMsg` varchar(255) DEFAULT NULL COMMENT '退款返回信息',\n  `refundSuccessTime` datetime DEFAULT NULL COMMENT '退款成功时间',\n  PRIMARY KEY (`ID`),\n  KEY `record_mebId_index` (`mebId`),\n  KEY `record_foreignKey_index` (`foreignKey`),\n  KEY `create_time_index` (`createTime`),\n  KEY `index_status` (`status`) USING BTREE,\n  KEY `index_jjid` (`jjid`) USING BTREE,\n  KEY `index_benefitId_app_id` (`benefitId`,`appId`) USING BTREE,\n  KEY `ix_moblie` (`mobile`),\n  KEY `ix_thirdOrderNo` (`thirdOrderNo`)\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8 COMMENT='权益激活记录'\n\n## EXPLAIN:\n{\n  \"ClassicResult\" : {\n    \"Columns\" : [ {\n      \"Name\" : \"id\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"select_type\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"table\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"partitions\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"type\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"possible_keys\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"key\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"key_len\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"ref\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"rows\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"filtered\",\n      \"I18nDesc\" : null\n    }, {\n      \"Name\" : \"Extra\",\n      \"I18nDesc\" : null\n    } ],\n    \"Rows\" : [ [ \"1\", \"SIMPLE\", \"benefit_acticvate_record\", \"\", \"ALL\", \"\", \"\", \"\", \"\", \"987588\", \"11.11\", \"Using where\" ]]\n  }\n}\n\n## Column Selectivity:\n{\n    \"benefit_acticvate_record\": [\n        {\n            \"reqArgs\": 43.0000%\n        }\n    ]\n}\n\n## Original SQL:\nSELECT\n  *\nFROM\n  `benefit_acticvate_record`\nWHERE\n  `reqArgs` LIKE '%Wehotel171450540847226847533%'\nLIMIT\n  0, 1000;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "Unable to solve SQL performance issues by creating indexes. Reason: The LIKE pattern with a leading wildcard ('%...%') cannot be efficiently utilized by standard B-tree indexes, as they require a fixed left-most prefix for pattern matching; consider using full-text search or restructuring the query logic instead."
                    }
                ]
            },
            {
                "case_id": "11",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"11\", \"difficulty_level\": \"3\", \"description\": \"业务case-测试OR\", \"create_table_statements\": \"CREATE TABLE `document` (\\n  `id` bigint(20) NOT NULL COMMENT '文档ID',\\n  `title` varchar(500) DEFAULT NULL COMMENT '文档名称',\\n  `pdfKey` varchar(100) DEFAULT NULL COMMENT '转换为pdf后的文件标识',\\n  `type` varchar(15) NOT NULL COMMENT '文档来源类型',\\n  `pages` int(5) DEFAULT NULL COMMENT '总页数',\\n  `sizes` int(11) DEFAULT NULL COMMENT '文件大小',\\n  `businessId` bigint(20) DEFAULT NULL COMMENT '关联的业务ID，如合同ID',\\n  `createTime` datetime NOT NULL COMMENT '创建时间',\\n  `pixelWidth` double DEFAULT NULL COMMENT '页宽',\\n  `pixelHeight` double DEFAULT NULL COMMENT '页高',\\n  `fileKey` varchar(100) DEFAULT NULL COMMENT '原文件标识',\\n  `origin` bigint(20) DEFAULT NULL COMMENT '原文件ID',\\n  `documentType` varchar(10) NOT NULL DEFAULT 'UPLOAD' COMMENT '文档类型',\\n  `antifakeCode` varchar(10) DEFAULT NULL COMMENT '防伪码',\\n  `usages` varchar(20) DEFAULT 'NORMAL' COMMENT '文件用途（NORMAL合同正文,SPONSOR_FILE发起方内部可见文档,TERMINATION作废声明,OFFLINE线下签署文件,ATTACHMENT附件EVIDENCE存证报告）',\\n  `htmlKey` varchar(100) DEFAULT NULL COMMENT 'HTML模板文件',\\n  `documentSort` int(11) DEFAULT NULL COMMENT '前端页面文档的排列顺序',\\n  `convertStrategy` varchar(20) DEFAULT NULL COMMENT '文件转换策略',\\n  `needUpdatePdf` tinyint(1) DEFAULT '0' COMMENT '是否需要更新PDF',\\n  `modifyHtml` tinyint(1) DEFAULT NULL COMMENT '是否允许HTML原文修改 ',\\n  `status` varchar(20) DEFAULT NULL COMMENT '文档状态',\\n  `creatorId` bigint(20) DEFAULT NULL COMMENT '创建者id',\\n  `signatoryId` bigint(20) DEFAULT NULL COMMENT '用于接收方上传附件,附件和签署方绑定',\\n  `signed` tinyint(1) DEFAULT NULL COMMENT '附件是否被签署',\\n  `headKey` varchar(50) DEFAULT NULL COMMENT 'HTML模版页眉文件',\\n  `footKey` varchar(50) DEFAULT NULL COMMENT 'HTML模版页脚文件',\\n  `backupKey` varchar(100) DEFAULT NULL COMMENT '备份文件标识',\\n  `attachId` bigint(20) DEFAULT NULL COMMENT '附件规则id',\\n  `fileHash` varchar(256) DEFAULT NULL,\\n  `originType` varchar(20) DEFAULT NULL COMMENT '文件原类型',\\n  `openDiyTitle` tinyint(4) DEFAULT NULL COMMENT '接口传递自定义标题',\\n  `noCertSign` tinyint(1) DEFAULT NULL COMMENT '是否无证书签署',\\n  `noCertDocId` bigint(20) DEFAULT NULL COMMENT '隐藏参数文档id',\\n  `operatorType` varchar(50) DEFAULT NULL COMMENT '隐藏参数的角色类型',\\n  `hideParamNames` varchar(500) DEFAULT NULL COMMENT '隐藏参数的名称',\\n  `readOnlyDocumentId` bigint(20) DEFAULT NULL COMMENT '隐藏非只读参数文档id',\\n  `jsonKey` varchar(100) DEFAULT NULL COMMENT 'json在文件服务器标识',\\n  `transientDocumentId` varchar(1024) DEFAULT NULL COMMENT 'Adobe文件id',\\n  `adobeDocumentId` varchar(256) DEFAULT NULL COMMENT 'Adobe文件库id',\\n  `mergeDocId` bigint(20) DEFAULT NULL COMMENT '合并后的文档ID',\\n  `atomizationDocId` bigint(20) DEFAULT NULL COMMENT '雾化文档id',\\n  `titleRule` varchar(500) DEFAULT NULL COMMENT '标题规则',\\n  `titleRuleType` tinyint(1) DEFAULT NULL COMMENT '标题规则类型',\\n  `oldTitle` varchar(500) DEFAULT NULL COMMENT '旧标题，非模板命名规则文档使用',\\n  `appId` bigint(20) DEFAULT NULL COMMENT '应用ID，即AppToken.id',\\n  `ownerPassword` varchar(20) DEFAULT NULL COMMENT '编辑密码',\\n  PRIMARY KEY (`id`) USING BTREE,\\n  KEY `IDX_DOC_PDFKEY` (`pdfKey`) USING BTREE,\\n  KEY `IDX_DOCUMENT_BUSINESS` (`businessId`) USING BTREE,\\n  KEY `IDX_ORIGIN` (`origin`),\\n  KEY `IDX_DOCUMENT_SIGNID` (`signatoryId`),\\n  KEY `IDX_NOCERTDOCID_READONLYDOCUMENTID` (`noCertDocId`,`readOnlyDocumentId`),\\n  KEY `IDX_MERGEDOCID` (`mergeDocId`),\\n  KEY `IDX_DOC_FILEKEY` (`fileKey`),\\n  KEY `ix_02` (`businessId`,`createTime`)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='文档信息表'\", \"sql\": \"SELECT\\n  *\\nfrom\\n  DOCUMENT\\nwhere\\n  (\\n    pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'\\n    or fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'\\n  );\", \"columns_selectivity\": \"\", \"explain\": \"{\\n        \\\"explain SELECT \\\\r\\\\n  * \\\\r\\\\nfrom \\\\r\\\\n  DOCUMENT \\\\r\\\\nwhere \\\\r\\\\n  (\\\\r\\\\n    pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne' \\\\r\\\\n    or fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'\\\\r\\\\n  )\\\": [\\n         {\\n          \\\"id\\\" : 1,\\n          \\\"select_type\\\" : \\\"SIMPLE\\\",\\n          \\\"table\\\" : \\\"DOCUMENT\\\",\\n          \\\"partitions\\\" : null,\\n          \\\"type\\\" : \\\"index_merge\\\",\\n          \\\"possible_keys\\\" : \\\"IDX_DOC_PDFKEY,IDX_DOC_FILEKEY\\\",\\n          \\\"key\\\" : \\\"IDX_DOC_PDFKEY,IDX_DOC_FILEKEY\\\",\\n          \\\"key_len\\\" : \\\"403,403\\\",\\n          \\\"ref\\\" : null,\\n          \\\"rows\\\" : 2,\\n          \\\"filtered\\\" : 100.0,\\n          \\\"Extra\\\" : \\\"Using union(IDX_DOC_PDFKEY,IDX_DOC_FILEKEY); Using where\\\"\\n         }\\n        ]}\", \"expected\": \"使用了index merge 当前查询性能满足要求，无需创建新索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE `document` (\n  `id` bigint(20) NOT NULL COMMENT '文档ID',\n  `title` varchar(500) DEFAULT NULL COMMENT '文档名称',\n  `pdfKey` varchar(100) DEFAULT NULL COMMENT '转换为pdf后的文件标识',\n  `type` varchar(15) NOT NULL COMMENT '文档来源类型',\n  `pages` int(5) DEFAULT NULL COMMENT '总页数',\n  `sizes` int(11) DEFAULT NULL COMMENT '文件大小',\n  `businessId` bigint(20) DEFAULT NULL COMMENT '关联的业务ID，如合同ID',\n  `createTime` datetime NOT NULL COMMENT '创建时间',\n  `pixelWidth` double DEFAULT NULL COMMENT '页宽',\n  `pixelHeight` double DEFAULT NULL COMMENT '页高',\n  `fileKey` varchar(100) DEFAULT NULL COMMENT '原文件标识',\n  `origin` bigint(20) DEFAULT NULL COMMENT '原文件ID',\n  `documentType` varchar(10) NOT NULL DEFAULT 'UPLOAD' COMMENT '文档类型',\n  `antifakeCode` varchar(10) DEFAULT NULL COMMENT '防伪码',\n  `usages` varchar(20) DEFAULT 'NORMAL' COMMENT '文件用途（NORMAL合同正文,SPONSOR_FILE发起方内部可见文档,TERMINATION作废声明,OFFLINE线下签署文件,ATTACHMENT附件EVIDENCE存证报告）',\n  `htmlKey` varchar(100) DEFAULT NULL COMMENT 'HTML模板文件',\n  `documentSort` int(11) DEFAULT NULL COMMENT '前端页面文档的排列顺序',\n  `convertStrategy` varchar(20) DEFAULT NULL COMMENT '文件转换策略',\n  `needUpdatePdf` tinyint(1) DEFAULT '0' COMMENT '是否需要更新PDF',\n  `modifyHtml` tinyint(1) DEFAULT NULL COMMENT '是否允许HTML原文修改 ',\n  `status` varchar(20) DEFAULT NULL COMMENT '文档状态',\n  `creatorId` bigint(20) DEFAULT NULL COMMENT '创建者id',\n  `signatoryId` bigint(20) DEFAULT NULL COMMENT '用于接收方上传附件,附件和签署方绑定',\n  `signed` tinyint(1) DEFAULT NULL COMMENT '附件是否被签署',\n  `headKey` varchar(50) DEFAULT NULL COMMENT 'HTML模版页眉文件',\n  `footKey` varchar(50) DEFAULT NULL COMMENT 'HTML模版页脚文件',\n  `backupKey` varchar(100) DEFAULT NULL COMMENT '备份文件标识',\n  `attachId` bigint(20) DEFAULT NULL COMMENT '附件规则id',\n  `fileHash` varchar(256) DEFAULT NULL,\n  `originType` varchar(20) DEFAULT NULL COMMENT '文件原类型',\n  `openDiyTitle` tinyint(4) DEFAULT NULL COMMENT '接口传递自定义标题',\n  `noCertSign` tinyint(1) DEFAULT NULL COMMENT '是否无证书签署',\n  `noCertDocId` bigint(20) DEFAULT NULL COMMENT '隐藏参数文档id',\n  `operatorType` varchar(50) DEFAULT NULL COMMENT '隐藏参数的角色类型',\n  `hideParamNames` varchar(500) DEFAULT NULL COMMENT '隐藏参数的名称',\n  `readOnlyDocumentId` bigint(20) DEFAULT NULL COMMENT '隐藏非只读参数文档id',\n  `jsonKey` varchar(100) DEFAULT NULL COMMENT 'json在文件服务器标识',\n  `transientDocumentId` varchar(1024) DEFAULT NULL COMMENT 'Adobe文件id',\n  `adobeDocumentId` varchar(256) DEFAULT NULL COMMENT 'Adobe文件库id',\n  `mergeDocId` bigint(20) DEFAULT NULL COMMENT '合并后的文档ID',\n  `atomizationDocId` bigint(20) DEFAULT NULL COMMENT '雾化文档id',\n  `titleRule` varchar(500) DEFAULT NULL COMMENT '标题规则',\n  `titleRuleType` tinyint(1) DEFAULT NULL COMMENT '标题规则类型',\n  `oldTitle` varchar(500) DEFAULT NULL COMMENT '旧标题，非模板命名规则文档使用',\n  `appId` bigint(20) DEFAULT NULL COMMENT '应用ID，即AppToken.id',\n  `ownerPassword` varchar(20) DEFAULT NULL COMMENT '编辑密码',\n  PRIMARY KEY (`id`) USING BTREE,\n  KEY `IDX_DOC_PDFKEY` (`pdfKey`) USING BTREE,\n  KEY `IDX_DOCUMENT_BUSINESS` (`businessId`) USING BTREE,\n  KEY `IDX_ORIGIN` (`origin`),\n  KEY `IDX_DOCUMENT_SIGNID` (`signatoryId`),\n  KEY `IDX_NOCERTDOCID_READONLYDOCUMENTID` (`noCertDocId`,`readOnlyDocumentId`),\n  KEY `IDX_MERGEDOCID` (`mergeDocId`),\n  KEY `IDX_DOC_FILEKEY` (`fileKey`),\n  KEY `ix_02` (`businessId`,`createTime`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='文档信息表'\n\n## EXPLAIN:\n{\n        \"explain SELECT \\r\\n  * \\r\\nfrom \\r\\n  DOCUMENT \\r\\nwhere \\r\\n  (\\r\\n    pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne' \\r\\n    or fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'\\r\\n  )\": [\n         {\n          \"id\" : 1,\n          \"select_type\" : \"SIMPLE\",\n          \"table\" : \"DOCUMENT\",\n          \"partitions\" : null,\n          \"type\" : \"index_merge\",\n          \"possible_keys\" : \"IDX_DOC_PDFKEY,IDX_DOC_FILEKEY\",\n          \"key\" : \"IDX_DOC_PDFKEY,IDX_DOC_FILEKEY\",\n          \"key_len\" : \"403,403\",\n          \"ref\" : null,\n          \"rows\" : 2,\n          \"filtered\" : 100.0,\n          \"Extra\" : \"Using union(IDX_DOC_PDFKEY,IDX_DOC_FILEKEY); Using where\"\n         }\n        ]}\n\n## Column Selectivity:\n\n\n## Original SQL:\nSELECT\n  *\nfrom\n  DOCUMENT\nwhere\n  (\n    pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'\n    or fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'\n  );\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "No performance issues; no indexes need to be created.\n\n**Reasoning:** The query is already using an efficient index_merge strategy with the existing indexes (IDX_DOC_PDFKEY and IDX_DOC_FILEKEY). The EXPLAIN shows only 2 rows are examined with 100% filter efficiency, indicating good selectivity. For OR conditions on different columns, the current index_merge union approach is optimal, and creating additional indexes would provide no performance benefit."
                    }
                ]
            },
            {
                "case_id": "12",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"12\", \"difficulty_level\": \"1\", \"description\": \"单表等值简单查询-简单等值条件查询，单列索引和避免重复索引\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * FROM users WHERE username = 'user_98000';\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |         10 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"给 users 表的 username 列加索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |         10 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"users\":{\"username\":100%}}\n\n## Original SQL:\nSELECT * FROM users WHERE username = 'user_98000';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_username ON users(username); Reason: Single-column index - enables efficient equality lookup on the highly selective username column instead of a full table scan."
                    }
                ]
            },
            {
                "case_id": "13",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"13\", \"difficulty_level\": \"1\", \"description\": \"单表等值简单查询-简单等值条件查询，单列索引和避免重复索引\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * FROM users WHERE email = 'user_1193@test.com';\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"email\\\":100%}}\", \"explain\": \"|id |select_type|table|partitions|type |possible_keys|key  |key_len|ref  |rows|filtered|Extra|\\n|---|-----------|-----|----------|-----|-------------|-----|-------|-----|----|--------|-----|\\n|1  |SIMPLE     |users|          |const|email        |email|803    |const|1   |100     |     |\", \"expected\": \"users 表的 email 列已有唯一索引，对于该查询无需创建新的索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n|id |select_type|table|partitions|type |possible_keys|key  |key_len|ref  |rows|filtered|Extra|\n|---|-----------|-----|----------|-----|-------------|-----|-------|-----|----|--------|-----|\n|1  |SIMPLE     |users|          |const|email        |email|803    |const|1   |100     |     |\n\n## Column Selectivity:\n{\"users\":{\"email\":100%}}\n\n## Original SQL:\nSELECT * FROM users WHERE email = 'user_1193@test.com';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "No performance issues; no indexes need to be created."
                    }
                ]
            },
            {
                "case_id": "14",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"14\", \"difficulty_level\": \"1\", \"description\": \"单表等值简单查询-索引长度不合理\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0,\\n  KEY `idx_username` (`username`(2))\\n);\", \"sql\": \"SELECT * FROM users WHERE username = 'user_98000';\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"username\\\":100%}}\", \"explain\": \"|id |select_type|table|partitions|type|possible_keys|key      |key_len|ref  |rows  |filtered|Extra      |\\n|---|-----------|-----|----------|----|-------------|---------|-------|-----|------|--------|-----------|\\n|1  |SIMPLE     |users|          |ref |idx_users    |idx_users|10     |const|49,791|100     |Using where|\", \"expected\": \"idx_username索引长度太短，导致扫描行数过多，需要重建idx_username索引，删除原有users表idx_username索引并在username列添加默认长度的索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0,\n  KEY `idx_username` (`username`(2))\n);\n\n## EXPLAIN:\n|id |select_type|table|partitions|type|possible_keys|key      |key_len|ref  |rows  |filtered|Extra      |\n|---|-----------|-----|----------|----|-------------|---------|-------|-----|------|--------|-----------|\n|1  |SIMPLE     |users|          |ref |idx_users    |idx_users|10     |const|49,791|100     |Using where|\n\n## Column Selectivity:\n{\"users\":{\"username\":100%}}\n\n## Original SQL:\nSELECT * FROM users WHERE username = 'user_98000';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_username_full ON users(username); Reason: Single-column index - The existing prefix index on username (first 2 characters) is insufficiently selective for equality filtering, examining 49,791 rows instead of the optimal 1 for a unique username value; a full-column index is required."
                    }
                ]
            },
            {
                "case_id": "15",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"15\", \"difficulty_level\": \"1\", \"description\": \"单表，范围查询-BETWEEN...AND...范围列可以加索引\", \"create_table_statements\": \"CREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\", \"sql\": \"SELECT * FROM orders WHERE pay_time \\nBETWEEN '2025-08-01 00:00:00' AND '2025-8-31 23:59:59' limit 10;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"pay_time\\\":35.23%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |      11.11 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"给 orders 表的 pay_time 列加索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |      11.11 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"orders\":{\"pay_time\":35.23%}}\n\n## Original SQL:\nSELECT * FROM orders WHERE pay_time \nBETWEEN '2025-08-01 00:00:00' AND '2025-8-31 23:59:59' limit 10;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_pay_time ON orders(pay_time); Reason: Single-column index - This index on pay_time enables efficient range filtering for the BETWEEN condition, allowing the database to quickly locate matching rows without performing a full table scan on 497K rows, and retrieve only the needed 10 rows efficiently."
                    }
                ]
            },
            {
                "case_id": "16",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"16\", \"difficulty_level\": \"1\", \"description\": \"单表，范围查询->=、<= 列加索引\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * FROM users WHERE points >= 1000 AND points <= 2000  limit 10;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"points\\\":19.882%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      11.11 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"给 users 表的 points 列加索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      11.11 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"users\":{\"points\":19.882%}}\n\n## Original SQL:\nSELECT * FROM users WHERE points >= 1000 AND points <= 2000  limit 10;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_points ON users(points); Reason: Single-column index - enables efficient range scan on points column instead of full table scan, avoiding examination of all 99,553 rows."
                    }
                ]
            },
            {
                "case_id": "17",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"17\", \"difficulty_level\": \"1\", \"description\": \"单表，范围查询->=、<= 列加索引\", \"create_table_statements\": \"CREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT user_id, ip_address, response_time_ms FROM access_logs WHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY);\", \"columns_selectivity\": \"{\\\"access_logs\\\":{\\\"created_at\\\":0.038%,\\\"ip_address\\\":69.552%,\\\"response_time_ms\\\":6%,\\\"user_id\\\":78.36%}}\", \"explain\": \"+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-------------+\\n|   id | select_type   | table       | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra       |\\n+======+===============+=============+==============+========+=================+=======+===========+=======+=========+============+=============+\\n|    1 | SIMPLE        | access_logs | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |      33.33 | Using where |\\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-------------+\", \"expected\": \"以下两种情况均可：\\n给 access_logs 表的 created_at 列创建单列索引\\n给 access_logs 表的 created_at, user_id, ip_address, response_time_ms列创建覆盖索引，且顺序要created_at为最左列\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-------------+\n|   id | select_type   | table       | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra       |\n+======+===============+=============+==============+========+=================+=======+===========+=======+=========+============+=============+\n|    1 | SIMPLE        | access_logs | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |      33.33 | Using where |\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-------------+\n\n## Column Selectivity:\n{\"access_logs\":{\"created_at\":0.038%,\"ip_address\":69.552%,\"response_time_ms\":6%,\"user_id\":78.36%}}\n\n## Original SQL:\nSELECT user_id, ip_address, response_time_ms FROM access_logs WHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY);\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_created_at ON access_logs(created_at, user_id, ip_address, response_time_ms); Reason: Covering index - enables efficient range scan on created_at while retrieving all required columns directly from the index without table lookups."
                    }
                ]
            },
            {
                "case_id": "18",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"18\", \"difficulty_level\": \"1\", \"description\": \"单表，简单分组、排序查询-给分组/排序列加索引，以消除文件排序\", \"create_table_statements\": \"CREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT * FROM access_logs ORDER BY created_at DESC LIMIT 1000;\", \"columns_selectivity\": \"{\\\"access_logs\\\":{\\\"created_at\\\":1.3960%}}\", \"explain\": \"+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+----------------+\\n|   id | select_type   | table       | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra          |\\n+======+===============+=============+==============+========+=================+=======+===========+=======+=========+============+================+\\n|    1 | SIMPLE        | access_logs | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |        100 | Using filesort |\\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+----------------+\", \"expected\": \"给 access_logs 表的 created_at 列加索引，消除文件排序\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+----------------+\n|   id | select_type   | table       | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra          |\n+======+===============+=============+==============+========+=================+=======+===========+=======+=========+============+================+\n|    1 | SIMPLE        | access_logs | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |        100 | Using filesort |\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+----------------+\n\n## Column Selectivity:\n{\"access_logs\":{\"created_at\":1.3960%}}\n\n## Original SQL:\nSELECT * FROM access_logs ORDER BY created_at DESC LIMIT 1000;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_created_at ON access_logs(created_at); Reason: Single-column index - eliminates filesort and full table scan for efficient ORDER BY DESC processing."
                    }
                ]
            },
            {
                "case_id": "19",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"19\", \"difficulty_level\": \"1\", \"description\": \"单表，简单分组、排序查询-给分组/排序列加索引，以消除文件排序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT gender, COUNT(*) AS user_count FROM users GROUP BY gender;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"gender\\\":0.006%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+---------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                           |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=================================+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |        100 | Using temporary; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+---------------------------------+\", \"expected\": \"给 users 表的 gender 列加索引，消除临时表和文件排序\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+---------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                           |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=================================+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |        100 | Using temporary; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+---------------------------------+\n\n## Column Selectivity:\n{\"users\":{\"gender\":0.006%}}\n\n## Original SQL:\nSELECT gender, COUNT(*) AS user_count FROM users GROUP BY gender;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_gender ON users(gender); Reason: Single-column index - enables efficient GROUP BY operation by eliminating filesort and temporary table creation through sorted index access."
                    }
                ]
            },
            {
                "case_id": "20",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"20\", \"difficulty_level\": \"1\", \"description\": \"单表，简单分组、排序查询-给分组/排序列加索引，以消除文件排序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT register_channel, COUNT(*) AS user_count\\nFROM users\\nGROUP BY register_channel;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"register_channel\\\":0.006%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+---------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                           |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=================================+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |        100 | Using temporary; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+---------------------------------+\", \"expected\": \"给 users 表的 register_channel 列加索引，消除临时表和文件排序\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+---------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                           |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=================================+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |        100 | Using temporary; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+---------------------------------+\n\n## Column Selectivity:\n{\"users\":{\"register_channel\":0.006%}}\n\n## Original SQL:\nSELECT register_channel, COUNT(*) AS user_count\nFROM users\nGROUP BY register_channel;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_register_channel ON users(register_channel); Reason: Single-column index - enables efficient GROUP BY operation by providing sorted order to eliminate temporary table and filesort operations."
                    }
                ]
            },
            {
                "case_id": "21",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"21\", \"difficulty_level\": \"1\", \"description\": \"单表，or 条件-无法通过索引解决性能场景，OR 条件导致索引失效\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * FROM users \\nWHERE gender = 1 OR register_channel = 'Web';\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"gender\\\":0.006%,\\\"register_channel\\\":0.006%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |         19 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"以下两种情况均可:\\n1. 无法通过索引解决SQL性能问题，OR条件列通常无法充分利用索引\\n2. 分别给users表的register_channel，gender列添加单列索引，优化器可能会利用index merge合并索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |         19 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"users\":{\"gender\":0.006%,\"register_channel\":0.006%}}\n\n## Original SQL:\nSELECT * FROM users \nWHERE gender = 1 OR register_channel = 'Web';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_gender ON users(gender); CREATE INDEX idx_register_channel ON users(register_channel); Reason: Single-column index - enables index merge optimization for the OR condition, allowing MySQL to combine indexed results instead of performing a full table scan of 99,553 rows."
                    }
                ]
            },
            {
                "case_id": "22",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"22\", \"difficulty_level\": \"1\", \"description\": \"单表，or 条件-无法通过索引解决性能场景，OR 条件导致索引失效\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * FROM users \\nWHERE vip_level = 3 OR last_login < '2023-01-01';\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"last_login\\\":35.294%,\\\"vip_level\\\":0.012%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |         40 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"以下两种情况均可:\\n1. 无法通过索引解决SQL性能问题，OR条件列通常无法充分利用索引\\n2. 分别给users表的vip_level，last_login列添加单列索引，优化器可能会利用index merge合并索引\\n3. 给users表的last_login列添加单列索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |         40 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"users\":{\"last_login\":35.294%,\"vip_level\":0.012%}}\n\n## Original SQL:\nSELECT * FROM users \nWHERE vip_level = 3 OR last_login < '2023-01-01';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_vip_level ON users(vip_level); CREATE INDEX idx_last_login ON users(last_login); Reason: Single-column indexes - enables MySQL to use index_merge strategy for the OR condition, efficiently retrieving rows matching either condition instead of performing a full table scan of 99,553 rows."
                    }
                ]
            },
            {
                "case_id": "23",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"23\", \"difficulty_level\": \"1\", \"description\": \"单表，or 条件-无法通过索引解决性能场景，OR 条件导致索引失效\", \"create_table_statements\": \"CREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\", \"sql\": \"SELECT * FROM products \\nWHERE stock > 100 OR weight < 1.0;\", \"columns_selectivity\": \"{\\\"products\\\":{\\\"stock\\\":10%,\\\"weight\\\":5.01%}}\", \"explain\": \"+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | products | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |      55.55 | Using where |\\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"以下两种情况均可：\\n1. 不能通过索引解决SQL中存在性能问题\\n2. 分别给products表的stock和weight创建单列索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\n\n## EXPLAIN:\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | products | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |      55.55 | Using where |\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"products\":{\"stock\":10%,\"weight\":5.01%}}\n\n## Original SQL:\nSELECT * FROM products \nWHERE stock > 100 OR weight < 1.0;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_stock ON products(stock); CREATE INDEX idx_weight ON products(weight); Reason: Single-column indexes - enable index merge optimization to efficiently process OR condition and avoid full table scan."
                    }
                ]
            },
            {
                "case_id": "24",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"24\", \"difficulty_level\": \"1\", \"description\": \"单表，or 条件-无法通过索引解决性能场景，OR 条件导致索引失效\", \"create_table_statements\": \"CREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\", \"sql\": \"SELECT * FROM products WHERE price > 500 AND price < 1000 OR weight > 5.0;\", \"columns_selectivity\": \"{\\\"products\\\":{\\\"price\\\":97.37%,\\\"weight\\\":5.01%}}\", \"explain\": \"+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | products | NULL         | ALL    | idx_p           | NULL  | NULL      | NULL  |   9836 |      40.74 | Using where |\\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"以下两种情况均可：\\n1. 不能通过索引解决SQL中存在性能问题\\n2. 列分给products表的price列和weight列创建单列索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\n\n## EXPLAIN:\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | products | NULL         | ALL    | idx_p           | NULL  | NULL      | NULL  |   9836 |      40.74 | Using where |\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"products\":{\"price\":97.37%,\"weight\":5.01%}}\n\n## Original SQL:\nSELECT * FROM products WHERE price > 500 AND price < 1000 OR weight > 5.0;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_price ON products(price); CREATE INDEX idx_weight ON products(weight); Reason: Single-column indexes - enable index merging optimization for the OR condition across different columns, reducing full table scan overhead."
                    }
                ]
            },
            {
                "case_id": "25",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"25\", \"difficulty_level\": \"2\", \"description\": \"单表，多条件查询-复合索引中列的顺序，要求从左到右等值列在前，范围列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * \\nFROM users \\nWHERE gender = 1 \\n  AND birthdate BETWEEN '1990-01-01' AND '2000-12-31';\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"birthdate\\\":19.876%,\\\"gender\\\":0.006%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |       1.11 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"以下两种情况均可：\\n1. 在 users 表的 gender 列和 birthdate 创建复合索引，注意 gender 列一定在最左边\\n2. 在 users 表的 birthdate 创建单列索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |       1.11 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"users\":{\"birthdate\":19.876%,\"gender\":0.006%}}\n\n## Original SQL:\nSELECT * \nFROM users \nWHERE gender = 1 \n  AND birthdate BETWEEN '1990-01-01' AND '2000-12-31';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_gender_birthdate ON users(gender, birthdate); Reason: Composite index - enables index range scan on both gender equality and birthdate range conditions to replace the current full table scan."
                    }
                ]
            },
            {
                "case_id": "26",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"26\", \"difficulty_level\": \"2\", \"description\": \"单表，多条件查询-复合索引中列的顺序，要求从左到右等值列在前，范围列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\", \"sql\": \"SELECT * \\nFROM products \\nWHERE category_id = 5 \\n  AND is_imported = 1 \\n  AND stock < 10;\", \"columns_selectivity\": \"{\\\"products\\\":{\\\"category_id\\\":0.2%,\\\"is_imported\\\":0.02%,\\\"stock\\\":10%}}\", \"explain\": \"+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | products | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |       0.33 | Using where |\\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"以下三种情况均可：\\n1. 在 products 表的 category_id 列和 is_imported 列和 stock 列创建复合索引，注意列顺序依次为 category_id，is_imported，stock\\n2. 在products表的stock列创建单列索引\\n3.表数据量较小，无性能问题\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\n\n## EXPLAIN:\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | products | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |       0.33 | Using where |\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"products\":{\"category_id\":0.2%,\"is_imported\":0.02%,\"stock\":10%}}\n\n## Original SQL:\nSELECT * \nFROM products \nWHERE category_id = 5 \n  AND is_imported = 1 \n  AND stock < 10;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_products_imported_category_stock ON products(is_imported, category_id, stock); Reason: Composite index - efficiently filters on multiple WHERE clause columns (is_imported, category_id, stock) to avoid full table scan of 9,836 rows."
                    }
                ]
            },
            {
                "case_id": "27",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"27\", \"difficulty_level\": \"2\", \"description\": \"单表，多条件查询-复合索引中列的顺序，要求从左到右等值列在前，范围列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\", \"sql\": \"SELECT * \\nFROM orders \\nWHERE pay_time BETWEEN '2025-08-10' AND '2025-09-20'\\n  AND amount > 1000 \\n  AND currency = 'CNY';\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"pay_time\\\":35.2300%,\\\"amount\\\":94.2960%,\\\"currency\\\":0.0020%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |       0.37 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"两种方式均可：\\n1. 在orders表的pay_time,currency列创建复合索引，且要求pay_time在最左列\\n2.在orders表的pay_time,amount列创建复合索引，且要求列顺序为：pay_time，amount\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |       0.37 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"orders\":{\"pay_time\":35.2300%,\"amount\":94.2960%,\"currency\":0.0020%}}\n\n## Original SQL:\nSELECT * \nFROM orders \nWHERE pay_time BETWEEN '2025-08-10' AND '2025-09-20'\n  AND amount > 1000 \n  AND currency = 'CNY';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_where_conditions ON orders(currency, pay_time, amount); Reason: Composite index - replaces full table scan (497,490 rows) with efficient index-based filtering on the three WHERE clause conditions, reducing scan to approximately 1,840 matching rows."
                    }
                ]
            },
            {
                "case_id": "28",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"28\", \"difficulty_level\": \"2\", \"description\": \"单表，多条件查询-复合索引中列的顺序，要求从左到右等值列在前，范围列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\", \"sql\": \"SELECT * \\nFROM products \\nWHERE stock > 100 \\n  AND weight < 5.0 \\n  AND is_imported = 1;\", \"columns_selectivity\": \"{\\\"products\\\":{\\\"is_imported\\\":0.02%,\\\"stock\\\":10%,\\\"weight\\\":5.01%}}\", \"explain\": \"+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | products | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |       1.11 | Using where |\\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"三种情况均可：\\n1. 在 products 表的 is_imported 列和 weight 列创建复合索引，注意 is_imported 一定在最左边\\n2. 在 products 表的 is_imported 列和 stock 列创建复合索引，注意 is_imported 一定在最左边\\n3. 分别给products表的stock和weight列创建单列索引\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\n\n## EXPLAIN:\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | products | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |       1.11 | Using where |\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"products\":{\"is_imported\":0.02%,\"stock\":10%,\"weight\":5.01%}}\n\n## Original SQL:\nSELECT * \nFROM products \nWHERE stock > 100 \n  AND weight < 5.0 \n  AND is_imported = 1;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_products_filter ON products (is_imported, stock, weight); Reason: Composite index - Enables efficient filtering on all three WHERE conditions (is_imported equality at 0.02% selectivity, stock and weight ranges) to replace the current full table scan of 9836 rows."
                    }
                ]
            },
            {
                "case_id": "29",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"29\", \"difficulty_level\": \"2\", \"description\": \"单表，多条件查询-复合索引中列的顺序，要求从左到右等值列在前，范围列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\", \"sql\": \"SELECT * FROM orders WHERE amount > 1000 and user_id = '15946' and ship_country = 'China' and delivery_company = 'UPS'\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"delivery_company\\\":0.008%,\\\"ship_country\\\":0.01%,\\\"user_id\\\":77.982%}}\", \"explain\": \"|id |select_type|table |partitions|type|possible_keys|key|key_len|ref|rows   |filtered|Extra      |\\n|---|-----------|------|----------|----|-------------|---|-------|---|-------|--------|-----------|\\n|1  |SIMPLE     |orders|          |ALL |             |   |       |   |497,080|0.03    |Using where|\", \"expected\": \"以下三种情况均可:\\n1. 在 orders 表的 user_id、ship_country、delivery_company列创建复合索引，注意列顺序从左到右必须为user_id、ship_country/delivery_company。\\n2. 在 orders 表的 user_id、ship_country、delivery_company、amount列创建复合索引，注意列顺序从左到右必须为user_id、ship_country、delivery_company、amount。\\n3. 无法通过索引解决SQL性能问题，存在隐式转换。\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\n\n## EXPLAIN:\n|id |select_type|table |partitions|type|possible_keys|key|key_len|ref|rows   |filtered|Extra      |\n|---|-----------|------|----------|----|-------------|---|-------|---|-------|--------|-----------|\n|1  |SIMPLE     |orders|          |ALL |             |   |       |   |497,080|0.03    |Using where|\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"delivery_company\":0.008%,\"ship_country\":0.01%,\"user_id\":77.982%}}\n\n## Original SQL:\nSELECT * FROM orders WHERE amount > 1000 and user_id = '15946' and ship_country = 'China' and delivery_company = 'UPS'\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_filter ON orders(user_id, ship_country, delivery_company, amount, order_sn, currency, pay_time, ship_city, ship_zip); Reason: Covering index - includes all columns needed by the query, eliminating table access completely and transforming the full table scan into an index-only scan."
                    }
                ]
            },
            {
                "case_id": "30",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"30\", \"difficulty_level\": \"3\", \"description\": \"单表，多条件 + 排序分组查询-复合索引中列的顺序，要求从左到右等值列在前，范围列或分组/排序列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT * \\nFROM access_logs \\nWHERE ip_address = '192.168.1.100' \\n  AND response_time_ms > 500 \\nORDER BY created_at DESC;\", \"columns_selectivity\": \"{\\\"access_logs\\\":{\\\"ip_address\\\":69.552%,\\\"response_time_ms\\\":6%}}\", \"explain\": \"+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-----------------------------+\\n|   id | select_type   | table       | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra                       |\\n+======+===============+=============+==============+========+=================+=======+===========+=======+=========+============+=============================+\\n|    1 | SIMPLE        | access_logs | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |       3.33 | Using where; Using filesort |\\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-----------------------------+\", \"expected\": \"以下两种情况均可：\\n1. 在 access_logs 表的ip_address, response_time_ms, created_at列创建复合索引，要求ip_address为左列\\n2.在 access_logs 表的 ip_address 列和 created_at 列创建复合索引，要求ip_address为左列\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-----------------------------+\n|   id | select_type   | table       | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra                       |\n+======+===============+=============+==============+========+=================+=======+===========+=======+=========+============+=============================+\n|    1 | SIMPLE        | access_logs | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |       3.33 | Using where; Using filesort |\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-----------------------------+\n\n## Column Selectivity:\n{\"access_logs\":{\"ip_address\":69.552%,\"response_time_ms\":6%}}\n\n## Original SQL:\nSELECT * \nFROM access_logs \nWHERE ip_address = '192.168.1.100' \n  AND response_time_ms > 500 \nORDER BY created_at DESC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_access_logs_ip_response_created ON access_logs(ip_address, response_time_ms, created_at); Reason: Composite index - enables efficient WHERE filtering and avoids filesort through index-provided ordering"
                    }
                ]
            },
            {
                "case_id": "31",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"31\", \"difficulty_level\": \"3\", \"description\": \"单表，多条件 + 排序分组查询-复合索引中列的顺序，要求从左到右等值列在前，范围列或分组/排序列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\", \"sql\": \"SELECT * \\nFROM orders \\nWHERE user_id = 12345 \\nORDER BY pay_time DESC \\nLIMIT 1;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"user_id\\\":77.982%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============================+\\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |         10 | Using where; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\", \"expected\": \"在 orders 表的 user_id 列和 pay_time 创建复合索引，注意 user_id 列一定在最左边\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============================+\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |         10 | Using where; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\n\n## Column Selectivity:\n{\"orders\":{\"user_id\":77.982%}}\n\n## Original SQL:\nSELECT * \nFROM orders \nWHERE user_id = 12345 \nORDER BY pay_time DESC \nLIMIT 1;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_user_id_pay_time ON orders(user_id, pay_time); Reason: Composite index - Enables efficient filtering on user_id and eliminates costly filesort by providing pre-sorted pay_time values within each user group."
                    }
                ]
            },
            {
                "case_id": "32",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"32\", \"difficulty_level\": \"3\", \"description\": \"单表，多条件 + 排序分组查询-复合索引中列的顺序，要求从左到右等值列在前，范围列或分组/排序列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * FROM users\\nWHERE register_channel = 'Web' AND gender = 1\\nORDER BY last_login DESC;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"gender\\\":0.006%,\\\"register_channel\\\":0.006%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============================+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |          1 | Using where; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\", \"expected\": \"在 users 表的 register_channel 列和 gender 列和 last_login 列创建复合索引，注意 last_login 列一定在最右边\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============================+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |          1 | Using where; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\n\n## Column Selectivity:\n{\"users\":{\"gender\":0.006%,\"register_channel\":0.006%}}\n\n## Original SQL:\nSELECT * FROM users\nWHERE register_channel = 'Web' AND gender = 1\nORDER BY last_login DESC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_users_register_channel_gender_login ON users(register_channel, gender, last_login DESC); Reason: Composite index - enables efficient filtering on WHERE conditions and eliminates filesort for ORDER BY"
                    }
                ]
            },
            {
                "case_id": "33",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"33\", \"difficulty_level\": \"3\", \"description\": \"单表，多条件 + 排序分组查询-复合索引中列的顺序，要求从左到右等值列在前，范围列或分组/排序列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\", \"sql\": \"SELECT * FROM orders\\nWHERE amount > 1000 AND ship_country = 'China'\\nORDER BY pay_time ASC;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"ship_country\\\":0.01%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============================+\\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |       3.33 | Using where; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\", \"expected\": \"以下三种情况均可：\\n1. 在orders表的ship_country, amount, pay_time列加复合索引，ship_country为左列\\n2. 在orders表的ship_country,pay_time列加复合索引，ship_country为左列\\n3. 在orders表的amount, ship_country, pay_time列加复合索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============================+\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |       3.33 | Using where; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"ship_country\":0.01%}}\n\n## Original SQL:\nSELECT * FROM orders\nWHERE amount > 1000 AND ship_country = 'China'\nORDER BY pay_time ASC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_ship_country_pay_time ON orders(ship_country, pay_time); Reason: Composite index - ship_country (0.01% highly selective column) is used for filtering to reduce full table scan from 497,490 rows, and pay_time is included to eliminate the expensive filesort operation by providing pre-sorted data."
                    }
                ]
            },
            {
                "case_id": "34",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"34\", \"difficulty_level\": \"3\", \"description\": \"单表，多条件 + 排序分组查询-复合索引中列的顺序，要求从左到右等值列在前，范围列或分组/排序列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * FROM users\\nWHERE vip_level >= 3 AND points > 1000\\nORDER BY birthdate ASC;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"points\\\":19.882%,\\\"vip_level\\\":0.012%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============================+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      11.11 | Using where; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\", \"expected\": \"以下两种情况均可：\\n1. 在users表的 points, vip_level列创建复合索引。\\n2. 在users表的 birthdate 列添加索引，消除文件排序。\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============================+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      11.11 | Using where; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-----------------------------+\n\n## Column Selectivity:\n{\"users\":{\"points\":19.882%,\"vip_level\":0.012%}}\n\n## Original SQL:\nSELECT * FROM users\nWHERE vip_level >= 3 AND points > 1000\nORDER BY birthdate ASC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_users_vip_points_birthdate ON users(vip_level, points, birthdate); Reason: Composite index - replaces full table scan with efficient index range scan on highly selective vip_level (0.012%) and points (19.882%) columns, and eliminates filesort by including birthdate in the index."
                    }
                ]
            },
            {
                "case_id": "35",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"35\", \"difficulty_level\": \"3\", \"description\": \"单表，多条件 + 排序分组查询-复合索引中列的顺序，要求从左到右等值列在前，范围列或分组/排序列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT \\n    register_channel, \\n    COUNT(*) AS user_count, \\n    AVG(points) AS avg_points\\nFROM \\n    users\\nWHERE \\n    gender = 1 \\n    AND birthdate BETWEEN '1990-01-01' AND '2000-12-31'\\n    AND vip_level > 0\\nGROUP BY \\n    register_channel\\nORDER BY \\n    user_count DESC;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"birthdate\\\":19.876%,\\\"gender\\\":0.006%,\\\"points\\\":19.882%,\\\"register_channel\\\":0.006%,\\\"vip_level\\\":0.012%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                                        |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+==============================================+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |       0.37 | Using where; Using temporary; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\", \"expected\": \"以下三种情况均可：\\n1. 在 users 表的 gender, birthdate, vip_level或register_channel列上创建复合索引，列顺序为：gender, birthdate, vip_level或register_channel（gender, birthdate位置可互换）\\n2. 在 users 表的 gender, birthdate, vip_level, register_channel, points 列创建覆盖索引，顺序要求前三列为gender, birthdate, vip_level（gender, birthdate位置可互换）\\n3. 在users表的birthdate列创建单列索引\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                                        |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+==============================================+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |       0.37 | Using where; Using temporary; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\n\n## Column Selectivity:\n{\"users\":{\"birthdate\":19.876%,\"gender\":0.006%,\"points\":19.882%,\"register_channel\":0.006%,\"vip_level\":0.012%}}\n\n## Original SQL:\nSELECT \n    register_channel, \n    COUNT(*) AS user_count, \n    AVG(points) AS avg_points\nFROM \n    users\nWHERE \n    gender = 1 \n    AND birthdate BETWEEN '1990-01-01' AND '2000-12-31'\n    AND vip_level > 0\nGROUP BY \n    register_channel\nORDER BY \n    user_count DESC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_users_gender_vip_birthdate_channel_points ON users(gender, vip_level, birthdate, register_channel, points); Reason: Covering index - includes all WHERE condition columns (gender, vip_level, birthdate), GROUP BY column (register_channel), and aggregate column (points) to eliminate full table scans and avoid table lookups."
                    }
                ]
            },
            {
                "case_id": "36",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"36\", \"difficulty_level\": \"3\", \"description\": \"单表，多条件 + 排序分组查询-复合索引中列的顺序，要求从左到右等值列在前，范围列或分组/排序列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\", \"sql\": \"SELECT \\n    ship_country, \\n    ship_city, \\n    COUNT(*) AS order_count, \\n    SUM(amount) AS total_amount\\nFROM \\n    orders\\nWHERE \\n    currency = 'CNY' \\n    AND pay_time BETWEEN '2025-08-10' AND '2025-09-20'\\n    AND amount > 1000\\nGROUP BY \\n    ship_country, ship_city\\nORDER BY \\n    total_amount DESC;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"currency\\\":0.002%,\\\"pay_time\\\":35.23%,\\\"ship_city\\\":0.01%,\\\"ship_country\\\":0.01%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                                        |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+==============================================+\\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |       0.37 | Using where; Using temporary; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\", \"expected\": \"在orders表的pay_time,currency,amount,ship_city,ship_country列创建覆盖索引，要求pay_time,currency,amount谓词列为左列，无顺序要求\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                                        |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+==============================================+\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |       0.37 | Using where; Using temporary; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"currency\":0.002%,\"pay_time\":35.23%,\"ship_city\":0.01%,\"ship_country\":0.01%}}\n\n## Original SQL:\nSELECT \n    ship_country, \n    ship_city, \n    COUNT(*) AS order_count, \n    SUM(amount) AS total_amount\nFROM \n    orders\nWHERE \n    currency = 'CNY' \n    AND pay_time BETWEEN '2025-08-10' AND '2025-09-20'\n    AND amount > 1000\nGROUP BY \n    ship_country, ship_city\nORDER BY \n    total_amount DESC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_cvr ON orders(currency, pay_time, amount, ship_country, ship_city); Reason: Covering index - includes all columns needed for WHERE filtering and GROUP BY operations, enabling index-only scan to eliminate the full table scan on 497K rows, reducing rows processed to ~1.8K (0.37% filtered)."
                    }
                ]
            },
            {
                "case_id": "37",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"37\", \"difficulty_level\": \"3\", \"description\": \"单表，多条件 + 排序分组查询-复合索引中列的顺序，要求从左到右等值列在前，范围列或分组/排序列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\", \"sql\": \"SELECT \\n    brand, \\n    origin_country, \\n    COUNT(*) AS product_count, \\n    AVG(price) AS avg_price\\nFROM \\n    products\\nWHERE \\n    is_imported = 1 \\n    AND stock > 0 \\n    AND weight < 5\\nGROUP BY \\n    brand, origin_country\\nORDER BY \\n    product_count DESC;\", \"columns_selectivity\": \"{\\\"products\\\":{\\\"brand\\\":0.05%,\\\"is_imported\\\":0.02%,\\\"origin_country\\\":0.06%,\\\"price\\\":97.37%,\\\"stock\\\":10%,\\\"weight\\\":5.01%}}\", \"explain\": \"+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                                        |\\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+==============================================+\\n|    1 | SIMPLE        | products | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |       1.11 | Using where; Using temporary; Using filesort |\\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\", \"expected\": \"以下三种情况均可\\n1. 谓词列选择性太低，不适合建索引，无法通过索引解决SQL性能问题\\n2. 为 products 表的 is_imported列、stock或weight列添加复合索引stock或weight只能存在一列\\n3. 创建覆盖索引，包含列is_imported, brand, origin_country, stock, weight, price，要求is_imported为最左列\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\n\n## EXPLAIN:\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                                        |\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+==============================================+\n|    1 | SIMPLE        | products | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |       1.11 | Using where; Using temporary; Using filesort |\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\n\n## Column Selectivity:\n{\"products\":{\"brand\":0.05%,\"is_imported\":0.02%,\"origin_country\":0.06%,\"price\":97.37%,\"stock\":10%,\"weight\":5.01%}}\n\n## Original SQL:\nSELECT \n    brand, \n    origin_country, \n    COUNT(*) AS product_count, \n    AVG(price) AS avg_price\nFROM \n    products\nWHERE \n    is_imported = 1 \n    AND stock > 0 \n    AND weight < 5\nGROUP BY \n    brand, origin_country\nORDER BY \n    product_count DESC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_products_filter_group ON products (is_imported, weight, stock, brand, origin_country, price); Reason: Covering index - eliminates full table scan and table lookups by including all columns required for WHERE filtering, SELECT, and GROUP BY clauses, reducing examined rows from 9,836 to approximately 109."
                    }
                ]
            },
            {
                "case_id": "38",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"38\", \"difficulty_level\": \"3\", \"description\": \"单表，多条件 + 排序分组查询-复合索引中列的顺序，要求从左到右等值列在前，范围列或分组/排序列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    ip_address, \\n    COUNT(*) AS request_count, \\n    AVG(response_time_ms) AS avg_response_time\\nFROM \\n    access_logs\\nWHERE \\n    http_method = 'GET' \\n    AND response_code = 200 \\n    AND created_at BETWEEN '2025-09-19 15:50:02' AND '2025-09-19 15:52:02'\\nGROUP BY \\n    ip_address\\nORDER BY \\n    request_count DESC;\", \"columns_selectivity\": \"{\\\"access_logs\\\":{\\\"created_at\\\":0.038%,\\\"http_method\\\":0.008%,\\\"ip_address\\\":69.552%,\\\"response_code\\\":0.006%,\\\"response_time_ms\\\":6%}}\", \"explain\": \"+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+----------------------------------------------+\\n|   id | select_type   | table       | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra                                        |\\n+======+===============+=============+==============+========+=================+=======+===========+=======+=========+============+==============================================+\\n|    1 | SIMPLE        | access_logs | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |       0.11 | Using where; Using temporary; Using filesort |\\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+----------------------------------------------+\", \"expected\": \"以下两种情况均可：\\n1. 在 access_logs 表的 created_at 列创建索引\\n2. 在 access_logs 表的 created_at、http_method、response_code、ip_address、response_time_ms 列创建覆盖索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+----------------------------------------------+\n|   id | select_type   | table       | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra                                        |\n+======+===============+=============+==============+========+=================+=======+===========+=======+=========+============+==============================================+\n|    1 | SIMPLE        | access_logs | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |       0.11 | Using where; Using temporary; Using filesort |\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+----------------------------------------------+\n\n## Column Selectivity:\n{\"access_logs\":{\"created_at\":0.038%,\"http_method\":0.008%,\"ip_address\":69.552%,\"response_code\":0.006%,\"response_time_ms\":6%}}\n\n## Original SQL:\nSELECT \n    ip_address, \n    COUNT(*) AS request_count, \n    AVG(response_time_ms) AS avg_response_time\nFROM \n    access_logs\nWHERE \n    http_method = 'GET' \n    AND response_code = 200 \n    AND created_at BETWEEN '2025-09-19 15:50:02' AND '2025-09-19 15:52:02'\nGROUP BY \n    ip_address\nORDER BY \n    request_count DESC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_access_logs_covering ON access_logs (http_method, response_code, created_at, ip_address, response_time_ms); Reason: Covering index - eliminates full table scan and enables index-only query execution by including all WHERE filter columns, GROUP BY column, and aggregation column."
                    }
                ]
            },
            {
                "case_id": "39",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"39\", \"difficulty_level\": \"3\", \"description\": \"单表，多条件 + 排序分组查询-复合索引中列的顺序，要求从左到右等值列在前，范围列或分组/排序列在后，等值列按列选择性由高到底排序，并且范围列仅能有一列\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT \\n    YEAR(birthdate) AS birth_year, \\n    gender, \\n    COUNT(*) AS user_count, \\n    MAX(points) AS max_points\\nFROM \\n    users\\nWHERE \\n    (phone IS NOT NULL OR email LIKE '%@gmail.com') \\n    AND last_login > '2023-01-01' \\n    AND points > 100\\nGROUP BY \\n    birth_year, gender\\nORDER BY \\n    birth_year ASC, gender ASC;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"birthdate\\\":19.876%,\\\"email\\\":100%,\\\"gender\\\":0.006%,\\\"last_login\\\":35.294%,\\\"phone\\\":99.912%,\\\"points\\\":19.882%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                                        |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+==============================================+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      10.12 | Using where; Using temporary; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\", \"expected\": \"以下两种情况均可：\\n1. 无法通过索引解决SQL性能问题\\n2. 在users表的phone,email,last_login,points,birthdate,gender列创建覆盖索引，要求phone,email,last_login,points列为左列，无顺序要求。\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                                        |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+==============================================+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      10.12 | Using where; Using temporary; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------+\n\n## Column Selectivity:\n{\"users\":{\"birthdate\":19.876%,\"email\":100%,\"gender\":0.006%,\"last_login\":35.294%,\"phone\":99.912%,\"points\":19.882%}}\n\n## Original SQL:\nSELECT \n    YEAR(birthdate) AS birth_year, \n    gender, \n    COUNT(*) AS user_count, \n    MAX(points) AS max_points\nFROM \n    users\nWHERE \n    (phone IS NOT NULL OR email LIKE '%@gmail.com') \n    AND last_login > '2023-01-01' \n    AND points > 100\nGROUP BY \n    birth_year, gender\nORDER BY \n    birth_year ASC, gender ASC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_filter_group ON users(points, last_login, gender, birthdate); Reason: Composite index - efficiently filters WHERE conditions on points and last_login (reducing examined rows from 99,553 to approximately 10,000), includes GROUP BY columns, and converts full table scan to index range scan."
                    }
                ]
            },
            {
                "case_id": "40",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"40\", \"difficulty_level\": \"2\", \"description\": \"单表，覆盖索引-是否适合创建覆盖索引判断\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT user_id, username, email, phone\\nFROM users\\nWHERE gender = 1 \\n  AND birthdate > '1990-01-01' \\n  AND vip_level >= 2;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"birthdate\\\":19.876%,\\\"email\\\":100%,\\\"gender\\\":0.006%,\\\"phone\\\":99.912%,\\\"user_id\\\":100%,\\\"username\\\":100%,\\\"vip_level\\\":0.012%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |       1.11 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"以下三种情况均可：\\n1. 无法通过索引解决SQL性能问题。\\n2. 由于查询SQL中涉及的列数过多，不建议创建覆盖索引，建议在 users 表的gender，birthdate，vip_level列创建复合索引，列顺序为：gender，vip_level，birthdate。\\n3. 在 users 表的birthdate列创建单列索引\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |       1.11 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"users\":{\"birthdate\":19.876%,\"email\":100%,\"gender\":0.006%,\"phone\":99.912%,\"user_id\":100%,\"username\":100%,\"vip_level\":0.012%}}\n\n## Original SQL:\nSELECT user_id, username, email, phone\nFROM users\nWHERE gender = 1 \n  AND birthdate > '1990-01-01' \n  AND vip_level >= 2;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_users_cover ON users(gender, vip_level, birthdate, username, email, phone); Reason: Covering index - includes all WHERE condition columns and SELECT columns to eliminate the full table scan (ALL type) and enable index-only scan without table access."
                    }
                ]
            },
            {
                "case_id": "41",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"41\", \"difficulty_level\": \"2\", \"description\": \"单表，覆盖索引-是否适合创建覆盖索引判断\", \"create_table_statements\": \"CREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\", \"sql\": \"SELECT order_id, order_sn, amount, pay_time\\nFROM orders\\nWHERE user_id = 12345 \\n  AND currency = 'CNY' \\n  AND pay_time IS NOT NULL;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"currency\\\":0.002%,\\\"order_id\\\":100%,\\\"order_sn\\\":100%,\\\"pay_time\\\":35.23%,\\\"user_id\\\":77.982%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |        0.9 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"以下三种情况均可：\\n1. 在orders表上创建覆盖索引，包含的列有：user_id，currency，pay_time, order_sn, amount，要求user_id，currency，pay_time为左列\\n2. 在orders表上创建复合索引，包含的字段和顺序为：user_id，pay_time\\n3. 在orders表上创建复合索引，包含的字段和顺序为：user_id，pay_time，pay_time\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |        0.9 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"currency\":0.002%,\"order_id\":100%,\"order_sn\":100%,\"pay_time\":35.23%,\"user_id\":77.982%}}\n\n## Original SQL:\nSELECT order_id, order_sn, amount, pay_time\nFROM orders\nWHERE user_id = 12345 \n  AND currency = 'CNY' \n  AND pay_time IS NOT NULL;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_user_currency_pay_time ON orders(user_id, currency, pay_time); Reason: Composite index - Supports filtering on all three WHERE conditions (user_id, currency, pay_time) to eliminate the full table scan of 497K rows and reduce rows evaluated to approximately 4.5K."
                    }
                ]
            },
            {
                "case_id": "42",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"42\", \"difficulty_level\": \"2\", \"description\": \"单表，覆盖索引-是否适合创建覆盖索引判断\", \"create_table_statements\": \"CREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\", \"sql\": \"SELECT product_id, product_name, price\\nFROM products\\nWHERE is_imported = 1 \\n  AND stock > 0;\", \"columns_selectivity\": \"{\\\"products\\\":{\\\"is_imported\\\":0.02%,\\\"price\\\":97.37%,\\\"product_id\\\":100%,\\\"product_name\\\":100%,\\\"stock\\\":10%}}\", \"explain\": \"+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | products | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |       3.33 | Using where |\\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"以下三种情况均可：\\n1. 无法通过索引解决SQL性能问题，由于where条件中列选择性太低，不适合建索引的查询\\n2. 为该查询创建覆盖索引，在products表的is_imported，stock，product_name，price列创建复合索引，注意is_imported为最左列，stock为左侧第二列\\n3. 在products表的istock列创建索引\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\n\n## EXPLAIN:\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | products | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |       3.33 | Using where |\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"products\":{\"is_imported\":0.02%,\"price\":97.37%,\"product_id\":100%,\"product_name\":100%,\"stock\":10%}}\n\n## Original SQL:\nSELECT product_id, product_name, price\nFROM products\nWHERE is_imported = 1 \n  AND stock > 0;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_imported_stock ON products(is_imported, stock, product_id, product_name, price); Reason: Covering index - includes filtering columns (is_imported, stock) and all selected columns (product_id, product_name, price) to enable index-only scans without table access, eliminating the current full table scan of 9836 rows."
                    }
                ]
            },
            {
                "case_id": "43",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"43\", \"difficulty_level\": \"2\", \"description\": \"单表，覆盖索引-是否适合创建覆盖索引判断\", \"create_table_statements\": \"CREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT log_id, request_url, response_code, response_time_ms\\nFROM access_logs\\nWHERE user_id = 67890 \\n  AND http_method = 'GET' \\n  AND response_code = 200 \\n  AND created_at > '2023-01-01';\", \"columns_selectivity\": \"{\\\"access_logs\\\":{\\\"created_at\\\":0.038%,\\\"http_method\\\":0.008%,\\\"log_id\\\":100%,\\\"request_url\\\":2%,\\\"response_code\\\":0.006%,\\\"response_time_ms\\\":6%,\\\"user_id\\\":78.36%}}\", \"explain\": \"+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-------------+\\n|   id | select_type   | table       | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra       |\\n+======+===============+=============+==============+========+=================+=======+===========+=======+=========+============+=============+\\n|    1 | SIMPLE        | access_logs | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |       0.03 | Using where |\\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-------------+\", \"expected\": \"以下两种情况均可：\\n1. 由于查询SQL中涉及的列数过多，不建议创建覆盖索引，在access_logs表上创建联合索引，包含的字段和顺序为：user_id，created_at。\\n2. 由于查询SQL中涉及的列数过多，不建议创建覆盖索引，在access_logs表的user_id, response_code, http_method, created_at列上创建联合索引，要求user_id在最左列，created_at在最右列。\\n3. 在access_logs表的user_id列创建单列索引\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-------------+\n|   id | select_type   | table       | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra       |\n+======+===============+=============+==============+========+=================+=======+===========+=======+=========+============+=============+\n|    1 | SIMPLE        | access_logs | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |       0.03 | Using where |\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-------------+\n\n## Column Selectivity:\n{\"access_logs\":{\"created_at\":0.038%,\"http_method\":0.008%,\"log_id\":100%,\"request_url\":2%,\"response_code\":0.006%,\"response_time_ms\":6%,\"user_id\":78.36%}}\n\n## Original SQL:\nSELECT log_id, request_url, response_code, response_time_ms\nFROM access_logs\nWHERE user_id = 67890 \n  AND http_method = 'GET' \n  AND response_code = 200 \n  AND created_at > '2023-01-01';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_access_logs_response_http_user ON access_logs(response_code, http_method, user_id, created_at); Reason: Composite index - avoids full table scan on 1.9M rows by enabling index-based filtering on all WHERE conditions (response_code, http_method, user_id, created_at)"
                    }
                ]
            },
            {
                "case_id": "44",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"44\", \"difficulty_level\": \"2\", \"description\": \"单表，like-Like 前模糊和前后模糊查询会导致索引失效，后模糊可以走索引\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * FROM users WHERE username LIKE 'John%';\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      11.11 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"模糊查询后模糊匹配会走索引，可在 users 表的 username 列创建索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      11.11 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"users\":{\"username\":100%}}\n\n## Original SQL:\nSELECT * FROM users WHERE username LIKE 'John%';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_username ON users(username); Reason: Single-column index - The LIKE 'John%' predicate supports index range scanning on the username column, which will eliminate the full table scan of 99,553 rows and reduce filtering to approximately 11,058 matching rows."
                    }
                ]
            },
            {
                "case_id": "45",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"45\", \"difficulty_level\": \"2\", \"description\": \"单表，like-Like 前模糊和前后模糊查询会导致索引失效，后模糊可以走索引\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * FROM users WHERE username LIKE '%smh';\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      11.11 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"like前模糊无法利用索引，无法通过索引优化解决SQL的性能问题，可以考虑用全文索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      11.11 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"users\":{\"username\":100%}}\n\n## Original SQL:\nSELECT * FROM users WHERE username LIKE '%smh';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "Unable to solve SQL performance issues by creating indexes. Reason: Leading wildcard patterns in LIKE clauses (LIKE '%smh') cannot utilize B-tree indexes for efficient scanning, as the database cannot determine where to start the search within the index, necessitating a full table scan regardless of index presence."
                    }
                ]
            },
            {
                "case_id": "46",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"46\", \"difficulty_level\": \"2\", \"description\": \"单表，like-Like 前模糊和前后模糊查询会导致索引失效，后模糊可以走索引\", \"create_table_statements\": \"CREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT * FROM access_logs WHERE request_url LIKE '%login%';\", \"columns_selectivity\": \"{\\\"access_logs\\\":{\\\"request_url\\\":2%}}\", \"explain\": \"+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-------------+\\n|   id | select_type   | table       | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra       |\\n+======+===============+=============+==============+========+=================+=======+===========+=======+=========+============+=============+\\n|    1 | SIMPLE        | access_logs | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |      11.11 | Using where |\\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-------------+\", \"expected\": \"like前后模糊无法利用索引，无法通过索引优化解决SQL的性能问题，可以考虑使用全文索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-------------+\n|   id | select_type   | table       | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra       |\n+======+===============+=============+==============+========+=================+=======+===========+=======+=========+============+=============+\n|    1 | SIMPLE        | access_logs | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |      11.11 | Using where |\n+------+---------------+-------------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-------------+\n\n## Column Selectivity:\n{\"access_logs\":{\"request_url\":2%}}\n\n## Original SQL:\nSELECT * FROM access_logs WHERE request_url LIKE '%login%';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "Unable to solve SQL performance issues by creating indexes. Reason: LIKE queries with leading wildcards ('%login%') cannot efficiently use standard B-tree indexes; MySQL cannot seek to matching values without scanning the entire table or index."
                    }
                ]
            },
            {
                "case_id": "47",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"47\", \"difficulty_level\": \"2\", \"description\": \"单表，不适合建索引-NOT IN 列索引多数情况不生效\", \"create_table_statements\": \"CREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\", \"sql\": \"SELECT * FROM orders \\nWHERE ship_country NOT IN ('China', 'USA');\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"ship_country\\\":0.01%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |         80 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"对于NOT IN查询，常规索引可能效果极其有限，不建议通过索引优化\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | orders  | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |         80 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"orders\":{\"ship_country\":0.01%}}\n\n## Original SQL:\nSELECT * FROM orders \nWHERE ship_country NOT IN ('China', 'USA');\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "Unable to solve SQL performance issues by creating indexes. Reason: NOT IN conditions cannot be efficiently optimized with indexes, and the query returns nearly 100% of data (based on 0.01% selectivity for the IN values), making full table scan the optimal access method."
                    }
                ]
            },
            {
                "case_id": "48",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"48\", \"difficulty_level\": \"2\", \"description\": \"单表，不适合建索引-NOT IN 列索引多数情况不生效\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * FROM users \\nWHERE gender NOT IN (1, 2) \\n  AND birthdate BETWEEN '1990-01-01' AND '2000-12-31' Limit 10;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"birthdate\\\":19.876%,\\\"gender\\\":0.006%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |       8.89 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"在users表的 birthdate 列添加索引\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |       8.89 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"users\":{\"birthdate\":19.876%,\"gender\":0.006%}}\n\n## Original SQL:\nSELECT * FROM users \nWHERE gender NOT IN (1, 2) \n  AND birthdate BETWEEN '1990-01-01' AND '2000-12-31' Limit 10;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_users_birthdate_gender ON users(birthdate, gender); Reason: Composite index - enables efficient range scanning on birthdate combined with gender filtering, eliminating the full table scan on 99,553 rows."
                    }
                ]
            },
            {
                "case_id": "49",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"49\", \"difficulty_level\": \"2\", \"description\": \"单表，不适合建索引-NOT IN 可以建索引的情况（覆盖索引）\", \"create_table_statements\": \"CREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\", \"sql\": \"SELECT ship_country FROM orders \\nWHERE ship_country NOT IN ('China', 'USA');\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"ship_country\\\":0.01%}}\", \"explain\": \"|id |select_type|table |partitions|type|possible_keys|key|key_len|ref|rows   |filtered|Extra      |\\n|---|-----------|------|----------|----|-------------|---|-------|---|-------|--------|-----------|\\n|1  |SIMPLE     |orders|          |ALL |             |   |       |   |497,513|80      |Using where|\", \"expected\": \"以下两种情况均可\\n1. 在 orders 表的 ship_country 添加索引\\n2. 无法通过索引解决SQL性能问题\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\n\n## EXPLAIN:\n|id |select_type|table |partitions|type|possible_keys|key|key_len|ref|rows   |filtered|Extra      |\n|---|-----------|------|----------|----|-------------|---|-------|---|-------|--------|-----------|\n|1  |SIMPLE     |orders|          |ALL |             |   |       |   |497,513|80      |Using where|\n\n## Column Selectivity:\n{\"orders\":{\"ship_country\":0.01%}}\n\n## Original SQL:\nSELECT ship_country FROM orders \nWHERE ship_country NOT IN ('China', 'USA');\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "Unable to solve SQL performance issues by creating indexes. Reason: NOT IN clause combined with 80% filter rate and low column cardinality (0.01%) makes indexing ineffective; most rows must still be accessed regardless of indexing strategy."
                    }
                ]
            },
            {
                "case_id": "50",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"50\", \"difficulty_level\": \"2\", \"description\": \"单表，不适合建索引-<> 列索引多数情况不生效\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * FROM users WHERE gender <> 1;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"gender\\\":0.006%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |         90 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"不等于操作符的条件列会导致索引失效，进行全表扫描，不建议通过索引优化\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |         90 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"users\":{\"gender\":0.006%}}\n\n## Original SQL:\nSELECT * FROM users WHERE gender <> 1;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "Unable to solve SQL performance issues by creating indexes. Reason: The column 'gender' has extremely low selectivity (0.006%) and the NOT EQUAL condition matches approximately 90% of rows, making any index ineffective since most of the table must be accessed regardless."
                    }
                ]
            },
            {
                "case_id": "51",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"51\", \"difficulty_level\": \"2\", \"description\": \"单表， IS NULL 条件-IS NULL列可以使用索引\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT user_id, username, email\\nFROM users\\nWHERE phone IS NULL;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"email\\\":100%,\\\"phone\\\":99.912%,\\\"user_id\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |         10 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"IS NULL列可以使用索引，在users表的phone列加索引\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | SIMPLE        | users   | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |         10 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"users\":{\"email\":100%,\"phone\":99.912%,\"user_id\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT user_id, username, email\nFROM users\nWHERE phone IS NULL;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_phone_covering ON users(phone, user_id, username, email); Reason: Covering index - enables index-only scan for WHERE phone IS NULL, avoiding full table scan of 99,553 rows."
                    }
                ]
            },
            {
                "case_id": "52",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"52\", \"difficulty_level\": \"3\", \"description\": \"多表关联的多条件查询，驱动表识别以及复合索引列顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.username, \\n    u.email, \\n    o.order_sn, \\n    o.amount, \\n    o.pay_time, \\n    p.product_name, \\n    p.price\\nFROM \\n    users u\\nJOIN \\n    orders o ON u.user_id = o.user_id\\nJOIN \\n    products p ON o.order_id = p.product_id\\nWHERE \\n    u.user_id = 12345\\n    AND o.pay_time BETWEEN '2025-08-10' AND '2025-09-20'\\n    AND p.category_id = 5;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_sn\\\":100%,\\\"pay_time\\\":35.23%},\\\"products\\\":{\\\"category_id\\\":0.2%,\\\"price\\\":97.37%,\\\"product_name\\\":100%},\\\"users\\\":{\\\"email\\\":100%,\\\"user_id\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                     |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=========+===========+=========================+========+============+=============+\\n|    1 | SIMPLE        | u       | NULL         | const  | PRIMARY         | PRIMARY | 8         | const                   |      1 |        100 | NULL        |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+-------------+\\n|    1 | SIMPLE        | p       | NULL         | ALL    | PRIMARY         | NULL    | NULL      | NULL                    |   9836 |         10 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+-------------+\\n|    1 | SIMPLE        | o       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.p.product_id |      1 |          5 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+-------------+\", \"expected\": \"以下两种情况均可：\\n情况1：\\n1. 在products表的category_id列创建单列索引\\n2. 在orders表的user_id、pay_time列创建复合索引，注意user_id需要在最左边\\n情况2：\\n创建覆盖索引：\\n1. orders 表的user_id, pay_time, order_sn, amount列创建覆盖索引,要求user_id 在最左列。\\n2. products表的category_id, product_id, product_name, price创建覆盖索引，要求category_id为最左列\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                     |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=========+===========+=========================+========+============+=============+\n|    1 | SIMPLE        | u       | NULL         | const  | PRIMARY         | PRIMARY | 8         | const                   |      1 |        100 | NULL        |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+-------------+\n|    1 | SIMPLE        | p       | NULL         | ALL    | PRIMARY         | NULL    | NULL      | NULL                    |   9836 |         10 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+-------------+\n|    1 | SIMPLE        | o       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.p.product_id |      1 |          5 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"order_sn\":100%,\"pay_time\":35.23%},\"products\":{\"category_id\":0.2%,\"price\":97.37%,\"product_name\":100%},\"users\":{\"email\":100%,\"user_id\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT \n    u.username, \n    u.email, \n    o.order_sn, \n    o.amount, \n    o.pay_time, \n    p.product_name, \n    p.price\nFROM \n    users u\nJOIN \n    orders o ON u.user_id = o.user_id\nJOIN \n    products p ON o.order_id = p.product_id\nWHERE \n    u.user_id = 12345\n    AND o.pay_time BETWEEN '2025-08-10' AND '2025-09-20'\n    AND p.category_id = 5;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_products_category_covering ON products(category_id, product_name, price); Reason: Covering index - eliminates full table scan on the products table by providing index-only access for category filtering and column retrieval."
                    }
                ]
            },
            {
                "case_id": "53",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"53\", \"difficulty_level\": \"3\", \"description\": \"多表关联的多条件查询，驱动表识别以及复合索引列顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.username, \\n    u.vip_level, \\n    a.request_url, \\n    a.http_method, \\n    a.response_code, \\n    a.created_at\\nFROM \\n    users u\\nJOIN \\n    access_logs a ON u.user_id = a.user_id\\nWHERE \\n    u.vip_level > 0\\n    AND a.created_at BETWEEN '2025-09-19 15:50:02' AND '2025-09-19 15:52:02'\\n    AND a.response_code = 200;\", \"columns_selectivity\": \"{\\\"access_logs\\\":{\\\"created_at\\\":0.038%,\\\"http_method\\\":0.008%,\\\"request_url\\\":2%,\\\"response_code\\\":0.006%},\\\"users\\\":{\\\"username\\\":100%,\\\"vip_level\\\":0.012%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |    rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=========+===========+======================+=========+============+=============+\\n|    1 | SIMPLE        | a       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 1987219 |       1.11 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+-------------+\\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.a.user_id |       1 |      33.33 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+-------------+\", \"expected\": \"以下两种情况均可：\\n1. 给 access_logs 表的 created_at 列创建索引。\\n2. 给 access_logs 表的 user_id、response_code、created_at、vip_level创建索引，要求vip_level为最右列。\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |    rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=========+===========+======================+=========+============+=============+\n|    1 | SIMPLE        | a       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 1987219 |       1.11 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+-------------+\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.a.user_id |       1 |      33.33 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+-------------+\n\n## Column Selectivity:\n{\"access_logs\":{\"created_at\":0.038%,\"http_method\":0.008%,\"request_url\":2%,\"response_code\":0.006%},\"users\":{\"username\":100%,\"vip_level\":0.012%}}\n\n## Original SQL:\nSELECT \n    u.username, \n    u.vip_level, \n    a.request_url, \n    a.http_method, \n    a.response_code, \n    a.created_at\nFROM \n    users u\nJOIN \n    access_logs a ON u.user_id = a.user_id\nWHERE \n    u.vip_level > 0\n    AND a.created_at BETWEEN '2025-09-19 15:50:02' AND '2025-09-19 15:52:02'\n    AND a.response_code = 200;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_access_logs_covering ON access_logs(response_code, created_at, user_id, request_url, http_method); Reason: Covering index - includes filter columns (response_code, created_at) to efficiently filter 1.987M rows, join column (user_id), and selected columns (request_url, http_method) to enable index-only query execution without table lookups, converting full table scan to index scan."
                    }
                ]
            },
            {
                "case_id": "54",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"54\", \"difficulty_level\": \"3\", \"description\": \"多表关联的多条件查询，驱动表识别以及复合索引列顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.username, \\n    u.phone, \\n    o.order_sn, \\n    o.amount, \\n    o.ship_country, \\n    o.ship_city, \\n    o.delivery_company\\nFROM \\n    users u\\nJOIN \\n    orders o ON u.user_id = o.user_id\\nWHERE \\n    o.ship_country = 'USA'\\n    AND o.pay_time IS NOT NULL\\n    AND u.gender = 1;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"delivery_company\\\":0.008%,\\\"order_sn\\\":100%,\\\"pay_time\\\":35.23%,\\\"ship_city\\\":0.01%,\\\"ship_country\\\":0.01%},\\\"users\\\":{\\\"gender\\\":0.006%,\\\"phone\\\":99.912%,\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+-------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra       |\\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+=============+\\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |          9 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+-------------+\\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |         10 | Using where |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+-------------+\", \"expected\": \"以下两种情况均可：\\n1. 在orders表的ship_country、user_id，pay_time列创建复合索引，且顺序为user_id,ship_country,pay_time（受pay_time is not null数据的占比数影响，pay_time不固定）\\n2. 在orders表的ship_country, pay_time,user_id列创建联合索引,顺序要求要求同。\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+-------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra       |\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+=============+\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |          9 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+-------------+\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |         10 | Using where |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"delivery_company\":0.008%,\"order_sn\":100%,\"pay_time\":35.23%,\"ship_city\":0.01%,\"ship_country\":0.01%},\"users\":{\"gender\":0.006%,\"phone\":99.912%,\"username\":100%}}\n\n## Original SQL:\nSELECT \n    u.username, \n    u.phone, \n    o.order_sn, \n    o.amount, \n    o.ship_country, \n    o.ship_city, \n    o.delivery_company\nFROM \n    users u\nJOIN \n    orders o ON u.user_id = o.user_id\nWHERE \n    o.ship_country = 'USA'\n    AND o.pay_time IS NOT NULL\n    AND u.gender = 1;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_ship_country_pay_time ON orders(ship_country, pay_time); Reason: Composite index - Replaces the full table scan (ALL type) of 497,490 rows with an efficient indexed lookup on the WHERE filter conditions (ship_country, pay_time), significantly improving the current bottleneck with only 9% filtering efficiency."
                    }
                ]
            },
            {
                "case_id": "55",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"55\", \"difficulty_level\": \"3\", \"description\": \"多表关联的多条件查询，驱动表识别以及复合索引列顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.username, \\n    a.request_url, \\n    a.response_time_ms, \\n    o.order_sn, \\n    o.amount\\nFROM \\n    users u\\nJOIN \\n    access_logs a ON u.user_id = a.user_id\\nLEFT JOIN \\n    orders o ON u.user_id = o.user_id\\nWHERE \\n    a.created_at BETWEEN '2025-09-19 15:50:02' AND '2025-09-19 15:52:02'\\n    AND a.response_time_ms > 500\\n    AND o.pay_time IS NOT NULL;\", \"columns_selectivity\": \"{\\\"access_logs\\\":{\\\"created_at\\\":0.038%,\\\"request_url\\\":2%,\\\"response_time_ms\\\":6%},\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_sn\\\":100%,\\\"pay_time\\\":35.23%},\\\"users\\\":{\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |    rows |   filtered | Extra                                              |\\n+======+===============+=========+==============+========+=================+=========+===========+======================+=========+============+====================================================+\\n|    1 | SIMPLE        | a       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 1987219 |        3.7 | Using where                                        |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.a.user_id |       1 |      100   | NULL                                               |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 |  497490 |        9   | Using where; Using join buffer (Block Nested Loop) |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\", \"expected\": \"以下两种情况均可：\\n1. 在 access_logs 表的 created_at 列创建索引，并且在 orders 的user_id列创建索引。\\n2. 在 access_logs 表的 created_at, response_time_ms列创建复合索引，并且在 orders 的 user_id, pay_time列创建符合索引\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |    rows |   filtered | Extra                                              |\n+======+===============+=========+==============+========+=================+=========+===========+======================+=========+============+====================================================+\n|    1 | SIMPLE        | a       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 1987219 |        3.7 | Using where                                        |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.a.user_id |       1 |      100   | NULL                                               |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 |  497490 |        9   | Using where; Using join buffer (Block Nested Loop) |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\n\n## Column Selectivity:\n{\"access_logs\":{\"created_at\":0.038%,\"request_url\":2%,\"response_time_ms\":6%},\"orders\":{\"amount\":94.296%,\"order_sn\":100%,\"pay_time\":35.23%},\"users\":{\"username\":100%}}\n\n## Original SQL:\nSELECT \n    u.username, \n    a.request_url, \n    a.response_time_ms, \n    o.order_sn, \n    o.amount\nFROM \n    users u\nJOIN \n    access_logs a ON u.user_id = a.user_id\nLEFT JOIN \n    orders o ON u.user_id = o.user_id\nWHERE \n    a.created_at BETWEEN '2025-09-19 15:50:02' AND '2025-09-19 15:52:02'\n    AND a.response_time_ms > 500\n    AND o.pay_time IS NOT NULL;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_access_logs_covering ON access_logs(created_at, response_time_ms, user_id, request_url); CREATE INDEX idx_orders_covering ON orders(user_id, pay_time, order_sn, amount); Reason: Covering indexes - eliminate full table scans on large tables (1.9M rows for access_logs and 497K rows for orders) by providing indexed access to filtered rows and including all columns required by the query."
                    }
                ]
            },
            {
                "case_id": "56",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"56\", \"difficulty_level\": \"3\", \"description\": \"多表关联的多条件分组排序查询，驱动表识别以及复合索引列顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.user_id,\\n    u.username,\\n    COUNT(o.order_id) AS order_count,\\n    SUM(o.amount) AS total_amount\\nFROM \\n    users u\\nJOIN \\n    orders o ON u.user_id = o.user_id\\nWHERE \\n    u.vip_level > 0\\n    AND o.pay_time BETWEEN '2025-08-10' AND '2025-08-11'\\nGROUP BY \\n    u.user_id, u.username\\nORDER BY \\n    total_amount DESC;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_id\\\":100%,\\\"pay_time\\\":35.23%},\\\"users\\\":{\\\"user_id\\\":100%,\\\"username\\\":100%,\\\"vip_level\\\":0.012%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra                                        |\\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+==============================================+\\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |      11.11 | Using where; Using temporary; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------------------------------------+\\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |      33.33 | Using where                                  |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------------------------------------+\", \"expected\": \"在orders表的pay_time,user_id,amount列创建复合索引，并要求pay_time在最左列\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra                                        |\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+==============================================+\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |      11.11 | Using where; Using temporary; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------------------------------------+\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |      33.33 | Using where                                  |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------------------------------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"order_id\":100%,\"pay_time\":35.23%},\"users\":{\"user_id\":100%,\"username\":100%,\"vip_level\":0.012%}}\n\n## Original SQL:\nSELECT \n    u.user_id,\n    u.username,\n    COUNT(o.order_id) AS order_count,\n    SUM(o.amount) AS total_amount\nFROM \n    users u\nJOIN \n    orders o ON u.user_id = o.user_id\nWHERE \n    u.vip_level > 0\n    AND o.pay_time BETWEEN '2025-08-10' AND '2025-08-11'\nGROUP BY \n    u.user_id, u.username\nORDER BY \n    total_amount DESC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_pay_time_user_id ON orders(pay_time, user_id, order_id, amount); Reason: Covering index - provides all columns needed from orders table (pay_time for range filtering, user_id for join condition, order_id and amount for aggregation), avoiding table lookups and converting the current full table scan into an efficient index range scan."
                    }
                ]
            },
            {
                "case_id": "57",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"57\", \"difficulty_level\": \"3\", \"description\": \"多表关联的多条件分组排序查询，驱动表识别以及复合索引列顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    o.ship_country,\\n    COUNT(o.order_id) AS order_count,\\n    SUM(o.amount) AS total_amount\\nFROM \\n    orders o\\nJOIN \\n    users u ON o.user_id = u.user_id\\nWHERE \\n    u.gender = 1\\n    AND o.currency = 'CNY'\\nGROUP BY \\n    o.ship_country\\nORDER BY \\n    order_count DESC;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"currency\\\":0.002%,\\\"order_id\\\":100%,\\\"ship_country\\\":0.01%},\\\"users\\\":{\\\"gender\\\":0.006%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra                                        |\\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+==============================================+\\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |         10 | Using where; Using temporary; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------------------------------------+\\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |         10 | Using where                                  |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------------------------------------+\", \"expected\": \"三种情况均可：\\n1. 在orders表的currency，user_id列创建复合索引，要求currency在最左列，并且在users表的currency列创建索引。\\n2. 在orders表的 currency 列创建索引。\\n3. 在orders表的currency, user_id, ship_country, amount列创建复合索引currency, user_id为最左列，并在users表的gender列创建索引\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra                                        |\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+==============================================+\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |         10 | Using where; Using temporary; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------------------------------------+\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |         10 | Using where                                  |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------------------------------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"currency\":0.002%,\"order_id\":100%,\"ship_country\":0.01%},\"users\":{\"gender\":0.006%}}\n\n## Original SQL:\nSELECT \n    o.ship_country,\n    COUNT(o.order_id) AS order_count,\n    SUM(o.amount) AS total_amount\nFROM \n    orders o\nJOIN \n    users u ON o.user_id = u.user_id\nWHERE \n    u.gender = 1\n    AND o.currency = 'CNY'\nGROUP BY \n    o.ship_country\nORDER BY \n    order_count DESC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_by_currency ON orders(currency, ship_country, user_id, order_id, amount); Reason: Covering index - Includes all columns needed for filtering (currency), grouping (ship_country), joining (user_id), and aggregation (order_id, amount) to eliminate the full table scan (497,490 rows) and expensive temporary/filesort operations."
                    }
                ]
            },
            {
                "case_id": "58",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"58\", \"difficulty_level\": \"3\", \"description\": \"多表关联的多条件分组排序查询，驱动表识别以及复合索引列顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.user_id, \\n    u.username, \\n    u.email, \\n    o.order_id, \\n    o.order_sn, \\n    o.amount, \\n    o.pay_time\\nFROM \\n    users u\\nLEFT JOIN \\n    orders o ON u.user_id = o.user_id\\nWHERE \\n    u.vip_level > 0\\nORDER BY \\n    u.register_channel DESC, \\n    u.user_id DESC\\nLIMIT 100;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_id\\\":100%,\\\"order_sn\\\":100%,\\\"pay_time\\\":35.23%},\\\"users\\\":{\\\"email\\\":100%,\\\"user_id\\\":100%,\\\"username\\\":100%,\\\"vip_level\\\":0.012%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                                              |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+====================================================+\\n|    1 | SIMPLE        | u       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      33.33 | Using where; Using temporary; Using filesort       |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------------+\\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |     100    | Using where; Using join buffer (Block Nested Loop) |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------------+\", \"expected\": \"在orders表的user_id列添加索引用以加速关联，并且在users表的register_channel列创建索引用以消除文件排序\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                                              |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+====================================================+\n|    1 | SIMPLE        | u       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      33.33 | Using where; Using temporary; Using filesort       |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------------+\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |     100    | Using where; Using join buffer (Block Nested Loop) |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"order_id\":100%,\"order_sn\":100%,\"pay_time\":35.23%},\"users\":{\"email\":100%,\"user_id\":100%,\"username\":100%,\"vip_level\":0.012%}}\n\n## Original SQL:\nSELECT \n    u.user_id, \n    u.username, \n    u.email, \n    o.order_id, \n    o.order_sn, \n    o.amount, \n    o.pay_time\nFROM \n    users u\nLEFT JOIN \n    orders o ON u.user_id = o.user_id\nWHERE \n    u.vip_level > 0\nORDER BY \n    u.register_channel DESC, \n    u.user_id DESC\nLIMIT 100;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_users_vip_order ON users(vip_level, register_channel, user_id); CREATE INDEX idx_orders_user_id ON orders(user_id); Reason: Composite index - optimizes WHERE filtering on vip_level and ORDER BY sorting on register_channel and user_id for users table; Single-column index - optimizes JOIN condition on user_id to eliminate full table scan on orders table and replace Block Nested Loop join with efficient index lookup."
                    }
                ]
            },
            {
                "case_id": "59",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"59\", \"difficulty_level\": \"3\", \"description\": \"多表关联的多条件分组排序查询，驱动表识别以及复合索引列顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT o.order_id, o.order_sn, o.amount, o.pay_time, o.ship_city\\n     FROM orders o\\n     JOIN users u ON o.user_id = u.user_id\\n     WHERE u.email = 'user_18@test.com'\\n     ORDER BY o.amount DESC;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_id\\\":100%,\\\"order_sn\\\":100%,\\\"pay_time\\\":35.23%,\\\"ship_city\\\":0.01%},\\\"users\\\":{\\\"email\\\":100%}}\", \"explain\": \"|id |select_type|table|partitions|type |possible_keys|key  |key_len|ref  |rows   |filtered|Extra                      |\\n|---|-----------|-----|----------|-----|-------------|-----|-------|-----|-------|--------|---------------------------|\\n|1  |SIMPLE     |u    |          |const|PRIMARY,email|email|803    |const|1      |100     |Using index; Using filesort|\\n|1  |SIMPLE     |o    |          |ALL  |             |     |       |     |497,837|10      |Using where                |\", \"expected\": \"以下两种情况均可：\\n1. 在orders表的user_id，amount列建立复合索引，注意user_id必须在最左边\\n2. 在orders表的user_id, amount, order_sn, pay_time, ship_city列创建覆盖索引，要求user_id，amount为左列\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n|id |select_type|table|partitions|type |possible_keys|key  |key_len|ref  |rows   |filtered|Extra                      |\n|---|-----------|-----|----------|-----|-------------|-----|-------|-----|-------|--------|---------------------------|\n|1  |SIMPLE     |u    |          |const|PRIMARY,email|email|803    |const|1      |100     |Using index; Using filesort|\n|1  |SIMPLE     |o    |          |ALL  |             |     |       |     |497,837|10      |Using where                |\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"order_id\":100%,\"order_sn\":100%,\"pay_time\":35.23%,\"ship_city\":0.01%},\"users\":{\"email\":100%}}\n\n## Original SQL:\nSELECT o.order_id, o.order_sn, o.amount, o.pay_time, o.ship_city\n     FROM orders o\n     JOIN users u ON o.user_id = u.user_id\n     WHERE u.email = 'user_18@test.com'\n     ORDER BY o.amount DESC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_user_id_amount ON orders(user_id, amount DESC); Reason: Composite index - resolves the full table scan on the orders table by enabling efficient index lookup for the join condition (user_id = X) and eliminates the filesort by providing pre-sorted results in the required order (amount DESC)."
                    }
                ]
            },
            {
                "case_id": "60",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"60\", \"difficulty_level\": \"3\", \"description\": \"多表关联的多条件分组排序查询，驱动表识别以及复合索引列顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT u.user_id, u.username, SUM(o.amount) AS total_amount\\n     FROM users u\\n     JOIN orders o ON u.user_id = o.user_id\\n     WHERE u.last_login >= DATE_SUB(NOW(), INTERVAL 2 MONTH)\\n       AND u.vip_level >= 3\\n     GROUP BY u.user_id, u.username;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%},\\\"users\\\":{\\\"last_login\\\":35.294%,\\\"user_id\\\":100%,\\\"username\\\":100%,\\\"vip_level\\\":0.012%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+---------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra                           |\\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+=================================+\\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |     100    | Using temporary; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+---------------------------------+\\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |      11.11 | Using where                     |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+---------------------------------+\", \"expected\": \"必须：在orders表的user_id列加单列索引或者user_id, amount加符合索引，user_id在最左列\\n可选：在users表的last_login，vip_level或者last_login,vip_level,  username列建立覆盖索引，注意last_login列要求在最左列\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+---------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra                           |\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+=================================+\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |     100    | Using temporary; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+---------------------------------+\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |      11.11 | Using where                     |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+---------------------------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%},\"users\":{\"last_login\":35.294%,\"user_id\":100%,\"username\":100%,\"vip_level\":0.012%}}\n\n## Original SQL:\nSELECT u.user_id, u.username, SUM(o.amount) AS total_amount\n     FROM users u\n     JOIN orders o ON u.user_id = o.user_id\n     WHERE u.last_login >= DATE_SUB(NOW(), INTERVAL 2 MONTH)\n       AND u.vip_level >= 3\n     GROUP BY u.user_id, u.username;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_users_vip_last_login ON users(vip_level, last_login, user_id, username); Reason: Covering index - enables efficient filtering on WHERE conditions (vip_level, last_login) before joining with orders, allowing the optimizer to identify matching users upfront and reduce the dataset from 497,490 rows, eliminating the expensive full table scan."
                    }
                ]
            },
            {
                "case_id": "61",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"61\", \"difficulty_level\": \"3\", \"description\": \"多表，group by 不同表-关联查询中GROUP BY相同表的多列需要按字段顺序创建复合索引解决临时表和文件排序问题\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.user_id, \\n    u.username, \\n    SUM(o.amount) AS total_amount\\nFROM \\n    users u\\nJOIN \\n    orders o ON u.user_id = o.user_id\\nGROUP BY \\n    u.user_id, u.username;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%},\\\"users\\\":{\\\"user_id\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+---------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra                           |\\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+=================================+\\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |        100 | Using temporary; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+---------------------------------+\\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |        100 | NULL                            |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+---------------------------------+\", \"expected\": \"以下两种情况均可：\\n1. 在orders表的 user_id 列上创建索引，并且在users表的 user_id,username 列创建复合索引，user_id列必须在最左列\\n2. 在orders表的 user_id，amount列创建复合索引，要求user_id为左列\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+---------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra                           |\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+=================================+\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |        100 | Using temporary; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+---------------------------------+\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |        100 | NULL                            |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+---------------------------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%},\"users\":{\"user_id\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT \n    u.user_id, \n    u.username, \n    SUM(o.amount) AS total_amount\nFROM \n    users u\nJOIN \n    orders o ON u.user_id = o.user_id\nGROUP BY \n    u.user_id, u.username;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_user_id_amount ON orders(user_id, amount); Reason: Covering index - includes both the join column (user_id) and aggregation column (amount) to enable index-only scan, eliminating the full table scan of 497,490 rows on the orders table and improving join and aggregation performance."
                    }
                ]
            },
            {
                "case_id": "62",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"62\", \"difficulty_level\": \"3\", \"description\": \"多表，group by 不同表-关联查询中GROUP BY不同表的列无法解决临时表和文件排序问题\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.user_id, \\n    u.username, \\n    u.email, \\n    o.order_id, \\n    o.amount, \\n    o.pay_time\\nFROM \\n    users u\\nLEFT JOIN \\n    orders o ON u.user_id = o.user_id\\nORDER BY \\n    u.register_channel, \\n    o.pay_time DESC;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_id\\\":100%,\\\"pay_time\\\":35.23%},\\\"users\\\":{\\\"email\\\":100%,\\\"user_id\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                                              |\\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+====================================================+\\n|    1 | SIMPLE        | u       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |        100 | Using temporary; Using filesort                    |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------------+\\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |        100 | Using where; Using join buffer (Block Nested Loop) |\\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------------+\", \"expected\": \"在orders表的 user_id 列添加索引\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra                                              |\n+======+===============+=========+==============+========+=================+=======+===========+=======+========+============+====================================================+\n|    1 | SIMPLE        | u       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |        100 | Using temporary; Using filesort                    |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------------+\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |        100 | Using where; Using join buffer (Block Nested Loop) |\n+------+---------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+----------------------------------------------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"order_id\":100%,\"pay_time\":35.23%},\"users\":{\"email\":100%,\"user_id\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT \n    u.user_id, \n    u.username, \n    u.email, \n    o.order_id, \n    o.amount, \n    o.pay_time\nFROM \n    users u\nLEFT JOIN \n    orders o ON u.user_id = o.user_id\nORDER BY \n    u.register_channel, \n    o.pay_time DESC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_user_id_covering ON orders(user_id, pay_time, order_id, amount); Reason: Covering index - includes user_id for join condition, pay_time for ORDER BY, and order_id/amount for SELECT clause, converting expensive Block Nested Loop full table scan to efficient indexed join and eliminating heap lookups on the orders table."
                    }
                ]
            },
            {
                "case_id": "63",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"63\", \"difficulty_level\": \"3\", \"description\": \"多表，相同表多字段排序-关联表查询ORDER BY 相同表多字段，解决文件排序问题，包括需要将主键加入复合索引的场景\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    o.order_id, \\n    o.amount, \\n    o.ship_country, \\n    o.ship_city, \\n    u.user_id, \\n    u.username\\nFROM \\n    orders o\\nLEFT JOIN \\n    users u ON o.user_id = u.user_id\\nORDER BY \\n    o.order_id ASC, \\n    o.ship_city ASC;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_id\\\":100%,\\\"ship_city\\\":0.01%,\\\"ship_country\\\":0.01%},\\\"users\\\":{\\\"user_id\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra          |\\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+================+\\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |        100 | Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |        100 | NULL           |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\", \"expected\": \"两种情况均可\\n1. 无法通过索引解决SQL性能问题\\n2. 在orders表的order_id、ship_city列创建复合索引，要求order_id为左列\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra          |\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+================+\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |        100 | Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |        100 | NULL           |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"order_id\":100%,\"ship_city\":0.01%,\"ship_country\":0.01%},\"users\":{\"user_id\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT \n    o.order_id, \n    o.amount, \n    o.ship_country, \n    o.ship_city, \n    u.user_id, \n    u.username\nFROM \n    orders o\nLEFT JOIN \n    users u ON o.user_id = u.user_id\nORDER BY \n    o.order_id ASC, \n    o.ship_city ASC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_sort_covering ON orders(order_id, ship_city, amount, ship_country); Reason: Covering index - eliminates the filesort operation and table lookups by including all selected columns from the orders table in the correct sort order, significantly improving performance on this large dataset (497K rows)."
                    }
                ]
            },
            {
                "case_id": "64",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"64\", \"difficulty_level\": \"3\", \"description\": \"多表，相同表多字段排序-关联表查询ORDER BY 相同表多字段，解决文件排序问题，包括需要将主键加入复合索引的场景\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    o.order_id, \\n    o.amount, \\n    o.ship_country, \\n    o.ship_city, \\n    u.user_id, \\n    u.username\\nFROM \\n    orders o\\nLEFT JOIN \\n    users u ON o.user_id = u.user_id\\nORDER BY \\n    o.ship_country ASC, \\n    o.ship_city ASC;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_id\\\":100%,\\\"ship_city\\\":0.01%,\\\"ship_country\\\":0.01%},\\\"users\\\":{\\\"user_id\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra          |\\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+================+\\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |        100 | Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |        100 | NULL           |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\", \"expected\": \"两种情况均可\\n1. 无法通过索引解决SQL性能问题\\n2. 在orders表的ship_country、ship_city列创建复合索引，要求ship_country为左列\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra          |\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+================+\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |        100 | Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |        100 | NULL           |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"order_id\":100%,\"ship_city\":0.01%,\"ship_country\":0.01%},\"users\":{\"user_id\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT \n    o.order_id, \n    o.amount, \n    o.ship_country, \n    o.ship_city, \n    u.user_id, \n    u.username\nFROM \n    orders o\nLEFT JOIN \n    users u ON o.user_id = u.user_id\nORDER BY \n    o.ship_country ASC, \n    o.ship_city ASC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_ship_country_city ON orders(ship_country, ship_city, order_id, amount, user_id); Reason: Covering index - eliminates full table scan and filesort by providing all columns needed for SELECT and JOIN operations in the correct sort order."
                    }
                ]
            },
            {
                "case_id": "65",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"65\", \"difficulty_level\": \"3\", \"description\": \"多表，相同表多字段排序-当INNER JOIN时，在数据量较大的驱动表上创建索引（可以转换驱动表与被驱动表，从而减少扫描行数）\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    o.order_id, \\n    o.amount, \\n    o.ship_country, \\n    o.ship_city, \\n    u.user_id, \\n    u.username\\nFROM \\n    orders o\\nINNER JOIN \\n    users u ON o.user_id = u.user_id\\nORDER BY \\n    o.ship_country ASC, \\n    o.ship_city ASC;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_id\\\":100%,\\\"ship_city\\\":0.01%,\\\"ship_country\\\":0.01%},\\\"users\\\":{\\\"user_id\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra          |\\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+================+\\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |        100 | Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |        100 | NULL           |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\", \"expected\": \"两种情况均可：\\n1. 在orders表的user_id列创建索引\\n2. 在orders表的user_id,ship_country,ship_city列创建复合索引，要求列顺序为：user_id,ship_country,ship_city\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |   rows |   filtered | Extra          |\n+======+===============+=========+==============+========+=================+=========+===========+======================+========+============+================+\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 497490 |        100 | Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |      1 |        100 | NULL           |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+--------+------------+----------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"order_id\":100%,\"ship_city\":0.01%,\"ship_country\":0.01%},\"users\":{\"user_id\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT \n    o.order_id, \n    o.amount, \n    o.ship_country, \n    o.ship_city, \n    u.user_id, \n    u.username\nFROM \n    orders o\nINNER JOIN \n    users u ON o.user_id = u.user_id\nORDER BY \n    o.ship_country ASC, \n    o.ship_city ASC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_ship_covering ON orders(ship_country, ship_city, order_id, amount, user_id); Reason: Covering index - eliminates full table scan (497490 rows) and filesort by including all required columns (ship_country, ship_city for ORDER BY, plus order_id, amount, user_id for SELECT list), enabling efficient index-only execution."
                    }
                ]
            },
            {
                "case_id": "66",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"66\", \"difficulty_level\": \"3\", \"description\": \"表关联，复杂场景-关联查询的复合索引中关联列、条件列和排序/分组列的顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.username, \\n    o.order_sn, \\n    o.amount, \\n    o.pay_time, \\n    p.product_name, \\n    p.price, \\n    p.brand\\nFROM \\n    users u\\nJOIN \\n    orders o ON u.user_id = o.user_id\\nJOIN \\n    products p ON o.order_id = p.product_id\\nWHERE \\n    u.user_id = 12272\\nORDER BY \\n    o.pay_time DESC;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_sn\\\":100%,\\\"pay_time\\\":35.23%},\\\"products\\\":{\\\"brand\\\":0.05%,\\\"price\\\":97.37%,\\\"product_name\\\":100%},\\\"users\\\":{\\\"user_id\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+---------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                     |   rows |   filtered | Extra                           |\\n+======+===============+=========+==============+========+=================+=========+===========+=========================+========+============+=================================+\\n|    1 | SIMPLE        | u       | NULL         | const  | PRIMARY         | PRIMARY | 8         | const                   |      1 |        100 | Using temporary; Using filesort |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+---------------------------------+\\n|    1 | SIMPLE        | p       | NULL         | ALL    | PRIMARY         | NULL    | NULL      | NULL                    |   9836 |        100 | NULL                            |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+---------------------------------+\\n|    1 | SIMPLE        | o       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.p.product_id |      1 |         10 | Using where                     |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+---------------------------------+\", \"expected\": \"以下两种情况均可：\\n1. 在orders表的user_id,pay_time列添加复合索引，user_id列必须在左边\\n2. 无性能问题，不需要创建索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+---------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                     |   rows |   filtered | Extra                           |\n+======+===============+=========+==============+========+=================+=========+===========+=========================+========+============+=================================+\n|    1 | SIMPLE        | u       | NULL         | const  | PRIMARY         | PRIMARY | 8         | const                   |      1 |        100 | Using temporary; Using filesort |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+---------------------------------+\n|    1 | SIMPLE        | p       | NULL         | ALL    | PRIMARY         | NULL    | NULL      | NULL                    |   9836 |        100 | NULL                            |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+---------------------------------+\n|    1 | SIMPLE        | o       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.p.product_id |      1 |         10 | Using where                     |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+-------------------------+--------+------------+---------------------------------+\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"order_sn\":100%,\"pay_time\":35.23%},\"products\":{\"brand\":0.05%,\"price\":97.37%,\"product_name\":100%},\"users\":{\"user_id\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT \n    u.username, \n    o.order_sn, \n    o.amount, \n    o.pay_time, \n    p.product_name, \n    p.price, \n    p.brand\nFROM \n    users u\nJOIN \n    orders o ON u.user_id = o.user_id\nJOIN \n    products p ON o.order_id = p.product_id\nWHERE \n    u.user_id = 12272\nORDER BY \n    o.pay_time DESC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_user_id_pay_time ON orders(user_id, pay_time DESC); Reason: Composite index - supports the WHERE clause filter on user_id = 12272 and ORDER BY pay_time DESC, eliminating the \"Using temporary; Using filesort\" operations that are causing performance degradation."
                    }
                ]
            },
            {
                "case_id": "67",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"67\", \"difficulty_level\": \"3\", \"description\": \"表关联，复杂场景-关联查询的复合索引中关联列、条件列和排序/分组列的顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.user_id,\\n    u.username,\\n    u.vip_level,\\n    o.order_sn,\\n    o.pay_time,\\n    al.request_url,\\n    al.created_at AS access_time\\nFROM \\n    users u\\nJOIN \\n    orders o ON u.user_id = o.user_id\\nJOIN \\n    access_logs al ON u.user_id = al.user_id\\nWHERE \\n    u.vip_level > 0\\nORDER BY \\n    u.user_id, al.created_at DESC;\", \"columns_selectivity\": \"{\\\"access_logs\\\":{\\\"created_at\\\":0.038%,\\\"request_url\\\":2%},\\\"orders\\\":{\\\"order_sn\\\":100%,\\\"pay_time\\\":35.23%},\\\"users\\\":{\\\"user_id\\\":100%,\\\"username\\\":100%,\\\"vip_level\\\":0.012%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |    rows |   filtered | Extra                                              |\\n+======+===============+=========+==============+========+=================+=========+===========+======================+=========+============+====================================================+\\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 |  497490 |     100    | Using temporary; Using filesort                    |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |       1 |      33.33 | Using where                                        |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\\n|    1 | SIMPLE        | al      | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 1987219 |      10    | Using where; Using join buffer (Block Nested Loop) |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\", \"expected\": \"两种情况均可：\\n1. 分别在orders表的user_id列和access_logs表的user_id列添加索引。\\n2. 在access_logs表的user_id列添加索引。\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |    rows |   filtered | Extra                                              |\n+======+===============+=========+==============+========+=================+=========+===========+======================+=========+============+====================================================+\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 |  497490 |     100    | Using temporary; Using filesort                    |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |       1 |      33.33 | Using where                                        |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\n|    1 | SIMPLE        | al      | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 1987219 |      10    | Using where; Using join buffer (Block Nested Loop) |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\n\n## Column Selectivity:\n{\"access_logs\":{\"created_at\":0.038%,\"request_url\":2%},\"orders\":{\"order_sn\":100%,\"pay_time\":35.23%},\"users\":{\"user_id\":100%,\"username\":100%,\"vip_level\":0.012%}}\n\n## Original SQL:\nSELECT \n    u.user_id,\n    u.username,\n    u.vip_level,\n    o.order_sn,\n    o.pay_time,\n    al.request_url,\n    al.created_at AS access_time\nFROM \n    users u\nJOIN \n    orders o ON u.user_id = o.user_id\nJOIN \n    access_logs al ON u.user_id = al.user_id\nWHERE \n    u.vip_level > 0\nORDER BY \n    u.user_id, al.created_at DESC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_access_logs_user_id_created_at ON access_logs(user_id, created_at DESC); CREATE INDEX idx_orders_user_id ON orders(user_id); CREATE INDEX idx_users_vip_level ON users(vip_level); Reason: Composite and single-column indexes - composite index on access_logs(user_id, created_at DESC) eliminates the full table scan of 1.9M rows and optimizes ORDER BY sorting; single-column indexes on orders(user_id) and users(vip_level) optimize join operations and WHERE clause filtering."
                    }
                ]
            },
            {
                "case_id": "68",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"68\", \"difficulty_level\": \"3\", \"description\": \"表关联，复杂场景-关联查询的复合索引中关联列、条件列和排序/分组列的顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.user_id, \\n    u.username, \\n    a.request_url, \\n    a.response_code, \\n    o.order_id, \\n    o.amount, \\n    o.pay_time\\nFROM \\n    users u\\nJOIN \\n    access_logs a ON u.user_id = a.user_id\\nJOIN \\n    orders o ON u.user_id = o.user_id\\nWHERE \\n    a.request_url LIKE '%/resource%'\\n    AND o.amount > 500\\nORDER BY \\n    o.pay_time DESC;\", \"columns_selectivity\": \"{\\\"access_logs\\\":{\\\"request_url\\\":2%,\\\"response_code\\\":0.006%},\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_id\\\":100%,\\\"pay_time\\\":35.23%},\\\"users\\\":{\\\"user_id\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |    rows |   filtered | Extra                                              |\\n+======+===============+=========+==============+========+=================+=========+===========+======================+=========+============+====================================================+\\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 |  497490 |      33.33 | Using where; Using temporary; Using filesort       |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |       1 |     100    | NULL                                               |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\\n|    1 | SIMPLE        | a       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 1987219 |       1.11 | Using where; Using join buffer (Block Nested Loop) |\\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\", \"expected\": \"在orders表的amount,pay_time,user_id列创建覆盖索引，且列顺序为(amount,pay_time,user_id)或(user_id,pay_time,amount)，并在access_logs表的user_id或user_id, request_url, response_code列创建索引\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\n|   id | select_type   | table   | partitions   | type   | possible_keys   | key     | key_len   | ref                  |    rows |   filtered | Extra                                              |\n+======+===============+=========+==============+========+=================+=========+===========+======================+=========+============+====================================================+\n|    1 | SIMPLE        | o       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 |  497490 |      33.33 | Using where; Using temporary; Using filesort       |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\n|    1 | SIMPLE        | u       | NULL         | eq_ref | PRIMARY         | PRIMARY | 8         | test_index.o.user_id |       1 |     100    | NULL                                               |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\n|    1 | SIMPLE        | a       | NULL         | ALL    | NULL            | NULL    | NULL      | NULL                 | 1987219 |       1.11 | Using where; Using join buffer (Block Nested Loop) |\n+------+---------------+---------+--------------+--------+-----------------+---------+-----------+----------------------+---------+------------+----------------------------------------------------+\n\n## Column Selectivity:\n{\"access_logs\":{\"request_url\":2%,\"response_code\":0.006%},\"orders\":{\"amount\":94.296%,\"order_id\":100%,\"pay_time\":35.23%},\"users\":{\"user_id\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT \n    u.user_id, \n    u.username, \n    a.request_url, \n    a.response_code, \n    o.order_id, \n    o.amount, \n    o.pay_time\nFROM \n    users u\nJOIN \n    access_logs a ON u.user_id = a.user_id\nJOIN \n    orders o ON u.user_id = o.user_id\nWHERE \n    a.request_url LIKE '%/resource%'\n    AND o.amount > 500\nORDER BY \n    o.pay_time DESC;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_access_logs_user_id ON access_logs(user_id); CREATE INDEX idx_orders_amount_pay_time ON orders(amount, pay_time); Reason: Single-column index enables efficient join on access_logs.user_id replacing Block Nested Loop full table scan of 1.98M rows; Covering index optimizes orders table by supporting WHERE (amount > 500) filtering and ORDER BY (pay_time DESC) sorting without filesort, eliminating the need to scan 497K rows."
                    }
                ]
            },
            {
                "case_id": "69",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"69\", \"difficulty_level\": \"3\", \"description\": \"关联子查询-子查询索引创建，条件列和查询列在覆盖索引中的顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.user_id, \\n    u.username, \\n    (SELECT MAX(created_at) \\n     FROM access_logs \\n     WHERE user_id = u.user_id) AS last_login_time\\nFROM \\n    users u\\nWHERE \\n    u.vip_level > 0;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"user_id\\\":100%,\\\"username\\\":100%},\\\"access_logs\\\":{\\\"user_id\\\":5.0460%,\\\"created_at\\\":1.3960%},}\", \"explain\": \"以下两种情况均可：\\n1. 无法通过索引解决SQL性能问题，response_code 列选择性过低或存在隐式类型转换。\\n2. 给access_logs表的response_code加索引。\\n（隐式类型转换导致索引失效的前提是在索引列上进行转换，默认情况下MySQL的转换规则是将字符串转为数字，所以response_code的索引是有效的）\", \"expected\": \"必须：在access_logs表的(user_id)或(user_id、created_at)列创建索引\\n可选：在users表的(vip_level)或(username,vip_level)列创建索引，要求vip_level为左列\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n以下两种情况均可：\n1. 无法通过索引解决SQL性能问题，response_code 列选择性过低或存在隐式类型转换。\n2. 给access_logs表的response_code加索引。\n（隐式类型转换导致索引失效的前提是在索引列上进行转换，默认情况下MySQL的转换规则是将字符串转为数字，所以response_code的索引是有效的）\n\n## Column Selectivity:\n{\"users\":{\"user_id\":100%,\"username\":100%},\"access_logs\":{\"user_id\":5.0460%,\"created_at\":1.3960%},}\n\n## Original SQL:\nSELECT \n    u.user_id, \n    u.username, \n    (SELECT MAX(created_at) \n     FROM access_logs \n     WHERE user_id = u.user_id) AS last_login_time\nFROM \n    users u\nWHERE \n    u.vip_level > 0;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_users_vip_level ON users(vip_level); CREATE INDEX idx_access_logs_user_id_created_at ON access_logs(user_id, created_at); Reason: Single-column and Covering index - The single-column index on vip_level optimizes the main query filter, while the covering index on access_logs optimizes the correlated subquery by covering both the filter column (user_id) and aggregation column (created_at)."
                    }
                ]
            },
            {
                "case_id": "70",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"70\", \"difficulty_level\": \"3\", \"description\": \"关联子查询-子查询索引创建，条件列和查询列在覆盖索引中的顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.user_id, \\n    u.username, \\n    (SELECT AVG(o.amount) \\n     FROM orders o \\n     WHERE o.user_id = u.user_id) AS avg_amount,\\n    (SELECT MAX(o.pay_time) \\n     FROM orders o \\n     WHERE o.user_id = u.user_id) AS last_order_time\\nFROM \\n    users u\\nWHERE \\n    u.gender = 1;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"user_id\\\":100%,\\\"username\\\":100%,\\\"gender\\\":0.0060%},\\\"orders\\\":{\\\"user_id\\\":77.9820%,\\\"amount\\\":94.2960%,\\\"pay_time\\\":35.2300%}}\", \"explain\": \"+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type        | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+====================+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | PRIMARY            | u       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |         10 | Using where |\\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|    3 | DEPENDENT SUBQUERY | o       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |         10 | Using where |\\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|    2 | DEPENDENT SUBQUERY | o       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |         10 | Using where |\\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"必须：在orders表的user_id或user_id, amount（也可包含pay_time）列创建索引\\n可选：在users表的gender列（可包含username列）创建合索引，要求gender为左列\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type        | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+====================+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | PRIMARY            | u       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |         10 | Using where |\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|    3 | DEPENDENT SUBQUERY | o       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |         10 | Using where |\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|    2 | DEPENDENT SUBQUERY | o       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |         10 | Using where |\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"users\":{\"user_id\":100%,\"username\":100%,\"gender\":0.0060%},\"orders\":{\"user_id\":77.9820%,\"amount\":94.2960%,\"pay_time\":35.2300%}}\n\n## Original SQL:\nSELECT \n    u.user_id, \n    u.username, \n    (SELECT AVG(o.amount) \n     FROM orders o \n     WHERE o.user_id = u.user_id) AS avg_amount,\n    (SELECT MAX(o.pay_time) \n     FROM orders o \n     WHERE o.user_id = u.user_id) AS last_order_time\nFROM \n    users u\nWHERE \n    u.gender = 1;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_users_gender ON users(gender); CREATE INDEX idx_orders_user_id_amount_paytime ON orders(user_id, amount, pay_time); Reason: Single-column and Covering indexes - Single-column index accelerates gender filtering in the primary query; Covering index eliminates full table scans in dependent subqueries by including all required columns for aggregations."
                    }
                ]
            },
            {
                "case_id": "71",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"71\", \"difficulty_level\": \"3\", \"description\": \"关联子查询-子查询索引创建，条件列和查询列在覆盖索引中的顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    u.user_id, \\n    u.username, \\n    (SELECT COUNT(*) \\n     FROM access_logs a \\n     WHERE a.user_id = u.user_id) AS log_count,\\n    (SELECT a.request_url \\n     FROM access_logs a \\n     WHERE a.user_id = u.user_id \\n     ORDER BY a.created_at DESC \\n     LIMIT 1) AS last_visited_url\\nFROM \\n    users u\\nWHERE \\n    u.points > 500;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"user_id\\\":100%,\\\"username\\\":100%,\\\"points\\\":19.8820%},\\\"access_logs\\\":{\\\"user_id\\\":78.3600%,\\\"request_url\\\":2.0000%,\\\"created_at\\\":0.0380%},}\", \"explain\": \"+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-----------------------------+\\n|   id | select_type        | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra                       |\\n+======+====================+=========+==============+========+=================+=======+===========+=======+=========+============+=============================+\\n|    1 | PRIMARY            | u       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   99553 |      33.33 | Using where                 |\\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-----------------------------+\\n|    3 | DEPENDENT SUBQUERY | a       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |      10    | Using where; Using filesort |\\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-----------------------------+\\n|    2 | DEPENDENT SUBQUERY | a       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |      10    | Using where                 |\\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-----------------------------+\", \"expected\": \"必须：在access_logs表的user_id列创建索引或user_id和created_at列创建复合索引\\n可选：在users表的points,username列创建复合索引，要求points在左边\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-----------------------------+\n|   id | select_type        | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |    rows |   filtered | Extra                       |\n+======+====================+=========+==============+========+=================+=======+===========+=======+=========+============+=============================+\n|    1 | PRIMARY            | u       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   99553 |      33.33 | Using where                 |\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-----------------------------+\n|    3 | DEPENDENT SUBQUERY | a       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |      10    | Using where; Using filesort |\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-----------------------------+\n|    2 | DEPENDENT SUBQUERY | a       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 1987219 |      10    | Using where                 |\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+---------+------------+-----------------------------+\n\n## Column Selectivity:\n{\"users\":{\"user_id\":100%,\"username\":100%,\"points\":19.8820%},\"access_logs\":{\"user_id\":78.3600%,\"request_url\":2.0000%,\"created_at\":0.0380%},}\n\n## Original SQL:\nSELECT \n    u.user_id, \n    u.username, \n    (SELECT COUNT(*) \n     FROM access_logs a \n     WHERE a.user_id = u.user_id) AS log_count,\n    (SELECT a.request_url \n     FROM access_logs a \n     WHERE a.user_id = u.user_id \n     ORDER BY a.created_at DESC \n     LIMIT 1) AS last_visited_url\nFROM \n    users u\nWHERE \n    u.points > 500;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_users_points ON users(points); CREATE INDEX idx_access_logs_user_id_created_at_request_url ON access_logs(user_id, created_at DESC, request_url); Reason: Single-column index on users.points to eliminate full table scan in WHERE clause; Covering index on access_logs to eliminate filesort for ORDER BY and enable index-only access for the dependent subqueries with efficient user_id filtering."
                    }
                ]
            },
            {
                "case_id": "72",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"72\", \"difficulty_level\": \"3\", \"description\": \"关联子查询-子查询索引创建，条件列和查询列在覆盖索引中的顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n    p.product_id, \\n    p.product_name, \\n    p.stock\\nFROM \\n    products p\\nWHERE \\n    p.is_imported = 1 \\n    AND p.stock > (\\n        SELECT AVG(stock) \\n        FROM products \\n        WHERE is_imported = 1\\n    );\", \"columns_selectivity\": \"{\\\"products\\\":{\\\"is_imported\\\":0.02%,\\\"product_id\\\":100%,\\\"product_name\\\":100%,\\\"stock\\\":10%}}\", \"explain\": \"+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | PRIMARY       | p        | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |       3.33 | Using where |\\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|    2 | SUBQUERY      | products | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |      10    | Using where |\\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"三种情况均可：\\n1. 所涉及到的列选择性过低，无法通过索引解决SQL性能问题\\n2. 为此查询创建覆盖索引，在products表的is_imported,stock,product_name列创建复合索引，列顺序为is_imported,stock,product_name\\n3. 为此查询创建覆盖索引，在products表的is_imported,stock列创建复合索引，列顺序为is_imported,stock\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type   | table    | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+===============+==========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | PRIMARY       | p        | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |       3.33 | Using where |\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|    2 | SUBQUERY      | products | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |   9836 |      10    | Using where |\n+------+---------------+----------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"products\":{\"is_imported\":0.02%,\"product_id\":100%,\"product_name\":100%,\"stock\":10%}}\n\n## Original SQL:\nSELECT \n    p.product_id, \n    p.product_name, \n    p.stock\nFROM \n    products p\nWHERE \n    p.is_imported = 1 \n    AND p.stock > (\n        SELECT AVG(stock) \n        FROM products \n        WHERE is_imported = 1\n    );\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_products_imported_stock ON products(is_imported, stock); Reason: Composite index - eliminates full table scans by enabling efficient index range scans on WHERE conditions (is_imported equality filter + stock range condition), improving both main query and subquery performance."
                    }
                ]
            },
            {
                "case_id": "73",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"73\", \"difficulty_level\": \"3\", \"description\": \"关联子查询-子查询索引创建，条件列和查询列在覆盖索引中的顺序\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\\nCREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\\nCREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT u.user_id, u.username, u.email\\nFROM users u\\nWHERE EXISTS (\\n    SELECT 1\\n    FROM orders o\\n    WHERE o.user_id = u.user_id\\n    AND o.pay_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)\\n)\\nAND u.last_login >= DATE_SUB(NOW(), INTERVAL 7 DAY);\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"user_id\\\":100%,\\\"username\\\":100%,\\\"last_login\\\":35.2940%,\\\"email\\\":100%,},\\\"orders\\\":{\\\"user_id\\\":77.9820%,\\\"pay_time\\\":35.2300%}}\", \"explain\": \"+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|   id | select_type        | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\\n+======+====================+=========+==============+========+=================+=======+===========+=======+========+============+=============+\\n|    1 | PRIMARY            | u       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      33.33 | Using where |\\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\\n|    2 | DEPENDENT SUBQUERY | o       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |       3.33 | Using where |\\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\", \"expected\": \"在orders表的user_id，pay_time列创建复合索引，user_id必须为最左列，并在users表的last_login列创建索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|   id | select_type        | table   | partitions   | type   | possible_keys   | key   | key_len   | ref   |   rows |   filtered | Extra       |\n+======+====================+=========+==============+========+=================+=======+===========+=======+========+============+=============+\n|    1 | PRIMARY            | u       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  |  99553 |      33.33 | Using where |\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n|    2 | DEPENDENT SUBQUERY | o       | NULL         | ALL    | NULL            | NULL  | NULL      | NULL  | 497490 |       3.33 | Using where |\n+------+--------------------+---------+--------------+--------+-----------------+-------+-----------+-------+--------+------------+-------------+\n\n## Column Selectivity:\n{\"users\":{\"user_id\":100%,\"username\":100%,\"last_login\":35.2940%,\"email\":100%,},\"orders\":{\"user_id\":77.9820%,\"pay_time\":35.2300%}}\n\n## Original SQL:\nSELECT u.user_id, u.username, u.email\nFROM users u\nWHERE EXISTS (\n    SELECT 1\n    FROM orders o\n    WHERE o.user_id = u.user_id\n    AND o.pay_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)\n)\nAND u.last_login >= DATE_SUB(NOW(), INTERVAL 7 DAY);\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_user_id_pay_time ON orders(user_id, pay_time); CREATE INDEX idx_users_last_login ON users(last_login); Reason: Composite index - optimizes dependent subquery by enabling efficient index seek on user_id and range scan on pay_time instead of full table scan; Single-column index - accelerates main query filtering by last_login to reduce rows passed to dependent subquery."
                    }
                ]
            },
            {
                "case_id": "74",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"74\", \"difficulty_level\": \"3\", \"description\": \"隐式类型转换的查询-隐式类型转换导致索引失效的前提是在索引列上进行转换，默认情况下MySQL的转换规则是将字符串转为数字\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * \\nFROM users \\nWHERE username = 1234;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"username\\\":100%}}\", \"explain\": \"|id |select_type|table|partitions|type|possible_keys|key|key_len|ref|rows  |filtered|Extra      |\\n|---|-----------|-----|----------|----|-------------|---|-------|---|------|--------|-----------|\\n|1  |SIMPLE     |users|          |ALL |             |   |       |   |99,494|10      |Using where|\", \"expected\": \"无法通过索引解决SQL存在的性能问题，存在隐式类型转换\\n（隐式类型转换导致索引失效的前提是在索引列上进行转换，默认情况下MySQL的转换规则是将字符串转为数字）\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n|id |select_type|table|partitions|type|possible_keys|key|key_len|ref|rows  |filtered|Extra      |\n|---|-----------|-----|----------|----|-------------|---|-------|---|------|--------|-----------|\n|1  |SIMPLE     |users|          |ALL |             |   |       |   |99,494|10      |Using where|\n\n## Column Selectivity:\n{\"users\":{\"username\":100%}}\n\n## Original SQL:\nSELECT * \nFROM users \nWHERE username = 1234;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_username ON users(username); Reason: Single-column index - Eliminates full table scan (ALL) by providing indexed access on the username WHERE clause equality filter."
                    }
                ]
            },
            {
                "case_id": "75",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"75\", \"difficulty_level\": \"3\", \"description\": \"隐式类型转换的查询-隐式类型转换导致索引失效的前提是在索引列上进行转换，默认情况下MySQL的转换规则是将字符串转为数字\", \"create_table_statements\": \"CREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT * \\nFROM access_logs\\nWHERE response_code = '200';\", \"columns_selectivity\": \"{\\\"access_logs\\\":{\\\"response_code\\\":0.006%}}\", \"explain\": \"|id |select_type|table      |partitions|type|possible_keys|key|key_len|ref|rows     |filtered|Extra      |\\n|---|-----------|-----------|----------|----|-------------|---|-------|---|---------|--------|-----------|\\n|1  |SIMPLE     |access_logs|          |ALL |             |   |       |   |1,988,985|10      |Using where|\", \"expected\": \"以下两种情况均可：\\n1. 无法通过索引解决SQL性能问题，response_code 列选择性过低或存在隐式类型转换。\\n2. 给access_logs表的response_code加索引。\\n（隐式类型转换导致索引失效的前提是在索引列上进行转换，默认情况下MySQL的转换规则是将字符串转为数字，所以response_code的索引是有效的）\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n|id |select_type|table      |partitions|type|possible_keys|key|key_len|ref|rows     |filtered|Extra      |\n|---|-----------|-----------|----------|----|-------------|---|-------|---|---------|--------|-----------|\n|1  |SIMPLE     |access_logs|          |ALL |             |   |       |   |1,988,985|10      |Using where|\n\n## Column Selectivity:\n{\"access_logs\":{\"response_code\":0.006%}}\n\n## Original SQL:\nSELECT * \nFROM access_logs\nWHERE response_code = '200';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_response_code ON access_logs(response_code); Reason: Single-column index - eliminates full table scan of ~2M rows by enabling efficient direct lookup on the response_code column, reducing rows examined from 1,988,985 to approximately 199K matching rows."
                    }
                ]
            },
            {
                "case_id": "76",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"76\", \"difficulty_level\": \"3\", \"description\": \"隐式类型转换的查询-表字符集不一致，utf8mb4向下兼容utf8，如果驱动表(列)为utf8，被驱动表(列)为utf8mb4，是不存在隐式转换的，反之则需要隐式转换\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  phone VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\", \"sql\": \"SELECT u.username,u.email,o.order_sn,o.amount,o.ship_country,o.ship_city \\nFROM users u\\nleft join orders o on u.phone = o.phone \\nwhere u.user_id = 100;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_sn\\\":100%,\\\"ship_city\\\":0.01%,\\\"ship_country\\\":0.01%},\\\"users\\\":{\\\"email\\\":100%,\\\"user_id\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"|id |select_type|table|partitions|type |possible_keys|key    |key_len|ref  |rows   |filtered|Extra      |\\n|---|-----------|-----|----------|-----|-------------|-------|-------|-----|-------|--------|-----------|\\n|1  |SIMPLE     |u    |          |const|PRIMARY      |PRIMARY|8      |const|1      |100     |           |\\n|1  |SIMPLE     |o    |          |ALL  |             |       |       |     |497,369|100     |Using where|\", \"expected\": \"以下两种情况均可\\n1. 给 orders 表的 phone 列创建索引。\\n（表字符集不一致，utf8mb4向下兼容utf8，如果驱动表(列)为utf8，被驱动表(列)为utf8mb4，是不存在隐式转换的，反之则需要隐式转换）\\n2. 存在隐式类型转换，无法通过索引解决SQL性能问题\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  phone VARCHAR(20),\n  delivery_company VARCHAR(50)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\n\n## EXPLAIN:\n|id |select_type|table|partitions|type |possible_keys|key    |key_len|ref  |rows   |filtered|Extra      |\n|---|-----------|-----|----------|-----|-------------|-------|-------|-----|-------|--------|-----------|\n|1  |SIMPLE     |u    |          |const|PRIMARY      |PRIMARY|8      |const|1      |100     |           |\n|1  |SIMPLE     |o    |          |ALL  |             |       |       |     |497,369|100     |Using where|\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"order_sn\":100%,\"ship_city\":0.01%,\"ship_country\":0.01%},\"users\":{\"email\":100%,\"user_id\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT u.username,u.email,o.order_sn,o.amount,o.ship_country,o.ship_city \nFROM users u\nleft join orders o on u.phone = o.phone \nwhere u.user_id = 100;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_phone_covering ON orders(phone, order_sn, amount, ship_country, ship_city); Reason: Covering index - eliminates the full table scan of 497,369 rows on orders during LEFT JOIN by indexing the join condition column (phone) and including all required output columns from orders."
                    }
                ]
            },
            {
                "case_id": "77",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"77\", \"difficulty_level\": \"3\", \"description\": \"隐式类型转换的查询-表字符集不一致，utf8mb4向下兼容utf8，如果驱动表(列)为utf8，被驱动表(列)为utf8mb4，是不存在隐式转换的，反之则需要隐式转换\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  phone VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\", \"sql\": \"SELECT u.username,u.email,o.order_sn,o.amount,o.ship_country,o.ship_city \\nFROM users u\\nleft join orders o on u.phone = o.phone \\nwhere u.user_id = 100;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_sn\\\":100%,\\\"ship_city\\\":0.01%,\\\"ship_country\\\":0.01%},\\\"users\\\":{\\\"email\\\":100%,\\\"user_id\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"|id |select_type|table|partitions|type |possible_keys|key    |key_len|ref  |rows   |filtered|Extra      |\\n|---|-----------|-----|----------|-----|-------------|-------|-------|-----|-------|--------|-----------|\\n|1  |SIMPLE     |u    |          |const|PRIMARY      |PRIMARY|8      |const|1      |100     |           |\\n|1  |SIMPLE     |o    |          |ALL  |             |       |       |     |497,369|100     |Using where|\", \"expected\": \"无法通过索引解决SQL存在的性能问题，表字符集不一致，存在字符集隐式类型转换。（表字符集不一致，utf8mb4向下兼容utf8，如果驱动表(列)为utf8，被驱动表(列)为utf8mb4，是不存在隐式转换的，反之则需要隐式转换）\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  phone VARCHAR(20),\n  delivery_company VARCHAR(50)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n## EXPLAIN:\n|id |select_type|table|partitions|type |possible_keys|key    |key_len|ref  |rows   |filtered|Extra      |\n|---|-----------|-----|----------|-----|-------------|-------|-------|-----|-------|--------|-----------|\n|1  |SIMPLE     |u    |          |const|PRIMARY      |PRIMARY|8      |const|1      |100     |           |\n|1  |SIMPLE     |o    |          |ALL  |             |       |       |     |497,369|100     |Using where|\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"order_sn\":100%,\"ship_city\":0.01%,\"ship_country\":0.01%},\"users\":{\"email\":100%,\"user_id\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT u.username,u.email,o.order_sn,o.amount,o.ship_country,o.ship_city \nFROM users u\nleft join orders o on u.phone = o.phone \nwhere u.user_id = 100;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_phone ON orders(phone); Reason: Single-column index - eliminates full table scan on orders table by enabling efficient index-based lookup on the join condition (phone), avoiding scan of 497,369 rows."
                    }
                ]
            },
            {
                "case_id": "78",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"78\", \"difficulty_level\": \"2\", \"description\": \"谓词列带有函数或计算的查询-索引列使用函数，索引列计算导致索引失效\", \"create_table_statements\": \"CREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\", \"sql\": \"SELECT product_id, product_name\\nFROM products \\nWHERE UPPER(product_name) = 'SMARTPHONE';\", \"columns_selectivity\": \"{\\\"products\\\":{\\\"product_id\\\":100%,\\\"product_name\\\":100%}}\", \"explain\": \"|id |select_type|table   |partitions|type|possible_keys|key|key_len|ref|rows |filtered|Extra      |\\n|---|-----------|--------|----------|----|-------------|---|-------|---|-----|--------|-----------|\\n|1  |SIMPLE     |products|          |ALL |             |   |       |   |9,836|100     |Using where|\", \"expected\": \"以下两种情况均可：\\n1. 无法通过索引解决SQL存在的性能问题,函数导致索引失效\\n2. 在products表的 product_name 列创建单列索引（覆盖索引）\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\n\n## EXPLAIN:\n|id |select_type|table   |partitions|type|possible_keys|key|key_len|ref|rows |filtered|Extra      |\n|---|-----------|--------|----------|----|-------------|---|-------|---|-----|--------|-----------|\n|1  |SIMPLE     |products|          |ALL |             |   |       |   |9,836|100     |Using where|\n\n## Column Selectivity:\n{\"products\":{\"product_id\":100%,\"product_name\":100%}}\n\n## Original SQL:\nSELECT product_id, product_name\nFROM products \nWHERE UPPER(product_name) = 'SMARTPHONE';\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "Unable to solve SQL performance issues by creating indexes. Reason: Function UPPER() applied to the column in the WHERE clause prevents index utilization; the query requires rewriting or schema modification instead."
                    }
                ]
            },
            {
                "case_id": "79",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"79\", \"difficulty_level\": \"2\", \"description\": \"谓词列带有函数或计算的查询-索引列使用函数，索引列计算导致索引失效\", \"create_table_statements\": \"CREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\", \"sql\": \"SELECT *\\nFROM products \\nWHERE stock + 1 = 100;\", \"columns_selectivity\": \"{\\\"products\\\":{\\\"stock\\\":10%}}\", \"explain\": \"|id |select_type|table   |partitions|type|possible_keys|key|key_len|ref|rows |filtered|Extra      |\\n|---|-----------|--------|----------|----|-------------|---|-------|---|-----|--------|-----------|\\n|1  |SIMPLE     |products|          |ALL |             |   |       |   |9,836|100     |Using where|\", \"expected\": \"无法通过索引解决SQL存在的性能问题，列计算会导致索引失效\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\n\n## EXPLAIN:\n|id |select_type|table   |partitions|type|possible_keys|key|key_len|ref|rows |filtered|Extra      |\n|---|-----------|--------|----------|----|-------------|---|-------|---|-----|--------|-----------|\n|1  |SIMPLE     |products|          |ALL |             |   |       |   |9,836|100     |Using where|\n\n## Column Selectivity:\n{\"products\":{\"stock\":10%}}\n\n## Original SQL:\nSELECT *\nFROM products \nWHERE stock + 1 = 100;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "Unable to solve SQL performance issues by creating indexes. Reason: The WHERE clause contains an expression applied to a column (stock + 1 = 100), which prevents traditional indexes from being used; the query would need to be rewritten as WHERE stock = 99 to benefit from indexing."
                    }
                ]
            },
            {
                "case_id": "80",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"80\", \"difficulty_level\": \"2\", \"description\": \"左右关联查询-识别驱动表，在被驱动表的关联列上创建索引\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\", \"sql\": \"SELECT u.username,u.email,o.order_sn,o.amount,o.ship_country,o.ship_city \\nFROM users u\\nleft join orders o on u.user_id = o.user_id \\nwhere o.user_id = 100;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_sn\\\":100%,\\\"ship_city\\\":0.01%,\\\"ship_country\\\":0.01%,\\\"user_id\\\":77.982%},\\\"users\\\":{\\\"email\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"|id |select_type|table|partitions|type |possible_keys|key    |key_len|ref  |rows   |filtered|Extra      |\\n|---|-----------|-----|----------|-----|-------------|-------|-------|-----|-------|--------|-----------|\\n|1  |SIMPLE     |u    |          |const|PRIMARY      |PRIMARY|8      |const|1      |100     |           |\\n|1  |SIMPLE     |o    |          |ALL  |             |       |       |     |497,658|10      |Using where|\", \"expected\": \"以下两种情况均可：\\n1. 无法通过索引解决SQL存在的性能问题\\n2. orders表创建覆盖索引，注意列顺序要求user_id在最左列\\n3.创建单列索引，在orders表的user_id列创建索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\n\n## EXPLAIN:\n|id |select_type|table|partitions|type |possible_keys|key    |key_len|ref  |rows   |filtered|Extra      |\n|---|-----------|-----|----------|-----|-------------|-------|-------|-----|-------|--------|-----------|\n|1  |SIMPLE     |u    |          |const|PRIMARY      |PRIMARY|8      |const|1      |100     |           |\n|1  |SIMPLE     |o    |          |ALL  |             |       |       |     |497,658|10      |Using where|\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"order_sn\":100%,\"ship_city\":0.01%,\"ship_country\":0.01%,\"user_id\":77.982%},\"users\":{\"email\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT u.username,u.email,o.order_sn,o.amount,o.ship_country,o.ship_city \nFROM users u\nleft join orders o on u.user_id = o.user_id \nwhere o.user_id = 100;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_orders_user_id ON orders(user_id); Reason: Single-column index - enables efficient lookup for the JOIN condition and WHERE clause, converting the full table scan (497,658 rows) to indexed access."
                    }
                ]
            },
            {
                "case_id": "81",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"81\", \"difficulty_level\": \"2\", \"description\": \"左右关联查询-识别驱动表，在被驱动表的关联列上创建索引\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\\nCREATE TABLE orders (\\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT NOT NULL,\\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\\n  amount DECIMAL(12, 2) NOT NULL,\\n  currency CHAR(3) DEFAULT 'CNY',\\n  pay_time DATETIME,\\n  ship_country VARCHAR(50),\\n  ship_city VARCHAR(50),\\n  ship_zip VARCHAR(20),\\n  delivery_company VARCHAR(50)\\n);\", \"sql\": \"SELECT u.username,u.email,o.order_sn,o.amount,o.ship_country,o.ship_city \\nFROM users u\\nright join orders o on u.user_id = o.user_id ;\", \"columns_selectivity\": \"{\\\"orders\\\":{\\\"amount\\\":94.296%,\\\"order_sn\\\":100%,\\\"ship_city\\\":0.01%,\\\"ship_country\\\":0.01%},\\\"users\\\":{\\\"email\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"|id |select_type|table|partitions|type  |possible_keys|key    |key_len|ref                 |rows   |filtered|Extra|\\n|---|-----------|-----|----------|------|-------------|-------|-------|--------------------|-------|--------|-----|\\n|1  |SIMPLE     |o    |          |ALL   |             |       |       |                    |496,791|100     |     |\\n|1  |SIMPLE     |u    |          |eq_ref|PRIMARY      |PRIMARY|8      |test_index.o.user_id|1      |100     |     |\", \"expected\": \"以下两种情况均可：\\n1. 无法通过索引解决SQL存在的性能问题\\n2. 给orders表的user_id，order_sn，amount，ship_country，ship_city 列添加覆盖索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\nCREATE TABLE orders (\n  order_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT NOT NULL,\n  order_sn VARCHAR(50) NOT NULL UNIQUE,\n  amount DECIMAL(12, 2) NOT NULL,\n  currency CHAR(3) DEFAULT 'CNY',\n  pay_time DATETIME,\n  ship_country VARCHAR(50),\n  ship_city VARCHAR(50),\n  ship_zip VARCHAR(20),\n  delivery_company VARCHAR(50)\n);\n\n## EXPLAIN:\n|id |select_type|table|partitions|type  |possible_keys|key    |key_len|ref                 |rows   |filtered|Extra|\n|---|-----------|-----|----------|------|-------------|-------|-------|--------------------|-------|--------|-----|\n|1  |SIMPLE     |o    |          |ALL   |             |       |       |                    |496,791|100     |     |\n|1  |SIMPLE     |u    |          |eq_ref|PRIMARY      |PRIMARY|8      |test_index.o.user_id|1      |100     |     |\n\n## Column Selectivity:\n{\"orders\":{\"amount\":94.296%,\"order_sn\":100%,\"ship_city\":0.01%,\"ship_country\":0.01%},\"users\":{\"email\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT u.username,u.email,o.order_sn,o.amount,o.ship_country,o.ship_city \nFROM users u\nright join orders o on u.user_id = o.user_id ;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "# Index Recommendation:\n\nCREATE INDEX idx_orders_covering ON orders(user_id, order_sn, amount, ship_country, ship_city); Reason: Covering index - enables index-only scan of all required orders columns, eliminating full table scan and reducing I/O to improve query performance."
                    }
                ]
            },
            {
                "case_id": "82",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"82\", \"difficulty_level\": \"3\", \"description\": \"UNION查询-union查询的索引建议，给独立查询分别建索引，但是外层的排序/分组导致的临时表和文件排序问题无法通过索引解决\", \"create_table_statements\": \"CREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n  * \\nFROM (\\n  SELECT \\n    * \\n  FROM \\n    access_logs \\n  WHERE \\n    request_url = '/api/v1/resource/247'\\n  UNION\\n  SELECT \\n    * \\n  FROM \\n    access_logs \\n  WHERE \\n    ip_address = '192.168.52.116'\\n) AS logs\", \"columns_selectivity\": \"{\\\"access_logs\\\":{\\\"ip_address\\\":69.5520%,\\\"request_url\\\":2.0000%}}\", \"explain\": \"|id |select_type |table      |partitions|type|possible_keys|key|key_len|ref|rows     |filtered|Extra          |\\n|---|------------|-----------|----------|----|-------------|---|-------|---|---------|--------|---------------|\\n|1  |PRIMARY     |<derived2> |          |ALL |             |   |       |   |397,796  |100     |               |\\n|2  |DERIVED     |access_logs|          |ALL |             |   |       |   |1,988,985|10      |Using where    |\\n|3  |UNION       |access_logs|          |ALL |             |   |       |   |1,988,985|10      |Using where    |\\n|   |UNION RESULT|<union2,3> |          |ALL |             |   |       |   |         |        |Using temporary|\", \"expected\": \"在 access_logs 表分别给request_url和ip_address加单列索引\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n|id |select_type |table      |partitions|type|possible_keys|key|key_len|ref|rows     |filtered|Extra          |\n|---|------------|-----------|----------|----|-------------|---|-------|---|---------|--------|---------------|\n|1  |PRIMARY     |<derived2> |          |ALL |             |   |       |   |397,796  |100     |               |\n|2  |DERIVED     |access_logs|          |ALL |             |   |       |   |1,988,985|10      |Using where    |\n|3  |UNION       |access_logs|          |ALL |             |   |       |   |1,988,985|10      |Using where    |\n|   |UNION RESULT|<union2,3> |          |ALL |             |   |       |   |         |        |Using temporary|\n\n## Column Selectivity:\n{\"access_logs\":{\"ip_address\":69.5520%,\"request_url\":2.0000%}}\n\n## Original SQL:\nSELECT \n  * \nFROM (\n  SELECT \n    * \n  FROM \n    access_logs \n  WHERE \n    request_url = '/api/v1/resource/247'\n  UNION\n  SELECT \n    * \n  FROM \n    access_logs \n  WHERE \n    ip_address = '192.168.52.116'\n) AS logs\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_request_url ON access_logs(request_url); CREATE INDEX idx_ip_address ON access_logs(ip_address); Reason: Single-column indexes - eliminate full table scans (type=ALL) by indexing the WHERE equality conditions on both UNION branches, with request_url providing excellent selectivity at 2%"
                    }
                ]
            },
            {
                "case_id": "83",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"83\", \"difficulty_level\": \"3\", \"description\": \"UNION查询-union查询的索引建议，给独立查询分别建索引，但是外层的排序/分组导致的临时表和文件排序问题无法通过索引解决\", \"create_table_statements\": \"CREATE TABLE access_logs (\\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  user_id BIGINT,\\n  request_url VARCHAR(500),\\n  http_method VARCHAR(10),\\n  response_code INT,\\n  response_time_ms INT,\\n  ip_address VARCHAR(50),\\n  user_agent VARCHAR(200),\\n  referrer VARCHAR(200),\\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\\n);\", \"sql\": \"SELECT \\n  * \\nFROM (\\n  SELECT \\n    * \\n  FROM \\n    access_logs \\n  WHERE \\n    request_url = '/api/v1/resource/247'\\n  UNION\\n  SELECT \\n    * \\n  FROM \\n    access_logs \\n  WHERE \\n    ip_address = '192.168.52.116'\\n) AS logs\\nORDER BY log_id,created_at;\", \"columns_selectivity\": \"{\\\"access_logs\\\":{\\\"ip_address\\\":69.5520%,\\\"request_url\\\":2.0000%,\\\"log_id\\\":100.0000%,\\\"created_at\\\"：0.0380%}}\", \"explain\": \"|id |select_type |table      |partitions|type|possible_keys|key|key_len|ref|rows     |filtered|Extra          |\\n|---|------------|-----------|----------|----|-------------|---|-------|---|---------|--------|---------------|\\n|1  |PRIMARY     |<derived2> |          |ALL |             |   |       |   |397,796  |100     |Using filesort |\\n|2  |DERIVED     |access_logs|          |ALL |             |   |       |   |1,988,985|10      |Using where    |\\n|3  |UNION       |access_logs|          |ALL |             |   |       |   |1,988,985|10      |Using where    |\\n|   |UNION RESULT|<union2,3> |          |ALL |             |   |       |   |         |        |Using temporary|\", \"expected\": \"在 access_logs 表分别给request_url和ip_address加单列索引\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE access_logs (\n  log_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  user_id BIGINT,\n  request_url VARCHAR(500),\n  http_method VARCHAR(10),\n  response_code INT,\n  response_time_ms INT,\n  ip_address VARCHAR(50),\n  user_agent VARCHAR(200),\n  referrer VARCHAR(200),\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n);\n\n## EXPLAIN:\n|id |select_type |table      |partitions|type|possible_keys|key|key_len|ref|rows     |filtered|Extra          |\n|---|------------|-----------|----------|----|-------------|---|-------|---|---------|--------|---------------|\n|1  |PRIMARY     |<derived2> |          |ALL |             |   |       |   |397,796  |100     |Using filesort |\n|2  |DERIVED     |access_logs|          |ALL |             |   |       |   |1,988,985|10      |Using where    |\n|3  |UNION       |access_logs|          |ALL |             |   |       |   |1,988,985|10      |Using where    |\n|   |UNION RESULT|<union2,3> |          |ALL |             |   |       |   |         |        |Using temporary|\n\n## Column Selectivity:\n{\"access_logs\":{\"ip_address\":69.5520%,\"request_url\":2.0000%,\"log_id\":100.0000%,\"created_at\"：0.0380%}}\n\n## Original SQL:\nSELECT \n  * \nFROM (\n  SELECT \n    * \n  FROM \n    access_logs \n  WHERE \n    request_url = '/api/v1/resource/247'\n  UNION\n  SELECT \n    * \n  FROM \n    access_logs \n  WHERE \n    ip_address = '192.168.52.116'\n) AS logs\nORDER BY log_id,created_at;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_request_url_log_created ON access_logs(request_url, log_id, created_at); CREATE INDEX idx_ip_address_log_created ON access_logs(ip_address, log_id, created_at); Reason: Composite index - indexes on multiple columns (WHERE filter columns and ORDER BY columns) will eliminate full table scans in both UNION queries and reduce filesort operations on the combined result set."
                    }
                ]
            },
            {
                "case_id": "84",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"84\", \"difficulty_level\": \"2\", \"description\": \"NULL查询-= NULL 会导致索引失效，IS NULL 不会导致索引失效\", \"create_table_statements\": \"CREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\", \"sql\": \"SELECT *\\nFROM products\\nwhere brand = NULL;\", \"columns_selectivity\": \"{\\\"products\\\":{\\\"brand\\\":0.05%}}\", \"explain\": \"|id |select_type|table   |partitions|type|possible_keys|key|key_len|ref|rows |filtered|Extra      |\\n|---|-----------|--------|----------|----|-------------|---|-------|---|-----|--------|-----------|\\n|1  |SIMPLE     |products|          |ALL |             |   |       |   |9,836|10      |Using where|\", \"expected\": \"= NULL 会导致索引失效，无法通过索引解决SQL性能问题\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\n\n## EXPLAIN:\n|id |select_type|table   |partitions|type|possible_keys|key|key_len|ref|rows |filtered|Extra      |\n|---|-----------|--------|----------|----|-------------|---|-------|---|-----|--------|-----------|\n|1  |SIMPLE     |products|          |ALL |             |   |       |   |9,836|10      |Using where|\n\n## Column Selectivity:\n{\"products\":{\"brand\":0.05%}}\n\n## Original SQL:\nSELECT *\nFROM products\nwhere brand = NULL;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "Unable to solve SQL performance issues by creating indexes. Reason: The WHERE clause uses incorrect NULL comparison syntax (brand = NULL). In SQL, NULL comparisons require IS NULL or IS NOT NULL operators; the equals operator will never match NULL values. The query should be rewritten before performance optimization can be applied."
                    }
                ]
            },
            {
                "case_id": "85",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"85\", \"difficulty_level\": \"2\", \"description\": \"NULL查询-= NULL 会导致索引失效，IS NULL 不会导致索引失效\", \"create_table_statements\": \"CREATE TABLE products (\\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  product_name VARCHAR(200) NOT NULL,\\n  category_id BIGINT NOT NULL,\\n  brand VARCHAR(100),\\n  origin_country VARCHAR(50),\\n  price DECIMAL(10, 2) NOT NULL,\\n  weight DECIMAL(10, 2),\\n  stock INT NOT NULL,\\n  is_imported BOOLEAN DEFAULT 0,\\n  supplier_id BIGINT\\n);\", \"sql\": \"SELECT *\\nFROM products\\nwhere brand IS NULL;\", \"columns_selectivity\": \"{\\\"products\\\":{\\\"brand\\\":5%}}\", \"explain\": \"|id |select_type|table   |partitions|type|possible_keys|key|key_len|ref|rows |filtered|Extra      |\\n|---|-----------|--------|----------|----|-------------|---|-------|---|-----|--------|-----------|\\n|1  |SIMPLE     |products|          |ALL |             |   |       |   |9,836|10      |Using where|\", \"expected\": \"以下两种情况均可：\\n1. IS NULL 不会导致索引失效，在 products表的 brand 列上创建索引。\\n2. 无性能问题。\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE products (\n  product_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category_id BIGINT NOT NULL,\n  brand VARCHAR(100),\n  origin_country VARCHAR(50),\n  price DECIMAL(10, 2) NOT NULL,\n  weight DECIMAL(10, 2),\n  stock INT NOT NULL,\n  is_imported BOOLEAN DEFAULT 0,\n  supplier_id BIGINT\n);\n\n## EXPLAIN:\n|id |select_type|table   |partitions|type|possible_keys|key|key_len|ref|rows |filtered|Extra      |\n|---|-----------|--------|----------|----|-------------|---|-------|---|-----|--------|-----------|\n|1  |SIMPLE     |products|          |ALL |             |   |       |   |9,836|10      |Using where|\n\n## Column Selectivity:\n{\"products\":{\"brand\":5%}}\n\n## Original SQL:\nSELECT *\nFROM products\nwhere brand IS NULL;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_products_brand ON products(brand); Reason: Single-column index - will optimize the IS NULL condition by converting the full table scan (ALL) into an efficient index range scan, reducing rows scanned from 9,836 to approximately 984 rows."
                    }
                ]
            },
            {
                "case_id": "86",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"86\", \"difficulty_level\": \"2\", \"description\": \"ORDER BY ASC DESC 复合排序-ASC DESC混合排序会导致索引失效\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT \\n*\\nFROM \\n    users\\nORDER BY \\n    birthdate ASC, last_login DESC LIMIT 100;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"birthdated\\\":19.8760%,\\\"last_login\\\":35.2940%}}\", \"explain\": \"|id |select_type|table|partitions|type|possible_keys|key|key_len|ref|rows  |filtered|Extra         |\\n|---|-----------|-----|----------|----|-------------|---|-------|---|------|--------|--------------|\\n|1  |SIMPLE     |users|          |ALL |             |   |       |   |99,583|100     |Using filesort|\", \"expected\": \"ASC DESC混合排序会导致索引失效，无法通过索引解决SQL性能问题\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n|id |select_type|table|partitions|type|possible_keys|key|key_len|ref|rows  |filtered|Extra         |\n|---|-----------|-----|----------|----|-------------|---|-------|---|------|--------|--------------|\n|1  |SIMPLE     |users|          |ALL |             |   |       |   |99,583|100     |Using filesort|\n\n## Column Selectivity:\n{\"users\":{\"birthdated\":19.8760%,\"last_login\":35.2940%}}\n\n## Original SQL:\nSELECT \n*\nFROM \n    users\nORDER BY \n    birthdate ASC, last_login DESC LIMIT 100;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "CREATE INDEX idx_users_birthdate_last_login ON users(birthdate, last_login); Reason: Composite index - eliminates the expensive filesort operation by enabling index-based sorting for the ORDER BY columns, allowing the database to retrieve only the required 100 rows efficiently instead of sorting all 99,583 rows in memory."
                    }
                ]
            },
            {
                "case_id": "87",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"87\", \"difficulty_level\": \"1\", \"description\": \"恒等条件-恒等条件和无条件若查询列数量在复合索引允许的范围内，可以使用覆盖索引，否则无法使用索引解决性能问题\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT * FROM users \\nWHERE 1 = 1;\", \"columns_selectivity\": \"\", \"explain\": \"|id |select_type|table|partitions|type|possible_keys|key|key_len|ref|rows  |filtered|Extra|\\n|---|-----------|-----|----------|----|-------------|---|-------|---|------|--------|-----|\\n|1  |SIMPLE     |users|          |ALL |             |   |       |   |99,583|100     |     |\", \"expected\": \"无法通过索引解决SQL性能问题\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n|id |select_type|table|partitions|type|possible_keys|key|key_len|ref|rows  |filtered|Extra|\n|---|-----------|-----|----------|----|-------------|---|-------|---|------|--------|-----|\n|1  |SIMPLE     |users|          |ALL |             |   |       |   |99,583|100     |     |\n\n## Column Selectivity:\n\n\n## Original SQL:\nSELECT * FROM users \nWHERE 1 = 1;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "No performance issues; no indexes need to be created."
                    }
                ]
            },
            {
                "case_id": "88",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"88\", \"difficulty_level\": \"1\", \"description\": \"恒等条件-恒等条件和无条件若查询列数量在复合索引允许的范围内，可以使用覆盖索引，否则无法使用索引解决性能问题\", \"create_table_statements\": \"CREATE TABLE users (\\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\\n  username VARCHAR(100) NOT NULL,\\n  email VARCHAR(200) UNIQUE,\\n  phone VARCHAR(20),\\n  gender TINYINT,\\n  birthdate DATE,\\n  register_channel VARCHAR(50),\\n  last_login DATETIME,\\n  points INT DEFAULT 0,\\n  vip_level TINYINT DEFAULT 0\\n);\", \"sql\": \"SELECT user_id,username,birthdate FROM users \\nWHERE 1 = 1;\", \"columns_selectivity\": \"{\\\"users\\\":{\\\"birthdate\\\":19.876%,\\\"user_id\\\":100%,\\\"username\\\":100%}}\", \"explain\": \"|id |select_type|table|partitions|type|possible_keys|key|key_len|ref|rows  |filtered|Extra|\\n|---|-----------|-----|----------|----|-------------|---|-------|---|------|--------|-----|\\n|1  |SIMPLE     |users|          |ALL |             |   |       |   |99,583|100     |     |\", \"expected\": \"以下两种情况均可\\n1. 给users表的username,birthdate列创建复合索引\\n2. 恒等where条件，无法通过索引解决SQL性能问题\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert specializing in SQL index recommendation.\nGiven the table definitions, EXPLAIN, column selectivity, and the original SQL query, analyze the performance and provide index recommendations.\n\n## Output Requirements:\nOutput **only** a single string sentence. Choose one of the following three scenarios:\n\n1. **No performance issue**: If the query performance is acceptable and no index is needed, output: \"No performance issues; no indexes need to be created.\"\n\n2. **Cannot solve by index**: If the performance problem cannot be solved by creating indexes, output a brief one-sentence explanation starting with \"Unable to solve SQL performance issues by creating indexes. Reason: \" followed by the reason.\n\n3. **Create index**: If indexes can improve performance, output the CREATE INDEX statement(s) followed by a brief reason. You MUST explicitly specify the index type in the reason. Format: \"CREATE INDEX statement(s); Reason: [index type] - brief explanation\"\n   \n   Only three index types are allowed:\n   - Single-column index: index on one column\n   - Composite index: index on multiple columns\n   - Covering index: index that includes all columns needed by the query\n   \n   If multiple indexes are needed, output them separated by semicolons, then add a brief reason at the end.\n   Example: \"Complete CREATE INDEX statement; Reason: Single-column/Composite/Covering index - brief explanation\"\n\n## Table Definitions:\nCREATE TABLE users (\n  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,\n  username VARCHAR(100) NOT NULL,\n  email VARCHAR(200) UNIQUE,\n  phone VARCHAR(20),\n  gender TINYINT,\n  birthdate DATE,\n  register_channel VARCHAR(50),\n  last_login DATETIME,\n  points INT DEFAULT 0,\n  vip_level TINYINT DEFAULT 0\n);\n\n## EXPLAIN:\n|id |select_type|table|partitions|type|possible_keys|key|key_len|ref|rows  |filtered|Extra|\n|---|-----------|-----|----------|----|-------------|---|-------|---|------|--------|-----|\n|1  |SIMPLE     |users|          |ALL |             |   |       |   |99,583|100     |     |\n\n## Column Selectivity:\n{\"users\":{\"birthdate\":19.876%,\"user_id\":100%,\"username\":100%}}\n\n## Original SQL:\nSELECT user_id,username,birthdate FROM users \nWHERE 1 = 1;\n\n## Index Recommendation:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "No performance issues; no indexes need to be created."
                    }
                ]
            }
        ]
    },
    {
        "indicator_name": "logical_equivalence.jsonl",
        "indicator_weight": 3,
        "evaluation_type": "hybrid",
        "case_pass_count": 26,
        "case_wrong_count": 24,
        "correct_rate": 0.52,
        "case_datas": [
            {
                "case_id": "1",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"1\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，子查询中存在多余的投影列，这些列在外层查询中没有被使用。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\"], \"sql\": \"SELECT student_name FROM students WHERE student_id IN ( SELECT student_id FROM ( SELECT student_id, gender FROM ( SELECT student_id, gender FROM ( SELECT student_id, gender FROM students ) AS inner_dt2 ) AS inner_dt1 ) AS outer_dt );\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.40\\\"}, \\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\"]}}, {\\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [\\\"test_db_case_1_1748591779.students.student_id\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"using_index\\\": true, \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"2.40\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\"]}}]}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"2.40\"}, \"nested_loop\": [{\"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"possible_keys\": [\"PRIMARY\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"student_name\"]}}, {\"table\": {\"table_name\": \"students\", \"access_type\": \"eq_ref\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"4\", \"ref\": [\"test_db_case_1_1748591779.students.student_id\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"using_index\": true, \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"2.40\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\"]}}]}}\n\n## Original SQL:\nSELECT student_name FROM students WHERE student_id IN ( SELECT student_id FROM ( SELECT student_id, gender FROM ( SELECT student_id, gender FROM ( SELECT student_id, gender FROM students ) AS inner_dt2 ) AS inner_dt1 ) AS outer_dt );\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_name FROM students;"
                    }
                ]
            },
            {
                "case_id": "2",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"2\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，其中外部的WHERE子句条件可以下推到最内层的子查询中。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\"], \"sql\": \"SELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM teachers WHERE teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!' ) AS inner_dt1 ) AS inner_dt2 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.40\\\"}, \\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"teacher_id\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_2_1749458126`.`students`.`teacher_id` is not null)\\\"}}, {\\\"table\\\": {\\\"table_name\\\": \\\"teachers\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"teacher_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [\\\"test_db_case_2_1749458126.students.teacher_id\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"2.40\\\", \\\"data_read_per_join\\\": \\\"208\\\"}, \\\"used_columns\\\": [\\\"teacher_id\\\", \\\"teacher_name\\\"], \\\"attached_condition\\\": \\\"((`test_db_case_2_1749458126`.`teachers`.`teacher_name` >= 'Dr. ') and (`test_db_case_2_1749458126`.`teachers`.`teacher_name` < 'Dr.!'))\\\"}}]}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"2.40\"}, \"nested_loop\": [{\"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"teacher_id\"], \"attached_condition\": \"(`test_db_case_2_1749458126`.`students`.`teacher_id` is not null)\"}}, {\"table\": {\"table_name\": \"teachers\", \"access_type\": \"eq_ref\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"teacher_id\"], \"key_length\": \"4\", \"ref\": [\"test_db_case_2_1749458126.students.teacher_id\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"2.40\", \"data_read_per_join\": \"208\"}, \"used_columns\": [\"teacher_id\", \"teacher_name\"], \"attached_condition\": \"((`test_db_case_2_1749458126`.`teachers`.`teacher_name` >= 'Dr. ') and (`test_db_case_2_1749458126`.`teachers`.`teacher_name` < 'Dr.!'))\"}}]}}\n\n## Original SQL:\nSELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM teachers WHERE teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!' ) AS inner_dt1 ) AS inner_dt2 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT students.teacher_id, teachers.teacher_name FROM students JOIN teachers ON students.teacher_id = teachers.teacher_id WHERE teachers.teacher_name >= 'Dr. ' AND teachers.teacher_name < 'Dr.!'"
                    }
                ]
            },
            {
                "case_id": "3",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"3\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的JOIN语句，其中外部的WHERE子句条件可以下推到最内层的子查询中，同时存在可以投影下推的冗余列和可以进行LIKE前缀优化的条件。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, major VARCHAR(100), enroll_count INT );\", \"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE, enrollment_year INT );\", \"CREATE TABLE courses ( course_id INT AUTO_INCREMENT PRIMARY KEY, course_name VARCHAR(255) NOT NULL, course_credits INT, department_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department_id INT );\", \"CREATE TABLE departments ( department_id INT AUTO_INCREMENT PRIMARY KEY, department_name VARCHAR(100), location VARCHAR(100) );\"], \"sql\": \"SELECT initial_students.student_id, initial_students.student_name, final_courses.course_name, final_enrollments.enrollment_date, final_teachers.teacher_name FROM (SELECT student_id, student_name, major, enroll_count FROM students WHERE enroll_count > 5) AS initial_students JOIN (SELECT e.student_id, e.course_id, e.enrollment_date FROM enrollments e WHERE e.enrollment_year = 2024) AS final_enrollments ON initial_students.student_id = final_enrollments.student_id JOIN (SELECT course_id, course_name, department_id FROM courses WHERE course_credits >= 3) AS final_courses ON final_enrollments.course_id = final_courses.course_id LEFT JOIN (SELECT t.teacher_id, t.teacher_name FROM teachers t JOIN departments d ON t.department_id = d.department_id WHERE d.location = 'Building A') AS final_teachers ON final_courses.department_id = final_teachers.teacher_id WHERE initial_students.major = 'Physics' AND final_enrollments.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30' AND final_courses.course_name LIKE 'Advanced %';\", \"explain\": \"{\\\"query_block\\\": { \\\"select_id\\\": 1, \\\"cost_info\\\": { \\\"query_cost\\\": \\\"6.00\\\" }, \\\"nested_loop\\\": [ { \\\"table\\\": { \\\"table_name\\\": \\\"e\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"24\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"course_id\\\", \\\"enrollment_date\\\", \\\"enrollment_year\\\" ], \\\"attached_condition\\\": \\\"(((`test_db_case_5_1749718637`.`e`.`enrollment_year` = 2024) and (`test_db_case_5_1749718637`.`e`.`enrollment_date` between '2024-01-01' and '2024-06-30')) and (`test_db_case_5_1749718637`.`e`.`course_id` is not null))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"student_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.e.student_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"2.40\\\", \\\"data_read_per_join\\\": \\\"216\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"student_name\\\", \\\"major\\\", \\\"enroll_count\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_5_1749718637`.`students`.`major` = 'Physics') and (`test_db_case_5_1749718637`.`students`.`enroll_count` > 5))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"courses\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"course_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.e.course_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"3.60\\\", \\\"data_read_per_join\\\": \\\"272\\\" }, \\\"used_columns\\\": [ \\\"course_id\\\", \\\"course_name\\\", \\\"course_credits\\\", \\\"department_id\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_5_1749718637`.`courses`.`course_name` like 'Advanced %') and (`test_db_case_5_1749718637`.`courses`.`course_credits` >= 3))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"t\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"teacher_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.courses.department_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"4.80\\\", \\\"data_read_per_join\\\": \\\"112\\\" }, \\\"used_columns\\\": [ \\\"teacher_id\\\", \\\"teacher_name\\\", \\\"department_id\\\" ] } }, { \\\"table\\\": { \\\"table_name\\\": \\\"d\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"department_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.t.department_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"6.00\\\", \\\"data_read_per_join\\\": \\\"208\\\" }, \\\"used_columns\\\": [ \\\"department_id\\\", \\\"location\\\" ], \\\"attached_condition\\\": \\\"<if>(is_not_null_compl(t..d), (`test_db_case_5_1749718637`.`d`.`location` = 'Building A'), true)\\\" } } ] } }\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, major VARCHAR(100), enroll_count INT );\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE, enrollment_year INT );\nCREATE TABLE courses ( course_id INT AUTO_INCREMENT PRIMARY KEY, course_name VARCHAR(255) NOT NULL, course_credits INT, department_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department_id INT );\nCREATE TABLE departments ( department_id INT AUTO_INCREMENT PRIMARY KEY, department_name VARCHAR(100), location VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": { \"select_id\": 1, \"cost_info\": { \"query_cost\": \"6.00\" }, \"nested_loop\": [ { \"table\": { \"table_name\": \"e\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"24\" }, \"used_columns\": [ \"student_id\", \"course_id\", \"enrollment_date\", \"enrollment_year\" ], \"attached_condition\": \"(((`test_db_case_5_1749718637`.`e`.`enrollment_year` = 2024) and (`test_db_case_5_1749718637`.`e`.`enrollment_date` between '2024-01-01' and '2024-06-30')) and (`test_db_case_5_1749718637`.`e`.`course_id` is not null))\" } }, { \"table\": { \"table_name\": \"students\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"student_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.e.student_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"2.40\", \"data_read_per_join\": \"216\" }, \"used_columns\": [ \"student_id\", \"student_name\", \"major\", \"enroll_count\" ], \"attached_condition\": \"((`test_db_case_5_1749718637`.`students`.`major` = 'Physics') and (`test_db_case_5_1749718637`.`students`.`enroll_count` > 5))\" } }, { \"table\": { \"table_name\": \"courses\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"course_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.e.course_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"3.60\", \"data_read_per_join\": \"272\" }, \"used_columns\": [ \"course_id\", \"course_name\", \"course_credits\", \"department_id\" ], \"attached_condition\": \"((`test_db_case_5_1749718637`.`courses`.`course_name` like 'Advanced %') and (`test_db_case_5_1749718637`.`courses`.`course_credits` >= 3))\" } }, { \"table\": { \"table_name\": \"t\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"teacher_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.courses.department_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"4.80\", \"data_read_per_join\": \"112\" }, \"used_columns\": [ \"teacher_id\", \"teacher_name\", \"department_id\" ] } }, { \"table\": { \"table_name\": \"d\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"department_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.t.department_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"6.00\", \"data_read_per_join\": \"208\" }, \"used_columns\": [ \"department_id\", \"location\" ], \"attached_condition\": \"<if>(is_not_null_compl(t..d), (`test_db_case_5_1749718637`.`d`.`location` = 'Building A'), true)\" } } ] } }\n\n## Original SQL:\nSELECT initial_students.student_id, initial_students.student_name, final_courses.course_name, final_enrollments.enrollment_date, final_teachers.teacher_name FROM (SELECT student_id, student_name, major, enroll_count FROM students WHERE enroll_count > 5) AS initial_students JOIN (SELECT e.student_id, e.course_id, e.enrollment_date FROM enrollments e WHERE e.enrollment_year = 2024) AS final_enrollments ON initial_students.student_id = final_enrollments.student_id JOIN (SELECT course_id, course_name, department_id FROM courses WHERE course_credits >= 3) AS final_courses ON final_enrollments.course_id = final_courses.course_id LEFT JOIN (SELECT t.teacher_id, t.teacher_name FROM teachers t JOIN departments d ON t.department_id = d.department_id WHERE d.location = 'Building A') AS final_teachers ON final_courses.department_id = final_teachers.teacher_id WHERE initial_students.major = 'Physics' AND final_enrollments.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30' AND final_courses.course_name LIKE 'Advanced %';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT s.student_id, s.student_name, c.course_name, e.enrollment_date, t.teacher_name FROM enrollments e INNER JOIN students s ON e.student_id = s.student_id AND s.major = 'Physics' AND s.enroll_count > 5 INNER JOIN courses c ON e.course_id = c.course_id AND c.course_credits >= 3 AND c.course_name LIKE 'Advanced %' LEFT JOIN teachers t ON c.department_id = t.teacher_id AND EXISTS (SELECT 1 FROM departments WHERE department_id = t.department_id AND location = 'Building A') WHERE e.enrollment_year = 2024 AND e.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30'"
                    }
                ]
            },
            {
                "case_id": "4",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"4\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，子查询中存在多余的投影列，同时内层子查询有ORDER BY和LIMIT，但最外层查询仍可进行投影下推。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\"], \"sql\": \"SELECT s.student_id, s.student_name, s.date_of_birth FROM students s JOIN ( SELECT student_id, gender FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM students ORDER BY student_id DESC ) AS inner_dt3 ) AS inner_dt2 ORDER BY student_id DESC LIMIT 1 ) AS inner_dt1 ) dt ON s.student_id = dt.student_id WHERE dt.gender = 'MALE'\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"message\\\": \\\"no matching row in const table\\\", \\\"table\\\": {\\\"materialized_from_subquery\\\": {\\\"using_temporary_table\\\": true, \\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 3, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"ordering_operation\\\": {\\\"using_filesort\\\": false, \\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"index\\\", \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"gender\\\", \\\"date_of_birth\\\"]}}}}}}}\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"message\": \"no matching row in const table\", \"table\": {\"materialized_from_subquery\": {\"using_temporary_table\": true, \"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 3, \"cost_info\": {\"query_cost\": \"1.20\"}, \"ordering_operation\": {\"using_filesort\": false, \"table\": {\"table_name\": \"students\", \"access_type\": \"index\", \"key\": \"PRIMARY\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"gender\", \"date_of_birth\"]}}}}}}}\n\n## Original SQL:\nSELECT s.student_id, s.student_name, s.date_of_birth FROM students s JOIN ( SELECT student_id, gender FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM students ORDER BY student_id DESC ) AS inner_dt3 ) AS inner_dt2 ORDER BY student_id DESC LIMIT 1 ) AS inner_dt1 ) dt ON s.student_id = dt.student_id WHERE dt.gender = 'MALE'\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id, student_name, date_of_birth FROM students WHERE gender = 'Male' ORDER BY student_id DESC LIMIT 1"
                    }
                ]
            },
            {
                "case_id": "5",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"5\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的JOIN语句，其中外部的WHERE子句条件可以下推到最内层的子查询中，同时存在可以投影下推的冗余列和可以进行LIKE前缀优化的条件。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\"], \"sql\": \"SELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM teachers ) AS inner_dt1 ) AS inner_dt2 ) AS inner_dt3 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id WHERE outer_dt.teacher_name LIKE 'Dr. %';\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.40\\\"},\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"students\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"teacher_id\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"teachers\\\",\\\"access_type\\\": \\\"eq_ref\\\",\\\"possible_keys\\\": [\\\"PRIMARY\\\"],\\\"key\\\": \\\"PRIMARY\\\",\\\"used_key_parts\\\": [\\\"teacher_id\\\"],\\\"key_length\\\": \\\"4\\\",\\\"ref\\\": [\\\"test_db_case_5_1749537373.students.teacher_id\\\"],\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"208\\\"},\\\"used_columns\\\": [\\\"teacher_id\\\",\\\"teacher_name\\\",\\\"department\\\"],\\\"attached_condition\\\": \\\"(`test_db_case_5_1749537373`.`teachers`.`teacher_name` LIKE 'Dr. %')\\\"}}]}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"2.40\"},\"nested_loop\": [{\"table\": {\"table_name\": \"students\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"teacher_id\"]}},{\"table\": {\"table_name\": \"teachers\",\"access_type\": \"eq_ref\",\"possible_keys\": [\"PRIMARY\"],\"key\": \"PRIMARY\",\"used_key_parts\": [\"teacher_id\"],\"key_length\": \"4\",\"ref\": [\"test_db_case_5_1749537373.students.teacher_id\"],\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"208\"},\"used_columns\": [\"teacher_id\",\"teacher_name\",\"department\"],\"attached_condition\": \"(`test_db_case_5_1749537373`.`teachers`.`teacher_name` LIKE 'Dr. %')\"}}]}}}\n\n## Original SQL:\nSELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM teachers ) AS inner_dt1 ) AS inner_dt2 ) AS inner_dt3 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id WHERE outer_dt.teacher_name LIKE 'Dr. %';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT t.teacher_id, t.teacher_name FROM students JOIN teachers t ON students.teacher_id = t.teacher_id WHERE t.teacher_name LIKE 'Dr. %'"
                    }
                ]
            },
            {
                "case_id": "6",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"6\", \"db_type\": \"mysql\", \"description\": \"一个简单的SELECT语句，其中WHERE子句对字段使用了函数，导致隐式转换。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT student_id, CONCAT(\\\"id_\\\", student_id) as student_id2 FROM enrollments WHERE CONCAT(\\\"id_\\\", student_id) >= \\\"id_1000\\\" LIMIT 10;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"enrollments\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"24\\\"}, \\\"used_columns\\\": [\\\"student_id\\\"], \\\"attached_condition\\\": \\\"(concat('id_',`test_db_case_6_1748591779`.`enrollments`.`student_id`) >= 'id_1000')\\\"}}}\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"enrollments\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"24\"}, \"used_columns\": [\"student_id\"], \"attached_condition\": \"(concat('id_',`test_db_case_6_1748591779`.`enrollments`.`student_id`) >= 'id_1000')\"}}}\n\n## Original SQL:\nSELECT student_id, CONCAT(\"id_\", student_id) as student_id2 FROM enrollments WHERE CONCAT(\"id_\", student_id) >= \"id_1000\" LIMIT 10;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id, CONCAT(\"id_\", student_id) as student_id2 FROM enrollments WHERE student_id >= 1000 LIMIT 10;"
                    }
                ]
            },
            {
                "case_id": "7",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"7\", \"db_type\": \"mysql\", \"description\": \"一个包含COUNT标量子查询的SELECT语句，可以将其改写为IN子查询以利用SEMI JOIN特性。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) );\", \"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT * FROM students WHERE NOT ( SELECT count(*) FROM enrollments WHERE students.student_id = enrollments.student_id AND enrollment_id > 1000 ) > 0;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\"], \\\"attached_condition\\\": \\\"((/* select#2 */ select count(0) from `test_db_case_7_1748591779`.`enrollments` where ((`test_db_case_7_1748591779`.`students`.`student_id` = `test_db_case_7_1748591779`.`enrollments`.`student_id`) and (`test_db_case_7_1748591779`.`enrollment_id` > 1000))) <= 0)\\\", \\\"attached_subqueries\\\": [{\\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.41\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"enrollments\\\", \\\"access_type\\\": \\\"range\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"enrollment_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.21\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.41\\\", \\\"data_read_per_join\\\": \\\"24\\\"}, \\\"used_columns\\\": [\\\"enrollment_id\\\", \\\"student_id\\\"], \\\"attached_condition\\\": \\\"((`test_db_case_7_1748591779`.`students`.`student_id` = `test_db_case_7_1748591779`.`enrollments`.`student_id`) and (`test_db_case_7_1748591779`.`enrollment_id` > 1000))\\\"}}}]}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) );\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"student_name\"], \"attached_condition\": \"((/* select#2 */ select count(0) from `test_db_case_7_1748591779`.`enrollments` where ((`test_db_case_7_1748591779`.`students`.`student_id` = `test_db_case_7_1748591779`.`enrollments`.`student_id`) and (`test_db_case_7_1748591779`.`enrollment_id` > 1000))) <= 0)\", \"attached_subqueries\": [{\"dependent\": true, \"cacheable\": false, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.41\"}, \"table\": {\"table_name\": \"enrollments\", \"access_type\": \"range\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"enrollment_id\"], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.21\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.41\", \"data_read_per_join\": \"24\"}, \"used_columns\": [\"enrollment_id\", \"student_id\"], \"attached_condition\": \"((`test_db_case_7_1748591779`.`students`.`student_id` = `test_db_case_7_1748591779`.`enrollments`.`student_id`) and (`test_db_case_7_1748591779`.`enrollment_id` > 1000))\"}}}]}}\n\n## Original SQL:\nSELECT * FROM students WHERE NOT ( SELECT count(*) FROM enrollments WHERE students.student_id = enrollments.student_id AND enrollment_id > 1000 ) > 0;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM students WHERE NOT EXISTS (SELECT 1 FROM enrollments WHERE students.student_id = enrollments.student_id AND enrollment_id > 1000)"
                    }
                ]
            },
            {
                "case_id": "8",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"8\", \"db_type\": \"mysql\", \"description\": \"一个包含HAVING子句的SELECT语句，其中HAVING条件不依赖聚合函数，可以下推到WHERE子句。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE enrollment_date > '1993-11-26' OR enrollment_date < '1991-11-26' GROUP BY student_id HAVING student_id = 1999\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.20\\\"},\\\"grouping_operation\\\": {\\\"using_temporary_table\\\": true,\\\"using_filesort\\\": true,\\\"cost_info\\\": {\\\"sort_cost\\\": \\\"1.00\\\"},\\\"table\\\": {\\\"table_name\\\": \\\"enrollments\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"24\\\"},\\\"used_columns\\\": [\\\"enrollment_id\\\",\\\"student_id\\\",\\\"enrollment_date\\\"],\\\"attached_condition\\\": \\\"((`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` > '1993-11-26') or (`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` < '1991-11-26'))\\\"}}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"2.20\"},\"grouping_operation\": {\"using_temporary_table\": true,\"using_filesort\": true,\"cost_info\": {\"sort_cost\": \"1.00\"},\"table\": {\"table_name\": \"enrollments\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"24\"},\"used_columns\": [\"enrollment_id\",\"student_id\",\"enrollment_date\"],\"attached_condition\": \"((`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` > '1993-11-26') or (`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` < '1991-11-26'))\"}}}}\n\n## Original SQL:\nSELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE enrollment_date > '1993-11-26' OR enrollment_date < '1991-11-26' GROUP BY student_id HAVING student_id = 1999\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE student_id = 1999 AND (enrollment_date > '1993-11-26' OR enrollment_date < '1991-11-26') GROUP BY student_id"
                    }
                ]
            },
            {
                "case_id": "9",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"9\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，最内层的GROUP BY子句是不必要的，可以被消除。\", \"difficulty_level\": \"2\", \"sql\": \"SELECT student_id FROM students s WHERE EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id) AND s.gender = 'Female' AND s.date_of_birth <= CAST('2000-01-01' AS DATE) AND s.student_name != '张凯' GROUP BY student_id LIMIT 10;\", \"create_table_statements\": [\"CREATE TABLE students (student_id INT PRIMARY KEY, student_name VARCHAR(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL, gender VARCHAR(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci, date_of_birth DATE) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\", \"CREATE TABLE enrollments (enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, enrollment_date DATE, FOREIGN KEY (student_id) REFERENCES students(student_id)) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\"], \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"grouping_operation\\\": {\\\"using_filesort\\\": false, \\\"table\\\": {\\\"table_name\\\": \\\"s\\\", \\\"access_type\\\": \\\"index\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"1K\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\", \\\"gender\\\", \\\"date_of_birth\\\"], \\\"attached_condition\\\": \\\"(exists(/* select#2 */ select 1 from `test_db_case_9_1749465373`.`enrollments` `e` where (`test_db_case_9_1749465373`.`e`.`student_id` = `test_db_case_9_1749465373`.`s`.`student_id`)) and (`test_db_case_9_1749465373`.`s`.`gender` = 'Female') and (`test_db_case_9_1749465373`.`s`.`date_of_birth` <= <cache>(cast('2000-01-01' as date))) and (`test_db_case_9_1749465373`.`s`.`student_name` <> '张凯'))\\\", \\\"attached_subqueries\\\": [{\\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"e\\\", \\\"access_type\\\": \\\"ref\\\", \\\"possible_keys\\\": [\\\"student_id\\\"], \\\"key\\\": \\\"student_id\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"5\\\", \\\"ref\\\": [\\\"test_db_case_9_1749465373.s.student_id\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"using_index\\\": true, \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"24\\\"}, \\\"used_columns\\\": [\\\"student_id\\\"]}}}]}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students (student_id INT PRIMARY KEY, student_name VARCHAR(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL, gender VARCHAR(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci, date_of_birth DATE) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\nCREATE TABLE enrollments (enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, enrollment_date DATE, FOREIGN KEY (student_id) REFERENCES students(student_id)) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"1.20\"}, \"grouping_operation\": {\"using_filesort\": false, \"table\": {\"table_name\": \"s\", \"access_type\": \"index\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"1K\"}, \"used_columns\": [\"student_id\", \"student_name\", \"gender\", \"date_of_birth\"], \"attached_condition\": \"(exists(/* select#2 */ select 1 from `test_db_case_9_1749465373`.`enrollments` `e` where (`test_db_case_9_1749465373`.`e`.`student_id` = `test_db_case_9_1749465373`.`s`.`student_id`)) and (`test_db_case_9_1749465373`.`s`.`gender` = 'Female') and (`test_db_case_9_1749465373`.`s`.`date_of_birth` <= <cache>(cast('2000-01-01' as date))) and (`test_db_case_9_1749465373`.`s`.`student_name` <> '张凯'))\", \"attached_subqueries\": [{\"dependent\": true, \"cacheable\": false, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"e\", \"access_type\": \"ref\", \"possible_keys\": [\"student_id\"], \"key\": \"student_id\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"5\", \"ref\": [\"test_db_case_9_1749465373.s.student_id\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"using_index\": true, \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"24\"}, \"used_columns\": [\"student_id\"]}}}]}}}\n\n## Original SQL:\nSELECT student_id FROM students s WHERE EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id) AND s.gender = 'Female' AND s.date_of_birth <= CAST('2000-01-01' AS DATE) AND s.student_name != '张凯' GROUP BY student_id LIMIT 10;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id FROM students s WHERE EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id) AND s.gender = 'Female' AND s.date_of_birth <= '2000-01-01' AND s.student_name != '张凯' LIMIT 10;"
                    }
                ]
            },
            {
                "case_id": "10",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"10\", \"db_type\": \"mysql\", \"description\": \"一个包含非关联子查询的SELECT语句，可以将子查询转换为关联子查询。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) );\", \"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT );\"], \"sql\": \"SELECT * FROM students WHERE student_id IN ( SELECT student_id FROM enrollments AS inner_dt );\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"4.80\\\"}, \\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"<subquery2>\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"materialized_from_subquery\\\": {\\\"using_temporary_table\\\": true, \\\"query_block\\\": {\\\"table\\\": {\\\"table_name\\\": \\\"inner_dt\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"16\\\"}, \\\"used_columns\\\": [\\\"student_id\\\"]}}}}}, {\\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [\\\"<subquery2>.student_id\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"4.80\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\"]}}]}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) );\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"4.80\"}, \"nested_loop\": [{\"table\": {\"table_name\": \"<subquery2>\", \"access_type\": \"ALL\", \"materialized_from_subquery\": {\"using_temporary_table\": true, \"query_block\": {\"table\": {\"table_name\": \"inner_dt\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"16\"}, \"used_columns\": [\"student_id\"]}}}}}, {\"table\": {\"table_name\": \"students\", \"access_type\": \"eq_ref\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"4\", \"ref\": [\"<subquery2>.student_id\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"4.80\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"student_name\"]}}]}}\n\n## Original SQL:\nSELECT * FROM students WHERE student_id IN ( SELECT student_id FROM enrollments AS inner_dt );\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT s.* FROM students s WHERE EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id);"
                    }
                ]
            },
            {
                "case_id": "11",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"11\", \"db_type\": \"mysql\", \"description\": \"一个包含多个ROW_NUMBER()窗口函数和过滤条件的SELECT语句\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), date_of_birth DATE );\"], \"sql\": \"SELECT T1.student_name, T1.date_of_birth FROM students AS T1 WHERE (SELECT COUNT(*) FROM students AS T2 WHERE T2.student_name <= T1.student_name) <= 3 AND (SELECT COUNT(*) FROM students AS T3 WHERE T3.date_of_birth <= T1.date_of_birth) <= 2 ORDER BY T1.student_name, T1.date_of_birth;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.20\\\"}, \\\"ordering_operation\\\": {\\\"using_filesort\\\": true, \\\"cost_info\\\": {\\\"sort_cost\\\": \\\"1.00\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"T1\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\", \\\"date_of_birth\\\"], \\\"attached_condition\\\": \\\"(((/* select#2 */ select count(0) from `test_db_case_11_1748591779`.`students` `T2` where (`test_db_case_11_1748591779`.`T2`.`student_name` <= `test_db_case_11_1748591779`.`T1`.`student_name`)) <= 3) and ((/* select#3 */ select count(0) from `test_db_case_11_1748591779`.`students` `T3` where (`test_db_case_11_1748591779`.`T3`.`date_of_birth` <= `test_db_case_11_1748591779`.`T1`.`date_of_birth`)) <= 2))\\\", \\\"attached_subqueries\\\": [{\\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": {\\\"select_id\\\": 3, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"T3\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"date_of_birth\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_11_1748591779`.`T3`.`date_of_birth` <= `test_db_case_11_1748591779`.`T1`.`date_of_birth`)\\\"}}}, {\\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"T2\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_name\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_11_1748591779`.`T2`.`student_name` <= `test_db_case_11_1748591779`.`T1`.`student_name`)\\\"}}}]}}}}\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), date_of_birth DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"2.20\"}, \"ordering_operation\": {\"using_filesort\": true, \"cost_info\": {\"sort_cost\": \"1.00\"}, \"table\": {\"table_name\": \"T1\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"student_name\", \"date_of_birth\"], \"attached_condition\": \"(((/* select#2 */ select count(0) from `test_db_case_11_1748591779`.`students` `T2` where (`test_db_case_11_1748591779`.`T2`.`student_name` <= `test_db_case_11_1748591779`.`T1`.`student_name`)) <= 3) and ((/* select#3 */ select count(0) from `test_db_case_11_1748591779`.`students` `T3` where (`test_db_case_11_1748591779`.`T3`.`date_of_birth` <= `test_db_case_11_1748591779`.`T1`.`date_of_birth`)) <= 2))\", \"attached_subqueries\": [{\"dependent\": true, \"cacheable\": false, \"query_block\": {\"select_id\": 3, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"T3\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"date_of_birth\"], \"attached_condition\": \"(`test_db_case_11_1748591779`.`T3`.`date_of_birth` <= `test_db_case_11_1748591779`.`T1`.`date_of_birth`)\"}}}, {\"dependent\": true, \"cacheable\": false, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"T2\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_name\"], \"attached_condition\": \"(`test_db_case_11_1748591779`.`T2`.`student_name` <= `test_db_case_11_1748591779`.`T1`.`student_name`)\"}}}]}}}}\n\n## Original SQL:\nSELECT T1.student_name, T1.date_of_birth FROM students AS T1 WHERE (SELECT COUNT(*) FROM students AS T2 WHERE T2.student_name <= T1.student_name) <= 3 AND (SELECT COUNT(*) FROM students AS T3 WHERE T3.date_of_birth <= T1.date_of_birth) <= 2 ORDER BY T1.student_name, T1.date_of_birth;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_name, date_of_birth FROM (SELECT student_name, date_of_birth, COUNT(*) OVER (ORDER BY student_name RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as name_count, COUNT(*) OVER (ORDER BY date_of_birth RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as dob_count FROM students) t WHERE name_count <= 3 AND dob_count <= 2 ORDER BY student_name, date_of_birth;"
                    }
                ]
            },
            {
                "case_id": "12",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"12\", \"db_type\": \"mysql\", \"description\": \"一个包含UNION的SELECT语句，其中WHERE子句包含LIKE前缀匹配，可以改写为范围查询。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), major VARCHAR(100) );\"], \"sql\": \"SELECT * FROM students WHERE student_name LIKE 'John%' UNION SELECT * FROM students WHERE student_name LIKE 'Jane%';\", \"explain\": \"{\\\"query_block\\\": {\\\"union_result\\\": {\\\"using_temporary_table\\\": true, \\\"table_name\\\": \\\"<union1,2>\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"query_specifications\\\": [{\\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"208\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\", \\\"major\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_12_1748591779`.`students`.`student_name` like 'John%')\\\"}}}, {\\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"208\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\", \\\"major\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_12_1748591779`.`students`.`student_name` like 'Jane%')\\\"}}}]}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), major VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": {\"union_result\": {\"using_temporary_table\": true, \"table_name\": \"<union1,2>\", \"access_type\": \"ALL\", \"query_specifications\": [{\"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"208\"}, \"used_columns\": [\"student_id\", \"student_name\", \"major\"], \"attached_condition\": \"(`test_db_case_12_1748591779`.`students`.`student_name` like 'John%')\"}}}, {\"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"208\"}, \"used_columns\": [\"student_id\", \"student_name\", \"major\"], \"attached_condition\": \"(`test_db_case_12_1748591779`.`students`.`student_name` like 'Jane%')\"}}}]}}}\n\n## Original SQL:\nSELECT * FROM students WHERE student_name LIKE 'John%' UNION SELECT * FROM students WHERE student_name LIKE 'Jane%';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM students WHERE student_name LIKE 'John%' OR student_name LIKE 'Jane%';"
                    }
                ]
            },
            {
                "case_id": "13",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"13\", \"db_type\": \"mysql\", \"description\": \"一个包含UNION的SELECT语句，外部查询包含LIMIT子句，可以下推到UNION的各个分支中。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(100), reg_date DATE );\", \"CREATE TABLE articles ( id INT PRIMARY KEY, title VARCHAR(255), publish_time DATETIME );\"], \"sql\": \"SELECT * FROM (  (SELECT name FROM users ORDER BY reg_date DESC)  UNION  (SELECT title FROM articles ORDER BY publish_time DESC) ) AS mixed  ORDER BY name LIMIT 5;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"15.00\\\"}, \\\"ordering_operation\\\": {\\\"using_filesort\\\": true, \\\"cost_info\\\": {\\\"sort_cost\\\": \\\"4.00\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"mixed\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 4, \\\"rows_produced_per_join\\\": 4, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"10.20\\\", \\\"eval_cost\\\": \\\"0.80\\\", \\\"prefix_cost\\\": \\\"11.00\\\", \\\"data_read_per_join\\\": \\\"1K\\\"}, \\\"used_columns\\\": [\\\"name\\\"], \\\"materialized_from_subquery\\\": {\\\"using_temporary_table\\\": true, \\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"union_result\\\": {\\\"using_temporary_table\\\": true, \\\"table_name\\\": \\\"<union2,3>\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"query_specifications\\\": [{\\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"users\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"name\\\", \\\"reg_date\\\"]}}}, {\\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 3, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"articles\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"272\\\"}, \\\"used_columns\\\": [\\\"title\\\", \\\"publish_time\\\"]}}}]}}}}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(100), reg_date DATE );\nCREATE TABLE articles ( id INT PRIMARY KEY, title VARCHAR(255), publish_time DATETIME );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"15.00\"}, \"ordering_operation\": {\"using_filesort\": true, \"cost_info\": {\"sort_cost\": \"4.00\"}, \"table\": {\"table_name\": \"mixed\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 4, \"rows_produced_per_join\": 4, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"10.20\", \"eval_cost\": \"0.80\", \"prefix_cost\": \"11.00\", \"data_read_per_join\": \"1K\"}, \"used_columns\": [\"name\"], \"materialized_from_subquery\": {\"using_temporary_table\": true, \"dependent\": false, \"cacheable\": true, \"query_block\": {\"union_result\": {\"using_temporary_table\": true, \"table_name\": \"<union2,3>\", \"access_type\": \"ALL\", \"query_specifications\": [{\"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"users\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"name\", \"reg_date\"]}}}, {\"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 3, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"articles\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"272\"}, \"used_columns\": [\"title\", \"publish_time\"]}}}]}}}}}}\n\n## Original SQL:\nSELECT * FROM (  (SELECT name FROM users ORDER BY reg_date DESC)  UNION  (SELECT title FROM articles ORDER BY publish_time DESC) ) AS mixed  ORDER BY name LIMIT 5;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM ((SELECT name FROM users) UNION (SELECT title FROM articles)) AS mixed ORDER BY name LIMIT 5;"
                    }
                ]
            },
            {
                "case_id": "14",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"14\", \"db_type\": \"mysql\", \"description\": \"一个包含IN子查询的SELECT语句，子查询明确只返回一行，因此可以转换为标量子查询。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE students ( id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), score INT );\"], \"sql\": \"SELECT * FROM students WHERE id IN ( SELECT MAX(id) FROM students );\", \"explain\": \"{\\\"query_block\\\": { \\\"select_id\\\": 1, \\\"cost_info\\\": { \\\"query_cost\\\": \\\"1.20\\\" }, \\\"table\\\": { \\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\" }, \\\"used_columns\\\": [ \\\"id\\\", \\\"student_name\\\", \\\"score\\\" ], \\\"attached_condition\\\": \\\"<in_optimizer>(`test_db_case_14_1749536504`.`students`.`id`,<exists>(/* select#2 */ select max(`test_db_case_14_1749536504`.`students`.`id`) from `test_db_case_14_1749536504`.`students` having (<cache>(`test_db_case_14_1749536504`.`students`.`id`) = <ref_null_helper>(max(`test_db_case_14_1749536504`.`students`.`id`)))))\\\", \\\"attached_subqueries\\\": [ { \\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": { \\\"select_id\\\": 2, \\\"message\\\": \\\"No matching min/max row\\\" } } ] } } }\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), score INT );\n\n## Explain Output in JSON:\n{\"query_block\": { \"select_id\": 1, \"cost_info\": { \"query_cost\": \"1.20\" }, \"table\": { \"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\" }, \"used_columns\": [ \"id\", \"student_name\", \"score\" ], \"attached_condition\": \"<in_optimizer>(`test_db_case_14_1749536504`.`students`.`id`,<exists>(/* select#2 */ select max(`test_db_case_14_1749536504`.`students`.`id`) from `test_db_case_14_1749536504`.`students` having (<cache>(`test_db_case_14_1749536504`.`students`.`id`) = <ref_null_helper>(max(`test_db_case_14_1749536504`.`students`.`id`)))))\", \"attached_subqueries\": [ { \"dependent\": true, \"cacheable\": false, \"query_block\": { \"select_id\": 2, \"message\": \"No matching min/max row\" } } ] } } }\n\n## Original SQL:\nSELECT * FROM students WHERE id IN ( SELECT MAX(id) FROM students );\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM students ORDER BY id DESC LIMIT 1;"
                    }
                ]
            },
            {
                "case_id": "15",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"15\", \"db_type\": \"mysql\", \"description\": \"一个包含嵌套子查询的COUNT语句，其中外部的WHERE子句条件可以下推到内层的子查询中，并且子查询中存在可以投影下推的冗余列。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE enrollments ( student_id INT PRIMARY KEY, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT COUNT(*) FROM ( SELECT student_id, enrollment_date FROM enrollments WHERE student_id < 1000 ) AS dt WHERE enrollment_date >= '2023-01-01';\", \"explain\": \"{\\\"query_block\\\": { \\\"select_id\\\": 1, \\\"cost_info\\\": { \\\"query_cost\\\": \\\"1.41\\\" }, \\\"table\\\": { \\\"table_name\\\": \\\"enrollments\\\", \\\"access_type\\\": \\\"range\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"student_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.21\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.41\\\", \\\"data_read_per_join\\\": \\\"16\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"enrollment_date\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_15_1749719333`.`enrollments`.`enrollment_date` >= '2023-01-01') and (`test_db_case_15_1749719333`.`enrollments`.`student_id` < 1000))\\\" } } }\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE enrollments ( student_id INT PRIMARY KEY, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": { \"select_id\": 1, \"cost_info\": { \"query_cost\": \"1.41\" }, \"table\": { \"table_name\": \"enrollments\", \"access_type\": \"range\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"student_id\" ], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.21\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.41\", \"data_read_per_join\": \"16\" }, \"used_columns\": [ \"student_id\", \"enrollment_date\" ], \"attached_condition\": \"((`test_db_case_15_1749719333`.`enrollments`.`enrollment_date` >= '2023-01-01') and (`test_db_case_15_1749719333`.`enrollments`.`student_id` < 1000))\" } } }\n\n## Original SQL:\nSELECT COUNT(*) FROM ( SELECT student_id, enrollment_date FROM enrollments WHERE student_id < 1000 ) AS dt WHERE enrollment_date >= '2023-01-01';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT COUNT(*) FROM enrollments WHERE student_id < 1000 AND enrollment_date >= '2023-01-01';"
                    }
                ]
            },
            {
                "case_id": "16",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"16\", \"db_type\": \"mysql\", \"description\": \"一个简单的LEFT JOIN查询，明确引用了主表中的列，可能存在可消除的外连接。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;\"], \"sql\": \"SELECT o.o_custkey FROM orders o LEFT JOIN customer ON c_custkey=o_custkey\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"},\\\"table\\\": {\\\"table_name\\\": \\\"o\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"O_CUSTKEY\\\",\\\"O_ORDERKEY\\\",\\\"O_ORDERSTATUS\\\",\\\"O_TOTALPRICE\\\",\\\"O_ORDERDATE\\\",\\\"O_ORDERPRIORITY\\\",\\\"O_CLERK\\\",\\\"O_SHIPPRIORITY\\\",\\\"O_COMMENT\\\"]}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"1.20\"},\"table\": {\"table_name\": \"o\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"O_CUSTKEY\",\"O_ORDERKEY\",\"O_ORDERSTATUS\",\"O_TOTALPRICE\",\"O_ORDERDATE\",\"O_ORDERPRIORITY\",\"O_CLERK\",\"O_SHIPPRIORITY\",\"O_COMMENT\"]}}}\n\n## Original SQL:\nSELECT o.o_custkey FROM orders o LEFT JOIN customer ON c_custkey=o_custkey\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT o.o_custkey FROM orders o"
                    }
                ]
            },
            {
                "case_id": "17",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"17\", \"db_type\": \"mysql\", \"description\": \"一个包含LEFT JOIN的SELECT语句，连接条件为不等值连接，难以进行外连接消除。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\"], \"sql\": \"SELECT c.* FROM customer c LEFT JOIN orders o ON c.c_custkey > o.o_custkey\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"},\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"c\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"C_CUSTKEY\\\",\\\"C_NAME\\\",\\\"C_ADDRESS\\\",\\\"C_NATIONKEY\\\",\\\"C_PHONE\\\",\\\"C_ACCTBAL\\\",\\\"C_MKTSEGMENT\\\",\\\"C_COMMENT\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"o\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"O_CUSTKEY\\\",\\\"O_ORDERKEY\\\",\\\"O_ORDERSTATUS\\\",\\\"O_TOTALPRICE\\\",\\\"O_ORDERDATE\\\",\\\"O_ORDERPRIORITY\\\",\\\"O_CLERK\\\",\\\"O_SHIPPRIORITY\\\",\\\"O_COMMENT\\\"],\\\"attached_condition\\\": \\\"(`c`.`C_CUSTKEY` > `o`.`O_CUSTKEY`)\\\"}}]}}}\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"1.20\"},\"nested_loop\": [{\"table\": {\"table_name\": \"c\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"C_CUSTKEY\",\"C_NAME\",\"C_ADDRESS\",\"C_NATIONKEY\",\"C_PHONE\",\"C_ACCTBAL\",\"C_MKTSEGMENT\",\"C_COMMENT\"]}},{\"table\": {\"table_name\": \"o\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"O_CUSTKEY\",\"O_ORDERKEY\",\"O_ORDERSTATUS\",\"O_TOTALPRICE\",\"O_ORDERDATE\",\"O_ORDERPRIORITY\",\"O_CLERK\",\"O_SHIPPRIORITY\",\"O_COMMENT\"],\"attached_condition\": \"(`c`.`C_CUSTKEY` > `o`.`O_CUSTKEY`)\"}}]}}}\n\n## Original SQL:\nSELECT c.* FROM customer c LEFT JOIN orders o ON c.c_custkey > o.o_custkey\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT c.* FROM customer c LEFT JOIN orders o ON c.C_CUSTKEY = o.O_CUSTKEY"
                    }
                ]
            },
            {
                "case_id": "18",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"18\", \"db_type\": \"mysql\", \"description\": \"一个包含LEFT JOIN的SELECT语句，连接条件为不等值连接，难以进行外连接消除，且使用了表别名。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\"], \"sql\": \"SELECT c.* FROM customer AS c LEFT JOIN orders AS o ON c.c_custkey > o.o_custkey\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"},\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"c\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"C_CUSTKEY\\\",\\\"C_NAME\\\",\\\"C_ADDRESS\\\",\\\"C_NATIONKEY\\\",\\\"C_PHONE\\\",\\\"C_ACCTBAL\\\",\\\"C_MKTSEGMENT\\\",\\\"C_COMMENT\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"o\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"O_CUSTKEY\\\",\\\"O_ORDERKEY\\\",\\\"O_ORDERSTATUS\\\",\\\"O_TOTALPRICE\\\",\\\"O_ORDERDATE\\\",\\\"O_ORDERPRIORITY\\\",\\\"O_CLERK\\\",\\\"O_SHIPPRIORITY\\\",\\\"O_COMMENT\\\"],\\\"attached_condition\\\": \\\"(`c`.`C_CUSTKEY` > `o`.`O_CUSTKEY`)\\\"}}]}}}\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"1.20\"},\"nested_loop\": [{\"table\": {\"table_name\": \"c\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"C_CUSTKEY\",\"C_NAME\",\"C_ADDRESS\",\"C_NATIONKEY\",\"C_PHONE\",\"C_ACCTBAL\",\"C_MKTSEGMENT\",\"C_COMMENT\"]}},{\"table\": {\"table_name\": \"o\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"O_CUSTKEY\",\"O_ORDERKEY\",\"O_ORDERSTATUS\",\"O_TOTALPRICE\",\"O_ORDERDATE\",\"O_ORDERPRIORITY\",\"O_CLERK\",\"O_SHIPPRIORITY\",\"O_COMMENT\"],\"attached_condition\": \"(`c`.`C_CUSTKEY` > `o`.`O_CUSTKEY`)\"}}]}}}\n\n## Original SQL:\nSELECT c.* FROM customer AS c LEFT JOIN orders AS o ON c.c_custkey > o.o_custkey\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT c.* FROM customer AS c LEFT JOIN orders AS o ON c.c_custkey = o.o_custkey"
                    }
                ]
            },
            {
                "case_id": "19",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"19\", \"db_type\": \"mysql\", \"description\": \"一个包含INNER JOIN和DISTINCT的SELECT语句，可能存在不必要的DISTINCT，且包含排序操作。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE PatientRecords (PatientID INT PRIMARY KEY,Name VARCHAR(255),Age INT);CREATE TABLE DoctorSchedules (DoctorID INT PRIMARY KEY,ScheduleDate DATE,PatientID INT);CREATE TABLE MedicalDevices (DeviceID INT PRIMARY KEY,DeviceName VARCHAR(255),PatientID INT);CREATE TABLE TreatmentHistory (TreatmentID INT PRIMARY KEY,PatientID INT,TreatmentDate DATE);\"], \"sql\": \"SELECT DISTINCT PatientRecords.PatientID, PatientRecords.Name, TreatmentHistory.TreatmentDate FROM PatientRecords INNER JOIN TreatmentHistory ON PatientRecords.PatientID = TreatmentHistory.PatientID ORDER BY TreatmentHistory.TreatmentDate DESC\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"},\\\"duplicates_removal\\\": {\\\"using_temporary_table\\\": true,\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"PatientRecords\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"PatientID\\\",\\\"Name\\\",\\\"Age\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"TreatmentHistory\\\",\\\"access_type\\\": \\\"ref\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"TreatmentID\\\",\\\"PatientID\\\",\\\"TreatmentDate\\\"],\\\"attached_condition\\\": \\\"(`PatientRecords`.`PatientID` = `TreatmentHistory`.`PatientID`)\\\"}}]}}}\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE PatientRecords (PatientID INT PRIMARY KEY,Name VARCHAR(255),Age INT);CREATE TABLE DoctorSchedules (DoctorID INT PRIMARY KEY,ScheduleDate DATE,PatientID INT);CREATE TABLE MedicalDevices (DeviceID INT PRIMARY KEY,DeviceName VARCHAR(255),PatientID INT);CREATE TABLE TreatmentHistory (TreatmentID INT PRIMARY KEY,PatientID INT,TreatmentDate DATE);\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"1.20\"},\"duplicates_removal\": {\"using_temporary_table\": true,\"nested_loop\": [{\"table\": {\"table_name\": \"PatientRecords\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"PatientID\",\"Name\",\"Age\"]}},{\"table\": {\"table_name\": \"TreatmentHistory\",\"access_type\": \"ref\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"TreatmentID\",\"PatientID\",\"TreatmentDate\"],\"attached_condition\": \"(`PatientRecords`.`PatientID` = `TreatmentHistory`.`PatientID`)\"}}]}}}\n\n## Original SQL:\nSELECT DISTINCT PatientRecords.PatientID, PatientRecords.Name, TreatmentHistory.TreatmentDate FROM PatientRecords INNER JOIN TreatmentHistory ON PatientRecords.PatientID = TreatmentHistory.PatientID ORDER BY TreatmentHistory.TreatmentDate DESC\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT PatientRecords.PatientID, PatientRecords.Name, TreatmentHistory.TreatmentDate FROM PatientRecords INNER JOIN TreatmentHistory ON PatientRecords.PatientID = TreatmentHistory.PatientID ORDER BY TreatmentHistory.TreatmentDate DESC"
                    }
                ]
            },
            {
                "case_id": "20",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"20\", \"db_type\": \"mysql\", \"description\": \"一个简单的LEFT JOIN查询，可能存在可消除的外连接，且未引用被连接表中的任何列。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\"], \"sql\": \"SELECT o_custkey FROM orders LEFT JOIN customer ON c_custkey=o_custkey\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"0.70\\\"}, \\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"orders\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"0.25\\\", \\\"eval_cost\\\": \\\"0.10\\\", \\\"prefix_cost\\\": \\\"0.35\\\", \\\"data_read_per_join\\\": \\\"472\\\"}, \\\"used_columns\\\": [\\\"O_CUSTKEY\\\"]}}, {\\\"table\\\": {\\\"table_name\\\": \\\"customer\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"C_CUSTKEY\\\"], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [\\\"test_db_case_10_1749728367.orders.O_CUSTKEY\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"using_index\\\": true, \\\"cost_info\\\": {\\\"read_cost\\\": \\\"0.25\\\", \\\"eval_cost\\\": \\\"0.10\\\", \\\"prefix_cost\\\": \\\"0.70\\\", \\\"data_read_per_join\\\": \\\"848\\\"}, \\\"used_columns\\\": [\\\"C_CUSTKEY\\\"]}}]}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"0.70\"}, \"nested_loop\": [{\"table\": {\"table_name\": \"orders\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"0.25\", \"eval_cost\": \"0.10\", \"prefix_cost\": \"0.35\", \"data_read_per_join\": \"472\"}, \"used_columns\": [\"O_CUSTKEY\"]}}, {\"table\": {\"table_name\": \"customer\", \"access_type\": \"eq_ref\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"C_CUSTKEY\"], \"key_length\": \"4\", \"ref\": [\"test_db_case_10_1749728367.orders.O_CUSTKEY\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"using_index\": true, \"cost_info\": {\"read_cost\": \"0.25\", \"eval_cost\": \"0.10\", \"prefix_cost\": \"0.70\", \"data_read_per_join\": \"848\"}, \"used_columns\": [\"C_CUSTKEY\"]}}]}}\n\n## Original SQL:\nSELECT o_custkey FROM orders LEFT JOIN customer ON c_custkey=o_custkey\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT o_custkey FROM orders"
                    }
                ]
            },
            {
                "case_id": "21",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"21\", \"db_type\": \"oracle\", \"description\": \"本次改写的核心技术是将score_model_factor表的JOIN转换为EXISTS子查询。原SQL中,虽然JOIN了score_model_factor表,但SELECT子句中并未使用该表的任何列(仅用于过滤),这正是JOIN转EXISTS优化的典型场景。改写后,通过EXISTS(SELECT 1 FROM score_model_factor f WHERE f.model_factor_id = t.model_factor_id)实现了相同的语义:只有当SCORE_RATING_RECORD_DETAIL.model_factor_id在score_model_factor表中存在时,该行才被保留。EXISTS的优势在于:(1)利用主键索引快速验证;(2)找到第一条匹配记录即返回TRUE,无需扫描所有匹配行;(3)不需要传递score_model_factor的列数据,减少内存和网络开销。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE SEQUENCE score_rating_record_seq; CREATE TABLE SCORE_RATING_RECORD (score_rating_record_id NUMBER PRIMARY KEY, rpt_dt DATE NOT NULL); CREATE OR REPLACE TRIGGER score_rating_record_bi BEFORE INSERT ON SCORE_RATING_RECORD FOR EACH ROW BEGIN IF :NEW.score_rating_record_id IS NULL THEN SELECT score_rating_record_seq.NEXTVAL INTO :NEW.score_rating_record_id FROM DUAL; END IF; END;\", \"CREATE SEQUENCE score_rating_region_record_seq; CREATE TABLE score_rating_region_record (score_rating_region_record_id NUMBER PRIMARY KEY, score_rating_record_id NUMBER NOT NULL, region_cd VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER score_rating_region_record_bi BEFORE INSERT ON score_rating_region_record FOR EACH ROW BEGIN IF :NEW.score_rating_region_record_id IS NULL THEN SELECT score_rating_region_record_seq.NEXTVAL INTO :NEW.score_rating_region_record_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_srr_score_rating_record_id ON score_rating_region_record(score_rating_record_id);\", \"CREATE INDEX idx_srr_region_cd ON score_rating_region_record(region_cd);\", \"CREATE SEQUENCE score_rating_record_detail_seq; CREATE TABLE SCORE_RATING_RECORD_DETAIL (score_rating_record_detail_id NUMBER PRIMARY KEY, score_rating_region_record_id NUMBER NOT NULL, model_factor_id NUMBER NOT NULL, factor_cd VARCHAR2(50) NOT NULL, factor_value NUMBER(18,4), option_init VARCHAR2(100)); CREATE OR REPLACE TRIGGER score_rating_record_detail_bi BEFORE INSERT ON SCORE_RATING_RECORD_DETAIL FOR EACH ROW BEGIN IF :NEW.score_rating_record_detail_id IS NULL THEN SELECT score_rating_record_detail_seq.NEXTVAL INTO :NEW.score_rating_record_detail_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_srrd_region_record_id ON SCORE_RATING_RECORD_DETAIL(score_rating_region_record_id);\", \"CREATE INDEX idx_srrd_model_factor_id ON SCORE_RATING_RECORD_DETAIL(model_factor_id);\", \"CREATE INDEX idx_srrd_factor_cd ON SCORE_RATING_RECORD_DETAIL(factor_cd);\", \"CREATE SEQUENCE score_model_factor_seq; CREATE TABLE score_model_factor (model_factor_id NUMBER PRIMARY KEY, factor_name VARCHAR2(100), factor_desc VARCHAR2(500)); CREATE OR REPLACE TRIGGER score_model_factor_bi BEFORE INSERT ON score_model_factor FOR EACH ROW BEGIN IF :NEW.model_factor_id IS NULL THEN SELECT score_model_factor_seq.NEXTVAL INTO :NEW.model_factor_id FROM DUAL; END IF; END;\"], \"sql\": \"select a.rpt_dt,s.region_cd , t.factor_cd,t.factor_value,t.option_init from SCORE_RATING_RECORD a\\njoin score_rating_region_record s on a.score_rating_record_id =s.score_rating_record_id\\njoin SCORE_RATING_RECORD_DETAIL t on s.score_rating_region_record_id =t.score_rating_region_record_id\\njoin score_model_factor f on f.model_factor_id =t.model_factor_id\\nwhere a.score_rating_record_id =1951215209649586177\\norder by s.region_cd , t.factor_cd;\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t109\\t50\\t2650\\t37698709\\t108\\n1\\t  SORT ORDER BY \\t109\\t50\\t2650\\t37698709\\t108\\n2\\t  HASH JOIN  \\t108\\t50\\t2650\\t817426\\t108\\n3\\t   NESTED LOOPS  \\t108\\t50\\t2650\\t817426\\t108\\n4\\t  NESTED LOOPS  \\t108\\t100\\t2650\\t817426\\t108\\n5\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n6\\t   NESTED LOOPS  \\t6\\t1\\t34\\t45189\\t6\\n7\\t  TABLE ACCESS BY INDEX ROWID SCORE_RATING_RECORD\\t3\\t1\\t18\\t22584\\t3\\n8\\t  INDEX UNIQUE SCAN SYS_C008302\\t2\\t1\\t\\t15293\\t2\\n9\\t  TABLE ACCESS BY INDEX ROWID BATCHED SCORE_RATING_REGION_RECORD\\t3\\t1\\t16\\t22604\\t3\\n10\\t  INDEX RANGE SCAN IDX_SRR_SCORE_RATING_RECORD_ID\\t2\\t1\\t\\t15293\\t2\\n11\\t  INDEX RANGE SCAN IDX_SRRD_REGION_RECORD_ID\\t2\\t100\\t\\t35093\\t2\\n12\\t  TABLE ACCESS BY INDEX ROWID SCORE_RATING_RECORD_DETAIL\\t102\\t100\\t1900\\t772237\\t102\\n13\\t   TABLE ACCESS FULL SCORE_RATING_RECORD_DETAIL\\t102\\t100\\t1900\\t772237\\t102\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE score_rating_record_seq; CREATE TABLE SCORE_RATING_RECORD (score_rating_record_id NUMBER PRIMARY KEY, rpt_dt DATE NOT NULL); CREATE OR REPLACE TRIGGER score_rating_record_bi BEFORE INSERT ON SCORE_RATING_RECORD FOR EACH ROW BEGIN IF :NEW.score_rating_record_id IS NULL THEN SELECT score_rating_record_seq.NEXTVAL INTO :NEW.score_rating_record_id FROM DUAL; END IF; END;\nCREATE SEQUENCE score_rating_region_record_seq; CREATE TABLE score_rating_region_record (score_rating_region_record_id NUMBER PRIMARY KEY, score_rating_record_id NUMBER NOT NULL, region_cd VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER score_rating_region_record_bi BEFORE INSERT ON score_rating_region_record FOR EACH ROW BEGIN IF :NEW.score_rating_region_record_id IS NULL THEN SELECT score_rating_region_record_seq.NEXTVAL INTO :NEW.score_rating_region_record_id FROM DUAL; END IF; END;\nCREATE INDEX idx_srr_score_rating_record_id ON score_rating_region_record(score_rating_record_id);\nCREATE INDEX idx_srr_region_cd ON score_rating_region_record(region_cd);\nCREATE SEQUENCE score_rating_record_detail_seq; CREATE TABLE SCORE_RATING_RECORD_DETAIL (score_rating_record_detail_id NUMBER PRIMARY KEY, score_rating_region_record_id NUMBER NOT NULL, model_factor_id NUMBER NOT NULL, factor_cd VARCHAR2(50) NOT NULL, factor_value NUMBER(18,4), option_init VARCHAR2(100)); CREATE OR REPLACE TRIGGER score_rating_record_detail_bi BEFORE INSERT ON SCORE_RATING_RECORD_DETAIL FOR EACH ROW BEGIN IF :NEW.score_rating_record_detail_id IS NULL THEN SELECT score_rating_record_detail_seq.NEXTVAL INTO :NEW.score_rating_record_detail_id FROM DUAL; END IF; END;\nCREATE INDEX idx_srrd_region_record_id ON SCORE_RATING_RECORD_DETAIL(score_rating_region_record_id);\nCREATE INDEX idx_srrd_model_factor_id ON SCORE_RATING_RECORD_DETAIL(model_factor_id);\nCREATE INDEX idx_srrd_factor_cd ON SCORE_RATING_RECORD_DETAIL(factor_cd);\nCREATE SEQUENCE score_model_factor_seq; CREATE TABLE score_model_factor (model_factor_id NUMBER PRIMARY KEY, factor_name VARCHAR2(100), factor_desc VARCHAR2(500)); CREATE OR REPLACE TRIGGER score_model_factor_bi BEFORE INSERT ON score_model_factor FOR EACH ROW BEGIN IF :NEW.model_factor_id IS NULL THEN SELECT score_model_factor_seq.NEXTVAL INTO :NEW.model_factor_id FROM DUAL; END IF; END;\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t109\t50\t2650\t37698709\t108\n1\t  SORT ORDER BY \t109\t50\t2650\t37698709\t108\n2\t  HASH JOIN  \t108\t50\t2650\t817426\t108\n3\t   NESTED LOOPS  \t108\t50\t2650\t817426\t108\n4\t  NESTED LOOPS  \t108\t100\t2650\t817426\t108\n5\t  STATISTICS COLLECTOR  \t\t\t\t\t\n6\t   NESTED LOOPS  \t6\t1\t34\t45189\t6\n7\t  TABLE ACCESS BY INDEX ROWID SCORE_RATING_RECORD\t3\t1\t18\t22584\t3\n8\t  INDEX UNIQUE SCAN SYS_C008302\t2\t1\t\t15293\t2\n9\t  TABLE ACCESS BY INDEX ROWID BATCHED SCORE_RATING_REGION_RECORD\t3\t1\t16\t22604\t3\n10\t  INDEX RANGE SCAN IDX_SRR_SCORE_RATING_RECORD_ID\t2\t1\t\t15293\t2\n11\t  INDEX RANGE SCAN IDX_SRRD_REGION_RECORD_ID\t2\t100\t\t35093\t2\n12\t  TABLE ACCESS BY INDEX ROWID SCORE_RATING_RECORD_DETAIL\t102\t100\t1900\t772237\t102\n13\t   TABLE ACCESS FULL SCORE_RATING_RECORD_DETAIL\t102\t100\t1900\t772237\t102\n\n## Original SQL:\nselect a.rpt_dt,s.region_cd , t.factor_cd,t.factor_value,t.option_init from SCORE_RATING_RECORD a\njoin score_rating_region_record s on a.score_rating_record_id =s.score_rating_record_id\njoin SCORE_RATING_RECORD_DETAIL t on s.score_rating_region_record_id =t.score_rating_region_record_id\njoin score_model_factor f on f.model_factor_id =t.model_factor_id\nwhere a.score_rating_record_id =1951215209649586177\norder by s.region_cd , t.factor_cd;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select a.rpt_dt,s.region_cd,t.factor_cd,t.factor_value,t.option_init from SCORE_RATING_RECORD a join score_rating_region_record s on a.score_rating_record_id=s.score_rating_record_id join SCORE_RATING_RECORD_DETAIL t on s.score_rating_region_record_id=t.score_rating_region_record_id where a.score_rating_record_id=1951215209649586177 order by s.region_cd,t.factor_cd"
                    }
                ]
            },
            {
                "case_id": "22",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"22\", \"db_type\": \"oracle\", \"description\": \"此次改写主要采用了谓词下推技术，试图通过提前过滤减少数据量。同时移除了内层不必要的ORDER BY操作（因为最外层使用ROWNUM限制结果集），理论上可以节省排序成本。还优化了日期比较条件，使其更加精确。然而，由于过滤条件位置调整不当，导致了SQL语义发生变化。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE SEQUENCE SYS_READ_HIS_LOG_SEQ; CREATE TABLE SYS_READ_HIS_LOG (PKID NUMBER PRIMARY KEY, FD_MODEL_ID NUMBER, FD_MODEL_NAME VARCHAR2(200), FD_READ_TIME TIMESTAMP); CREATE OR REPLACE TRIGGER SYS_READ_HIS_LOG_BI BEFORE INSERT ON SYS_READ_HIS_LOG FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT SYS_READ_HIS_LOG_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_sys_read_model_name ON SYS_READ_HIS_LOG(FD_MODEL_NAME);\", \"CREATE INDEX idx_sys_read_model_id ON SYS_READ_HIS_LOG(FD_MODEL_ID);\", \"CREATE INDEX idx_sys_read_time ON SYS_READ_HIS_LOG(FD_READ_TIME);\", \"CREATE SEQUENCE MANUAL_FILE_SEQ; CREATE TABLE MANUAL_FILE (FD_ID NUMBER PRIMARY KEY, FD_FILE_ID NUMBER); CREATE OR REPLACE TRIGGER MANUAL_FILE_BI BEFORE INSERT ON MANUAL_FILE FOR EACH ROW BEGIN IF :NEW.FD_ID IS NULL THEN SELECT MANUAL_FILE_SEQ.NEXTVAL INTO :NEW.FD_ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_manual_file_id ON MANUAL_FILE(FD_FILE_ID);\", \"CREATE SEQUENCE MANUAL_FILE_BASIC_INFO_SEQ; CREATE TABLE MANUAL_FILE_BASIC_INFO (PKID NUMBER PRIMARY KEY, FD_FILE_NAME VARCHAR2(200), FD_NO VARCHAR2(100), MANUAL_ID NUMBER, IS_DELETED VARCHAR2(1) DEFAULT '0'); CREATE OR REPLACE TRIGGER MANUAL_FILE_BASIC_INFO_BI BEFORE INSERT ON MANUAL_FILE_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT MANUAL_FILE_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mfbi_manual_id ON MANUAL_FILE_BASIC_INFO(MANUAL_ID);\", \"CREATE INDEX idx_mfbi_is_deleted ON MANUAL_FILE_BASIC_INFO(IS_DELETED);\", \"CREATE SEQUENCE XMAIR_MANUAL_BASIC_INFO_SEQ; CREATE TABLE XMAIR_MANUAL_BASIC_INFO (PKID NUMBER PRIMARY KEY, TYPE_ID NUMBER); CREATE OR REPLACE TRIGGER XMAIR_MANUAL_BASIC_INFO_BI BEFORE INSERT ON XMAIR_MANUAL_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT XMAIR_MANUAL_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_xmbi_type_id ON XMAIR_MANUAL_BASIC_INFO(TYPE_ID);\"], \"sql\": \"SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (\\n  SELECT  max(FD_MODEL_ID) FD_MODEL_ID,sum(countNumber) sumNumber ,max(FD_FILE_ID) FD_FILE_ID FROM (\\n  SELECT FD_MODEL_ID,count(1) countNumber from\\n  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL\\n  <if test=\\\"startDate != null and startDate != ''\\\">\\n   and FD_READ_TIME >= to_date(#{startDate},'yyyy-mm-dd')\\n  </if>\\n  <if test=\\\"endDate != null and endDate != ''\\\">\\n   and FD_READ_TIME &lt;= to_date(#{endDate},'yyyy-mm-dd')\\n  </if>\\n  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID\\n  GROUP BY FD_FILE_ID order by  sumNumber desc ) w\\n  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi\\n  ON mfbi.PKID = w.FD_FILE_ID\\n  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID\\n  <where>\\n   mfbi.IS_DELETED = '0'\\n   <if test=\\\" typeIdsByMfId != null  and typeIdsByMfId.size>0\\\">\\n  and  xmbi.TYPE_ID in\\n  <foreach collection=\\\"typeIdsByMfId\\\" item=\\\"typeId\\\" open=\\\"(\\\" separator=\\\",\\\" close=\\\")\\\">\\n  #{typeId}\\n  </foreach>\\n   </if>\\n   and rownum <![CDATA[ <= ]]> 10\\n  </where>\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t101\\t10\\t670\\t32701838\\t100\\n1\\t  COUNT STOPKEY \\t\\t\\t\\t\\t\\n2\\t  NESTED LOOPS  \\t101\\t10\\t670\\t32701838\\t100\\n3\\t   NESTED LOOPS  \\t101\\t20\\t670\\t32701838\\t100\\n4\\t  VIEW  \\t61\\t1000\\t26000\\t32373380\\t60\\n5\\t  SORT ORDER BY \\t3030\\t1000\\t29000\\t1618668956\\t2986\\n6\\t   HASH GROUP BY \\t3030\\t1000\\t29000\\t1618668956\\t2986\\n7\\t  VIEW  \\t3028\\t1000\\t29000\\t1544033810\\t2986\\n8\\t  HASH JOIN OUTER \\t3028\\t1000\\t33000\\t1544033810\\t2986\\n9\\t   NESTED LOOPS OUTER \\t3028\\t1000\\t33000\\t1544033810\\t2986\\n10\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n11\\t  VIEW  VW_GBF_8\\t2497\\t1000\\t26000\\t1259582159\\t2463\\n12\\t   HASH GROUP BY \\t2497\\t1000\\t46000\\t1259582159\\t2463\\n13\\t  TABLE ACCESS FULL SYS_READ_HIS_LOG\\t2472\\t1000000\\t46000000\\t324705404\\t2463\\n14\\t  TABLE ACCESS BY INDEX ROWID MANUAL_FILE\\t528\\t1\\t7\\t183701651\\t523\\n15\\t  INDEX UNIQUE SCAN SYS_C008302\\t\\t\\t\\t\\t\\n16\\t   TABLE ACCESS FULL MANUAL_FILE\\t528\\t1000000\\t7000000\\t183701651\\t523\\n17\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n18\\t   TABLE ACCESS BY INDEX ROWID MANUAL_FILE_BASIC_INFO\\t2\\t1\\t41\\t16423\\t2\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE SYS_READ_HIS_LOG_SEQ; CREATE TABLE SYS_READ_HIS_LOG (PKID NUMBER PRIMARY KEY, FD_MODEL_ID NUMBER, FD_MODEL_NAME VARCHAR2(200), FD_READ_TIME TIMESTAMP); CREATE OR REPLACE TRIGGER SYS_READ_HIS_LOG_BI BEFORE INSERT ON SYS_READ_HIS_LOG FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT SYS_READ_HIS_LOG_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_sys_read_model_name ON SYS_READ_HIS_LOG(FD_MODEL_NAME);\nCREATE INDEX idx_sys_read_model_id ON SYS_READ_HIS_LOG(FD_MODEL_ID);\nCREATE INDEX idx_sys_read_time ON SYS_READ_HIS_LOG(FD_READ_TIME);\nCREATE SEQUENCE MANUAL_FILE_SEQ; CREATE TABLE MANUAL_FILE (FD_ID NUMBER PRIMARY KEY, FD_FILE_ID NUMBER); CREATE OR REPLACE TRIGGER MANUAL_FILE_BI BEFORE INSERT ON MANUAL_FILE FOR EACH ROW BEGIN IF :NEW.FD_ID IS NULL THEN SELECT MANUAL_FILE_SEQ.NEXTVAL INTO :NEW.FD_ID FROM DUAL; END IF; END;\nCREATE INDEX idx_manual_file_id ON MANUAL_FILE(FD_FILE_ID);\nCREATE SEQUENCE MANUAL_FILE_BASIC_INFO_SEQ; CREATE TABLE MANUAL_FILE_BASIC_INFO (PKID NUMBER PRIMARY KEY, FD_FILE_NAME VARCHAR2(200), FD_NO VARCHAR2(100), MANUAL_ID NUMBER, IS_DELETED VARCHAR2(1) DEFAULT '0'); CREATE OR REPLACE TRIGGER MANUAL_FILE_BASIC_INFO_BI BEFORE INSERT ON MANUAL_FILE_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT MANUAL_FILE_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_mfbi_manual_id ON MANUAL_FILE_BASIC_INFO(MANUAL_ID);\nCREATE INDEX idx_mfbi_is_deleted ON MANUAL_FILE_BASIC_INFO(IS_DELETED);\nCREATE SEQUENCE XMAIR_MANUAL_BASIC_INFO_SEQ; CREATE TABLE XMAIR_MANUAL_BASIC_INFO (PKID NUMBER PRIMARY KEY, TYPE_ID NUMBER); CREATE OR REPLACE TRIGGER XMAIR_MANUAL_BASIC_INFO_BI BEFORE INSERT ON XMAIR_MANUAL_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT XMAIR_MANUAL_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_xmbi_type_id ON XMAIR_MANUAL_BASIC_INFO(TYPE_ID);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t101\t10\t670\t32701838\t100\n1\t  COUNT STOPKEY \t\t\t\t\t\n2\t  NESTED LOOPS  \t101\t10\t670\t32701838\t100\n3\t   NESTED LOOPS  \t101\t20\t670\t32701838\t100\n4\t  VIEW  \t61\t1000\t26000\t32373380\t60\n5\t  SORT ORDER BY \t3030\t1000\t29000\t1618668956\t2986\n6\t   HASH GROUP BY \t3030\t1000\t29000\t1618668956\t2986\n7\t  VIEW  \t3028\t1000\t29000\t1544033810\t2986\n8\t  HASH JOIN OUTER \t3028\t1000\t33000\t1544033810\t2986\n9\t   NESTED LOOPS OUTER \t3028\t1000\t33000\t1544033810\t2986\n10\t  STATISTICS COLLECTOR  \t\t\t\t\t\n11\t  VIEW  VW_GBF_8\t2497\t1000\t26000\t1259582159\t2463\n12\t   HASH GROUP BY \t2497\t1000\t46000\t1259582159\t2463\n13\t  TABLE ACCESS FULL SYS_READ_HIS_LOG\t2472\t1000000\t46000000\t324705404\t2463\n14\t  TABLE ACCESS BY INDEX ROWID MANUAL_FILE\t528\t1\t7\t183701651\t523\n15\t  INDEX UNIQUE SCAN SYS_C008302\t\t\t\t\t\n16\t   TABLE ACCESS FULL MANUAL_FILE\t528\t1000000\t7000000\t183701651\t523\n17\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n18\t   TABLE ACCESS BY INDEX ROWID MANUAL_FILE_BASIC_INFO\t2\t1\t41\t16423\t2\n\n## Original SQL:\nSELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (\n  SELECT  max(FD_MODEL_ID) FD_MODEL_ID,sum(countNumber) sumNumber ,max(FD_FILE_ID) FD_FILE_ID FROM (\n  SELECT FD_MODEL_ID,count(1) countNumber from\n  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL\n  <if test=\"startDate != null and startDate != ''\">\n   and FD_READ_TIME >= to_date(#{startDate},'yyyy-mm-dd')\n  </if>\n  <if test=\"endDate != null and endDate != ''\">\n   and FD_READ_TIME &lt;= to_date(#{endDate},'yyyy-mm-dd')\n  </if>\n  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID\n  GROUP BY FD_FILE_ID order by  sumNumber desc ) w\n  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi\n  ON mfbi.PKID = w.FD_FILE_ID\n  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID\n  <where>\n   mfbi.IS_DELETED = '0'\n   <if test=\" typeIdsByMfId != null  and typeIdsByMfId.size>0\">\n  and  xmbi.TYPE_ID in\n  <foreach collection=\"typeIdsByMfId\" item=\"typeId\" open=\"(\" separator=\",\" close=\")\">\n  #{typeId}\n  </foreach>\n   </if>\n   and rownum <![CDATA[ <= ]]> 10\n  </where>\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO,w.sumNumber countNumber FROM (SELECT FD_FILE_ID,sumNumber FROM (SELECT mf.FD_FILE_ID,SUM(cnt) sumNumber FROM (SELECT FD_MODEL_ID,COUNT(*) cnt FROM SYS_READ_HIS_LOG WHERE FD_MODEL_NAME='com.xmair.core.entity.DO.XmairManualFileNew' AND FD_MODEL_ID IS NOT NULL GROUP BY FD_MODEL_ID) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID=t.FD_MODEL_ID GROUP BY mf.FD_FILE_ID ORDER BY sumNumber DESC) WHERE ROWNUM<=10) w LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi ON mfbi.PKID=w.FD_FILE_ID LEFT JOIN XMAIR_MANUAL_BASIC_INFO xmbi ON xmbi.PKID=mfbi.MANUAL_ID WHERE mfbi.IS_DELETED='0'"
                    }
                ]
            },
            {
                "case_id": "23",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"23\", \"db_type\": \"oracle\", \"description\": \"此次改写将子查询内部的'LEFT JOIN mrtrecordinfo B ON A.ID = B.ID'改为'INNER JOIN'。改写的理论基础是：由于外层查询使用了WHERE A.ID IN (SELECT bid FROM ...)条件，而bid来源于B.ID，这意味着只有B.ID存在的记录才会被选中。因此LEFT JOIN产生的NULL行在后续过滤中会被完全排除，使用INNER JOIN语义上等价且理论上可减少NULL处理开销。然而实际测试显示，Oracle优化器在处理原始LEFT JOIN时已经识别出这种模式并进行了等价优化，导致手动改写未产生实质性能提升。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE SEQUENCE mrtopration_seq; CREATE TABLE mrtopration (ID NUMBER PRIMARY KEY, PRAMARYID NUMBER, OPERCODE VARCHAR2(50), OPERNAME VARCHAR2(100), OPERDEPT VARCHAR2(100), OPERDATE DATE NOT NULL, MARK VARCHAR2(500), MARK2 VARCHAR2(500), MARK3 VARCHAR2(500), MARK4 VARCHAR2(500), OPERTYPE VARCHAR2(50), NEXTOPERTYPE VARCHAR2(50), PREOPERTYPE VARCHAR2(50), VALID NUMBER(1), CONFIRMUSER VARCHAR2(100), CONFIRMDEPT VARCHAR2(100), VERSIONNUMBER NUMBER); CREATE OR REPLACE TRIGGER mrtopration_bi BEFORE INSERT ON mrtopration FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtopration_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mrtopration_operdate ON mrtopration(OPERDATE);\", \"CREATE INDEX idx_mrtopration_opercode ON mrtopration(OPERCODE);\", \"CREATE SEQUENCE mrtrecordinfo_seq; CREATE TABLE mrtrecordinfo (ID NUMBER PRIMARY KEY, IN_TIMES NUMBER, NAME VARCHAR2(100), IN_DATE DATE, OUT_DATE DATE, OUT_DEPT VARCHAR2(100), RECORD_STATE VARCHAR2(50)); CREATE OR REPLACE TRIGGER mrtrecordinfo_bi BEFORE INSERT ON mrtrecordinfo FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtrecordinfo_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mrtrecordinfo_indate ON mrtrecordinfo(IN_DATE);\", \"CREATE TABLE mrtrecordregresses (RECODE_NO NUMBER NOT NULL, OPER_DATE DATE NOT NULL, OPERID VARCHAR2(50) NOT NULL, BACKREASON VARCHAR2(500), CONSTRAINT pk_mrtrecordregresses PRIMARY KEY (RECODE_NO, OPER_DATE, OPERID));\"], \"sql\": \"SELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID WHERE A.ID IN (SELECT bid FROM (SELECT B.ID AS bid, B.IN_DATE AS inDate, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID WHERE B.ID LIKE :\\\"SYS_B_0\\\" || :1 || :\\\" SYS_B_1\\\" GROUP BY B.ID, B.IN_DATE) WHERE rn BETWEEN :2 + :\\\"SYS_B_2\\\" AND :3 + :4 ) ORDER BY A.OPERDATE DESC\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t3725\\t10\\t1950\\t907708019\\t3700\\n1\\t  SORT ORDER BY \\t3725\\t10\\t1950\\t907708019\\t3700\\n2\\t  HASH JOIN OUTER \\t3724\\t10\\t1950\\t870837954\\t3700\\n3\\t   NESTED LOOPS OUTER \\t3724\\t10\\t1950\\t870837954\\t3700\\n4\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n5\\t  HASH JOIN OUTER \\t3714\\t10\\t1560\\t870747739\\t3690\\n6\\t   NESTED LOOPS OUTER \\t3714\\t10\\t1560\\t870747739\\t3690\\n7\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n8\\t  HASH JOIN  \\t3694\\t10\\t1110\\t870583611\\t3670\\n9\\t   NESTED LOOPS  \\t3694\\t10\\t1110\\t870583611\\t3670\\n10\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n11\\t  VIEW  VW_NSO_1\\t3673\\t10\\t40\\t833547416\\t3650\\n12\\t   HASH UNIQUE \\t\\t10\\t150\\t\\t\\n13\\t  VIEW  \\t3673\\t10\\t150\\t833547416\\t3650\\n14\\t  WINDOW NOSORT STOPKEY \\t3673\\t50000\\t750000\\t833547416\\t3650\\n15\\t   SORT GROUP BY \\t3673\\t50000\\t750000\\t833547416\\t3650\\n16\\t  HASH JOIN SEMI \\t3413\\t50000\\t750000\\t757426652\\t3392\\n17\\t  TABLE ACCESS FULL MRTRECORDINFO\\t2081\\t50000\\t550000\\t407379316\\t2070\\n18\\t  INDEX FAST FULL SCAN SYS_C008302\\t514\\t1000000\\t4000000\\t133352700\\t510\\n19\\t  TABLE ACCESS BY INDEX ROWID MRTOPRATION\\t2\\t1\\t107\\t16613\\t2\\n20\\t  INDEX UNIQUE SCAN SYS_C008302\\t1\\t1\\t\\t9021\\t1\\n21\\t   TABLE ACCESS FULL MRTOPRATION\\t2\\t1\\t107\\t16613\\t2\\n22\\t  TABLE ACCESS BY INDEX ROWID MRTRECORDINFO\\t2\\t1\\t45\\t16413\\t2\\n23\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n24\\t   TABLE ACCESS FULL MRTRECORDINFO\\t2\\t1\\t45\\t16413\\t2\\n25\\t  TABLE ACCESS BY INDEX ROWID MRTRECORDREGRESSES\\t1\\t1\\t39\\t9021\\t1\\n26\\t  INDEX UNIQUE SCAN PK_MRTRECORDREGRESSES\\t1\\t1\\t\\t9021\\t1\\n27\\t   TABLE ACCESS FULL MRTRECORDREGRESSES\\t1\\t1\\t39\\t9021\\t1\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE mrtopration_seq; CREATE TABLE mrtopration (ID NUMBER PRIMARY KEY, PRAMARYID NUMBER, OPERCODE VARCHAR2(50), OPERNAME VARCHAR2(100), OPERDEPT VARCHAR2(100), OPERDATE DATE NOT NULL, MARK VARCHAR2(500), MARK2 VARCHAR2(500), MARK3 VARCHAR2(500), MARK4 VARCHAR2(500), OPERTYPE VARCHAR2(50), NEXTOPERTYPE VARCHAR2(50), PREOPERTYPE VARCHAR2(50), VALID NUMBER(1), CONFIRMUSER VARCHAR2(100), CONFIRMDEPT VARCHAR2(100), VERSIONNUMBER NUMBER); CREATE OR REPLACE TRIGGER mrtopration_bi BEFORE INSERT ON mrtopration FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtopration_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\nCREATE INDEX idx_mrtopration_operdate ON mrtopration(OPERDATE);\nCREATE INDEX idx_mrtopration_opercode ON mrtopration(OPERCODE);\nCREATE SEQUENCE mrtrecordinfo_seq; CREATE TABLE mrtrecordinfo (ID NUMBER PRIMARY KEY, IN_TIMES NUMBER, NAME VARCHAR2(100), IN_DATE DATE, OUT_DATE DATE, OUT_DEPT VARCHAR2(100), RECORD_STATE VARCHAR2(50)); CREATE OR REPLACE TRIGGER mrtrecordinfo_bi BEFORE INSERT ON mrtrecordinfo FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtrecordinfo_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\nCREATE INDEX idx_mrtrecordinfo_indate ON mrtrecordinfo(IN_DATE);\nCREATE TABLE mrtrecordregresses (RECODE_NO NUMBER NOT NULL, OPER_DATE DATE NOT NULL, OPERID VARCHAR2(50) NOT NULL, BACKREASON VARCHAR2(500), CONSTRAINT pk_mrtrecordregresses PRIMARY KEY (RECODE_NO, OPER_DATE, OPERID));\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t3725\t10\t1950\t907708019\t3700\n1\t  SORT ORDER BY \t3725\t10\t1950\t907708019\t3700\n2\t  HASH JOIN OUTER \t3724\t10\t1950\t870837954\t3700\n3\t   NESTED LOOPS OUTER \t3724\t10\t1950\t870837954\t3700\n4\t  STATISTICS COLLECTOR  \t\t\t\t\t\n5\t  HASH JOIN OUTER \t3714\t10\t1560\t870747739\t3690\n6\t   NESTED LOOPS OUTER \t3714\t10\t1560\t870747739\t3690\n7\t  STATISTICS COLLECTOR  \t\t\t\t\t\n8\t  HASH JOIN  \t3694\t10\t1110\t870583611\t3670\n9\t   NESTED LOOPS  \t3694\t10\t1110\t870583611\t3670\n10\t  STATISTICS COLLECTOR  \t\t\t\t\t\n11\t  VIEW  VW_NSO_1\t3673\t10\t40\t833547416\t3650\n12\t   HASH UNIQUE \t\t10\t150\t\t\n13\t  VIEW  \t3673\t10\t150\t833547416\t3650\n14\t  WINDOW NOSORT STOPKEY \t3673\t50000\t750000\t833547416\t3650\n15\t   SORT GROUP BY \t3673\t50000\t750000\t833547416\t3650\n16\t  HASH JOIN SEMI \t3413\t50000\t750000\t757426652\t3392\n17\t  TABLE ACCESS FULL MRTRECORDINFO\t2081\t50000\t550000\t407379316\t2070\n18\t  INDEX FAST FULL SCAN SYS_C008302\t514\t1000000\t4000000\t133352700\t510\n19\t  TABLE ACCESS BY INDEX ROWID MRTOPRATION\t2\t1\t107\t16613\t2\n20\t  INDEX UNIQUE SCAN SYS_C008302\t1\t1\t\t9021\t1\n21\t   TABLE ACCESS FULL MRTOPRATION\t2\t1\t107\t16613\t2\n22\t  TABLE ACCESS BY INDEX ROWID MRTRECORDINFO\t2\t1\t45\t16413\t2\n23\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n24\t   TABLE ACCESS FULL MRTRECORDINFO\t2\t1\t45\t16413\t2\n25\t  TABLE ACCESS BY INDEX ROWID MRTRECORDREGRESSES\t1\t1\t39\t9021\t1\n26\t  INDEX UNIQUE SCAN PK_MRTRECORDREGRESSES\t1\t1\t\t9021\t1\n27\t   TABLE ACCESS FULL MRTRECORDREGRESSES\t1\t1\t39\t9021\t1\n\n## Original SQL:\nSELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID WHERE A.ID IN (SELECT bid FROM (SELECT B.ID AS bid, B.IN_DATE AS inDate, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID WHERE B.ID LIKE :\"SYS_B_0\" || :1 || :\" SYS_B_1\" GROUP BY B.ID, B.IN_DATE) WHERE rn BETWEEN :2 + :\"SYS_B_2\" AND :3 + :4 ) ORDER BY A.OPERDATE DESC\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID WHERE A.ID IN (SELECT B.ID FROM (SELECT B.ID, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn FROM mrtrecordinfo B WHERE B.ID LIKE :\"SYS_B_0\" || :1 || :\" SYS_B_1\") WHERE rn BETWEEN :2 + :\"SYS_B_2\" AND :3 + :4) ORDER BY A.OPERDATE DESC"
                    }
                ]
            },
            {
                "case_id": "24",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"24\", \"db_type\": \"oracle\", \"description\": \"这是一种经典的UNION ALL消除优化技术。当UNION ALL的多个分支查询相同的表，且仅在SELECT列表的计算逻辑或WHERE条件的常量值上有差异时，可以通过CASE表达式将不同的计算逻辑统一到一个SELECT语句中。改写的核心是将'metric_name IN (集合1) 返回round(VALUE,2)'和'metric_name IN (集合2) 返回round(VALUE*10,2)'两个分支，合并为'metric_name IN (集合1+集合2) 返回CASE WHEN...END'。这样WHERE条件从两次分别过滤变为一次过滤更大的集合，SELECT列表使用CASE根据metric_name动态选择计算方式。这种改写在保证逻辑等价的前提下，显著减少了I/O操作。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE SEQUENCE gv_session_seq; CREATE TABLE gv$session (session_id NUMBER PRIMARY KEY, inst_id NUMBER NOT NULL, TYPE VARCHAR2(20) NOT NULL, status VARCHAR2(20)); CREATE OR REPLACE TRIGGER gv_session_bi BEFORE INSERT ON gv$session FOR EACH ROW BEGIN IF :NEW.session_id IS NULL THEN SELECT gv_session_seq.NEXTVAL INTO :NEW.session_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_gv_session_inst_id ON gv$session(inst_id);\", \"CREATE INDEX idx_gv_session_type_status ON gv$session(TYPE, status);\", \"CREATE SEQUENCE gv_sysmetric_seq; CREATE TABLE gv$sysmetric (metric_id NUMBER PRIMARY KEY, inst_id NUMBER NOT NULL, end_time TIMESTAMP NOT NULL, metric_name VARCHAR2(100) NOT NULL, VALUE NUMBER(20,2), intsize_csec NUMBER); CREATE OR REPLACE TRIGGER gv_sysmetric_bi BEFORE INSERT ON gv$sysmetric FOR EACH ROW BEGIN IF :NEW.metric_id IS NULL THEN SELECT gv_sysmetric_seq.NEXTVAL INTO :NEW.metric_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_gv_sysmetric_inst_id ON gv$sysmetric(inst_id);\", \"CREATE INDEX idx_gv_sysmetric_intsize ON gv$sysmetric(intsize_csec);\", \"CREATE INDEX idx_gv_sysmetric_metric_name ON gv$sysmetric(metric_name);\"], \"sql\": \"SELECT\\n  c.inst_id,\\n  m.end_time AS checktime,\\n  c.conn,\\n  c.activeconn,\\n  m.sqlthroughput,\\n  m.sqlavgtime,\\n  m.user_commits,\\n  m.user_rollbacks,\\n  m.user_commits + m.user_rollbacks AS transactioncount,\\n  m.transactionavgtime\\nFROM\\n  (\\n  WITH\\n   t1 AS (\\n  SELECT\\n  inst_id,\\n  COUNT(*) conn\\n  FROM\\n  gv$session\\n  WHERE\\n  TYPE = 'USER'\\n  GROUP BY\\n  inst_id\\n   ),\\n   t2 AS (\\n  SELECT\\n  inst_id,\\n  COUNT(*) activeconn\\n  FROM\\n  gv$session\\n  WHERE\\n  TYPE = 'USER'\\n  AND status = 'ACTIVE'\\n  GROUP BY\\n  inst_id\\n   )\\n  SELECT\\n   t1.inst_id,\\n   t1.conn,\\n   t2.activeconn\\n  FROM\\n   t1,\\n   t2\\n  WHERE\\n   t1.inst_id = t2.inst_id\\n  ) c,\\n  (\\n  SELECT\\n   *\\n  FROM\\n   (\\n  SELECT\\n  inst_id,\\n  end_time,\\n  metric_name,\\n  round(VALUE, 2) VALUE\\n  FROM\\n  gv$sysmetric\\n  WHERE\\n  round(intsize_csec / 100, 0) = 60\\n  AND metric_name IN (\\n   'Executions Per Sec',\\n   'User Commits Per Sec',\\n   'User Rollbacks Per Sec'\\n  )\\n  UNION ALL\\n  SELECT\\n  inst_id,\\n  end_time,\\n  metric_name,\\n  round(VALUE * 10, 2) VALUE\\n  FROM\\n  gv$sysmetric\\n  WHERE\\n  round(intsize_csec / 100, 0) = 60\\n  AND metric_name IN (\\n   'SQL Service Response Time',\\n   'Response Time Per Txn'\\n  )\\n   ) PIVOT (\\n  AVG(VALUE) FOR metric_name IN (\\n  'Executions Per Sec' sqlthroughput,\\n  'SQL Service Response Time' sqlavgtime,\\n  'User Commits Per Sec' user_commits,\\n  'User Rollbacks Per Sec' user_rollbacks,\\n  'Response Time Per Txn' transactionavgtime\\n  )\\n   )\\n  ) m\\nWHERE\\n  c.inst_id = m.inst_id\\nORDER BY\\n  inst_id\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t6390\\t10000\\t1100000\\t2369214804\\t6326\\n1\\t  MERGE JOIN  \\t6390\\t10000\\t1100000\\t2369214804\\t6326\\n2\\t  MERGE JOIN  \\t5337\\t10000\\t950000\\t1861270817\\t5287\\n3\\t   SORT JOIN \\t4278\\t10000\\t800000\\t1093774272\\t4248\\n4\\t  VIEW  \\t4278\\t10000\\t800000\\t1093774272\\t4248\\n5\\t  HASH GROUP BY PIVOT \\t4278\\t10000\\t780000\\t1093774272\\t4248\\n6\\t   VIEW  \\t4092\\t10000\\t780000\\t1048013114\\t4064\\n7\\t  UNION-ALL  \\t\\t\\t\\t\\t\\n8\\t  TABLE ACCESS FULL GV$SYSMETRIC\\t2047\\t6000\\t246000\\t554616557\\t2032\\n9\\t  TABLE ACCESS FULL GV$SYSMETRIC\\t2045\\t4000\\t164000\\t493396557\\t2032\\n10\\t   SORT JOIN \\t1060\\t4\\t60\\t767496545\\t1039\\n11\\t  VIEW  \\t1059\\t4\\t60\\t730627615\\t1039\\n12\\t  HASH GROUP BY \\t1059\\t4\\t32\\t730627615\\t1039\\n13\\t   TABLE ACCESS FULL GV$SESSION\\t1046\\t500000\\t4000000\\t267282237\\t1039\\n14\\t  SORT JOIN \\t1053\\t4\\t60\\t507943987\\t1039\\n15\\t   VIEW  \\t1052\\t4\\t60\\t471075058\\t1039\\n16\\t  HASH GROUP BY \\t1052\\t4\\t60\\t471075058\\t1039\\n17\\t  TABLE ACCESS FULL GV$SESSION\\t1047\\t166667\\t2500005\\t303948903\\t1039\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE gv_session_seq; CREATE TABLE gv$session (session_id NUMBER PRIMARY KEY, inst_id NUMBER NOT NULL, TYPE VARCHAR2(20) NOT NULL, status VARCHAR2(20)); CREATE OR REPLACE TRIGGER gv_session_bi BEFORE INSERT ON gv$session FOR EACH ROW BEGIN IF :NEW.session_id IS NULL THEN SELECT gv_session_seq.NEXTVAL INTO :NEW.session_id FROM DUAL; END IF; END;\nCREATE INDEX idx_gv_session_inst_id ON gv$session(inst_id);\nCREATE INDEX idx_gv_session_type_status ON gv$session(TYPE, status);\nCREATE SEQUENCE gv_sysmetric_seq; CREATE TABLE gv$sysmetric (metric_id NUMBER PRIMARY KEY, inst_id NUMBER NOT NULL, end_time TIMESTAMP NOT NULL, metric_name VARCHAR2(100) NOT NULL, VALUE NUMBER(20,2), intsize_csec NUMBER); CREATE OR REPLACE TRIGGER gv_sysmetric_bi BEFORE INSERT ON gv$sysmetric FOR EACH ROW BEGIN IF :NEW.metric_id IS NULL THEN SELECT gv_sysmetric_seq.NEXTVAL INTO :NEW.metric_id FROM DUAL; END IF; END;\nCREATE INDEX idx_gv_sysmetric_inst_id ON gv$sysmetric(inst_id);\nCREATE INDEX idx_gv_sysmetric_intsize ON gv$sysmetric(intsize_csec);\nCREATE INDEX idx_gv_sysmetric_metric_name ON gv$sysmetric(metric_name);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t6390\t10000\t1100000\t2369214804\t6326\n1\t  MERGE JOIN  \t6390\t10000\t1100000\t2369214804\t6326\n2\t  MERGE JOIN  \t5337\t10000\t950000\t1861270817\t5287\n3\t   SORT JOIN \t4278\t10000\t800000\t1093774272\t4248\n4\t  VIEW  \t4278\t10000\t800000\t1093774272\t4248\n5\t  HASH GROUP BY PIVOT \t4278\t10000\t780000\t1093774272\t4248\n6\t   VIEW  \t4092\t10000\t780000\t1048013114\t4064\n7\t  UNION-ALL  \t\t\t\t\t\n8\t  TABLE ACCESS FULL GV$SYSMETRIC\t2047\t6000\t246000\t554616557\t2032\n9\t  TABLE ACCESS FULL GV$SYSMETRIC\t2045\t4000\t164000\t493396557\t2032\n10\t   SORT JOIN \t1060\t4\t60\t767496545\t1039\n11\t  VIEW  \t1059\t4\t60\t730627615\t1039\n12\t  HASH GROUP BY \t1059\t4\t32\t730627615\t1039\n13\t   TABLE ACCESS FULL GV$SESSION\t1046\t500000\t4000000\t267282237\t1039\n14\t  SORT JOIN \t1053\t4\t60\t507943987\t1039\n15\t   VIEW  \t1052\t4\t60\t471075058\t1039\n16\t  HASH GROUP BY \t1052\t4\t60\t471075058\t1039\n17\t  TABLE ACCESS FULL GV$SESSION\t1047\t166667\t2500005\t303948903\t1039\n\n## Original SQL:\nSELECT\n  c.inst_id,\n  m.end_time AS checktime,\n  c.conn,\n  c.activeconn,\n  m.sqlthroughput,\n  m.sqlavgtime,\n  m.user_commits,\n  m.user_rollbacks,\n  m.user_commits + m.user_rollbacks AS transactioncount,\n  m.transactionavgtime\nFROM\n  (\n  WITH\n   t1 AS (\n  SELECT\n  inst_id,\n  COUNT(*) conn\n  FROM\n  gv$session\n  WHERE\n  TYPE = 'USER'\n  GROUP BY\n  inst_id\n   ),\n   t2 AS (\n  SELECT\n  inst_id,\n  COUNT(*) activeconn\n  FROM\n  gv$session\n  WHERE\n  TYPE = 'USER'\n  AND status = 'ACTIVE'\n  GROUP BY\n  inst_id\n   )\n  SELECT\n   t1.inst_id,\n   t1.conn,\n   t2.activeconn\n  FROM\n   t1,\n   t2\n  WHERE\n   t1.inst_id = t2.inst_id\n  ) c,\n  (\n  SELECT\n   *\n  FROM\n   (\n  SELECT\n  inst_id,\n  end_time,\n  metric_name,\n  round(VALUE, 2) VALUE\n  FROM\n  gv$sysmetric\n  WHERE\n  round(intsize_csec / 100, 0) = 60\n  AND metric_name IN (\n   'Executions Per Sec',\n   'User Commits Per Sec',\n   'User Rollbacks Per Sec'\n  )\n  UNION ALL\n  SELECT\n  inst_id,\n  end_time,\n  metric_name,\n  round(VALUE * 10, 2) VALUE\n  FROM\n  gv$sysmetric\n  WHERE\n  round(intsize_csec / 100, 0) = 60\n  AND metric_name IN (\n   'SQL Service Response Time',\n   'Response Time Per Txn'\n  )\n   ) PIVOT (\n  AVG(VALUE) FOR metric_name IN (\n  'Executions Per Sec' sqlthroughput,\n  'SQL Service Response Time' sqlavgtime,\n  'User Commits Per Sec' user_commits,\n  'User Rollbacks Per Sec' user_rollbacks,\n  'Response Time Per Txn' transactionavgtime\n  )\n   )\n  ) m\nWHERE\n  c.inst_id = m.inst_id\nORDER BY\n  inst_id\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT c.inst_id, m.end_time AS checktime, c.conn, c.activeconn, m.sqlthroughput, m.sqlavgtime, m.user_commits, m.user_rollbacks, m.user_commits + m.user_rollbacks AS transactioncount, m.transactionavgtime FROM (SELECT inst_id, SUM(CASE WHEN TYPE = 'USER' THEN 1 ELSE 0 END) conn, SUM(CASE WHEN TYPE = 'USER' AND status = 'ACTIVE' THEN 1 ELSE 0 END) activeconn FROM gv$session WHERE TYPE = 'USER' GROUP BY inst_id) c INNER JOIN (SELECT * FROM (SELECT inst_id, end_time, metric_name, CASE WHEN metric_name IN ('Executions Per Sec', 'User Commits Per Sec', 'User Rollbacks Per Sec') THEN round(VALUE, 2) ELSE round(VALUE * 10, 2) END VALUE FROM gv$sysmetric WHERE intsize_csec >= 5950 AND intsize_csec <= 6049 AND metric_name IN ('Executions Per Sec', 'User Commits Per Sec', 'User Rollbacks Per Sec', 'SQL Service Response Time', 'Response Time Per Txn')) PIVOT (AVG(VALUE) FOR metric_name IN ('Executions Per Sec' sqlthroughput, 'SQL Service Response Time' sqlavgtime, 'User Commits Per Sec' user_commits, 'User Rollbacks Per Sec' user_rollbacks, 'Response Time Per Txn' transactionavgtime))) m ON c.inst_id = m.inst_id ORDER BY inst_id"
                    }
                ]
            },
            {
                "case_id": "25",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"25\", \"db_type\": \"mysql\", \"description\": \"在LEFT JOIN场景中，当WHERE子句包含对右表（被LEFT JOIN的表）的条件时，这些条件实际上会将LEFT JOIN转化为INNER JOIN的效果（因为NULL行会被WHERE过滤掉）。但如果将这些条件移到ON子句中，就能：1）保持真正的LEFT JOIN语义；2）在连接阶段就减少需要处理的数据；3）让优化器有更多优化空间。本次改写正是基于这一原理，将对表B的tenant_id和bo_name过滤从WHERE移到ON子句。同时清理了冗余的'A.tenant_id = 1065587309019136'重复条件（改写前WHERE子句中出现了多次）\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE acctg_trans_detail (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, gl_account_id BIGINT NOT NULL, master_voucher_id BIGINT, base_posted_dr DECIMAL(20,2) DEFAULT 0, base_posted_cr DECIMAL(20,2) DEFAULT 0, voucher_status_enum VARCHAR(50), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_tenant_id ON acctg_trans_detail(tenant_id);\", \"CREATE INDEX idx_master_voucher_id ON acctg_trans_detail(master_voucher_id);\", \"CREATE INDEX idx_tenant_gl_account ON acctg_trans_detail(tenant_id, gl_account_id);\", \"CREATE INDEX idx_voucher_status ON acctg_trans_detail(voucher_status_enum);\", \"CREATE TABLE acctg_trans (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, acctg_period VARCHAR(20), bo_name VARCHAR(100), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_tenant_id ON acctg_trans(tenant_id);\", \"CREATE INDEX idx_tenant_id_acctg_period ON acctg_trans(tenant_id, id, acctg_period);\", \"CREATE INDEX idx_bo_name ON acctg_trans(bo_name);\", \"CREATE TABLE gl_account_balance (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, gl_account_id BIGINT NOT NULL, acctg_period VARCHAR(20) NOT NULL, base_posted_dr DECIMAL(20,2) DEFAULT 0, base_posted_cr DECIMAL(20,2) DEFAULT 0, created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_tenant_id ON gl_account_balance(tenant_id);\", \"CREATE INDEX idx_gl_account_period ON gl_account_balance(gl_account_id, acctg_period, tenant_id);\", \"CREATE INDEX idx_acctg_period ON gl_account_balance(acctg_period);\", \"CREATE TABLE gl_account (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, code VARCHAR(50) NOT NULL, name VARCHAR(200), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_tenant_id ON gl_account(tenant_id);\", \"CREATE INDEX idx_tenant_code ON gl_account(tenant_id, code);\"], \"sql\": \"SELECT acctg.tenant_id, acctg.gl_account_id, ac.code, acctg.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg LEFT JOIN gl_account_balance A ON (A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id) AND A.tenant_id = 1065587309019136 LEFT JOIN gl_account ac ON (ac.id = acctg.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (acctg.base_posted_dr1 != ifnull(A.base_posted_dr, 0) OR acctg.base_posted_cr1 != ifnull(A.base_posted_cr, 0)) UNION SELECT A.tenant_id, A.gl_account_id, ac.code, A.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM gl_account_balance A LEFT JOIN (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id LEFT JOIN gl_account ac ON (ac.id = A.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND A.acctg_period NOT LIKE '%00' AND (A.base_posted_dr != ifnull(acctg.base_posted_dr1, 0) OR A.base_posted_cr != ifnull(acctg.base_posted_cr1, 0))) AND A.tenant_id = 1065587309019136 LIMIT 50001;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t13821\\t100.0\\t\\n1\\tPRIMARY\\tA\\t\\tref\\tidx_tenant_id,idx_gl_account_period,idx_acctg_period\\tidx_gl_account_period\\t98\\tacctg.gl_account_id,acctg.acctg_period,const\\t70\\t100.0\\tUsing where\\n1\\tPRIMARY\\tac\\t\\teq_ref\\tPRIMARY,idx_tenant_id,idx_tenant_code\\tPRIMARY\\t8\\tacctg.gl_account_id\\t1\\t100.0\\tUsing where\\n2\\tDERIVED\\tA\\t\\tref\\tidx_tenant_id,idx_tenant_gl_account,idx_voucher_status\\tidx_tenant_id\\t8\\tconst\\t497420\\t55.57\\tUsing where; Using temporary\\n2\\tDERIVED\\tB\\t\\teq_ref\\tPRIMARY,idx_tenant_id,idx_tenant_id_acctg_period\\tPRIMARY\\t8\\ttest_db.A.master_voucher_id\\t1\\t5.0\\tUsing where\\n3\\tUNION\\tA\\t\\tref\\tidx_tenant_id\\tidx_tenant_id\\t8\\tconst\\t497472\\t88.89\\tUsing where\\n3\\tUNION\\t<derived4>\\t\\tref\\t<auto_key0>\\t<auto_key0>\\t99\\tconst,test_db.A.gl_account_id,test_db.A.acctg_period\\t10\\t100.0\\tUsing where\\n3\\tUNION\\tac\\t\\teq_ref\\tPRIMARY,idx_tenant_id,idx_tenant_code\\tPRIMARY\\t8\\ttest_db.A.gl_account_id\\t1\\t100.0\\tUsing where\\n4\\tDERIVED\\tA\\t\\tref\\tidx_tenant_id,idx_tenant_gl_account,idx_voucher_status\\tidx_tenant_id\\t8\\tconst\\t497420\\t55.57\\tUsing where; Using temporary\\n4\\tDERIVED\\tB\\t\\teq_ref\\tPRIMARY,idx_tenant_id,idx_tenant_id_acctg_period\\tPRIMARY\\t8\\ttest_db.A.master_voucher_id\\t1\\t5.0\\tUsing where\\n5\\tUNION RESULT\\t<union1,3>\\t\\tALL\\t\\t\\t\\t\\t\\t\\tUsing temporary\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"union_result\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"select_id\\\": 5,\\n   \\\"table_name\\\": \\\"<union1,3>\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"query_specifications\\\": [\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n   \\\"select_id\\\": 1,\\n   \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"869134.39\\\"\\n   },\\n   \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"acctg\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"rows_examined_per_scan\\\": 13821,\\n   \\\"rows_produced_per_join\\\": 13821,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"175.26\\\",\\n  \\\"eval_cost\\\": \\\"1382.10\\\",\\n  \\\"prefix_cost\\\": \\\"1557.36\\\",\\n  \\\"data_read_per_join\\\": \\\"1M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"base_posted_dr1\\\",\\n  \\\"base_posted_cr1\\\"\\n   ],\\n   \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"364233.56\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"using_filesort\\\": false,\\n   \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"A\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_gl_account\\\",\\n  \\\"idx_voucher_status\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_tenant_id\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"tenant_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 497420,\\n   \\\"rows_produced_per_join\\\": 276421,\\n   \\\"filtered\\\": \\\"55.57\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"12601.85\\\",\\n  \\\"eval_cost\\\": \\\"27642.10\\\",\\n  \\\"prefix_cost\\\": \\\"62343.85\\\",\\n  \\\"data_read_per_join\\\": \\\"69M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"master_voucher_id\\\",\\n  \\\"base_posted_dr\\\",\\n  \\\"base_posted_cr\\\",\\n  \\\"voucher_status_enum\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`A`.`voucher_status_enum` is null) or (`test_db`.`A`.`voucher_status_enum` <> 'CANCELLED'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"B\\\",\\n   \\\"access_type\\\": \\\"eq_ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_id_acctg_period\\\"\\n   ],\\n   \\\"key\\\": \\\"PRIMARY\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"test_db.A.master_voucher_id\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 1,\\n   \\\"rows_produced_per_join\\\": 13821,\\n   \\\"filtered\\\": \\\"5.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"274247.61\\\",\\n  \\\"eval_cost\\\": \\\"1382.11\\\",\\n  \\\"prefix_cost\\\": \\\"364233.56\\\",\\n  \\\"data_read_per_join\\\": \\\"6M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"bo_name\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(<if>(found_match(B), ((`test_db`.`B`.`bo_name` is null) or (`test_db`.`B`.`bo_name` <> 'DraftAcctgTrans')), true) and <if>(is_not_null_compl(B), (`test_db`.`B`.`tenant_id` = 1065587309019136), true))\\\"\\n  }\\n  }\\n   ]\\n  }\\n  }\\n   }\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"A\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_gl_account_period\\\",\\n  \\\"idx_acctg_period\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_gl_account_period\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"tenant_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"98\\\",\\n   \\\"ref\\\": [\\n  \\\"acctg.gl_account_id\\\",\\n  \\\"acctg.acctg_period\\\",\\n  \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 70,\\n   \\\"rows_produced_per_join\\\": 980681,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"658345.61\\\",\\n  \\\"eval_cost\\\": \\\"98068.18\\\",\\n  \\\"prefix_cost\\\": \\\"757971.16\\\",\\n  \\\"data_read_per_join\\\": \\\"127M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"base_posted_dr\\\",\\n  \\\"base_posted_cr\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(<if>(found_match(A), ((`acctg`.`base_posted_dr1` <> ifnull(`test_db`.`A`.`base_posted_dr`,0)) or (`acctg`.`base_posted_cr1` <> ifnull(`test_db`.`A`.`base_posted_cr`,0))), true) and <if>(is_not_null_compl(A), (`acctg`.`tenant_id` = 1065587309019136), true))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"ac\\\",\\n   \\\"access_type\\\": \\\"eq_ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_code\\\"\\n   ],\\n   \\\"key\\\": \\\"PRIMARY\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"acctg.gl_account_id\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 1,\\n   \\\"rows_produced_per_join\\\": 980681,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"13095.05\\\",\\n  \\\"eval_cost\\\": \\\"98068.18\\\",\\n  \\\"prefix_cost\\\": \\\"869134.39\\\",\\n  \\\"data_read_per_join\\\": \\\"965M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"code\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"<if>(is_not_null_compl(ac), (`test_db`.`ac`.`tenant_id` = 1065587309019136), true)\\\"\\n  }\\n  }\\n   ]\\n  }\\n  },\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n   \\\"select_id\\\": 3,\\n   \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"2469300.89\\\"\\n   },\\n   \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"A\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"idx_tenant_id\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_tenant_id\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"tenant_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 497472,\\n   \\\"rows_produced_per_join\\\": 442202,\\n   \\\"filtered\\\": \\\"88.89\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"10520.84\\\",\\n  \\\"eval_cost\\\": \\\"44220.29\\\",\\n  \\\"prefix_cost\\\": \\\"60268.04\\\",\\n  \\\"data_read_per_join\\\": \\\"57M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"base_posted_dr\\\",\\n  \\\"base_posted_cr\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(not((`test_db`.`A`.`acctg_period` like '%00')))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"acctg\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"<auto_key0>\\\"\\n   ],\\n   \\\"key\\\": \\\"<auto_key0>\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\"\\n   ],\\n   \\\"key_length\\\": \\\"99\\\",\\n   \\\"ref\\\": [\\n  \\\"const\\\",\\n  \\\"test_db.A.gl_account_id\\\",\\n  \\\"test_db.A.acctg_period\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 10,\\n   \\\"rows_produced_per_join\\\": 4422348,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1105587.12\\\",\\n  \\\"eval_cost\\\": \\\"442234.85\\\",\\n  \\\"prefix_cost\\\": \\\"1608090.01\\\",\\n  \\\"data_read_per_join\\\": \\\"607M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"base_posted_dr1\\\",\\n  \\\"base_posted_cr1\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"<if>(found_match(acctg), ((`test_db`.`A`.`base_posted_dr` <> ifnull(`acctg`.`base_posted_dr1`,0)) or (`test_db`.`A`.`base_posted_cr` <> ifnull(`acctg`.`base_posted_cr1`,0))), true)\\\",\\n   \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 4,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"364233.56\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"using_filesort\\\": false,\\n   \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"A\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_gl_account\\\",\\n  \\\"idx_voucher_status\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_tenant_id\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"tenant_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 497420,\\n   \\\"rows_produced_per_join\\\": 276421,\\n   \\\"filtered\\\": \\\"55.57\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"12601.85\\\",\\n  \\\"eval_cost\\\": \\\"27642.10\\\",\\n  \\\"prefix_cost\\\": \\\"62343.85\\\",\\n  \\\"data_read_per_join\\\": \\\"69M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"master_voucher_id\\\",\\n  \\\"base_posted_dr\\\",\\n  \\\"base_posted_cr\\\",\\n  \\\"voucher_status_enum\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`A`.`voucher_status_enum` is null) or (`test_db`.`A`.`voucher_status_enum` <> 'CANCELLED'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"B\\\",\\n   \\\"access_type\\\": \\\"eq_ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_id_acctg_period\\\"\\n   ],\\n   \\\"key\\\": \\\"PRIMARY\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"test_db.A.master_voucher_id\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 1,\\n   \\\"rows_produced_per_join\\\": 13821,\\n   \\\"filtered\\\": \\\"5.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"274247.61\\\",\\n  \\\"eval_cost\\\": \\\"1382.11\\\",\\n  \\\"prefix_cost\\\": \\\"364233.56\\\",\\n  \\\"data_read_per_join\\\": \\\"6M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"bo_name\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(<if>(found_match(B), ((`test_db`.`B`.`bo_name` is null) or (`test_db`.`B`.`bo_name` <> 'DraftAcctgTrans')), true) and <if>(is_not_null_compl(B), (`test_db`.`B`.`tenant_id` = 1065587309019136), true))\\\"\\n  }\\n  }\\n   ]\\n  }\\n  }\\n   }\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"ac\\\",\\n   \\\"access_type\\\": \\\"eq_ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_code\\\"\\n   ],\\n   \\\"key\\\": \\\"PRIMARY\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"test_db.A.gl_account_id\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 1,\\n   \\\"rows_produced_per_join\\\": 4422348,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"418976.04\\\",\\n  \\\"eval_cost\\\": \\\"442234.85\\\",\\n  \\\"prefix_cost\\\": \\\"2469300.89\\\",\\n  \\\"data_read_per_join\\\": \\\"4G\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"code\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"<if>(is_not_null_compl(ac), (`test_db`.`ac`.`tenant_id` = 1065587309019136), true)\\\"\\n  }\\n  }\\n   ]\\n  }\\n  }\\n   ]\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE acctg_trans_detail (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, gl_account_id BIGINT NOT NULL, master_voucher_id BIGINT, base_posted_dr DECIMAL(20,2) DEFAULT 0, base_posted_cr DECIMAL(20,2) DEFAULT 0, voucher_status_enum VARCHAR(50), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_tenant_id ON acctg_trans_detail(tenant_id);\nCREATE INDEX idx_master_voucher_id ON acctg_trans_detail(master_voucher_id);\nCREATE INDEX idx_tenant_gl_account ON acctg_trans_detail(tenant_id, gl_account_id);\nCREATE INDEX idx_voucher_status ON acctg_trans_detail(voucher_status_enum);\nCREATE TABLE acctg_trans (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, acctg_period VARCHAR(20), bo_name VARCHAR(100), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_tenant_id ON acctg_trans(tenant_id);\nCREATE INDEX idx_tenant_id_acctg_period ON acctg_trans(tenant_id, id, acctg_period);\nCREATE INDEX idx_bo_name ON acctg_trans(bo_name);\nCREATE TABLE gl_account_balance (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, gl_account_id BIGINT NOT NULL, acctg_period VARCHAR(20) NOT NULL, base_posted_dr DECIMAL(20,2) DEFAULT 0, base_posted_cr DECIMAL(20,2) DEFAULT 0, created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_tenant_id ON gl_account_balance(tenant_id);\nCREATE INDEX idx_gl_account_period ON gl_account_balance(gl_account_id, acctg_period, tenant_id);\nCREATE INDEX idx_acctg_period ON gl_account_balance(acctg_period);\nCREATE TABLE gl_account (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, code VARCHAR(50) NOT NULL, name VARCHAR(200), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_tenant_id ON gl_account(tenant_id);\nCREATE INDEX idx_tenant_code ON gl_account(tenant_id, code);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t13821\t100.0\t\n1\tPRIMARY\tA\t\tref\tidx_tenant_id,idx_gl_account_period,idx_acctg_period\tidx_gl_account_period\t98\tacctg.gl_account_id,acctg.acctg_period,const\t70\t100.0\tUsing where\n1\tPRIMARY\tac\t\teq_ref\tPRIMARY,idx_tenant_id,idx_tenant_code\tPRIMARY\t8\tacctg.gl_account_id\t1\t100.0\tUsing where\n2\tDERIVED\tA\t\tref\tidx_tenant_id,idx_tenant_gl_account,idx_voucher_status\tidx_tenant_id\t8\tconst\t497420\t55.57\tUsing where; Using temporary\n2\tDERIVED\tB\t\teq_ref\tPRIMARY,idx_tenant_id,idx_tenant_id_acctg_period\tPRIMARY\t8\ttest_db.A.master_voucher_id\t1\t5.0\tUsing where\n3\tUNION\tA\t\tref\tidx_tenant_id\tidx_tenant_id\t8\tconst\t497472\t88.89\tUsing where\n3\tUNION\t<derived4>\t\tref\t<auto_key0>\t<auto_key0>\t99\tconst,test_db.A.gl_account_id,test_db.A.acctg_period\t10\t100.0\tUsing where\n3\tUNION\tac\t\teq_ref\tPRIMARY,idx_tenant_id,idx_tenant_code\tPRIMARY\t8\ttest_db.A.gl_account_id\t1\t100.0\tUsing where\n4\tDERIVED\tA\t\tref\tidx_tenant_id,idx_tenant_gl_account,idx_voucher_status\tidx_tenant_id\t8\tconst\t497420\t55.57\tUsing where; Using temporary\n4\tDERIVED\tB\t\teq_ref\tPRIMARY,idx_tenant_id,idx_tenant_id_acctg_period\tPRIMARY\t8\ttest_db.A.master_voucher_id\t1\t5.0\tUsing where\n5\tUNION RESULT\t<union1,3>\t\tALL\t\t\t\t\t\t\tUsing temporary\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"union_result\": {\n   \"using_temporary_table\": true,\n   \"select_id\": 5,\n   \"table_name\": \"<union1,3>\",\n   \"access_type\": \"ALL\",\n   \"query_specifications\": [\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n   \"select_id\": 1,\n   \"cost_info\": {\n  \"query_cost\": \"869134.39\"\n   },\n   \"nested_loop\": [\n  {\n  \"table\": {\n   \"table_name\": \"acctg\",\n   \"access_type\": \"ALL\",\n   \"rows_examined_per_scan\": 13821,\n   \"rows_produced_per_join\": 13821,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"175.26\",\n  \"eval_cost\": \"1382.10\",\n  \"prefix_cost\": \"1557.36\",\n  \"data_read_per_join\": \"1M\"\n   },\n   \"used_columns\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"base_posted_dr1\",\n  \"base_posted_cr1\"\n   ],\n   \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n   \"query_cost\": \"364233.56\"\n  },\n  \"grouping_operation\": {\n   \"using_temporary_table\": true,\n   \"using_filesort\": false,\n   \"nested_loop\": [\n  {\n  \"table\": {\n   \"table_name\": \"A\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"idx_tenant_id\",\n  \"idx_tenant_gl_account\",\n  \"idx_voucher_status\"\n   ],\n   \"key\": \"idx_tenant_id\",\n   \"used_key_parts\": [\n  \"tenant_id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"const\"\n   ],\n   \"rows_examined_per_scan\": 497420,\n   \"rows_produced_per_join\": 276421,\n   \"filtered\": \"55.57\",\n   \"cost_info\": {\n  \"read_cost\": \"12601.85\",\n  \"eval_cost\": \"27642.10\",\n  \"prefix_cost\": \"62343.85\",\n  \"data_read_per_join\": \"69M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"master_voucher_id\",\n  \"base_posted_dr\",\n  \"base_posted_cr\",\n  \"voucher_status_enum\"\n   ],\n   \"attached_condition\": \"((`test_db`.`A`.`voucher_status_enum` is null) or (`test_db`.`A`.`voucher_status_enum` <> 'CANCELLED'))\"\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"B\",\n   \"access_type\": \"eq_ref\",\n   \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_tenant_id\",\n  \"idx_tenant_id_acctg_period\"\n   ],\n   \"key\": \"PRIMARY\",\n   \"used_key_parts\": [\n  \"id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"test_db.A.master_voucher_id\"\n   ],\n   \"rows_examined_per_scan\": 1,\n   \"rows_produced_per_join\": 13821,\n   \"filtered\": \"5.00\",\n   \"cost_info\": {\n  \"read_cost\": \"274247.61\",\n  \"eval_cost\": \"1382.11\",\n  \"prefix_cost\": \"364233.56\",\n  \"data_read_per_join\": \"6M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"acctg_period\",\n  \"bo_name\"\n   ],\n   \"attached_condition\": \"(<if>(found_match(B), ((`test_db`.`B`.`bo_name` is null) or (`test_db`.`B`.`bo_name` <> 'DraftAcctgTrans')), true) and <if>(is_not_null_compl(B), (`test_db`.`B`.`tenant_id` = 1065587309019136), true))\"\n  }\n  }\n   ]\n  }\n  }\n   }\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"A\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"idx_tenant_id\",\n  \"idx_gl_account_period\",\n  \"idx_acctg_period\"\n   ],\n   \"key\": \"idx_gl_account_period\",\n   \"used_key_parts\": [\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"tenant_id\"\n   ],\n   \"key_length\": \"98\",\n   \"ref\": [\n  \"acctg.gl_account_id\",\n  \"acctg.acctg_period\",\n  \"const\"\n   ],\n   \"rows_examined_per_scan\": 70,\n   \"rows_produced_per_join\": 980681,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"658345.61\",\n  \"eval_cost\": \"98068.18\",\n  \"prefix_cost\": \"757971.16\",\n  \"data_read_per_join\": \"127M\"\n   },\n   \"used_columns\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"base_posted_dr\",\n  \"base_posted_cr\"\n   ],\n   \"attached_condition\": \"(<if>(found_match(A), ((`acctg`.`base_posted_dr1` <> ifnull(`test_db`.`A`.`base_posted_dr`,0)) or (`acctg`.`base_posted_cr1` <> ifnull(`test_db`.`A`.`base_posted_cr`,0))), true) and <if>(is_not_null_compl(A), (`acctg`.`tenant_id` = 1065587309019136), true))\"\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"ac\",\n   \"access_type\": \"eq_ref\",\n   \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_tenant_id\",\n  \"idx_tenant_code\"\n   ],\n   \"key\": \"PRIMARY\",\n   \"used_key_parts\": [\n  \"id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"acctg.gl_account_id\"\n   ],\n   \"rows_examined_per_scan\": 1,\n   \"rows_produced_per_join\": 980681,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"13095.05\",\n  \"eval_cost\": \"98068.18\",\n  \"prefix_cost\": \"869134.39\",\n  \"data_read_per_join\": \"965M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"code\"\n   ],\n   \"attached_condition\": \"<if>(is_not_null_compl(ac), (`test_db`.`ac`.`tenant_id` = 1065587309019136), true)\"\n  }\n  }\n   ]\n  }\n  },\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n   \"select_id\": 3,\n   \"cost_info\": {\n  \"query_cost\": \"2469300.89\"\n   },\n   \"nested_loop\": [\n  {\n  \"table\": {\n   \"table_name\": \"A\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"idx_tenant_id\"\n   ],\n   \"key\": \"idx_tenant_id\",\n   \"used_key_parts\": [\n  \"tenant_id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"const\"\n   ],\n   \"rows_examined_per_scan\": 497472,\n   \"rows_produced_per_join\": 442202,\n   \"filtered\": \"88.89\",\n   \"cost_info\": {\n  \"read_cost\": \"10520.84\",\n  \"eval_cost\": \"44220.29\",\n  \"prefix_cost\": \"60268.04\",\n  \"data_read_per_join\": \"57M\"\n   },\n   \"used_columns\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"base_posted_dr\",\n  \"base_posted_cr\"\n   ],\n   \"attached_condition\": \"(not((`test_db`.`A`.`acctg_period` like '%00')))\"\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"acctg\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"<auto_key0>\"\n   ],\n   \"key\": \"<auto_key0>\",\n   \"used_key_parts\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\"\n   ],\n   \"key_length\": \"99\",\n   \"ref\": [\n  \"const\",\n  \"test_db.A.gl_account_id\",\n  \"test_db.A.acctg_period\"\n   ],\n   \"rows_examined_per_scan\": 10,\n   \"rows_produced_per_join\": 4422348,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"1105587.12\",\n  \"eval_cost\": \"442234.85\",\n  \"prefix_cost\": \"1608090.01\",\n  \"data_read_per_join\": \"607M\"\n   },\n   \"used_columns\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"base_posted_dr1\",\n  \"base_posted_cr1\"\n   ],\n   \"attached_condition\": \"<if>(found_match(acctg), ((`test_db`.`A`.`base_posted_dr` <> ifnull(`acctg`.`base_posted_dr1`,0)) or (`test_db`.`A`.`base_posted_cr` <> ifnull(`acctg`.`base_posted_cr1`,0))), true)\",\n   \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 4,\n  \"cost_info\": {\n   \"query_cost\": \"364233.56\"\n  },\n  \"grouping_operation\": {\n   \"using_temporary_table\": true,\n   \"using_filesort\": false,\n   \"nested_loop\": [\n  {\n  \"table\": {\n   \"table_name\": \"A\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"idx_tenant_id\",\n  \"idx_tenant_gl_account\",\n  \"idx_voucher_status\"\n   ],\n   \"key\": \"idx_tenant_id\",\n   \"used_key_parts\": [\n  \"tenant_id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"const\"\n   ],\n   \"rows_examined_per_scan\": 497420,\n   \"rows_produced_per_join\": 276421,\n   \"filtered\": \"55.57\",\n   \"cost_info\": {\n  \"read_cost\": \"12601.85\",\n  \"eval_cost\": \"27642.10\",\n  \"prefix_cost\": \"62343.85\",\n  \"data_read_per_join\": \"69M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"master_voucher_id\",\n  \"base_posted_dr\",\n  \"base_posted_cr\",\n  \"voucher_status_enum\"\n   ],\n   \"attached_condition\": \"((`test_db`.`A`.`voucher_status_enum` is null) or (`test_db`.`A`.`voucher_status_enum` <> 'CANCELLED'))\"\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"B\",\n   \"access_type\": \"eq_ref\",\n   \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_tenant_id\",\n  \"idx_tenant_id_acctg_period\"\n   ],\n   \"key\": \"PRIMARY\",\n   \"used_key_parts\": [\n  \"id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"test_db.A.master_voucher_id\"\n   ],\n   \"rows_examined_per_scan\": 1,\n   \"rows_produced_per_join\": 13821,\n   \"filtered\": \"5.00\",\n   \"cost_info\": {\n  \"read_cost\": \"274247.61\",\n  \"eval_cost\": \"1382.11\",\n  \"prefix_cost\": \"364233.56\",\n  \"data_read_per_join\": \"6M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"acctg_period\",\n  \"bo_name\"\n   ],\n   \"attached_condition\": \"(<if>(found_match(B), ((`test_db`.`B`.`bo_name` is null) or (`test_db`.`B`.`bo_name` <> 'DraftAcctgTrans')), true) and <if>(is_not_null_compl(B), (`test_db`.`B`.`tenant_id` = 1065587309019136), true))\"\n  }\n  }\n   ]\n  }\n  }\n   }\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"ac\",\n   \"access_type\": \"eq_ref\",\n   \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_tenant_id\",\n  \"idx_tenant_code\"\n   ],\n   \"key\": \"PRIMARY\",\n   \"used_key_parts\": [\n  \"id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"test_db.A.gl_account_id\"\n   ],\n   \"rows_examined_per_scan\": 1,\n   \"rows_produced_per_join\": 4422348,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"418976.04\",\n  \"eval_cost\": \"442234.85\",\n  \"prefix_cost\": \"2469300.89\",\n  \"data_read_per_join\": \"4G\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"code\"\n   ],\n   \"attached_condition\": \"<if>(is_not_null_compl(ac), (`test_db`.`ac`.`tenant_id` = 1065587309019136), true)\"\n  }\n  }\n   ]\n  }\n  }\n   ]\n  }\n  }\n}\n\n## Original SQL:\nSELECT acctg.tenant_id, acctg.gl_account_id, ac.code, acctg.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg LEFT JOIN gl_account_balance A ON (A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id) AND A.tenant_id = 1065587309019136 LEFT JOIN gl_account ac ON (ac.id = acctg.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (acctg.base_posted_dr1 != ifnull(A.base_posted_dr, 0) OR acctg.base_posted_cr1 != ifnull(A.base_posted_cr, 0)) UNION SELECT A.tenant_id, A.gl_account_id, ac.code, A.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM gl_account_balance A LEFT JOIN (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id LEFT JOIN gl_account ac ON (ac.id = A.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND A.acctg_period NOT LIKE '%00' AND (A.base_posted_dr != ifnull(acctg.base_posted_dr1, 0) OR A.base_posted_cr != ifnull(acctg.base_posted_cr1, 0))) AND A.tenant_id = 1065587309019136 LIMIT 50001;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH trans_summary AS (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, SUM(A.base_posted_dr) AS base_posted_dr1, SUM(A.base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id WHERE A.tenant_id = 1065587309019136 AND (A.voucher_status_enum IS NULL OR A.voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans') GROUP BY A.tenant_id, A.gl_account_id, B.acctg_period) SELECT acctg.tenant_id, acctg.gl_account_id, ac.code, acctg.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM trans_summary acctg LEFT JOIN gl_account_balance A ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = 1065587309019136 LEFT JOIN gl_account ac ON ac.id = acctg.gl_account_id AND ac.tenant_id = 1065587309019136 WHERE acctg.base_posted_dr1 != IFNULL(A.base_posted_dr, 0) OR acctg.base_posted_cr1 != IFNULL(A.base_posted_cr, 0) UNION ALL SELECT A.tenant_id, A.gl_account_id, ac.code, A.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM gl_account_balance A LEFT JOIN trans_summary acctg ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id LEFT JOIN gl_account ac ON ac.id = A.gl_account_id AND ac.tenant_id = 1065587309019136 WHERE A.tenant_id = 1065587309019136 AND A.acctg_period NOT LIKE '%00' AND (A.base_posted_dr != IFNULL(acctg.base_posted_dr1, 0) OR A.base_posted_cr != IFNULL(acctg.base_posted_cr1, 0)) LIMIT 50001"
                    }
                ]
            },
            {
                "case_id": "26",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"26\", \"db_type\": \"postgresql\", \"description\": \"本次改写采用了CTE常量提取模式，将时间计算逻辑（fun_addmonth、to_char等）从连接条件中提取到CTE中，理论上可以避免在循环中重复计算这些函数。同时将COALESCE改写为显式OR条件，希望优化器能更好地理解谓词逻辑。然而，这种改写忽略了LIMIT 1对执行计划的影响：在只需要返回1行的场景下，原SQL的\\\"惰性计算\\\"策略更优，因为常量函数只会被调用极少次数。CTE的物化成本和额外的扫描开销在这种场景下无法被节省的计算成本所抵消。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE dwd_csi_ac02 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aae140 VARCHAR(10), aac008 VARCHAR(5), aac031 VARCHAR(5), aac030 NUMERIC(8,0), aae041 NUMERIC(6,0), aae042 NUMERIC(6,0));\", \"CREATE INDEX idx_dwd_csi_ac02_aac001 ON dwd_csi_ac02(aac001);\", \"CREATE INDEX idx_dwd_csi_ac02_composite ON dwd_csi_ac02(aae140, aac008, aac031, aac030, aae041, aae042);\", \"CREATE TABLE dwd_hrss_ac99 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aac147 VARCHAR(100));\", \"CREATE INDEX idx_dwd_hrss_ac99_aac001 ON dwd_hrss_ac99(aac001);\", \"CREATE INDEX idx_dwd_hrss_ac99_aac147 ON dwd_hrss_ac99(aac147);\"], \"sql\": \"select\\n\\t'lxzdqdwjf5nys',\\n\\t'连续在当前单位参保5年以上',\\n\\tc.aac147,\\n\\t'是',\\n\\t'连续在当前单位参保5年以上'\\nfrom\\n\\tdwd_csi_ac02 a,\\n\\t(\\n\\tselect\\n\\t\\t(fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)|| '31')::numeric aac030,\\n\\t\\t fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)::numeric aae041,\\n\\t\\tto_char(current_timestamp, 'yyyymm')::numeric aae042) b,\\n\\tdwd_hrss_ac99 c\\nwhere a.aac001::varchar = c.aac001::varchar\\n\\tand a.aae140 = '110'\\n\\tand a.aac008 = '1'\\n\\tand a.aac031 = '1'\\n\\tand a.aac030 <= b.aac030\\n\\tand a.aae041 <= b.aae041\\n\\tand coalesce(a.aae042, 999912) >= b.aae042\\n\\tand c.aac147 is not null limit 1\", \"explain\": \"QUERY PLAN\\nLimit  (cost=0.42..3.47 rows=1 width=166)\\n  ->  Nested Loop  (cost=0.42..45289.49 rows=14886 width=166)\\n  ->  Nested Loop  (cost=0.00..35441.33 rows=16590 width=19)\\n  Join Filter: ((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\\n  ->  Result  (cost=0.00..0.54 rows=1 width=96)\\n  ->  Seq Scan on dwd_csi_ac02 a  (cost=0.00..27602.00 rows=447931 width=40)\\n  Filter: (((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\\n  ->  Index Scan using idx_dwd_hrss_ac99_aac001 on dwd_hrss_ac99 c  (cost=0.42..0.58 rows=1 width=57)\\n  Index Cond: ((aac001)::text = (a.aac001)::text)\\n  Filter: (aac147 IS NOT NULL)\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Limit', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 3.47, 'Plan Rows': 1, 'Plan Width': 166, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.42, 'Total Cost': 45289.49, 'Plan Rows': 14886, 'Plan Width': 166, 'Inner Unique': False, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.0, 'Total Cost': 35441.33, 'Plan Rows': 16590, 'Plan Width': 19, 'Inner Unique': False, 'Join Filter': \\\"((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\\\", 'Plans': [{'Node Type': 'Result', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.0, 'Total Cost': 0.54, 'Plan Rows': 1, 'Plan Width': 96}, {'Node Type': 'Seq Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'dwd_csi_ac02', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 27602.0, 'Plan Rows': 447931, 'Plan Width': 40, 'Filter': \\\"(((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\\\"}]}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_dwd_hrss_ac99_aac001', 'Relation Name': 'dwd_hrss_ac99', 'Alias': 'c', 'Startup Cost': 0.42, 'Total Cost': 0.58, 'Plan Rows': 1, 'Plan Width': 57, 'Index Cond': '((aac001)::text = (a.aac001)::text)', 'Filter': '(aac147 IS NOT NULL)'}]}]}}]\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE dwd_csi_ac02 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aae140 VARCHAR(10), aac008 VARCHAR(5), aac031 VARCHAR(5), aac030 NUMERIC(8,0), aae041 NUMERIC(6,0), aae042 NUMERIC(6,0));\nCREATE INDEX idx_dwd_csi_ac02_aac001 ON dwd_csi_ac02(aac001);\nCREATE INDEX idx_dwd_csi_ac02_composite ON dwd_csi_ac02(aae140, aac008, aac031, aac030, aae041, aae042);\nCREATE TABLE dwd_hrss_ac99 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aac147 VARCHAR(100));\nCREATE INDEX idx_dwd_hrss_ac99_aac001 ON dwd_hrss_ac99(aac001);\nCREATE INDEX idx_dwd_hrss_ac99_aac147 ON dwd_hrss_ac99(aac147);\n\n## Explain Output in JSON:\nQUERY PLAN\nLimit  (cost=0.42..3.47 rows=1 width=166)\n  ->  Nested Loop  (cost=0.42..45289.49 rows=14886 width=166)\n  ->  Nested Loop  (cost=0.00..35441.33 rows=16590 width=19)\n  Join Filter: ((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\n  ->  Result  (cost=0.00..0.54 rows=1 width=96)\n  ->  Seq Scan on dwd_csi_ac02 a  (cost=0.00..27602.00 rows=447931 width=40)\n  Filter: (((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\n  ->  Index Scan using idx_dwd_hrss_ac99_aac001 on dwd_hrss_ac99 c  (cost=0.42..0.58 rows=1 width=57)\n  Index Cond: ((aac001)::text = (a.aac001)::text)\n  Filter: (aac147 IS NOT NULL)\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Limit', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 3.47, 'Plan Rows': 1, 'Plan Width': 166, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.42, 'Total Cost': 45289.49, 'Plan Rows': 14886, 'Plan Width': 166, 'Inner Unique': False, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.0, 'Total Cost': 35441.33, 'Plan Rows': 16590, 'Plan Width': 19, 'Inner Unique': False, 'Join Filter': \"((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\", 'Plans': [{'Node Type': 'Result', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.0, 'Total Cost': 0.54, 'Plan Rows': 1, 'Plan Width': 96}, {'Node Type': 'Seq Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'dwd_csi_ac02', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 27602.0, 'Plan Rows': 447931, 'Plan Width': 40, 'Filter': \"(((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\"}]}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_dwd_hrss_ac99_aac001', 'Relation Name': 'dwd_hrss_ac99', 'Alias': 'c', 'Startup Cost': 0.42, 'Total Cost': 0.58, 'Plan Rows': 1, 'Plan Width': 57, 'Index Cond': '((aac001)::text = (a.aac001)::text)', 'Filter': '(aac147 IS NOT NULL)'}]}]}}]\n\n## Original SQL:\nselect\n\t'lxzdqdwjf5nys',\n\t'连续在当前单位参保5年以上',\n\tc.aac147,\n\t'是',\n\t'连续在当前单位参保5年以上'\nfrom\n\tdwd_csi_ac02 a,\n\t(\n\tselect\n\t\t(fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)|| '31')::numeric aac030,\n\t\t fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)::numeric aae041,\n\t\tto_char(current_timestamp, 'yyyymm')::numeric aae042) b,\n\tdwd_hrss_ac99 c\nwhere a.aac001::varchar = c.aac001::varchar\n\tand a.aae140 = '110'\n\tand a.aac008 = '1'\n\tand a.aac031 = '1'\n\tand a.aac030 <= b.aac030\n\tand a.aae041 <= b.aae041\n\tand coalesce(a.aae042, 999912) >= b.aae042\n\tand c.aac147 is not null limit 1\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select 'lxzdqdwjf5nys','连续在当前单位参保5年以上',c.aac147,'是','连续在当前单位参保5年以上' from dwd_csi_ac02 a inner join dwd_hrss_ac99 c on a.aac001=c.aac001 where a.aae140='110' and a.aac008='1' and a.aac031='1' and a.aac030<=(fun_addmonth(to_char(current_timestamp,'yyyymm')::varchar,-61)||'31')::numeric and a.aae041<=fun_addmonth(to_char(current_timestamp,'yyyymm')::varchar,-61)::numeric and coalesce(a.aae042,999912)>=to_char(current_timestamp,'yyyymm')::numeric and c.aac147 is not null limit 1"
                    }
                ]
            },
            {
                "case_id": "27",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"27\", \"db_type\": \"postgresql\", \"description\": \"该改写试图用经典的'MAX+自连接'模式替代窗口函数来获取每个分组的最新记录。理论上，当窗口函数需要处理大量数据时，GROUP BY聚合可能更高效。然而，本次改写犯了两个严重错误：1) 在CTE定义和子查询中使用了SELECT指定列而非SELECT *，导致结果集缺少字段；2) 没有充分验证结果集的完整性。正确的改写应该保持与原SQL完全相同的输出列，只改变获取数据的方法。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE cash_transaction (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL, balance DECIMAL(15,2) NOT NULL DEFAULT 0, created_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, cash_type INTEGER NOT NULL);\", \"CREATE INDEX idx_cash_transaction_member_num ON cash_transaction(member_num);\", \"CREATE INDEX idx_cash_transaction_cash_type ON cash_transaction(cash_type);\", \"CREATE INDEX idx_cash_transaction_composite ON cash_transaction(member_num, cash_type, id DESC);\", \"CREATE TABLE cash (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL UNIQUE, credit_available DECIMAL(15,2) NOT NULL DEFAULT 0);\", \"CREATE INDEX idx_cash_member_num ON cash(member_num);\"], \"sql\": \"with temp as(\\n select * from (\\n select ROW_NUMBER() OVER (PARTITION BY member_num ORDER BY id desc)a,\\n member_num,balance,created_on\\n from cash_transaction where cash_type=2 )a\\n where a=1 and balance<>0)\\n select * from temp a \\n full outer join\\n ( select * from  cash where  credit_available<>0)b\\n on a.member_num=b.member_num\\n where a.balance<>b.credit_available\\n or a.member_num is null\\n or b.member_num is null\", \"explain\": \"QUERY PLAN\\nHash Full Join  (cost=100581.31..137547.65 rows=835137 width=58)\\n  Hash Cond: ((cash.member_num)::text = (a.member_num)::text)\\n  Filter: ((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))\\n  ->  Seq Scan on cash  (cost=0.00..19747.00 rows=859467 width=26)\\n  Filter: (credit_available <> '0'::numeric)\\n  ->  Hash  (cost=100546.39..100546.39 rows=2793 width=32)\\n  ->  Subquery Scan on a  (cost=0.42..100546.39 rows=2793 width=32)\\n  Filter: ((a.balance <> '0'::numeric) AND (a.a = 1))\\n  ->  WindowAgg  (cost=0.42..90052.89 rows=699567 width=40)\\n  Run Condition: (row_number() OVER (?) <= 1)\\n  ->  Index Scan using idx_cash_transaction_composite on cash_transaction  (cost=0.42..77810.47 rows=699567 width=32)\\n  Index Cond: (cash_type = 2)\\nJIT:\\n  Functions: 25\\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Hash Join', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Full', 'Startup Cost': 100581.31, 'Total Cost': 137547.65, 'Plan Rows': 835137, 'Plan Width': 58, 'Inner Unique': False, 'Hash Cond': '((cash.member_num)::text = (a.member_num)::text)', 'Filter': '((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'cash', 'Alias': 'cash', 'Startup Cost': 0.0, 'Total Cost': 19747.0, 'Plan Rows': 859467, 'Plan Width': 26, 'Filter': \\\"(credit_available <> '0'::numeric)\\\"}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 100546.39, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'a', 'Startup Cost': 0.42, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Filter': \\\"((a.balance <> '0'::numeric) AND (a.a = 1))\\\", 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 90052.89, 'Plan Rows': 699567, 'Plan Width': 40, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_cash_transaction_composite', 'Relation Name': 'cash_transaction', 'Alias': 'cash_transaction', 'Startup Cost': 0.42, 'Total Cost': 77810.47, 'Plan Rows': 699567, 'Plan Width': 32, 'Index Cond': '(cash_type = 2)'}]}]}]}]}, 'JIT': {'Functions': 25, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE cash_transaction (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL, balance DECIMAL(15,2) NOT NULL DEFAULT 0, created_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, cash_type INTEGER NOT NULL);\nCREATE INDEX idx_cash_transaction_member_num ON cash_transaction(member_num);\nCREATE INDEX idx_cash_transaction_cash_type ON cash_transaction(cash_type);\nCREATE INDEX idx_cash_transaction_composite ON cash_transaction(member_num, cash_type, id DESC);\nCREATE TABLE cash (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL UNIQUE, credit_available DECIMAL(15,2) NOT NULL DEFAULT 0);\nCREATE INDEX idx_cash_member_num ON cash(member_num);\n\n## Explain Output in JSON:\nQUERY PLAN\nHash Full Join  (cost=100581.31..137547.65 rows=835137 width=58)\n  Hash Cond: ((cash.member_num)::text = (a.member_num)::text)\n  Filter: ((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))\n  ->  Seq Scan on cash  (cost=0.00..19747.00 rows=859467 width=26)\n  Filter: (credit_available <> '0'::numeric)\n  ->  Hash  (cost=100546.39..100546.39 rows=2793 width=32)\n  ->  Subquery Scan on a  (cost=0.42..100546.39 rows=2793 width=32)\n  Filter: ((a.balance <> '0'::numeric) AND (a.a = 1))\n  ->  WindowAgg  (cost=0.42..90052.89 rows=699567 width=40)\n  Run Condition: (row_number() OVER (?) <= 1)\n  ->  Index Scan using idx_cash_transaction_composite on cash_transaction  (cost=0.42..77810.47 rows=699567 width=32)\n  Index Cond: (cash_type = 2)\nJIT:\n  Functions: 25\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Hash Join', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Full', 'Startup Cost': 100581.31, 'Total Cost': 137547.65, 'Plan Rows': 835137, 'Plan Width': 58, 'Inner Unique': False, 'Hash Cond': '((cash.member_num)::text = (a.member_num)::text)', 'Filter': '((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'cash', 'Alias': 'cash', 'Startup Cost': 0.0, 'Total Cost': 19747.0, 'Plan Rows': 859467, 'Plan Width': 26, 'Filter': \"(credit_available <> '0'::numeric)\"}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 100546.39, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'a', 'Startup Cost': 0.42, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Filter': \"((a.balance <> '0'::numeric) AND (a.a = 1))\", 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 90052.89, 'Plan Rows': 699567, 'Plan Width': 40, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_cash_transaction_composite', 'Relation Name': 'cash_transaction', 'Alias': 'cash_transaction', 'Startup Cost': 0.42, 'Total Cost': 77810.47, 'Plan Rows': 699567, 'Plan Width': 32, 'Index Cond': '(cash_type = 2)'}]}]}]}]}, 'JIT': {'Functions': 25, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\n\n## Original SQL:\nwith temp as(\n select * from (\n select ROW_NUMBER() OVER (PARTITION BY member_num ORDER BY id desc)a,\n member_num,balance,created_on\n from cash_transaction where cash_type=2 )a\n where a=1 and balance<>0)\n select * from temp a \n full outer join\n ( select * from  cash where  credit_available<>0)b\n on a.member_num=b.member_num\n where a.balance<>b.credit_available\n or a.member_num is null\n or b.member_num is null\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select * from (select distinct on (member_num) member_num,balance,created_on from cash_transaction where cash_type=2 and balance<>0 order by member_num,id desc) a full outer join (select * from cash where credit_available<>0) b on a.member_num=b.member_num where a.balance is distinct from b.credit_available or a.member_num is null or b.member_num is null"
                    }
                ]
            },
            {
                "case_id": "28",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"28\", \"db_type\": \"oracle\", \"description\": \"本次改写主要做了两方面优化：1) 消除了子查询中计算但从未使用的first_tran_date字段，减少了一次min()聚合操作；2) 将onhold_accounts这个内联视图展开，直接在主查询中JOIN audit_header和audit_detail表，并将过滤条件移到WHERE子句中。这种改写理论上可以给优化器更多的优化空间，但由于原SQL结构已经较为优化，实际收益有限。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE SEQUENCE accounts_seq; CREATE TABLE accounts (acc_account_no VARCHAR2(50), acc_subacc_no VARCHAR2(50), acc_incep_date DATE NOT NULL, acc_act_code VARCHAR2(20), acc_gact_type VARCHAR2(10), PRIMARY KEY (acc_account_no, acc_subacc_no)); CREATE OR REPLACE TRIGGER accounts_bi BEFORE INSERT ON accounts FOR EACH ROW BEGIN NULL; END;\", \"CREATE INDEX idx_accounts_act_code ON accounts(acc_act_code);\", \"CREATE INDEX idx_accounts_gact_type ON accounts(acc_gact_type);\", \"CREATE INDEX idx_accounts_incep_date ON accounts(acc_incep_date);\", \"CREATE SEQUENCE account_headers_seq; CREATE TABLE account_headers (acch_account_no VARCHAR2(50) PRIMARY KEY, acch_title VARCHAR2(200), acch_brn_code VARCHAR2(20)); CREATE OR REPLACE TRIGGER account_headers_bi BEFORE INSERT ON account_headers FOR EACH ROW BEGIN NULL; END;\", \"CREATE INDEX idx_acch_account_no ON account_headers(acch_account_no);\", \"CREATE SEQUENCE account_types_seq; CREATE TABLE account_types (act_code VARCHAR2(20) PRIMARY KEY, act_long_name VARCHAR2(100)); CREATE OR REPLACE TRIGGER account_types_bi BEFORE INSERT ON account_types FOR EACH ROW BEGIN NULL; END;\", \"CREATE SEQUENCE transactions_seq; CREATE TABLE transactions (tran_seqno NUMBER PRIMARY KEY, tran_account_no VARCHAR2(50) NOT NULL, tran_subacc_no VARCHAR2(50) NOT NULL, tran_date DATE NOT NULL, tran_amount_cr NUMBER(18,2), tran_trans_code VARCHAR2(20), tran_pay_method VARCHAR2(10), tran_create_by VARCHAR2(50)); CREATE OR REPLACE TRIGGER transactions_bi BEFORE INSERT ON transactions FOR EACH ROW BEGIN IF :NEW.tran_seqno IS NULL THEN SELECT transactions_seq.NEXTVAL INTO :NEW.tran_seqno FROM DUAL; END IF; END;\", \"CREATE INDEX idx_trans_account_subacc ON transactions(tran_account_no, tran_subacc_no);\", \"CREATE INDEX idx_trans_date ON transactions(tran_date);\", \"CREATE INDEX idx_trans_trans_code ON transactions(tran_trans_code);\", \"CREATE INDEX idx_trans_pay_method ON transactions(tran_pay_method);\", \"CREATE SEQUENCE audit_header_seq; CREATE TABLE audit_header (audh_seqno NUMBER PRIMARY KEY, audh_key1 VARCHAR2(50), audh_key2 VARCHAR2(50), audh_date DATE, audh_table_prefix VARCHAR2(20), audh_change_type VARCHAR2(10)); CREATE OR REPLACE TRIGGER audit_header_bi BEFORE INSERT ON audit_header FOR EACH ROW BEGIN IF :NEW.audh_seqno IS NULL THEN SELECT audit_header_seq.NEXTVAL INTO :NEW.audh_seqno FROM DUAL; END IF; END;\", \"CREATE INDEX idx_audh_keys ON audit_header(audh_key1, audh_key2);\", \"CREATE INDEX idx_audh_table_prefix ON audit_header(audh_table_prefix);\", \"CREATE INDEX idx_audh_change_type ON audit_header(audh_change_type);\", \"CREATE SEQUENCE audit_detail_seq; CREATE TABLE audit_detail (audd_id NUMBER PRIMARY KEY, audd_audh_seqno NUMBER NOT NULL, audd_col_sufix VARCHAR2(50), audd_old_value VARCHAR2(200), audd_new_value VARCHAR2(200)); CREATE OR REPLACE TRIGGER audit_detail_bi BEFORE INSERT ON audit_detail FOR EACH ROW BEGIN IF :NEW.audd_id IS NULL THEN SELECT audit_detail_seq.NEXTVAL INTO :NEW.audd_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_audd_audh_seqno ON audit_detail(audd_audh_seqno);\", \"CREATE INDEX idx_audd_col_sufix ON audit_detail(audd_col_sufix);\", \"CREATE SEQUENCE account_links_seq; CREATE TABLE ACCOUNT_LINKS (accl_id NUMBER PRIMARY KEY, accl_account_no VARCHAR2(50) NOT NULL, accl_subacc_no VARCHAR2(50) NOT NULL, accl_holder_pos NUMBER, accl_cust_seqno NUMBER); CREATE OR REPLACE TRIGGER account_links_bi BEFORE INSERT ON ACCOUNT_LINKS FOR EACH ROW BEGIN IF :NEW.accl_id IS NULL THEN SELECT account_links_seq.NEXTVAL INTO :NEW.accl_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_accl_account_subacc ON ACCOUNT_LINKS(accl_account_no, accl_subacc_no);\", \"CREATE INDEX idx_accl_holder_pos ON ACCOUNT_LINKS(accl_holder_pos);\", \"CREATE SEQUENCE account_holding_tax_seq; CREATE TABLE SUMMIT.ACCOUNT_HOLDING_TAX (acctax_id NUMBER PRIMARY KEY, ACCTAX_ACCOUNT_NO VARCHAR2(50) NOT NULL, ACCTAX_SUBACC_NO VARCHAR2(50) NOT NULL, ACCTAX_CUST_SEQNO NUMBER, ACCTAX_EFF_DATE_FROM DATE); CREATE OR REPLACE TRIGGER account_holding_tax_bi BEFORE INSERT ON SUMMIT.ACCOUNT_HOLDING_TAX FOR EACH ROW BEGIN IF :NEW.acctax_id IS NULL THEN SELECT account_holding_tax_seq.NEXTVAL INTO :NEW.acctax_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_acctax_composite ON SUMMIT.ACCOUNT_HOLDING_TAX(ACCTAX_ACCOUNT_NO, ACCTAX_SUBACC_NO, ACCTAX_CUST_SEQNO);\"], \"sql\": \"SELECT DISTINCT acc_account_no, \\n  acc_subacc_no, \\n  acch_title,\\n  to_char(acc_incep_date,'DD/MM/YYYY') acc_incep_date,\\n  htax.ACCTAX_EFF_DATE_FROM,\\n  to_char(onhold_accounts.audh_date, 'DD-MON-YYYY') approved_date,\\n  act_long_name, \\n  tran_amount_cr,\\n  tran_create_by,\\n  CASE WHEN (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) < 0 THEN 0 ELSE\\n   (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) END time_on_approved,\\n  acch_brn_code\\n  FROM\\n  (\\n   (\\n  SELECT accounts.acc_account_no,\\n   acch_title, \\n   accounts.acc_subacc_no,\\n   acc_incep_date,\\n   act_long_name,\\n   tran_amount_cr,\\n   transactions.tran_create_by,\\n   first_tran_date,\\n   acch_brn_code\\n  FROM accounts \\n  JOIN account_headers ON account_headers.acch_account_no = accounts.acc_account_no\\n  JOIN account_types ON acc_act_code = act_code\\n  JOIN \\n   (\\n  SELECT tran_account_no, tran_subacc_no, min(tran_seqno) first_tran_seq, min(tran_date) first_tran_date\\n  FROM transactions\\n  WHERE tran_amount_cr IS NOT NULL\\n  AND tran_trans_code IN ('RIC','RSAV')\\n  AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE\\n  AND tran_pay_method not in ('C','CQ')   --Exclude cash and cheque receipts as those accounts will already have the passbook.\\n  GROUP BY tran_account_no, tran_subacc_no\\n   ) first_trans\\n   ON tran_account_no = acc_account_no AND tran_subacc_no = acc_subacc_no\\n  JOIN transactions ON tran_seqno = first_trans.first_tran_seq\\n  WHERE acc_gact_type IN ('S', 'IC') \\n   AND acc_incep_date BETWEEN IN_INCEP_FROM_DATE and IN_INCEP_TO_DATE\\n   ) opened_accounts\\n   JOIN\\n   (\\n  SELECT audh_key1, audh_key2, audh_date, audd_old_value, audd_new_value\\n  FROM audit_header\\n  JOIN audit_detail\\n   ON audh_seqno = audd_audh_seqno\\n  WHERE audh_table_prefix = 'ACC'\\n   AND audd_col_sufix = 'PROCESS_STATUS'\\n   AND audh_change_type  = 'I'\\n   AND audd_old_value IS NULL \\n   AND audd_new_value = 1\\n   ) onhold_accounts\\n  ON opened_accounts.acc_account_no = onhold_accounts.audh_key1\\n   AND opened_accounts.acc_subacc_no = onhold_accounts.audh_key2\\n   JOIN ACCOUNT_LINKS al ON al.accl_account_no = opened_accounts.ACC_ACCOUNT_NO and al.accl_subacc_no = opened_accounts.ACC_SUBACC_NO and al.accl_holder_pos = 1\\n   JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax \\n  ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO\\n   AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO\\n   AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO\\n  )\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t1320\\t1\\t264\\t333735386\\t1311\\n1\\t  HASH UNIQUE \\t1320\\t1\\t264\\t333735386\\t1311\\n2\\t  HASH JOIN  \\t1319\\t1\\t264\\t296866817\\t1311\\n3\\t   NESTED LOOPS  \\t1319\\t1\\t264\\t296866817\\t1311\\n4\\t  NESTED LOOPS  \\t1319\\t1\\t264\\t296866817\\t1311\\n5\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n6\\t   NESTED LOOPS  \\t1317\\t1\\t249\\t296850384\\t1309\\n7\\t  HASH JOIN  \\t1294\\t1\\t236\\t296676455\\t1286\\n8\\t  NESTED LOOPS  \\t1294\\t1\\t236\\t296676455\\t1286\\n9\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n10\\t  HASH JOIN  \\t1291\\t1\\t206\\t296653810\\t1283\\n11\\t  NESTED LOOPS  \\t1291\\t1\\t206\\t296653810\\t1283\\n12\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n13\\t  HASH JOIN  \\t1289\\t1\\t180\\t296638517\\t1281\\n14\\t  NESTED LOOPS  \\t1289\\t1\\t180\\t296638517\\t1281\\n15\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n16\\t  HASH JOIN  \\t1287\\t1\\t132\\t296622185\\t1279\\n17\\t  NESTED LOOPS  \\t1287\\t1\\t132\\t296622185\\t1279\\n18\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n19\\t  NESTED LOOPS  \\t1283\\t4\\t328\\t296586099\\t1275\\n20\\t  HASH JOIN  \\t1278\\t4\\t208\\t296542487\\t1270\\n21\\t   NESTED LOOPS  \\t1278\\t4\\t208\\t296542487\\t1270\\n22\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n23\\t  TABLE ACCESS FULL AUDIT_DETAIL\\t1270\\t4\\t84\\t296476515\\t1262\\n24\\t  TABLE ACCESS BY INDEX ROWID AUDIT_HEADER\\t2\\t1\\t31\\t16493\\t2\\n25\\t  INDEX UNIQUE SCAN SYS_C008309\\t1\\t1\\t\\t9021\\t1\\n26\\t   TABLE ACCESS FULL AUDIT_HEADER\\t2\\t1\\t31\\t16493\\t2\\n27\\t  TABLE ACCESS BY INDEX ROWID ACCOUNTS\\t2\\t1\\t30\\t16548\\t2\\n28\\t   INDEX UNIQUE SCAN SYS_C008302\\t1\\t1\\t\\t9021\\t1\\n29\\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_TYPES\\t1\\t1\\t50\\t9021\\t1\\n30\\t  INDEX UNIQUE SCAN SYS_C008304\\t1\\t1\\t\\t9021\\t1\\n31\\t  TABLE ACCESS FULL ACCOUNT_TYPES\\t1\\t1\\t50\\t9021\\t1\\n32\\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_HEADERS\\t2\\t1\\t48\\t16333\\t2\\n33\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n34\\t  TABLE ACCESS FULL ACCOUNT_HEADERS\\t2\\t1\\t48\\t16333\\t2\\n35\\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_LINKS\\t2\\t1\\t26\\t15293\\t2\\n36\\t  INDEX RANGE SCAN IDX_ACCL_ACCOUNT_SUBACC\\t2\\t10\\t\\t15293\\t2\\n37\\t  TABLE ACCESS FULL ACCOUNT_LINKS\\t2\\t1\\t26\\t15293\\t2\\n38\\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_HOLDING_TAX\\t3\\t1\\t30\\t22644\\t3\\n39\\t  INDEX RANGE SCAN IDX_ACCTAX_COMPOSITE\\t2\\t1\\t\\t15293\\t2\\n40\\t  TABLE ACCESS FULL ACCOUNT_HOLDING_TAX\\t3\\t1\\t30\\t22644\\t3\\n41\\t  VIEW PUSHED PREDICATE  \\t23\\t1\\t13\\t173930\\t23\\n42\\t  FILTER  \\t\\t\\t\\t\\t\\n43\\t   SORT AGGREGATE \\t\\t1\\t40\\t\\t\\n44\\t  TABLE ACCESS BY INDEX ROWID BATCHED TRANSACTIONS\\t23\\t1\\t40\\t173930\\t23\\n45\\t  INDEX RANGE SCAN IDX_TRANS_ACCOUNT_SUBACC\\t3\\t20\\t\\t25364\\t3\\n46\\t  INDEX UNIQUE SCAN SYS_C008308\\t1\\t1\\t\\t9021\\t1\\n47\\t  TABLE ACCESS BY INDEX ROWID TRANSACTIONS\\t2\\t1\\t15\\t16433\\t2\\n48\\t   TABLE ACCESS FULL TRANSACTIONS\\t2\\t1\\t15\\t16433\\t2\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE accounts_seq; CREATE TABLE accounts (acc_account_no VARCHAR2(50), acc_subacc_no VARCHAR2(50), acc_incep_date DATE NOT NULL, acc_act_code VARCHAR2(20), acc_gact_type VARCHAR2(10), PRIMARY KEY (acc_account_no, acc_subacc_no)); CREATE OR REPLACE TRIGGER accounts_bi BEFORE INSERT ON accounts FOR EACH ROW BEGIN NULL; END;\nCREATE INDEX idx_accounts_act_code ON accounts(acc_act_code);\nCREATE INDEX idx_accounts_gact_type ON accounts(acc_gact_type);\nCREATE INDEX idx_accounts_incep_date ON accounts(acc_incep_date);\nCREATE SEQUENCE account_headers_seq; CREATE TABLE account_headers (acch_account_no VARCHAR2(50) PRIMARY KEY, acch_title VARCHAR2(200), acch_brn_code VARCHAR2(20)); CREATE OR REPLACE TRIGGER account_headers_bi BEFORE INSERT ON account_headers FOR EACH ROW BEGIN NULL; END;\nCREATE INDEX idx_acch_account_no ON account_headers(acch_account_no);\nCREATE SEQUENCE account_types_seq; CREATE TABLE account_types (act_code VARCHAR2(20) PRIMARY KEY, act_long_name VARCHAR2(100)); CREATE OR REPLACE TRIGGER account_types_bi BEFORE INSERT ON account_types FOR EACH ROW BEGIN NULL; END;\nCREATE SEQUENCE transactions_seq; CREATE TABLE transactions (tran_seqno NUMBER PRIMARY KEY, tran_account_no VARCHAR2(50) NOT NULL, tran_subacc_no VARCHAR2(50) NOT NULL, tran_date DATE NOT NULL, tran_amount_cr NUMBER(18,2), tran_trans_code VARCHAR2(20), tran_pay_method VARCHAR2(10), tran_create_by VARCHAR2(50)); CREATE OR REPLACE TRIGGER transactions_bi BEFORE INSERT ON transactions FOR EACH ROW BEGIN IF :NEW.tran_seqno IS NULL THEN SELECT transactions_seq.NEXTVAL INTO :NEW.tran_seqno FROM DUAL; END IF; END;\nCREATE INDEX idx_trans_account_subacc ON transactions(tran_account_no, tran_subacc_no);\nCREATE INDEX idx_trans_date ON transactions(tran_date);\nCREATE INDEX idx_trans_trans_code ON transactions(tran_trans_code);\nCREATE INDEX idx_trans_pay_method ON transactions(tran_pay_method);\nCREATE SEQUENCE audit_header_seq; CREATE TABLE audit_header (audh_seqno NUMBER PRIMARY KEY, audh_key1 VARCHAR2(50), audh_key2 VARCHAR2(50), audh_date DATE, audh_table_prefix VARCHAR2(20), audh_change_type VARCHAR2(10)); CREATE OR REPLACE TRIGGER audit_header_bi BEFORE INSERT ON audit_header FOR EACH ROW BEGIN IF :NEW.audh_seqno IS NULL THEN SELECT audit_header_seq.NEXTVAL INTO :NEW.audh_seqno FROM DUAL; END IF; END;\nCREATE INDEX idx_audh_keys ON audit_header(audh_key1, audh_key2);\nCREATE INDEX idx_audh_table_prefix ON audit_header(audh_table_prefix);\nCREATE INDEX idx_audh_change_type ON audit_header(audh_change_type);\nCREATE SEQUENCE audit_detail_seq; CREATE TABLE audit_detail (audd_id NUMBER PRIMARY KEY, audd_audh_seqno NUMBER NOT NULL, audd_col_sufix VARCHAR2(50), audd_old_value VARCHAR2(200), audd_new_value VARCHAR2(200)); CREATE OR REPLACE TRIGGER audit_detail_bi BEFORE INSERT ON audit_detail FOR EACH ROW BEGIN IF :NEW.audd_id IS NULL THEN SELECT audit_detail_seq.NEXTVAL INTO :NEW.audd_id FROM DUAL; END IF; END;\nCREATE INDEX idx_audd_audh_seqno ON audit_detail(audd_audh_seqno);\nCREATE INDEX idx_audd_col_sufix ON audit_detail(audd_col_sufix);\nCREATE SEQUENCE account_links_seq; CREATE TABLE ACCOUNT_LINKS (accl_id NUMBER PRIMARY KEY, accl_account_no VARCHAR2(50) NOT NULL, accl_subacc_no VARCHAR2(50) NOT NULL, accl_holder_pos NUMBER, accl_cust_seqno NUMBER); CREATE OR REPLACE TRIGGER account_links_bi BEFORE INSERT ON ACCOUNT_LINKS FOR EACH ROW BEGIN IF :NEW.accl_id IS NULL THEN SELECT account_links_seq.NEXTVAL INTO :NEW.accl_id FROM DUAL; END IF; END;\nCREATE INDEX idx_accl_account_subacc ON ACCOUNT_LINKS(accl_account_no, accl_subacc_no);\nCREATE INDEX idx_accl_holder_pos ON ACCOUNT_LINKS(accl_holder_pos);\nCREATE SEQUENCE account_holding_tax_seq; CREATE TABLE SUMMIT.ACCOUNT_HOLDING_TAX (acctax_id NUMBER PRIMARY KEY, ACCTAX_ACCOUNT_NO VARCHAR2(50) NOT NULL, ACCTAX_SUBACC_NO VARCHAR2(50) NOT NULL, ACCTAX_CUST_SEQNO NUMBER, ACCTAX_EFF_DATE_FROM DATE); CREATE OR REPLACE TRIGGER account_holding_tax_bi BEFORE INSERT ON SUMMIT.ACCOUNT_HOLDING_TAX FOR EACH ROW BEGIN IF :NEW.acctax_id IS NULL THEN SELECT account_holding_tax_seq.NEXTVAL INTO :NEW.acctax_id FROM DUAL; END IF; END;\nCREATE INDEX idx_acctax_composite ON SUMMIT.ACCOUNT_HOLDING_TAX(ACCTAX_ACCOUNT_NO, ACCTAX_SUBACC_NO, ACCTAX_CUST_SEQNO);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t1320\t1\t264\t333735386\t1311\n1\t  HASH UNIQUE \t1320\t1\t264\t333735386\t1311\n2\t  HASH JOIN  \t1319\t1\t264\t296866817\t1311\n3\t   NESTED LOOPS  \t1319\t1\t264\t296866817\t1311\n4\t  NESTED LOOPS  \t1319\t1\t264\t296866817\t1311\n5\t  STATISTICS COLLECTOR  \t\t\t\t\t\n6\t   NESTED LOOPS  \t1317\t1\t249\t296850384\t1309\n7\t  HASH JOIN  \t1294\t1\t236\t296676455\t1286\n8\t  NESTED LOOPS  \t1294\t1\t236\t296676455\t1286\n9\t   STATISTICS COLLECTOR  \t\t\t\t\t\n10\t  HASH JOIN  \t1291\t1\t206\t296653810\t1283\n11\t  NESTED LOOPS  \t1291\t1\t206\t296653810\t1283\n12\t   STATISTICS COLLECTOR  \t\t\t\t\t\n13\t  HASH JOIN  \t1289\t1\t180\t296638517\t1281\n14\t  NESTED LOOPS  \t1289\t1\t180\t296638517\t1281\n15\t   STATISTICS COLLECTOR  \t\t\t\t\t\n16\t  HASH JOIN  \t1287\t1\t132\t296622185\t1279\n17\t  NESTED LOOPS  \t1287\t1\t132\t296622185\t1279\n18\t   STATISTICS COLLECTOR  \t\t\t\t\t\n19\t  NESTED LOOPS  \t1283\t4\t328\t296586099\t1275\n20\t  HASH JOIN  \t1278\t4\t208\t296542487\t1270\n21\t   NESTED LOOPS  \t1278\t4\t208\t296542487\t1270\n22\t  STATISTICS COLLECTOR  \t\t\t\t\t\n23\t  TABLE ACCESS FULL AUDIT_DETAIL\t1270\t4\t84\t296476515\t1262\n24\t  TABLE ACCESS BY INDEX ROWID AUDIT_HEADER\t2\t1\t31\t16493\t2\n25\t  INDEX UNIQUE SCAN SYS_C008309\t1\t1\t\t9021\t1\n26\t   TABLE ACCESS FULL AUDIT_HEADER\t2\t1\t31\t16493\t2\n27\t  TABLE ACCESS BY INDEX ROWID ACCOUNTS\t2\t1\t30\t16548\t2\n28\t   INDEX UNIQUE SCAN SYS_C008302\t1\t1\t\t9021\t1\n29\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_TYPES\t1\t1\t50\t9021\t1\n30\t  INDEX UNIQUE SCAN SYS_C008304\t1\t1\t\t9021\t1\n31\t  TABLE ACCESS FULL ACCOUNT_TYPES\t1\t1\t50\t9021\t1\n32\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_HEADERS\t2\t1\t48\t16333\t2\n33\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n34\t  TABLE ACCESS FULL ACCOUNT_HEADERS\t2\t1\t48\t16333\t2\n35\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_LINKS\t2\t1\t26\t15293\t2\n36\t  INDEX RANGE SCAN IDX_ACCL_ACCOUNT_SUBACC\t2\t10\t\t15293\t2\n37\t  TABLE ACCESS FULL ACCOUNT_LINKS\t2\t1\t26\t15293\t2\n38\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_HOLDING_TAX\t3\t1\t30\t22644\t3\n39\t  INDEX RANGE SCAN IDX_ACCTAX_COMPOSITE\t2\t1\t\t15293\t2\n40\t  TABLE ACCESS FULL ACCOUNT_HOLDING_TAX\t3\t1\t30\t22644\t3\n41\t  VIEW PUSHED PREDICATE  \t23\t1\t13\t173930\t23\n42\t  FILTER  \t\t\t\t\t\n43\t   SORT AGGREGATE \t\t1\t40\t\t\n44\t  TABLE ACCESS BY INDEX ROWID BATCHED TRANSACTIONS\t23\t1\t40\t173930\t23\n45\t  INDEX RANGE SCAN IDX_TRANS_ACCOUNT_SUBACC\t3\t20\t\t25364\t3\n46\t  INDEX UNIQUE SCAN SYS_C008308\t1\t1\t\t9021\t1\n47\t  TABLE ACCESS BY INDEX ROWID TRANSACTIONS\t2\t1\t15\t16433\t2\n48\t   TABLE ACCESS FULL TRANSACTIONS\t2\t1\t15\t16433\t2\n\n## Original SQL:\nSELECT DISTINCT acc_account_no, \n  acc_subacc_no, \n  acch_title,\n  to_char(acc_incep_date,'DD/MM/YYYY') acc_incep_date,\n  htax.ACCTAX_EFF_DATE_FROM,\n  to_char(onhold_accounts.audh_date, 'DD-MON-YYYY') approved_date,\n  act_long_name, \n  tran_amount_cr,\n  tran_create_by,\n  CASE WHEN (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) < 0 THEN 0 ELSE\n   (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) END time_on_approved,\n  acch_brn_code\n  FROM\n  (\n   (\n  SELECT accounts.acc_account_no,\n   acch_title, \n   accounts.acc_subacc_no,\n   acc_incep_date,\n   act_long_name,\n   tran_amount_cr,\n   transactions.tran_create_by,\n   first_tran_date,\n   acch_brn_code\n  FROM accounts \n  JOIN account_headers ON account_headers.acch_account_no = accounts.acc_account_no\n  JOIN account_types ON acc_act_code = act_code\n  JOIN \n   (\n  SELECT tran_account_no, tran_subacc_no, min(tran_seqno) first_tran_seq, min(tran_date) first_tran_date\n  FROM transactions\n  WHERE tran_amount_cr IS NOT NULL\n  AND tran_trans_code IN ('RIC','RSAV')\n  AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE\n  AND tran_pay_method not in ('C','CQ')   --Exclude cash and cheque receipts as those accounts will already have the passbook.\n  GROUP BY tran_account_no, tran_subacc_no\n   ) first_trans\n   ON tran_account_no = acc_account_no AND tran_subacc_no = acc_subacc_no\n  JOIN transactions ON tran_seqno = first_trans.first_tran_seq\n  WHERE acc_gact_type IN ('S', 'IC') \n   AND acc_incep_date BETWEEN IN_INCEP_FROM_DATE and IN_INCEP_TO_DATE\n   ) opened_accounts\n   JOIN\n   (\n  SELECT audh_key1, audh_key2, audh_date, audd_old_value, audd_new_value\n  FROM audit_header\n  JOIN audit_detail\n   ON audh_seqno = audd_audh_seqno\n  WHERE audh_table_prefix = 'ACC'\n   AND audd_col_sufix = 'PROCESS_STATUS'\n   AND audh_change_type  = 'I'\n   AND audd_old_value IS NULL \n   AND audd_new_value = 1\n   ) onhold_accounts\n  ON opened_accounts.acc_account_no = onhold_accounts.audh_key1\n   AND opened_accounts.acc_subacc_no = onhold_accounts.audh_key2\n   JOIN ACCOUNT_LINKS al ON al.accl_account_no = opened_accounts.ACC_ACCOUNT_NO and al.accl_subacc_no = opened_accounts.ACC_SUBACC_NO and al.accl_holder_pos = 1\n   JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax \n  ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO\n   AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO\n   AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO\n  )\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT DISTINCT a.acc_account_no, a.acc_subacc_no, ah.acch_title, TO_CHAR(a.acc_incep_date,'DD/MM/YYYY') acc_incep_date, htax.ACCTAX_EFF_DATE_FROM, TO_CHAR(ad.audh_date, 'DD-MON-YYYY') approved_date, at.act_long_name, t.tran_amount_cr, t.tran_create_by, CASE WHEN (TRUNC(a.acc_incep_date) - TRUNC(ad.audh_date)) < 0 THEN 0 ELSE (TRUNC(a.acc_incep_date) - TRUNC(ad.audh_date)) END time_on_approved, ah.acch_brn_code FROM accounts a INNER JOIN account_headers ah ON ah.acch_account_no = a.acc_account_no INNER JOIN account_types at ON a.acc_act_code = at.act_code INNER JOIN (SELECT tran_account_no, tran_subacc_no, MIN(tran_seqno) first_tran_seq FROM transactions WHERE tran_amount_cr IS NOT NULL AND tran_trans_code IN ('RIC','RSAV') AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE AND tran_pay_method NOT IN ('C','CQ') GROUP BY tran_account_no, tran_subacc_no) ft ON ft.tran_account_no = a.acc_account_no AND ft.tran_subacc_no = a.acc_subacc_no INNER JOIN transactions t ON t.tran_seqno = ft.first_tran_seq INNER JOIN audit_header ad ON ad.audh_key1 = a.acc_account_no AND ad.audh_key2 = a.acc_subacc_no AND ad.audh_table_prefix = 'ACC' AND ad.audh_change_type = 'I' INNER JOIN audit_detail audd ON ad.audh_seqno = audd.audd_audh_seqno AND audd.audd_col_sufix = 'PROCESS_STATUS' AND audd.audd_old_value IS NULL AND audd.audd_new_value = 1 INNER JOIN ACCOUNT_LINKS al ON al.accl_account_no = a.acc_account_no AND al.accl_subacc_no = a.acc_subacc_no AND al.accl_holder_pos = 1 INNER JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO WHERE a.acc_gact_type IN ('S', 'IC') AND a.acc_incep_date BETWEEN IN_INCEP_FROM_DATE AND IN_INCEP_TO_DATE;"
                    }
                ]
            },
            {
                "case_id": "29",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"29\", \"db_type\": \"oracle\", \"description\": \"改写试图通过三个方向优化：1）谓词优化：将SUBSTR函数改为LIKE谓词以便索引扫描；将HAVING COUNT(DECODE())改为简单的WHERE过滤；2）投影裁剪：对于COUNT(*)查询，将SELECT所有列改为SELECT 1，减少数据传输；3）数据预过滤：在连接前通过内联视图过滤数据。理论上这些都是常见的优化技术，但在本案例中，HAVING到WHERE的转换导致优化器基数估算失准，反而产生了更差的执行计划。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE SEQUENCE jobinfo_his_seq; CREATE TABLE jobinfo_his (id NUMBER PRIMARY KEY, jobid VARCHAR2(50) NOT NULL, tellercode VARCHAR2(50), jobname VARCHAR2(100), jobstatus VARCHAR2(10), jobstartpersname VARCHAR2(100), jobpriorpersname VARCHAR2(100), jobtype VARCHAR2(50), createtime DATE NOT NULL, tranname VARCHAR2(100), issucc VARCHAR2(1), tranprop VARCHAR2(100), trandata VARCHAR2(4000), jbjg VARCHAR2(100), jbgy VARCHAR2(100), ldlcid VARCHAR2(50)); CREATE OR REPLACE TRIGGER jobinfo_his_bi BEFORE INSERT ON jobinfo_his FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT jobinfo_his_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_jobinfo_his_jobid ON jobinfo_his(jobid);\", \"CREATE INDEX idx_jobinfo_his_status ON jobinfo_his(jobstatus);\", \"CREATE INDEX idx_jobinfo_his_createtime ON jobinfo_his(createtime);\", \"CREATE INDEX idx_jobinfo_his_composite ON jobinfo_his(jobid, jobstatus, createtime);\", \"CREATE SEQUENCE businodeinst_seq; CREATE TABLE businodeinst (id NUMBER PRIMARY KEY, nodeinstid VARCHAR2(50) NOT NULL, flowinstid VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER businodeinst_bi BEFORE INSERT ON businodeinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT businodeinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_businodeinst_nodeinstid ON businodeinst(nodeinstid);\", \"CREATE INDEX idx_businodeinst_flowinstid ON businodeinst(flowinstid);\", \"CREATE SEQUENCE busiflowinst_seq; CREATE TABLE busiflowinst (id NUMBER PRIMARY KEY, flowinstid VARCHAR2(50) NOT NULL, status VARCHAR2(10)); CREATE OR REPLACE TRIGGER busiflowinst_bi BEFORE INSERT ON busiflowinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT busiflowinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_busiflowinst_flowinstid ON busiflowinst(flowinstid);\", \"CREATE INDEX idx_busiflowinst_composite ON busiflowinst(flowinstid, status);\"], \"sql\": \"select\\n  count(*)\\nfrom\\n  (\\n  select\\n   tt.jobid,\\n   tt.tellercode,\\n   tt.jobname,\\n   tt.jobstatus,\\n   tt.jobstartpersname,\\n   tt.jobpriorpersname,\\n   tt.jobtype,\\n   tt.createtime,\\n   tt.tranname,\\n   tt.issucc,\\n   tt.tranprop,\\n   tt.trandata,\\n   tt.jbjg,\\n   tt.jbgy,\\n   tt.ldlcid\\n  from\\n   (\\n  select\\n  t3.jobid,\\n  t3.tellercode,\\n  t3.jobname,\\n  t3.jobstatus,\\n  t3.jobstartpersname,\\n  t3.jobpriorpersname,\\n  t3.jobtype,\\n  t3.createtime,\\n  t3.tranname,\\n  t3.issucc,\\n  t3.tranprop,\\n  t3.trandata,\\n  t3.jbjg,\\n  t3.jbgy,\\n  t3.ldlcid,\\n  row_number() over (\\n   partition by\\n  t3.jobid\\n   order by\\n  t3.createtime desc\\n  ) as rn\\n  from\\n  jobinfo_his t3\\n  where\\n  exists (\\n   select\\n  t2.jobid\\n   from\\n  jobinfo_his t2\\n   where\\n  t2.jobid = t3.jobid\\n  and exists (\\n  select\\n   t1.jobid\\n  from\\n   jobinfo_his t1\\n  where\\n   t1.jobid = t2.jobid\\n   and t1.jobstatus = 'O'\\n   and substr(jobid, 0, 1) = 'A'\\n  )\\n   group by\\n  t2.jobid\\n   having\\n  count(decode(t2.jobstatus, 'N', 1, null)) = 0\\n  )\\n   ) tt\\n  where\\n   tt.rn = 1\\n  union all\\n  select\\n   t.jobid,\\n   t.tellercode,\\n   t.jobname,\\n   t.jobstatus,\\n   t.jobstartpersname,\\n   t.jobpriorpersname,\\n   t.jobtype,\\n   t.createtime,\\n   t.tranname,\\n   t.issucc,\\n   t.tranprop,\\n   t.trandata,\\n   t.jbjg,\\n   t.jbgy,\\n   t.ldlcid\\n  from\\n   jobinfo_his t,\\n   businodeinst t1,\\n   busiflowinst t2\\n  where\\n   t.jobid = t1.nodeinstid\\n   and t1.flowinstid = t2.flowinstid\\n   and t2.status = '1'\\n   and t.jobstatus = 'O'\\n  )\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t11679\\t1\\t\\t1903461107\\t11627\\n1\\t  SORT AGGREGATE \\t\\t1\\t\\t\\t\\n2\\t  VIEW  \\t11679\\t343333\\t\\t1903461107\\t11627\\n3\\t   UNION-ALL  \\t\\t\\t\\t\\t\\n4\\t  VIEW  \\t4181\\t10000\\t130000\\t837889750\\t4158\\n5\\t  WINDOW SORT PUSHED RANK \\t4181\\t10000\\t290000\\t837889750\\t4158\\n6\\t   NESTED LOOPS  \\t4180\\t10000\\t290000\\t795034459\\t4158\\n7\\t  VIEW  VW_NSO_1\\t3611\\t500\\t5500\\t785488019\\t3590\\n8\\t  HASH GROUP BY \\t3611\\t500\\t12000\\t785488019\\t3590\\n9\\t   HASH JOIN RIGHT SEMI \\t3609\\t64600\\t1550400\\t702111454\\t3590\\n10\\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1807\\t3333\\t39996\\t433839085\\t1795\\n11\\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1800\\t1000000\\t12000000\\t167172419\\t1795\\n12\\t  INDEX RANGE SCAN IDX_JOBINFO_HIS_COMPOSITE\\t2\\t20\\t360\\t19093\\t2\\n13\\t  HASH JOIN  \\t7498\\t333333\\t16666650\\t1065571358\\t7469\\n14\\t  INDEX FAST FULL SCAN IDX_BUSIFLOWINST_COMPOSITE\\t957\\t500000\\t7500000\\t194989133\\t952\\n15\\t  HASH JOIN  \\t5157\\t333333\\t11666655\\t713706795\\t5138\\n16\\t   NESTED LOOPS  \\t5157\\t333333\\t11666655\\t713706795\\t5138\\n17\\t  NESTED LOOPS  \\t\\t\\t\\t\\t\\n18\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n19\\t   INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1801\\t333333\\t3999996\\t217172419\\t1795\\n20\\t  INDEX RANGE SCAN IDX_BUSINODEINST_NODEINSTID\\t\\t\\t\\t\\t\\n21\\t  TABLE ACCESS BY INDEX ROWID BUSINODEINST\\t1316\\t1\\t23\\t224396555\\t1310\\n22\\t   TABLE ACCESS FULL BUSINODEINST\\t1316\\t1000000\\t23000000\\t224396555\\t1310\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE jobinfo_his_seq; CREATE TABLE jobinfo_his (id NUMBER PRIMARY KEY, jobid VARCHAR2(50) NOT NULL, tellercode VARCHAR2(50), jobname VARCHAR2(100), jobstatus VARCHAR2(10), jobstartpersname VARCHAR2(100), jobpriorpersname VARCHAR2(100), jobtype VARCHAR2(50), createtime DATE NOT NULL, tranname VARCHAR2(100), issucc VARCHAR2(1), tranprop VARCHAR2(100), trandata VARCHAR2(4000), jbjg VARCHAR2(100), jbgy VARCHAR2(100), ldlcid VARCHAR2(50)); CREATE OR REPLACE TRIGGER jobinfo_his_bi BEFORE INSERT ON jobinfo_his FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT jobinfo_his_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_jobinfo_his_jobid ON jobinfo_his(jobid);\nCREATE INDEX idx_jobinfo_his_status ON jobinfo_his(jobstatus);\nCREATE INDEX idx_jobinfo_his_createtime ON jobinfo_his(createtime);\nCREATE INDEX idx_jobinfo_his_composite ON jobinfo_his(jobid, jobstatus, createtime);\nCREATE SEQUENCE businodeinst_seq; CREATE TABLE businodeinst (id NUMBER PRIMARY KEY, nodeinstid VARCHAR2(50) NOT NULL, flowinstid VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER businodeinst_bi BEFORE INSERT ON businodeinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT businodeinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_businodeinst_nodeinstid ON businodeinst(nodeinstid);\nCREATE INDEX idx_businodeinst_flowinstid ON businodeinst(flowinstid);\nCREATE SEQUENCE busiflowinst_seq; CREATE TABLE busiflowinst (id NUMBER PRIMARY KEY, flowinstid VARCHAR2(50) NOT NULL, status VARCHAR2(10)); CREATE OR REPLACE TRIGGER busiflowinst_bi BEFORE INSERT ON busiflowinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT busiflowinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_busiflowinst_flowinstid ON busiflowinst(flowinstid);\nCREATE INDEX idx_busiflowinst_composite ON busiflowinst(flowinstid, status);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t11679\t1\t\t1903461107\t11627\n1\t  SORT AGGREGATE \t\t1\t\t\t\n2\t  VIEW  \t11679\t343333\t\t1903461107\t11627\n3\t   UNION-ALL  \t\t\t\t\t\n4\t  VIEW  \t4181\t10000\t130000\t837889750\t4158\n5\t  WINDOW SORT PUSHED RANK \t4181\t10000\t290000\t837889750\t4158\n6\t   NESTED LOOPS  \t4180\t10000\t290000\t795034459\t4158\n7\t  VIEW  VW_NSO_1\t3611\t500\t5500\t785488019\t3590\n8\t  HASH GROUP BY \t3611\t500\t12000\t785488019\t3590\n9\t   HASH JOIN RIGHT SEMI \t3609\t64600\t1550400\t702111454\t3590\n10\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1807\t3333\t39996\t433839085\t1795\n11\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1800\t1000000\t12000000\t167172419\t1795\n12\t  INDEX RANGE SCAN IDX_JOBINFO_HIS_COMPOSITE\t2\t20\t360\t19093\t2\n13\t  HASH JOIN  \t7498\t333333\t16666650\t1065571358\t7469\n14\t  INDEX FAST FULL SCAN IDX_BUSIFLOWINST_COMPOSITE\t957\t500000\t7500000\t194989133\t952\n15\t  HASH JOIN  \t5157\t333333\t11666655\t713706795\t5138\n16\t   NESTED LOOPS  \t5157\t333333\t11666655\t713706795\t5138\n17\t  NESTED LOOPS  \t\t\t\t\t\n18\t  STATISTICS COLLECTOR  \t\t\t\t\t\n19\t   INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1801\t333333\t3999996\t217172419\t1795\n20\t  INDEX RANGE SCAN IDX_BUSINODEINST_NODEINSTID\t\t\t\t\t\n21\t  TABLE ACCESS BY INDEX ROWID BUSINODEINST\t1316\t1\t23\t224396555\t1310\n22\t   TABLE ACCESS FULL BUSINODEINST\t1316\t1000000\t23000000\t224396555\t1310\n\n## Original SQL:\nselect\n  count(*)\nfrom\n  (\n  select\n   tt.jobid,\n   tt.tellercode,\n   tt.jobname,\n   tt.jobstatus,\n   tt.jobstartpersname,\n   tt.jobpriorpersname,\n   tt.jobtype,\n   tt.createtime,\n   tt.tranname,\n   tt.issucc,\n   tt.tranprop,\n   tt.trandata,\n   tt.jbjg,\n   tt.jbgy,\n   tt.ldlcid\n  from\n   (\n  select\n  t3.jobid,\n  t3.tellercode,\n  t3.jobname,\n  t3.jobstatus,\n  t3.jobstartpersname,\n  t3.jobpriorpersname,\n  t3.jobtype,\n  t3.createtime,\n  t3.tranname,\n  t3.issucc,\n  t3.tranprop,\n  t3.trandata,\n  t3.jbjg,\n  t3.jbgy,\n  t3.ldlcid,\n  row_number() over (\n   partition by\n  t3.jobid\n   order by\n  t3.createtime desc\n  ) as rn\n  from\n  jobinfo_his t3\n  where\n  exists (\n   select\n  t2.jobid\n   from\n  jobinfo_his t2\n   where\n  t2.jobid = t3.jobid\n  and exists (\n  select\n   t1.jobid\n  from\n   jobinfo_his t1\n  where\n   t1.jobid = t2.jobid\n   and t1.jobstatus = 'O'\n   and substr(jobid, 0, 1) = 'A'\n  )\n   group by\n  t2.jobid\n   having\n  count(decode(t2.jobstatus, 'N', 1, null)) = 0\n  )\n   ) tt\n  where\n   tt.rn = 1\n  union all\n  select\n   t.jobid,\n   t.tellercode,\n   t.jobname,\n   t.jobstatus,\n   t.jobstartpersname,\n   t.jobpriorpersname,\n   t.jobtype,\n   t.createtime,\n   t.tranname,\n   t.issucc,\n   t.tranprop,\n   t.trandata,\n   t.jbjg,\n   t.jbgy,\n   t.ldlcid\n  from\n   jobinfo_his t,\n   businodeinst t1,\n   busiflowinst t2\n  where\n   t.jobid = t1.nodeinstid\n   and t1.flowinstid = t2.flowinstid\n   and t2.status = '1'\n   and t.jobstatus = 'O'\n  )\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select count(*) from (select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid from (select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid, row_number() over (partition by t.jobid order by t.createtime desc) as rn from jobinfo_his t where t.jobid like 'A%' and exists (select 1 from jobinfo_his where jobid = t.jobid and jobstatus = 'O') and not exists (select 1 from jobinfo_his where jobid = t.jobid and jobstatus = 'N')) where rn = 1 union all select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid from jobinfo_his t inner join businodeinst t1 on t.jobid = t1.nodeinstid inner join busiflowinst t2 on t1.flowinstid = t2.flowinstid where t2.status = '1' and t.jobstatus = 'O')"
                    }
                ]
            },
            {
                "case_id": "30",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"30\", \"db_type\": \"oracle\", \"description\": \"此改写的核心是将原SQL中针对nortran表的7个独立子查询(n1-n7)和1个去重子查询(z)通过CTE的GROUP BY + MAX + CASE WHEN技术合并。原SQL中每个子查询都有WHERE条件过滤不同的nortran_aufd_code，改写后通过CASE WHEN在单次扫描中同时提取所有需要的字段值，然后用MAX聚合选择每个transaction的值。这种行列转换技术将EAV(Entity-Attribute-Value)模型的多行数据透视为宽表的单行数据。同时，将nobtran的过滤条件前置，减少JOIN时的数据量。这种改写方式在OLAP场景中常用于优化维度属性的多次JOIN。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE SEQUENCE nobtran_seq; CREATE TABLE nobtran (nobtran_id NUMBER PRIMARY KEY, nobtran_transaction_no NUMBER NOT NULL, nobtran_acat_code VARCHAR2(20), nobtran_effective_date DATE, nobtran_trans_status_ind VARCHAR2(1), nobtran_pidm NUMBER NOT NULL, nobtran_apply_ind VARCHAR2(1) DEFAULT 'N'); CREATE OR REPLACE TRIGGER nobtran_bi BEFORE INSERT ON nobtran FOR EACH ROW BEGIN IF :NEW.nobtran_id IS NULL THEN SELECT nobtran_seq.NEXTVAL INTO :NEW.nobtran_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nobtran_acat_code ON nobtran(nobtran_acat_code);\", \"CREATE INDEX idx_nobtran_pidm ON nobtran(nobtran_pidm);\", \"CREATE INDEX idx_nobtran_transaction_no ON nobtran(nobtran_transaction_no);\", \"CREATE INDEX idx_nobtran_status ON nobtran(nobtran_trans_status_ind);\", \"CREATE INDEX idx_nobtran_apply_ind ON nobtran(nobtran_apply_ind);\", \"CREATE SEQUENCE spriden_seq; CREATE TABLE spriden (spriden_pidm NUMBER PRIMARY KEY, spriden_id VARCHAR2(50) NOT NULL, spriden_last_name VARCHAR2(100) NOT NULL, spriden_first_name VARCHAR2(100), spriden_change_ind VARCHAR2(1)); CREATE OR REPLACE TRIGGER spriden_bi BEFORE INSERT ON spriden FOR EACH ROW BEGIN IF :NEW.spriden_pidm IS NULL THEN SELECT spriden_seq.NEXTVAL INTO :NEW.spriden_pidm FROM DUAL; END IF; END;\", \"CREATE INDEX idx_spriden_change_ind ON spriden(spriden_change_ind);\", \"CREATE SEQUENCE norrout_seq; CREATE TABLE norrout (norrout_id NUMBER PRIMARY KEY, norrout_transaction_no NUMBER NOT NULL, norrout_queue_status_ind VARCHAR2(1), norrout_level_no NUMBER); CREATE OR REPLACE TRIGGER norrout_bi BEFORE INSERT ON norrout FOR EACH ROW BEGIN IF :NEW.norrout_id IS NULL THEN SELECT norrout_seq.NEXTVAL INTO :NEW.norrout_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_norrout_transaction_no ON norrout(norrout_transaction_no);\", \"CREATE INDEX idx_norrout_level_no ON norrout(norrout_level_no);\", \"CREATE INDEX idx_norrout_queue_status ON norrout(norrout_queue_status_ind);\", \"CREATE SEQUENCE pebempl_seq; CREATE TABLE pebempl (pebempl_pidm NUMBER PRIMARY KEY, pebempl_ecls_code VARCHAR2(10) NOT NULL, pebempl_current_hire_date DATE); CREATE OR REPLACE TRIGGER pebempl_bi BEFORE INSERT ON pebempl FOR EACH ROW BEGIN IF :NEW.pebempl_pidm IS NULL THEN SELECT pebempl_seq.NEXTVAL INTO :NEW.pebempl_pidm FROM DUAL; END IF; END;\", \"CREATE INDEX idx_pebempl_ecls_code ON pebempl(pebempl_ecls_code);\", \"CREATE SEQUENCE nortran_seq; CREATE TABLE nortran (nortran_id NUMBER PRIMARY KEY, nortran_transaction_no NUMBER NOT NULL, nortran_apty_code VARCHAR2(20), nortran_aufd_code VARCHAR2(50) NOT NULL, nortran_value VARCHAR2(200), nortran_posn VARCHAR2(50)); CREATE OR REPLACE TRIGGER nortran_bi BEFORE INSERT ON nortran FOR EACH ROW BEGIN IF :NEW.nortran_id IS NULL THEN SELECT nortran_seq.NEXTVAL INTO :NEW.nortran_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nortran_transaction_no ON nortran(nortran_transaction_no);\", \"CREATE INDEX idx_nortran_aufd_code ON nortran(nortran_aufd_code);\", \"CREATE INDEX idx_nortran_apty_code ON nortran(nortran_apty_code);\", \"CREATE SEQUENCE nortern_seq; CREATE TABLE nortern (nortern_id NUMBER PRIMARY KEY, nortern_transaction_no NUMBER NOT NULL, nortern_effective_date DATE, nortern_earn_code VARCHAR2(20), nortern_hrs NUMBER(10,2), nortern_special_rate NUMBER(15,2)); CREATE OR REPLACE TRIGGER nortern_bi BEFORE INSERT ON nortern FOR EACH ROW BEGIN IF :NEW.nortern_id IS NULL THEN SELECT nortern_seq.NEXTVAL INTO :NEW.nortern_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nortern_transaction_no ON nortern(nortern_transaction_no);\"], \"sql\": \"select s.spriden_id EID,\\n  s.spriden_last_name ||', '||s.spriden_first_name \\\"NAME\\\",\\n  b.nobtran_transaction_no \\\"TRANS NO.\\\",\\n  z.nortran_posn \\\"POSN NO\\\",\\n  b.nobtran_effective_date \\\"QUERY DATE\\\", \\n  b.nobtran_acat_code \\\"ACAT CODE\\\",\\n  n1.nortran_value \\\"CURRENT HIRE DATE\\\",\\n  n2.nortran_value \\\"BEGIN PERSONNEL DATE\\\",\\n  n3.nortran_value \\\"SALARY GROUP\\\",\\n  n4.nortran_value \\\"APPOINTMENT PERCENT\\\",\\n  n5.nortran_value \\\"ANNUAL SALARY\\\",\\n  t1.nortern_effective_date \\\"PAY DATA EFFECTIVE DATE\\\",\\n  t1.nortern_earn_code \\\"PAY DATA EARNINGS\\\",\\n  t1.nortern_hrs \\\"PAY DATA HOURS\\\",\\n  t1.nortern_special_rate \\\"PAY DATA SPECIAL RATE\\\",\\n  n6.nortran_value \\\"END JOB EFFECTIVE DATE\\\",\\n  n7.nortran_value \\\"END PERSONNEL DATE\\\"\\n   ,case b.nobtran_trans_status_ind\\n   when 'A' then 'Approved'\\n   when 'C' then 'Completed'\\n   when 'V' then 'Voided' \\n   when 'D' then 'Disapproved'\\n   when 'R' then 'Return for Correction'\\n   when 'P' then 'Pending'\\n   when 'W' then 'Waiting'\\n   when 'T' then 'Partially Completed'\\n   when 'N' then 'Cancelled'\\n   when 'U' then 'Superuser Update'\\n  end trans_status   \\n  ,case r.norrout_queue_status_ind\\n   when 'A' then 'Approved by that Approver'\\n   when 'D' then 'Disapproved'\\n   when 'F' then 'FYI'\\n   when 'I' then 'In Queue'\\n   when 'K' then 'Acknowledged'\\n   when 'L' then 'Applied by Applier'\\n   when 'M' then 'More Information'\\n   when 'O' then 'Overridden'\\n   when 'P' then 'Pending Action by Approver/Applier '\\n   when 'Q' then 'Removed from Queue'\\n   when 'R' then 'Return for Correction'\\n  end queue_status\\n  ,r.norrout_level_no\\n  \\n\\n  from nobtran b,spriden s, norrout r, pebempl pp, /*nbrjobs nbr,*/\\n  (select nc.nortran_transaction_no,nc.nortran_apty_code,nc.nortran_aufd_code,nc.nortran_value\\n  from nortran nc\\n   where nc.nortran_aufd_code = 'PEBEMPL_CURRENT_HIRE_DATE'\\n  ) n1, /* Current Hire Date */\\n  (select nb.nortran_transaction_no,nb.nortran_apty_code,nb.nortran_aufd_code,nb.nortran_value\\n  from nortran nb\\n   where nb.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' \\n  ) n2,  /*Begin Personnnel Date*/ \\n  (select ns.nortran_transaction_no,ns.nortran_apty_code,ns.nortran_aufd_code,ns.nortran_value\\n  from nortran ns\\n   where ns.nortran_aufd_code = 'NBRJOBS_SGRP_CODE'\\n   ) n3, /* Salary Group */\\n  (select na.nortran_transaction_no,na.nortran_apty_code,na.nortran_aufd_code,na.nortran_value\\n  from nortran na\\n   where na.nortran_aufd_code = 'NBRJOBS_APPT_PCT'\\n  ) n4, /*Appointment Percent*/ \\n  (select nu.nortran_transaction_no,nu.nortran_apty_code,nu.nortran_aufd_code,nu.nortran_value\\n  from nortran nu\\n   where nu.nortran_aufd_code = 'NBRJOBS_ANN_SALARY'\\n  ) n5, /*Annual Salary*/\\n  (select nj.nortran_transaction_no,nj.nortran_apty_code,nj.nortran_aufd_code,nj.nortran_value\\n  from nortran nj\\n   where nj.nortran_aufd_code = 'NBRJOBS_EFFECTIVE_DATE'  \\n  and nj.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n6,  /*End Job Effective Date*/\\n  (select np.nortran_transaction_no,np.nortran_apty_code,np.nortran_aufd_code,np.nortran_value\\n  from nortran np\\n   where np.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE'  \\n  and np.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n7,  /*End Personnel Date*/\\n\\n  (select t.nortern_transaction_no,t.nortern_effective_date,t.nortern_earn_code,\\n   t.nortern_hrs, t.nortern_special_rate\\n  from nortern t) t1 \\n\\n   ,(select unique zz.nortran_transaction_no,zz.nortran_posn\\n  from nortran zz\\n   where zz.nortran_posn is not null\\n  ) z\\n\\n where b.nobtran_acat_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') /*employee*/\\n  /*waiting,completed,partially completedc,ancelled,supperuser update */\\n  /* and nobtran_trans_status_ind in ('W','C','T','U') */\\n   and b.nobtran_pidm = s.spriden_pidm\\n   and s.spriden_change_ind is null\\n   \\n   and b.nobtran_transaction_no = t1.nortern_transaction_no(+) /*Pay Data*/\\n   \\n   and b.nobtran_transaction_no = n1.nortran_transaction_no(+) /*Current Hire Date*/\\n   \\n   and b.nobtran_transaction_no = n2.nortran_transaction_no(+) /*Begin Personnnel Date*/\\n   \\n   and b.nobtran_transaction_no = n3.nortran_transaction_no(+) /*Salary Group*/\\n   \\n   and b.nobtran_transaction_no = n4.nortran_transaction_no(+) /*Appointment Percent*/\\n   \\n   and b.nobtran_transaction_no = n5.nortran_transaction_no(+) /*Annual Salary*/\\n   \\n   and b.nobtran_transaction_no = n6.nortran_transaction_no(+) /*End Job Effective Date*/\\n   \\n   and b.nobtran_transaction_no = n7.nortran_transaction_no(+) /*End Personnel Date*/\\n   \\n   and nobtran_transaction_no = r.norrout_transaction_no(+)\\n   --get all queue status\\n   /*and r.norrout_queue_status_ind = 'A'*/\\n   and r.norrout_level_no = 90 /* Pending HR approval Queue */\\n   -- not applied yet\\n   and b.nobtran_apply_ind = 'N' /*Applied ePAFs will not be listed*/\\n   --HR does not care about voided ePAFs\\n   and nobtran_trans_status_ind <> 'V'\\n   --get posn\\n   and b.nobtran_transaction_no = z.nortran_transaction_no\\n   and r.norrout_queue_status_ind <> 'A'\\n  -- exclude student\\n   and s.spriden_pidm = pp.pebempl_pidm\\n   and pp.pebempl_ecls_code not in ('RE','FW','GS','MW')\\n\\n   order by 3\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t68442\\t220696\\t81657520\\t10388402242\\t68160\\n1\\t  MERGE JOIN OUTER \\t68442\\t220696\\t81657520\\t10388402242\\t68160\\n2\\t  MERGE JOIN  \\t61068\\t220696\\t77243600\\t9073000336\\t60822\\n3\\t   MERGE JOIN OUTER \\t59624\\t1072825\\t366906150\\t8593654179\\t59391\\n4\\t  MERGE JOIN  \\t55673\\t1000048\\t302014496\\t8042006798\\t55455\\n5\\t  MERGE JOIN OUTER \\t40155\\t875042\\t236261340\\t5632420040\\t40002\\n6\\t   MERGE JOIN OUTER \\t36204\\t815681\\t187606630\\t5082114259\\t36066\\n7\\t  MERGE JOIN OUTER \\t32442\\t760347\\t149028012\\t4563228883\\t32318\\n8\\t  MERGE JOIN OUTER \\t28680\\t708767\\t114820254\\t4044718907\\t28570\\n9\\t   MERGE JOIN OUTER \\t24918\\t660686\\t84567808\\t3526558831\\t24822\\n10\\t  MERGE JOIN OUTER \\t21156\\t615866\\t57891404\\t3008724855\\t21074\\n11\\t  SORT JOIN \\t17394\\t574088\\t34445280\\t2491195079\\t17326\\n12\\t   HASH JOIN  \\t9138\\t574088\\t34445280\\t1827947896\\t9088\\n13\\t  HASH JOIN  \\t4697\\t656100\\t23619600\\t973767459\\t4671\\n14\\t  TABLE ACCESS FULL PEBEMPL\\t794\\t656100\\t3936600\\t362530962\\t784\\n15\\t  TABLE ACCESS FULL SPRIDEN\\t1351\\t1000000\\t30000000\\t285272492\\t1343\\n16\\t  TABLE ACCESS FULL NOBTRAN\\t1454\\t875000\\t21000000\\t548613482\\t1439\\n17\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n18\\t   TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n19\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n20\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n21\\t   SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n22\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n23\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n24\\t   TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n25\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n26\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n27\\t   SORT JOIN \\t3951\\t166667\\t6666680\\t544369681\\t3936\\n28\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t6666680\\t350105675\\t2236\\n29\\t  SORT JOIN \\t15518\\t1000000\\t32000000\\t2409581958\\t15453\\n30\\t   VIEW  \\t6805\\t1000000\\t32000000\\t1336011571\\t6769\\n31\\t  HASH UNIQUE \\t6805\\t1000000\\t12000000\\t1336011571\\t6769\\n32\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t1000000\\t12000000\\t328759001\\t2236\\n33\\t  SORT JOIN \\t3951\\t166667\\t6666680\\t544369681\\t3936\\n34\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t6666680\\t350105675\\t2236\\n35\\t   SORT JOIN \\t1444\\t180000\\t1440000\\t479346156\\t1431\\n36\\t  TABLE ACCESS FULL NORROUT\\t792\\t180000\\t1440000\\t290580962\\t784\\n37\\t  SORT JOIN \\t7374\\t1000000\\t20000000\\t1315401906\\t7338\\n38\\t   TABLE ACCESS FULL NORTERN\\t1304\\t1000000\\t20000000\\t284040483\\t1296\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE nobtran_seq; CREATE TABLE nobtran (nobtran_id NUMBER PRIMARY KEY, nobtran_transaction_no NUMBER NOT NULL, nobtran_acat_code VARCHAR2(20), nobtran_effective_date DATE, nobtran_trans_status_ind VARCHAR2(1), nobtran_pidm NUMBER NOT NULL, nobtran_apply_ind VARCHAR2(1) DEFAULT 'N'); CREATE OR REPLACE TRIGGER nobtran_bi BEFORE INSERT ON nobtran FOR EACH ROW BEGIN IF :NEW.nobtran_id IS NULL THEN SELECT nobtran_seq.NEXTVAL INTO :NEW.nobtran_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nobtran_acat_code ON nobtran(nobtran_acat_code);\nCREATE INDEX idx_nobtran_pidm ON nobtran(nobtran_pidm);\nCREATE INDEX idx_nobtran_transaction_no ON nobtran(nobtran_transaction_no);\nCREATE INDEX idx_nobtran_status ON nobtran(nobtran_trans_status_ind);\nCREATE INDEX idx_nobtran_apply_ind ON nobtran(nobtran_apply_ind);\nCREATE SEQUENCE spriden_seq; CREATE TABLE spriden (spriden_pidm NUMBER PRIMARY KEY, spriden_id VARCHAR2(50) NOT NULL, spriden_last_name VARCHAR2(100) NOT NULL, spriden_first_name VARCHAR2(100), spriden_change_ind VARCHAR2(1)); CREATE OR REPLACE TRIGGER spriden_bi BEFORE INSERT ON spriden FOR EACH ROW BEGIN IF :NEW.spriden_pidm IS NULL THEN SELECT spriden_seq.NEXTVAL INTO :NEW.spriden_pidm FROM DUAL; END IF; END;\nCREATE INDEX idx_spriden_change_ind ON spriden(spriden_change_ind);\nCREATE SEQUENCE norrout_seq; CREATE TABLE norrout (norrout_id NUMBER PRIMARY KEY, norrout_transaction_no NUMBER NOT NULL, norrout_queue_status_ind VARCHAR2(1), norrout_level_no NUMBER); CREATE OR REPLACE TRIGGER norrout_bi BEFORE INSERT ON norrout FOR EACH ROW BEGIN IF :NEW.norrout_id IS NULL THEN SELECT norrout_seq.NEXTVAL INTO :NEW.norrout_id FROM DUAL; END IF; END;\nCREATE INDEX idx_norrout_transaction_no ON norrout(norrout_transaction_no);\nCREATE INDEX idx_norrout_level_no ON norrout(norrout_level_no);\nCREATE INDEX idx_norrout_queue_status ON norrout(norrout_queue_status_ind);\nCREATE SEQUENCE pebempl_seq; CREATE TABLE pebempl (pebempl_pidm NUMBER PRIMARY KEY, pebempl_ecls_code VARCHAR2(10) NOT NULL, pebempl_current_hire_date DATE); CREATE OR REPLACE TRIGGER pebempl_bi BEFORE INSERT ON pebempl FOR EACH ROW BEGIN IF :NEW.pebempl_pidm IS NULL THEN SELECT pebempl_seq.NEXTVAL INTO :NEW.pebempl_pidm FROM DUAL; END IF; END;\nCREATE INDEX idx_pebempl_ecls_code ON pebempl(pebempl_ecls_code);\nCREATE SEQUENCE nortran_seq; CREATE TABLE nortran (nortran_id NUMBER PRIMARY KEY, nortran_transaction_no NUMBER NOT NULL, nortran_apty_code VARCHAR2(20), nortran_aufd_code VARCHAR2(50) NOT NULL, nortran_value VARCHAR2(200), nortran_posn VARCHAR2(50)); CREATE OR REPLACE TRIGGER nortran_bi BEFORE INSERT ON nortran FOR EACH ROW BEGIN IF :NEW.nortran_id IS NULL THEN SELECT nortran_seq.NEXTVAL INTO :NEW.nortran_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nortran_transaction_no ON nortran(nortran_transaction_no);\nCREATE INDEX idx_nortran_aufd_code ON nortran(nortran_aufd_code);\nCREATE INDEX idx_nortran_apty_code ON nortran(nortran_apty_code);\nCREATE SEQUENCE nortern_seq; CREATE TABLE nortern (nortern_id NUMBER PRIMARY KEY, nortern_transaction_no NUMBER NOT NULL, nortern_effective_date DATE, nortern_earn_code VARCHAR2(20), nortern_hrs NUMBER(10,2), nortern_special_rate NUMBER(15,2)); CREATE OR REPLACE TRIGGER nortern_bi BEFORE INSERT ON nortern FOR EACH ROW BEGIN IF :NEW.nortern_id IS NULL THEN SELECT nortern_seq.NEXTVAL INTO :NEW.nortern_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nortern_transaction_no ON nortern(nortern_transaction_no);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t68442\t220696\t81657520\t10388402242\t68160\n1\t  MERGE JOIN OUTER \t68442\t220696\t81657520\t10388402242\t68160\n2\t  MERGE JOIN  \t61068\t220696\t77243600\t9073000336\t60822\n3\t   MERGE JOIN OUTER \t59624\t1072825\t366906150\t8593654179\t59391\n4\t  MERGE JOIN  \t55673\t1000048\t302014496\t8042006798\t55455\n5\t  MERGE JOIN OUTER \t40155\t875042\t236261340\t5632420040\t40002\n6\t   MERGE JOIN OUTER \t36204\t815681\t187606630\t5082114259\t36066\n7\t  MERGE JOIN OUTER \t32442\t760347\t149028012\t4563228883\t32318\n8\t  MERGE JOIN OUTER \t28680\t708767\t114820254\t4044718907\t28570\n9\t   MERGE JOIN OUTER \t24918\t660686\t84567808\t3526558831\t24822\n10\t  MERGE JOIN OUTER \t21156\t615866\t57891404\t3008724855\t21074\n11\t  SORT JOIN \t17394\t574088\t34445280\t2491195079\t17326\n12\t   HASH JOIN  \t9138\t574088\t34445280\t1827947896\t9088\n13\t  HASH JOIN  \t4697\t656100\t23619600\t973767459\t4671\n14\t  TABLE ACCESS FULL PEBEMPL\t794\t656100\t3936600\t362530962\t784\n15\t  TABLE ACCESS FULL SPRIDEN\t1351\t1000000\t30000000\t285272492\t1343\n16\t  TABLE ACCESS FULL NOBTRAN\t1454\t875000\t21000000\t548613482\t1439\n17\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n18\t   TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n19\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n20\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n21\t   SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n22\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n23\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n24\t   TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n25\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n26\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n27\t   SORT JOIN \t3951\t166667\t6666680\t544369681\t3936\n28\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t6666680\t350105675\t2236\n29\t  SORT JOIN \t15518\t1000000\t32000000\t2409581958\t15453\n30\t   VIEW  \t6805\t1000000\t32000000\t1336011571\t6769\n31\t  HASH UNIQUE \t6805\t1000000\t12000000\t1336011571\t6769\n32\t  TABLE ACCESS FULL NORTRAN\t2245\t1000000\t12000000\t328759001\t2236\n33\t  SORT JOIN \t3951\t166667\t6666680\t544369681\t3936\n34\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t6666680\t350105675\t2236\n35\t   SORT JOIN \t1444\t180000\t1440000\t479346156\t1431\n36\t  TABLE ACCESS FULL NORROUT\t792\t180000\t1440000\t290580962\t784\n37\t  SORT JOIN \t7374\t1000000\t20000000\t1315401906\t7338\n38\t   TABLE ACCESS FULL NORTERN\t1304\t1000000\t20000000\t284040483\t1296\n\n## Original SQL:\nselect s.spriden_id EID,\n  s.spriden_last_name ||', '||s.spriden_first_name \"NAME\",\n  b.nobtran_transaction_no \"TRANS NO.\",\n  z.nortran_posn \"POSN NO\",\n  b.nobtran_effective_date \"QUERY DATE\", \n  b.nobtran_acat_code \"ACAT CODE\",\n  n1.nortran_value \"CURRENT HIRE DATE\",\n  n2.nortran_value \"BEGIN PERSONNEL DATE\",\n  n3.nortran_value \"SALARY GROUP\",\n  n4.nortran_value \"APPOINTMENT PERCENT\",\n  n5.nortran_value \"ANNUAL SALARY\",\n  t1.nortern_effective_date \"PAY DATA EFFECTIVE DATE\",\n  t1.nortern_earn_code \"PAY DATA EARNINGS\",\n  t1.nortern_hrs \"PAY DATA HOURS\",\n  t1.nortern_special_rate \"PAY DATA SPECIAL RATE\",\n  n6.nortran_value \"END JOB EFFECTIVE DATE\",\n  n7.nortran_value \"END PERSONNEL DATE\"\n   ,case b.nobtran_trans_status_ind\n   when 'A' then 'Approved'\n   when 'C' then 'Completed'\n   when 'V' then 'Voided' \n   when 'D' then 'Disapproved'\n   when 'R' then 'Return for Correction'\n   when 'P' then 'Pending'\n   when 'W' then 'Waiting'\n   when 'T' then 'Partially Completed'\n   when 'N' then 'Cancelled'\n   when 'U' then 'Superuser Update'\n  end trans_status   \n  ,case r.norrout_queue_status_ind\n   when 'A' then 'Approved by that Approver'\n   when 'D' then 'Disapproved'\n   when 'F' then 'FYI'\n   when 'I' then 'In Queue'\n   when 'K' then 'Acknowledged'\n   when 'L' then 'Applied by Applier'\n   when 'M' then 'More Information'\n   when 'O' then 'Overridden'\n   when 'P' then 'Pending Action by Approver/Applier '\n   when 'Q' then 'Removed from Queue'\n   when 'R' then 'Return for Correction'\n  end queue_status\n  ,r.norrout_level_no\n  \n\n  from nobtran b,spriden s, norrout r, pebempl pp, /*nbrjobs nbr,*/\n  (select nc.nortran_transaction_no,nc.nortran_apty_code,nc.nortran_aufd_code,nc.nortran_value\n  from nortran nc\n   where nc.nortran_aufd_code = 'PEBEMPL_CURRENT_HIRE_DATE'\n  ) n1, /* Current Hire Date */\n  (select nb.nortran_transaction_no,nb.nortran_apty_code,nb.nortran_aufd_code,nb.nortran_value\n  from nortran nb\n   where nb.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' \n  ) n2,  /*Begin Personnnel Date*/ \n  (select ns.nortran_transaction_no,ns.nortran_apty_code,ns.nortran_aufd_code,ns.nortran_value\n  from nortran ns\n   where ns.nortran_aufd_code = 'NBRJOBS_SGRP_CODE'\n   ) n3, /* Salary Group */\n  (select na.nortran_transaction_no,na.nortran_apty_code,na.nortran_aufd_code,na.nortran_value\n  from nortran na\n   where na.nortran_aufd_code = 'NBRJOBS_APPT_PCT'\n  ) n4, /*Appointment Percent*/ \n  (select nu.nortran_transaction_no,nu.nortran_apty_code,nu.nortran_aufd_code,nu.nortran_value\n  from nortran nu\n   where nu.nortran_aufd_code = 'NBRJOBS_ANN_SALARY'\n  ) n5, /*Annual Salary*/\n  (select nj.nortran_transaction_no,nj.nortran_apty_code,nj.nortran_aufd_code,nj.nortran_value\n  from nortran nj\n   where nj.nortran_aufd_code = 'NBRJOBS_EFFECTIVE_DATE'  \n  and nj.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n6,  /*End Job Effective Date*/\n  (select np.nortran_transaction_no,np.nortran_apty_code,np.nortran_aufd_code,np.nortran_value\n  from nortran np\n   where np.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE'  \n  and np.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n7,  /*End Personnel Date*/\n\n  (select t.nortern_transaction_no,t.nortern_effective_date,t.nortern_earn_code,\n   t.nortern_hrs, t.nortern_special_rate\n  from nortern t) t1 \n\n   ,(select unique zz.nortran_transaction_no,zz.nortran_posn\n  from nortran zz\n   where zz.nortran_posn is not null\n  ) z\n\n where b.nobtran_acat_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') /*employee*/\n  /*waiting,completed,partially completedc,ancelled,supperuser update */\n  /* and nobtran_trans_status_ind in ('W','C','T','U') */\n   and b.nobtran_pidm = s.spriden_pidm\n   and s.spriden_change_ind is null\n   \n   and b.nobtran_transaction_no = t1.nortern_transaction_no(+) /*Pay Data*/\n   \n   and b.nobtran_transaction_no = n1.nortran_transaction_no(+) /*Current Hire Date*/\n   \n   and b.nobtran_transaction_no = n2.nortran_transaction_no(+) /*Begin Personnnel Date*/\n   \n   and b.nobtran_transaction_no = n3.nortran_transaction_no(+) /*Salary Group*/\n   \n   and b.nobtran_transaction_no = n4.nortran_transaction_no(+) /*Appointment Percent*/\n   \n   and b.nobtran_transaction_no = n5.nortran_transaction_no(+) /*Annual Salary*/\n   \n   and b.nobtran_transaction_no = n6.nortran_transaction_no(+) /*End Job Effective Date*/\n   \n   and b.nobtran_transaction_no = n7.nortran_transaction_no(+) /*End Personnel Date*/\n   \n   and nobtran_transaction_no = r.norrout_transaction_no(+)\n   --get all queue status\n   /*and r.norrout_queue_status_ind = 'A'*/\n   and r.norrout_level_no = 90 /* Pending HR approval Queue */\n   -- not applied yet\n   and b.nobtran_apply_ind = 'N' /*Applied ePAFs will not be listed*/\n   --HR does not care about voided ePAFs\n   and nobtran_trans_status_ind <> 'V'\n   --get posn\n   and b.nobtran_transaction_no = z.nortran_transaction_no\n   and r.norrout_queue_status_ind <> 'A'\n  -- exclude student\n   and s.spriden_pidm = pp.pebempl_pidm\n   and pp.pebempl_ecls_code not in ('RE','FW','GS','MW')\n\n   order by 3\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH nt AS (SELECT nortran_transaction_no, MAX(CASE WHEN nortran_aufd_code='PEBEMPL_CURRENT_HIRE_DATE' THEN nortran_value END) n1_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_PERS_CHG_DATE' THEN nortran_value END) n2_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_SGRP_CODE' THEN nortran_value END) n3_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_APPT_PCT' THEN nortran_value END) n4_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_ANN_SALARY' THEN nortran_value END) n5_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_EFFECTIVE_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) n6_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_PERS_CHG_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) n7_val, MAX(CASE WHEN nortran_posn IS NOT NULL THEN nortran_posn END) z_posn FROM nortran GROUP BY nortran_transaction_no) SELECT s.spriden_id EID, s.spriden_last_name||', '||s.spriden_first_name \"NAME\", b.nobtran_transaction_no \"TRANS NO.\", nt.z_posn \"POSN NO\", b.nobtran_effective_date \"QUERY DATE\", b.nobtran_acat_code \"ACAT CODE\", nt.n1_val \"CURRENT HIRE DATE\", nt.n2_val \"BEGIN PERSONNEL DATE\", nt.n3_val \"SALARY GROUP\", nt.n4_val \"APPOINTMENT PERCENT\", nt.n5_val \"ANNUAL SALARY\", t1.nortern_effective_date \"PAY DATA EFFECTIVE DATE\", t1.nortern_earn_code \"PAY DATA EARNINGS\", t1.nortern_hrs \"PAY DATA HOURS\", t1.nortern_special_rate \"PAY DATA SPECIAL RATE\", nt.n6_val \"END JOB EFFECTIVE DATE\", nt.n7_val \"END PERSONNEL DATE\", CASE b.nobtran_trans_status_ind WHEN 'A' THEN 'Approved' WHEN 'C' THEN 'Completed' WHEN 'V' THEN 'Voided' WHEN 'D' THEN 'Disapproved' WHEN 'R' THEN 'Return for Correction' WHEN 'P' THEN 'Pending' WHEN 'W' THEN 'Waiting' WHEN 'T' THEN 'Partially Completed' WHEN 'N' THEN 'Cancelled' WHEN 'U' THEN 'Superuser Update' END trans_status, CASE r.norrout_queue_status_ind WHEN 'A' THEN 'Approved by that Approver' WHEN 'D' THEN 'Disapproved' WHEN 'F' THEN 'FYI' WHEN 'I' THEN 'In Queue' WHEN 'K' THEN 'Acknowledged' WHEN 'L' THEN 'Applied by Applier' WHEN 'M' THEN 'More Information' WHEN 'O' THEN 'Overridden' WHEN 'P' THEN 'Pending Action by Approver/Applier' WHEN 'Q' THEN 'Removed from Queue' WHEN 'R' THEN 'Return for Correction' END queue_status, r.norrout_level_no FROM nobtran b INNER JOIN spriden s ON b.nobtran_pidm=s.spriden_pidm AND s.spriden_change_ind IS NULL INNER JOIN pebempl pp ON s.spriden_pidm=pp.pebempl_pidm AND pp.pebempl_ecls_code NOT IN ('RE','FW','GS','MW') INNER JOIN nt ON b.nobtran_transaction_no=nt.nortran_transaction_no LEFT OUTER JOIN nortern t1 ON b.nobtran_transaction_no=t1.nortern_transaction_no LEFT OUTER JOIN norrout r ON b.nobtran_transaction_no=r.norrout_transaction_no AND r.norrout_level_no=90 WHERE b.nobtran_acat_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') AND b.nobtran_apply_ind='N' AND b.nobtran_trans_status_ind<>'V' AND (r.norrout_queue_status_ind IS NULL OR r.norrout_queue_status_ind<>'A') ORDER BY 3"
                    }
                ]
            },
            {
                "case_id": "31",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"31\", \"db_type\": \"oracle\", \"description\": \"本次改写是一个纯语法层面的变更，仅将派生表（子查询）的别名从't'改为't2'，并相应更新外层SELECT语句中的列引用（t.age→t2.age等）。这种改写不改变SQL的语义、执行逻辑或数据访问路径，对数据库优化器来说两个查询完全等价。从性能优化角度看，这不是一个有效的改写方案，因为它不涉及任何能够提升性能的技术手段，如索引利用、连接顺序调整、谓词下推、子查询展开等。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE SAPR3.BSIS (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BUZEI VARCHAR2(3) NOT NULL, HKONT VARCHAR2(10), DMBTR NUMBER(15,2), WAERS VARCHAR2(3), MONAT VARCHAR2(2), BLDAT VARCHAR2(8), CONSTRAINT pk_bsis PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR, BUZEI));\", \"CREATE INDEX idx_bsis_query ON SAPR3.BSIS(GJAHR, BUKRS, HKONT, MANDT, BUZEI, WAERS, MONAT, BLDAT);\", \"CREATE INDEX idx_bsis_join ON SAPR3.BSIS(BELNR, GJAHR, BUKRS);\", \"CREATE TABLE SAPR3.BKPF (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BLDAT VARCHAR2(8), CONSTRAINT pk_bkpf PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR));\"], \"sql\": \"SELECT\\n  t.age,\\n  CASE \\n  WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days'\\n  WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days'\\n  ELSE 'Above 7 Days'\\n  END AS age_bucket,\\n  t.amount_local,\\n  t.hkont AS gl_account,\\n  t.bukrs AS company_code\\nFROM (\\n  SELECT \\n  b.BUKRS,\\n  b.HKONT,\\n  b.DMBTR AS amount_local,\\n  (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age\\n  FROM (\\n  SELECT /*+ FIRST_ROWS(30) */\\n   BELNR, GJAHR, BUKRS, HKONT, DMBTR\\n  FROM SAPR3.BSIS\\n  WHERE GJAHR = '2025'\\n  AND BUKRS = '0100'\\n  AND HKONT = '0000895200'\\n  AND MANDT = '500'\\n  AND BUZEI = '002'\\n  AND WAERS = 'INR'\\n  AND MONAT = '01'\\n  AND BLDAT = '20240401'\\n  ) b\\n  JOIN SAPR3.BKPF k\\n   ON b.BELNR = k.BELNR\\n  AND b.GJAHR = k.GJAHR\\n  AND b.BUKRS = k.BUKRS\\n) t\\nORDER BY t.age;\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t4225\\t1\\t81\\t810400605\\t4203\\n1\\t  SORT ORDER BY \\t4225\\t1\\t81\\t810400605\\t4203\\n2\\t  HASH JOIN  \\t4224\\t1\\t81\\t773532036\\t4203\\n3\\t   NESTED LOOPS  \\t4224\\t1\\t81\\t773532036\\t4203\\n4\\t  NESTED LOOPS  \\t\\t\\t\\t\\t\\n5\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n6\\t   TABLE ACCESS FULL BSIS\\t2748\\t6289\\t327028\\t456661695\\t2736\\n7\\t  INDEX UNIQUE SCAN PK_BKPF\\t\\t\\t\\t\\t\\n8\\t  TABLE ACCESS BY INDEX ROWID BKPF\\t1475\\t1\\t29\\t311326990\\t1467\\n9\\t   TABLE ACCESS FULL BKPF\\t1475\\t40000\\t1160000\\t311326990\\t1467\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE SAPR3.BSIS (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BUZEI VARCHAR2(3) NOT NULL, HKONT VARCHAR2(10), DMBTR NUMBER(15,2), WAERS VARCHAR2(3), MONAT VARCHAR2(2), BLDAT VARCHAR2(8), CONSTRAINT pk_bsis PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR, BUZEI));\nCREATE INDEX idx_bsis_query ON SAPR3.BSIS(GJAHR, BUKRS, HKONT, MANDT, BUZEI, WAERS, MONAT, BLDAT);\nCREATE INDEX idx_bsis_join ON SAPR3.BSIS(BELNR, GJAHR, BUKRS);\nCREATE TABLE SAPR3.BKPF (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BLDAT VARCHAR2(8), CONSTRAINT pk_bkpf PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR));\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t4225\t1\t81\t810400605\t4203\n1\t  SORT ORDER BY \t4225\t1\t81\t810400605\t4203\n2\t  HASH JOIN  \t4224\t1\t81\t773532036\t4203\n3\t   NESTED LOOPS  \t4224\t1\t81\t773532036\t4203\n4\t  NESTED LOOPS  \t\t\t\t\t\n5\t  STATISTICS COLLECTOR  \t\t\t\t\t\n6\t   TABLE ACCESS FULL BSIS\t2748\t6289\t327028\t456661695\t2736\n7\t  INDEX UNIQUE SCAN PK_BKPF\t\t\t\t\t\n8\t  TABLE ACCESS BY INDEX ROWID BKPF\t1475\t1\t29\t311326990\t1467\n9\t   TABLE ACCESS FULL BKPF\t1475\t40000\t1160000\t311326990\t1467\n\n## Original SQL:\nSELECT\n  t.age,\n  CASE \n  WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days'\n  WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days'\n  ELSE 'Above 7 Days'\n  END AS age_bucket,\n  t.amount_local,\n  t.hkont AS gl_account,\n  t.bukrs AS company_code\nFROM (\n  SELECT \n  b.BUKRS,\n  b.HKONT,\n  b.DMBTR AS amount_local,\n  (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age\n  FROM (\n  SELECT /*+ FIRST_ROWS(30) */\n   BELNR, GJAHR, BUKRS, HKONT, DMBTR\n  FROM SAPR3.BSIS\n  WHERE GJAHR = '2025'\n  AND BUKRS = '0100'\n  AND HKONT = '0000895200'\n  AND MANDT = '500'\n  AND BUZEI = '002'\n  AND WAERS = 'INR'\n  AND MONAT = '01'\n  AND BLDAT = '20240401'\n  ) b\n  JOIN SAPR3.BKPF k\n   ON b.BELNR = k.BELNR\n  AND b.GJAHR = k.GJAHR\n  AND b.BUKRS = k.BUKRS\n) t\nORDER BY t.age;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT t.age, CASE WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days' WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days' ELSE 'Above 7 Days' END AS age_bucket, t.amount_local, t.hkont AS gl_account, t.bukrs AS company_code FROM (SELECT b.BUKRS, b.HKONT, b.DMBTR AS amount_local, (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age FROM (SELECT /*+ INDEX(BSIS idx_bsis_query) */ BELNR, GJAHR, BUKRS, HKONT, DMBTR, MANDT FROM SAPR3.BSIS WHERE GJAHR = '2025' AND BUKRS = '0100' AND HKONT = '0000895200' AND MANDT = '500' AND BUZEI = '002' AND WAERS = 'INR' AND MONAT = '01' AND BLDAT = '20240401') b JOIN SAPR3.BKPF k ON b.BELNR = k.BELNR AND b.GJAHR = k.GJAHR AND b.BUKRS = k.BUKRS AND b.MANDT = k.MANDT) t ORDER BY t.age;"
                    }
                ]
            },
            {
                "case_id": "32",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"32\", \"db_type\": \"postgresql\", \"description\": \"本次改写采用了经典的查询优化技术组合：\\n\\n1. **谓词下推（Predicate Pushdown）**：将out_date的过滤条件从最外层WHERE子句移到tmep_ip CTE内部。这样可以尽早过滤数据，减少CTE物化的数据量，虽然在本例中优化器已经将过滤推到了Parallel Seq Scan阶段，但显式下推使逻辑更清晰，且在某些复杂场景下能帮助优化器更好地生成执行计划。\\n\\n2. **投影裁剪（Column Pruning）**：在diagnosis_ranked子查询中，移除了不再需要的diagnosis_type_name字段。该字段仅用于窗口函数的排序，在rn=1筛选后就没有实际意义了，因此在WindowAgg之后立即裁剪，避免传递到上层的GroupAggregate和Materialize节点。\\n\\n3. **聚合维度优化**：diagnosis_end的GROUP BY从4个字段减少到3个字段。因为diagnosis_type_name在窗口函数排序后已被隐含使用（通过rn=1保证了每组只保留优先级最高的记录），在最终聚合时不需要再作为分组键。这减少了哈希表的键空间和比较开销。\\n\\n4. **逻辑等价性保证**：虽然进行了多处优化，但查询的核心逻辑保持不变：\\n   - 诊断类型的优先级排序规则完全一致\\n   - ROW_NUMBER()窗口函数的分区和排序逻辑相同\\n   - MAX聚合对diagnosis_flag分组的处理逻辑相同\\n   - 最终JOIN关联条件和结果集完全一致\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE his_temp_ip_patient_info (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, inpatient_name VARCHAR(100), age INTEGER, sex VARCHAR(10), in_date TIMESTAMP, out_date TIMESTAMP, times VARCHAR(20), person_type VARCHAR(50), patient_no VARCHAR(50), current_dept_code VARCHAR(50));\", \"CREATE INDEX idx_his_temp_ip_patient_info_register_no_times ON his_temp_ip_patient_info(register_no, times);\", \"CREATE INDEX idx_his_temp_ip_patient_info_out_date ON his_temp_ip_patient_info(out_date);\", \"CREATE TABLE his_temp_ip_settle (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, times VARCHAR(20) NOT NULL, total_cost DECIMAL(12,2));\", \"CREATE INDEX idx_his_temp_ip_settle_register_no_times ON his_temp_ip_settle(register_no, times);\", \"CREATE TABLE emr_temp_ip_patient_diagnosis (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, type VARCHAR(50), diagnosis_type_name VARCHAR(100), diagnosis_flag VARCHAR(1), diagnosis_code VARCHAR(50), diagnosis_name VARCHAR(200), diagnosis_no INTEGER, file_visit_type VARCHAR(10));\", \"CREATE INDEX idx_emr_temp_ip_patient_diagnosis_file_visit ON emr_temp_ip_patient_diagnosis(file_visit_type, inp_no, visit_id);\", \"CREATE INDEX idx_emr_temp_ip_patient_diagnosis_group ON emr_temp_ip_patient_diagnosis(inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag);\", \"CREATE TABLE emr_temp_ip_patient_operation (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, operation_code VARCHAR(50), operation_no INTEGER);\", \"CREATE INDEX idx_emr_temp_ip_patient_operation_inp_visit ON emr_temp_ip_patient_operation(inp_no, visit_id);\"], \"sql\": \"with tmep_ip as (\\n  select \\n  a.register_no as patientid, \\n  a.inpatient_name as patientname, \\n  a.age,\\n  a.sex as gender, \\n  date(a.in_date) as indate, \\n  date(a.out_date) as outdate,\\n  a.times as inhospitaltimes, \\n  a.person_type as persontype, \\n  a.patient_no as serialno,\\n  b.total_cost as medicalcost, \\n  'doctor' as entrymode, \\n  'remind' as defaulttab,\\n  a.current_dept_code as deptcode, \\n  '440100' as citycode \\n  from his_temp_ip_patient_info a \\n  left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times\\n),\\ndiagnosis as (\\n  select \\n  inp_no, \\n  visit_id as times, \\n  type, \\n  diagnosis_type_name,\\n  diagnosis_flag,\\n  case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes,\\n  case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes,\\n  case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names \\n  from emr_temp_ip_patient_diagnosis \\n  where file_visit_type = '2'\\n  group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag\\n),\\ndiagnosis_ranked as (\\n  select \\n  *,\\n  row_number() over (\\n   partition by inp_no, times, type \\n   order by \\n  case \\n  when type = '病历诊断' and diagnosis_type_name = '最后诊断' then 1\\n  when type = '病历诊断' and diagnosis_type_name = '初步诊断' then 2\\n  when type = '首页诊断' and diagnosis_type_name = '出院诊断' then 1\\n  when type = '首页诊断' and diagnosis_type_name = '门诊诊断' then 2\\n  else 3\\n  end\\n  ) as rn\\n  from diagnosis\\n),\\ndiagnosis_end as (\\n  select \\n  inp_no, \\n  times, \\n  type, \\n  diagnosis_type_name,\\n  max(case when diagnosis_flag = '1' then diagnosis_codes end) as diagnosis_codes,\\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_codes end) as chinese_diagnosis_codes,\\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_names end) as chinese_diagnosis_names\\n  from diagnosis_ranked\\n  where rn = 1\\n  group by inp_no, times, type, diagnosis_type_name\\n),\\noperations as (\\n  select \\n  inp_no, \\n  visit_id as times, \\n  string_agg(operation_code, ',' order by operation_no) as operation_codes \\n  from emr_temp_ip_patient_operation\\n  group by inp_no, visit_id \\n)\\nselect \\n  t.patientid, \\n  t.patientname, \\n  t.age,\\n  t.gender, \\n  t.indate, \\n  t.outdate, \\n  t.inhospitaltimes, \\n  d.type,\\n  d.diagnosis_codes as diagnosiscode,\\n  o.operation_codes as operationcode,\\n  t.medicalcost, \\n  t.persontype, \\n  t.entrymode, \\n  t.serialno, \\n  t.defaulttab,\\n  d.chinese_diagnosis_codes as chinesediagnosiscode,\\n  d.chinese_diagnosis_names as chinesediagnosename,\\n  t.deptcode, \\n  t.citycode \\nfrom tmep_ip t \\nleft join diagnosis_end d on t.patientid = d.inp_no and t.inhospitaltimes::varchar = d.times\\nleft join operations o on t.patientid = o.inp_no and t.inhospitaltimes::varchar = o.times\\nwhere t.outdate > '2025-01-01'\\norder by t.outdate desc\", \"explain\": \"QUERY PLAN\\nSort  (cost=445130.58..445963.91 rows=333333 width=308)\\n  Sort Key: (date(a.out_date)) DESC\\n  ->  Merge Left Join  (cost=64922.35..318848.93 rows=333333 width=308)\\n  Merge Cond: (((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))\\n  ->  Gather Merge  (cost=64668.41..197286.44 rows=333333 width=111)\\n  Workers Planned: 2\\n  ->  Merge Left Join  (cost=63668.38..157811.52 rows=138889 width=111)\\n  Merge Cond: (((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))\\n  ->  Sort  (cost=63667.28..64014.50 rows=138889 width=79)\\n  Sort Key: a.register_no, a.times\\n  ->  Parallel Hash Right Join  (cost=24279.33..45629.67 rows=138889 width=79)\\n  Hash Cond: (((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))\\n  ->  Parallel Seq Scan on his_temp_ip_settle b  (cost=0.00..11519.67 rows=416667 width=22)\\n  ->  Parallel Hash  (cost=20432.00..20432.00 rows=138889 width=73)\\n  ->  Parallel Seq Scan on his_temp_ip_patient_info a  (cost=0.00..20432.00 rows=138889 width=73)\\n  Filter: (date(out_date) > '2025-01-01'::date)\\n  ->  GroupAggregate  (cost=1.11..91601.88 rows=100000 width=44)\\n  Group Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\\n  ->  Incremental Sort  (cost=1.11..82851.88 rows=1000000 width=25)\\n  Sort Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id, emr_temp_ip_patient_operation.operation_no\\n  Presorted Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\\n  ->  Index Scan using idx_emr_temp_ip_patient_operation_inp_visit on emr_temp_ip_patient_operation  (cost=0.42..51742.24 rows=1000000 width=25)\\n  ->  Materialize  (cost=253.95..118226.71 rows=489 width=121)\\n  ->  GroupAggregate  (cost=253.95..118220.60 rows=489 width=134)\\n  Group Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\\n  ->  Incremental Sort  (cost=253.95..118203.21 rows=500 width=136)\\n  Sort Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\\n  Presorted Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type\\n  ->  Subquery Scan on diagnosis_ranked  (cost=12.28..118181.09 rows=500 width=136)\\n  Filter: (diagnosis_ranked.rn = 1)\\n  ->  WindowAgg  (cost=12.28..116931.09 rows=100000 width=148)\\n  Run Condition: (row_number() OVER (?) <= 1)\\n  ->  Incremental Sort  (cost=12.28..112681.09 rows=100000 width=140)\\n  Sort Key: diagnosis.inp_no, diagnosis.times, diagnosis.type, (CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\\n  Presorted Key: diagnosis.inp_no, diagnosis.times, diagnosis.type\\n  ->  Subquery Scan on diagnosis  (cost=1.16..109570.13 rows=100000 width=140)\\n  ->  GroupAggregate  (cost=1.16..107570.13 rows=100000 width=136)\\n  Group Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag\\n  ->  Incremental Sort  (cost=1.16..87820.13 rows=1000000 width=76)\\n  Sort Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag, emr_temp_ip_patient_diagnosis.diagnosis_no\\n  Presorted Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id\\n  ->  Index Scan using idx_emr_temp_ip_patient_diagnosis_file_visit on emr_temp_ip_patient_diagnosis  (cost=0.42..56710.49 rows=1000000 width=76)\\n  Index Cond: ((file_visit_type)::text = '2'::text)\\nJIT:\\n  Functions: 59\\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 445130.58, 'Total Cost': 445963.91, 'Plan Rows': 333333, 'Plan Width': 308, 'Sort Key': ['(date(a.out_date)) DESC'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 64922.35, 'Total Cost': 318848.93, 'Plan Rows': 333333, 'Plan Width': 308, 'Inner Unique': False, 'Merge Cond': '(((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))', 'Plans': [{'Node Type': 'Gather Merge', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 64668.41, 'Total Cost': 197286.44, 'Plan Rows': 333333, 'Plan Width': 111, 'Workers Planned': 2, 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 63668.38, 'Total Cost': 157811.52, 'Plan Rows': 138889, 'Plan Width': 111, 'Inner Unique': True, 'Merge Cond': '(((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))', 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 63667.28, 'Total Cost': 64014.5, 'Plan Rows': 138889, 'Plan Width': 79, 'Sort Key': ['a.register_no', 'a.times'], 'Plans': [{'Node Type': 'Hash Join', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Join Type': 'Right', 'Startup Cost': 24279.33, 'Total Cost': 45629.67, 'Plan Rows': 138889, 'Plan Width': 79, 'Inner Unique': False, 'Hash Cond': '(((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_settle', 'Alias': 'b', 'Startup Cost': 0.0, 'Total Cost': 11519.67, 'Plan Rows': 416667, 'Plan Width': 22}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': True, 'Async Capable': False, 'Startup Cost': 20432.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_patient_info', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Filter': \\\"(date(out_date) > '2025-01-01'::date)\\\"}]}]}]}, {'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 91601.88, 'Plan Rows': 100000, 'Plan Width': 44, 'Group Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 82851.88, 'Plan Rows': 1000000, 'Plan Width': 25, 'Sort Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id', 'emr_temp_ip_patient_operation.operation_no'], 'Presorted Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_operation_inp_visit', 'Relation Name': 'emr_temp_ip_patient_operation', 'Alias': 'emr_temp_ip_patient_operation', 'Startup Cost': 0.42, 'Total Cost': 51742.24, 'Plan Rows': 1000000, 'Plan Width': 25}]}]}]}]}, {'Node Type': 'Materialize', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118226.71, 'Plan Rows': 489, 'Plan Width': 121, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118220.6, 'Plan Rows': 489, 'Plan Width': 134, 'Group Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118203.21, 'Plan Rows': 500, 'Plan Width': 136, 'Sort Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Presorted Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis_ranked', 'Startup Cost': 12.28, 'Total Cost': 118181.09, 'Plan Rows': 500, 'Plan Width': 136, 'Filter': '(diagnosis_ranked.rn = 1)', 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 116931.09, 'Plan Rows': 100000, 'Plan Width': 148, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 112681.09, 'Plan Rows': 100000, 'Plan Width': 140, 'Sort Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type', \\\"(CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\\\"], 'Presorted Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis', 'Startup Cost': 1.16, 'Total Cost': 109570.13, 'Plan Rows': 100000, 'Plan Width': 140, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 107570.13, 'Plan Rows': 100000, 'Plan Width': 136, 'Group Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 87820.13, 'Plan Rows': 1000000, 'Plan Width': 76, 'Sort Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag', 'emr_temp_ip_patient_diagnosis.diagnosis_no'], 'Presorted Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_diagnosis_file_visit', 'Relation Name': 'emr_temp_ip_patient_diagnosis', 'Alias': 'emr_temp_ip_patient_diagnosis', 'Startup Cost': 0.42, 'Total Cost': 56710.49, 'Plan Rows': 1000000, 'Plan Width': 76, 'Index Cond': \\\"((file_visit_type)::text = '2'::text)\\\"}]}]}]}]}]}]}]}]}]}]}]}, 'JIT': {'Functions': 59, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE his_temp_ip_patient_info (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, inpatient_name VARCHAR(100), age INTEGER, sex VARCHAR(10), in_date TIMESTAMP, out_date TIMESTAMP, times VARCHAR(20), person_type VARCHAR(50), patient_no VARCHAR(50), current_dept_code VARCHAR(50));\nCREATE INDEX idx_his_temp_ip_patient_info_register_no_times ON his_temp_ip_patient_info(register_no, times);\nCREATE INDEX idx_his_temp_ip_patient_info_out_date ON his_temp_ip_patient_info(out_date);\nCREATE TABLE his_temp_ip_settle (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, times VARCHAR(20) NOT NULL, total_cost DECIMAL(12,2));\nCREATE INDEX idx_his_temp_ip_settle_register_no_times ON his_temp_ip_settle(register_no, times);\nCREATE TABLE emr_temp_ip_patient_diagnosis (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, type VARCHAR(50), diagnosis_type_name VARCHAR(100), diagnosis_flag VARCHAR(1), diagnosis_code VARCHAR(50), diagnosis_name VARCHAR(200), diagnosis_no INTEGER, file_visit_type VARCHAR(10));\nCREATE INDEX idx_emr_temp_ip_patient_diagnosis_file_visit ON emr_temp_ip_patient_diagnosis(file_visit_type, inp_no, visit_id);\nCREATE INDEX idx_emr_temp_ip_patient_diagnosis_group ON emr_temp_ip_patient_diagnosis(inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag);\nCREATE TABLE emr_temp_ip_patient_operation (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, operation_code VARCHAR(50), operation_no INTEGER);\nCREATE INDEX idx_emr_temp_ip_patient_operation_inp_visit ON emr_temp_ip_patient_operation(inp_no, visit_id);\n\n## Explain Output in JSON:\nQUERY PLAN\nSort  (cost=445130.58..445963.91 rows=333333 width=308)\n  Sort Key: (date(a.out_date)) DESC\n  ->  Merge Left Join  (cost=64922.35..318848.93 rows=333333 width=308)\n  Merge Cond: (((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))\n  ->  Gather Merge  (cost=64668.41..197286.44 rows=333333 width=111)\n  Workers Planned: 2\n  ->  Merge Left Join  (cost=63668.38..157811.52 rows=138889 width=111)\n  Merge Cond: (((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))\n  ->  Sort  (cost=63667.28..64014.50 rows=138889 width=79)\n  Sort Key: a.register_no, a.times\n  ->  Parallel Hash Right Join  (cost=24279.33..45629.67 rows=138889 width=79)\n  Hash Cond: (((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))\n  ->  Parallel Seq Scan on his_temp_ip_settle b  (cost=0.00..11519.67 rows=416667 width=22)\n  ->  Parallel Hash  (cost=20432.00..20432.00 rows=138889 width=73)\n  ->  Parallel Seq Scan on his_temp_ip_patient_info a  (cost=0.00..20432.00 rows=138889 width=73)\n  Filter: (date(out_date) > '2025-01-01'::date)\n  ->  GroupAggregate  (cost=1.11..91601.88 rows=100000 width=44)\n  Group Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\n  ->  Incremental Sort  (cost=1.11..82851.88 rows=1000000 width=25)\n  Sort Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id, emr_temp_ip_patient_operation.operation_no\n  Presorted Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\n  ->  Index Scan using idx_emr_temp_ip_patient_operation_inp_visit on emr_temp_ip_patient_operation  (cost=0.42..51742.24 rows=1000000 width=25)\n  ->  Materialize  (cost=253.95..118226.71 rows=489 width=121)\n  ->  GroupAggregate  (cost=253.95..118220.60 rows=489 width=134)\n  Group Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\n  ->  Incremental Sort  (cost=253.95..118203.21 rows=500 width=136)\n  Sort Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\n  Presorted Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type\n  ->  Subquery Scan on diagnosis_ranked  (cost=12.28..118181.09 rows=500 width=136)\n  Filter: (diagnosis_ranked.rn = 1)\n  ->  WindowAgg  (cost=12.28..116931.09 rows=100000 width=148)\n  Run Condition: (row_number() OVER (?) <= 1)\n  ->  Incremental Sort  (cost=12.28..112681.09 rows=100000 width=140)\n  Sort Key: diagnosis.inp_no, diagnosis.times, diagnosis.type, (CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\n  Presorted Key: diagnosis.inp_no, diagnosis.times, diagnosis.type\n  ->  Subquery Scan on diagnosis  (cost=1.16..109570.13 rows=100000 width=140)\n  ->  GroupAggregate  (cost=1.16..107570.13 rows=100000 width=136)\n  Group Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag\n  ->  Incremental Sort  (cost=1.16..87820.13 rows=1000000 width=76)\n  Sort Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag, emr_temp_ip_patient_diagnosis.diagnosis_no\n  Presorted Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id\n  ->  Index Scan using idx_emr_temp_ip_patient_diagnosis_file_visit on emr_temp_ip_patient_diagnosis  (cost=0.42..56710.49 rows=1000000 width=76)\n  Index Cond: ((file_visit_type)::text = '2'::text)\nJIT:\n  Functions: 59\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 445130.58, 'Total Cost': 445963.91, 'Plan Rows': 333333, 'Plan Width': 308, 'Sort Key': ['(date(a.out_date)) DESC'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 64922.35, 'Total Cost': 318848.93, 'Plan Rows': 333333, 'Plan Width': 308, 'Inner Unique': False, 'Merge Cond': '(((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))', 'Plans': [{'Node Type': 'Gather Merge', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 64668.41, 'Total Cost': 197286.44, 'Plan Rows': 333333, 'Plan Width': 111, 'Workers Planned': 2, 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 63668.38, 'Total Cost': 157811.52, 'Plan Rows': 138889, 'Plan Width': 111, 'Inner Unique': True, 'Merge Cond': '(((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))', 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 63667.28, 'Total Cost': 64014.5, 'Plan Rows': 138889, 'Plan Width': 79, 'Sort Key': ['a.register_no', 'a.times'], 'Plans': [{'Node Type': 'Hash Join', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Join Type': 'Right', 'Startup Cost': 24279.33, 'Total Cost': 45629.67, 'Plan Rows': 138889, 'Plan Width': 79, 'Inner Unique': False, 'Hash Cond': '(((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_settle', 'Alias': 'b', 'Startup Cost': 0.0, 'Total Cost': 11519.67, 'Plan Rows': 416667, 'Plan Width': 22}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': True, 'Async Capable': False, 'Startup Cost': 20432.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_patient_info', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Filter': \"(date(out_date) > '2025-01-01'::date)\"}]}]}]}, {'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 91601.88, 'Plan Rows': 100000, 'Plan Width': 44, 'Group Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 82851.88, 'Plan Rows': 1000000, 'Plan Width': 25, 'Sort Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id', 'emr_temp_ip_patient_operation.operation_no'], 'Presorted Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_operation_inp_visit', 'Relation Name': 'emr_temp_ip_patient_operation', 'Alias': 'emr_temp_ip_patient_operation', 'Startup Cost': 0.42, 'Total Cost': 51742.24, 'Plan Rows': 1000000, 'Plan Width': 25}]}]}]}]}, {'Node Type': 'Materialize', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118226.71, 'Plan Rows': 489, 'Plan Width': 121, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118220.6, 'Plan Rows': 489, 'Plan Width': 134, 'Group Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118203.21, 'Plan Rows': 500, 'Plan Width': 136, 'Sort Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Presorted Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis_ranked', 'Startup Cost': 12.28, 'Total Cost': 118181.09, 'Plan Rows': 500, 'Plan Width': 136, 'Filter': '(diagnosis_ranked.rn = 1)', 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 116931.09, 'Plan Rows': 100000, 'Plan Width': 148, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 112681.09, 'Plan Rows': 100000, 'Plan Width': 140, 'Sort Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type', \"(CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\"], 'Presorted Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis', 'Startup Cost': 1.16, 'Total Cost': 109570.13, 'Plan Rows': 100000, 'Plan Width': 140, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 107570.13, 'Plan Rows': 100000, 'Plan Width': 136, 'Group Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 87820.13, 'Plan Rows': 1000000, 'Plan Width': 76, 'Sort Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag', 'emr_temp_ip_patient_diagnosis.diagnosis_no'], 'Presorted Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_diagnosis_file_visit', 'Relation Name': 'emr_temp_ip_patient_diagnosis', 'Alias': 'emr_temp_ip_patient_diagnosis', 'Startup Cost': 0.42, 'Total Cost': 56710.49, 'Plan Rows': 1000000, 'Plan Width': 76, 'Index Cond': \"((file_visit_type)::text = '2'::text)\"}]}]}]}]}]}]}]}]}]}]}]}, 'JIT': {'Functions': 59, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\n\n## Original SQL:\nwith tmep_ip as (\n  select \n  a.register_no as patientid, \n  a.inpatient_name as patientname, \n  a.age,\n  a.sex as gender, \n  date(a.in_date) as indate, \n  date(a.out_date) as outdate,\n  a.times as inhospitaltimes, \n  a.person_type as persontype, \n  a.patient_no as serialno,\n  b.total_cost as medicalcost, \n  'doctor' as entrymode, \n  'remind' as defaulttab,\n  a.current_dept_code as deptcode, \n  '440100' as citycode \n  from his_temp_ip_patient_info a \n  left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times\n),\ndiagnosis as (\n  select \n  inp_no, \n  visit_id as times, \n  type, \n  diagnosis_type_name,\n  diagnosis_flag,\n  case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes,\n  case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes,\n  case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names \n  from emr_temp_ip_patient_diagnosis \n  where file_visit_type = '2'\n  group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag\n),\ndiagnosis_ranked as (\n  select \n  *,\n  row_number() over (\n   partition by inp_no, times, type \n   order by \n  case \n  when type = '病历诊断' and diagnosis_type_name = '最后诊断' then 1\n  when type = '病历诊断' and diagnosis_type_name = '初步诊断' then 2\n  when type = '首页诊断' and diagnosis_type_name = '出院诊断' then 1\n  when type = '首页诊断' and diagnosis_type_name = '门诊诊断' then 2\n  else 3\n  end\n  ) as rn\n  from diagnosis\n),\ndiagnosis_end as (\n  select \n  inp_no, \n  times, \n  type, \n  diagnosis_type_name,\n  max(case when diagnosis_flag = '1' then diagnosis_codes end) as diagnosis_codes,\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_codes end) as chinese_diagnosis_codes,\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_names end) as chinese_diagnosis_names\n  from diagnosis_ranked\n  where rn = 1\n  group by inp_no, times, type, diagnosis_type_name\n),\noperations as (\n  select \n  inp_no, \n  visit_id as times, \n  string_agg(operation_code, ',' order by operation_no) as operation_codes \n  from emr_temp_ip_patient_operation\n  group by inp_no, visit_id \n)\nselect \n  t.patientid, \n  t.patientname, \n  t.age,\n  t.gender, \n  t.indate, \n  t.outdate, \n  t.inhospitaltimes, \n  d.type,\n  d.diagnosis_codes as diagnosiscode,\n  o.operation_codes as operationcode,\n  t.medicalcost, \n  t.persontype, \n  t.entrymode, \n  t.serialno, \n  t.defaulttab,\n  d.chinese_diagnosis_codes as chinesediagnosiscode,\n  d.chinese_diagnosis_names as chinesediagnosename,\n  t.deptcode, \n  t.citycode \nfrom tmep_ip t \nleft join diagnosis_end d on t.patientid = d.inp_no and t.inhospitaltimes::varchar = d.times\nleft join operations o on t.patientid = o.inp_no and t.inhospitaltimes::varchar = o.times\nwhere t.outdate > '2025-01-01'\norder by t.outdate desc\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "with filtered_ip as (select a.register_no, a.inpatient_name, a.age, a.sex, a.in_date, a.out_date, a.times, a.person_type, a.patient_no, a.current_dept_code, b.total_cost from his_temp_ip_patient_info a left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times where a.out_date >= '2025-01-02'::timestamp), diagnosis as (select inp_no, visit_id as times, type, diagnosis_type_name, diagnosis_flag, case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes, case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes, case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names from emr_temp_ip_patient_diagnosis where file_visit_type = '2' group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag), diagnosis_ranked as (select *, row_number() over (partition by inp_no, times, type order by case when type='病历诊断' and diagnosis_type_name='最后诊断' then 1 when type='病历诊断' and diagnosis_type_name='初步诊断' then 2 when type='首页诊断' and diagnosis_type_name='出院诊断' then 1 when type='首页诊断' and diagnosis_type_name='门诊诊断' then 2 else 3 end) as rn from diagnosis), diagnosis_final as (select inp_no, times, type, diagnosis_type_name, max(case when diagnosis_flag='1' then diagnosis_codes end) as diagnosis_codes, max(case when diagnosis_flag='0' then chinese_diagnosis_codes end) as chinese_diagnosis_codes, max(case when diagnosis_flag='0' then chinese_diagnosis_names end) as chinese_diagnosis_names from diagnosis_ranked where rn = 1 group by inp_no, times, type, diagnosis_type_name), operations as (select inp_no, visit_id as times, string_agg(operation_code, ',' order by operation_no) as operation_codes from emr_temp_ip_patient_operation group by inp_no, visit_id) select t.register_no as patientid, t.inpatient_name as patientname, t.age, t.sex as gender, date(t.in_date) as indate, date(t.out_date) as outdate, t.times as inhospitaltimes, d.type, d.diagnosis_codes as diagnosiscode, o.operation_codes as operationcode, t.total_cost as medicalcost, t.person_type as persontype, 'doctor' as entrymode, t.patient_no as serialno, 'remind' as defaulttab, d.chinese_diagnosis_codes as chinesediagnosiscode, d.chinese_diagnosis_names as chinesediagnosename, t.current_dept_code as deptcode, '440100' as citycode from filtered_ip t left join diagnosis_final d on t.register_no = d.inp_no and t.times = d.times left join operations o on t.register_no = o.inp_no and t.times = o.times order by t.out_date desc;"
                    }
                ]
            },
            {
                "case_id": "33",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"33\", \"db_type\": \"mysql\", \"description\": \"这次改写的核心思想是消除WHERE子句中的LEFT函数调用，因为函数作用于列会阻止索引使用。改写策略是将前缀匹配逻辑展开为21个具体的等值比较条件（对应字符串'745070056000500070090'的每个前缀）。每个条件形式为：(code_length = N AND CODE = 'prefix')。理论上，这种改写可以让优化器使用索引，因为CODE列现在是等值比较而非函数参数。然而实际效果适得其反，原因是：1) 条件数量过多（21个OR）导致评估开销增加；2) 每个条件仍需调用CHAR_LENGTH函数验证长度；3) MySQL对多OR条件的索引使用优化有限，最终仍选择全表扫描。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE t_org_architecture (ID INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(100), CODE VARCHAR(50), TYPE VARCHAR(50), principal VARCHAR(100), CATEGORY VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_code ON t_org_architecture(CODE);\"], \"sql\": \"SELECT \\n  ID, \\n  `NAME`, \\n  `CODE`, \\n  `TYPE`, \\n  principal, \\n  CATEGORY \\nFROM \\n  t_org_architecture \\nWHERE \\n  LEFT('745070056000500070090',  LENGTH(`CODE`)) = `CODE` \\nGROUP BY \\n  LENGTH(`CODE`);\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tSIMPLE\\tt_org_architecture\\t\\tALL\\tidx_code\\t\\t\\t\\t993209\\t10.0\\tUsing where; Using temporary\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"101257.36\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"using_filesort\\\": false,\\n   \\\"table\\\": {\\n   \\\"table_name\\\": \\\"t_org_architecture\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"idx_code\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 993209,\\n   \\\"rows_produced_per_join\\\": 99320,\\n   \\\"filtered\\\": \\\"10.00\\\",\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"91325.27\\\",\\n   \\\"eval_cost\\\": \\\"9932.09\\\",\\n   \\\"prefix_cost\\\": \\\"101257.36\\\",\\n   \\\"data_read_per_join\\\": \\\"134M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"ID\\\",\\n   \\\"NAME\\\",\\n   \\\"CODE\\\",\\n   \\\"TYPE\\\",\\n   \\\"principal\\\",\\n   \\\"CATEGORY\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(left('745070056000500070090',length(`test_db`.`t_org_architecture`.`CODE`)) = `test_db`.`t_org_architecture`.`CODE`)\\\"\\n   }\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE t_org_architecture (ID INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(100), CODE VARCHAR(50), TYPE VARCHAR(50), principal VARCHAR(100), CATEGORY VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_code ON t_org_architecture(CODE);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tSIMPLE\tt_org_architecture\t\tALL\tidx_code\t\t\t\t993209\t10.0\tUsing where; Using temporary\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"101257.36\"\n  },\n  \"grouping_operation\": {\n   \"using_temporary_table\": true,\n   \"using_filesort\": false,\n   \"table\": {\n   \"table_name\": \"t_org_architecture\",\n   \"access_type\": \"ALL\",\n   \"possible_keys\": [\n   \"idx_code\"\n   ],\n   \"rows_examined_per_scan\": 993209,\n   \"rows_produced_per_join\": 99320,\n   \"filtered\": \"10.00\",\n   \"cost_info\": {\n   \"read_cost\": \"91325.27\",\n   \"eval_cost\": \"9932.09\",\n   \"prefix_cost\": \"101257.36\",\n   \"data_read_per_join\": \"134M\"\n   },\n   \"used_columns\": [\n   \"ID\",\n   \"NAME\",\n   \"CODE\",\n   \"TYPE\",\n   \"principal\",\n   \"CATEGORY\"\n   ],\n   \"attached_condition\": \"(left('745070056000500070090',length(`test_db`.`t_org_architecture`.`CODE`)) = `test_db`.`t_org_architecture`.`CODE`)\"\n   }\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  ID, \n  `NAME`, \n  `CODE`, \n  `TYPE`, \n  principal, \n  CATEGORY \nFROM \n  t_org_architecture \nWHERE \n  LEFT('745070056000500070090',  LENGTH(`CODE`)) = `CODE` \nGROUP BY \n  LENGTH(`CODE`);\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT ID, NAME, CODE, TYPE, principal, CATEGORY FROM t_org_architecture WHERE CODE <= '745070056000500070090' AND LEFT('745070056000500070090', LENGTH(CODE)) = CODE GROUP BY LENGTH(CODE) ORDER BY NULL;"
                    }
                ]
            },
            {
                "case_id": "34",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"34\", \"db_type\": \"mysql\", \"description\": \"核心技术是将非Sargable条件(索引列上的函数)改写为Sargable条件(可利用索引的条件)。对日期列使用函数会导致索引失效，改用范围查询可以充分利用索引。同时修正了数据类型不匹配问题(Flag字段定义为CHAR但与整数比较)，并清理了冗余条件。这种改写在保证结果一致性的前提下，通过技术手段显著降低了查询开销\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE m_membermain (MebID INT PRIMARY KEY AUTO_INCREMENT COMMENT '会员ID', Flag CHAR(1) NOT NULL DEFAULT '1' COMMENT '标志位', MebType TINYINT NOT NULL COMMENT '会员类型', CreateTime DATETIME NOT NULL COMMENT '创建时间') ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_flag ON m_membermain(Flag);\", \"CREATE INDEX idx_mebtype ON m_membermain(MebType);\", \"CREATE INDEX idx_createtime ON m_membermain(CreateTime);\", \"CREATE INDEX idx_flag_mebtype_createtime ON m_membermain(Flag, MebType, CreateTime);\"], \"sql\": \"SELECT \\n  count(DISTINCT MebID) \\nFROM \\n  m_membermain mm \\nWHERE \\n  mm.Flag <> '0' \\n  AND mm.MebType IN (1, 2, 5, 6, 8) \\n  AND MebID IS NOT NULL \\n  AND substring(CreateTime, 1, 10) = '2025-09-02' \\nLIMIT \\n  1000;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tSIMPLE\\tmm\\t\\trange\\tPRIMARY,idx_flag,idx_mebtype,idx_createtime,idx_flag_mebtype_createtime\\tidx_flag_mebtype_createtime\\t4\\t\\t499246\\t100.0\\tUsing where; Using index\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"100062.45\\\"\\n  },\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"mm\\\",\\n   \\\"access_type\\\": \\\"range\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"PRIMARY\\\",\\n   \\\"idx_flag\\\",\\n   \\\"idx_mebtype\\\",\\n   \\\"idx_createtime\\\",\\n   \\\"idx_flag_mebtype_createtime\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_flag_mebtype_createtime\\\",\\n   \\\"used_key_parts\\\": [\\n   \\\"Flag\\\"\\n   ],\\n   \\\"key_length\\\": \\\"4\\\",\\n   \\\"rows_examined_per_scan\\\": 499246,\\n   \\\"rows_produced_per_join\\\": 499246,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"using_index\\\": true,\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"50137.85\\\",\\n   \\\"eval_cost\\\": \\\"49924.60\\\",\\n   \\\"prefix_cost\\\": \\\"100062.45\\\",\\n   \\\"data_read_per_join\\\": \\\"7M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"MebID\\\",\\n   \\\"Flag\\\",\\n   \\\"MebType\\\",\\n   \\\"CreateTime\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`mm`.`Flag` <> '0') and (`test_db`.`mm`.`MebType` in (1,2,5,6,8)) and (substr(`test_db`.`mm`.`CreateTime`,1,10) = '2025-09-02'))\\\"\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE m_membermain (MebID INT PRIMARY KEY AUTO_INCREMENT COMMENT '会员ID', Flag CHAR(1) NOT NULL DEFAULT '1' COMMENT '标志位', MebType TINYINT NOT NULL COMMENT '会员类型', CreateTime DATETIME NOT NULL COMMENT '创建时间') ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_flag ON m_membermain(Flag);\nCREATE INDEX idx_mebtype ON m_membermain(MebType);\nCREATE INDEX idx_createtime ON m_membermain(CreateTime);\nCREATE INDEX idx_flag_mebtype_createtime ON m_membermain(Flag, MebType, CreateTime);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tSIMPLE\tmm\t\trange\tPRIMARY,idx_flag,idx_mebtype,idx_createtime,idx_flag_mebtype_createtime\tidx_flag_mebtype_createtime\t4\t\t499246\t100.0\tUsing where; Using index\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"100062.45\"\n  },\n  \"table\": {\n   \"table_name\": \"mm\",\n   \"access_type\": \"range\",\n   \"possible_keys\": [\n   \"PRIMARY\",\n   \"idx_flag\",\n   \"idx_mebtype\",\n   \"idx_createtime\",\n   \"idx_flag_mebtype_createtime\"\n   ],\n   \"key\": \"idx_flag_mebtype_createtime\",\n   \"used_key_parts\": [\n   \"Flag\"\n   ],\n   \"key_length\": \"4\",\n   \"rows_examined_per_scan\": 499246,\n   \"rows_produced_per_join\": 499246,\n   \"filtered\": \"100.00\",\n   \"using_index\": true,\n   \"cost_info\": {\n   \"read_cost\": \"50137.85\",\n   \"eval_cost\": \"49924.60\",\n   \"prefix_cost\": \"100062.45\",\n   \"data_read_per_join\": \"7M\"\n   },\n   \"used_columns\": [\n   \"MebID\",\n   \"Flag\",\n   \"MebType\",\n   \"CreateTime\"\n   ],\n   \"attached_condition\": \"((`test_db`.`mm`.`Flag` <> '0') and (`test_db`.`mm`.`MebType` in (1,2,5,6,8)) and (substr(`test_db`.`mm`.`CreateTime`,1,10) = '2025-09-02'))\"\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  count(DISTINCT MebID) \nFROM \n  m_membermain mm \nWHERE \n  mm.Flag <> '0' \n  AND mm.MebType IN (1, 2, 5, 6, 8) \n  AND MebID IS NOT NULL \n  AND substring(CreateTime, 1, 10) = '2025-09-02' \nLIMIT \n  1000;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT count(DISTINCT MebID) FROM m_membermain mm WHERE mm.Flag <> '0' AND mm.MebType IN (1,2,5,6,8) AND CreateTime >= '2025-09-02' AND CreateTime < '2025-09-03'"
                    }
                ]
            },
            {
                "case_id": "35",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"35\", \"db_type\": \"mysql\", \"description\": \"这是一个典型的消除无用计算的优化案例。当外层查询只是COUNT(*)时，内层子查询中计算的所有列值（包括通过子查询计算的auditJobIdcounts）都不会影响最终结果。COUNT(*)只关心有多少行满足WHERE条件，而不关心这些行的具体内容。因此可以直接将内层子查询展开，删除所有不必要的列选择和子查询计算，只保留WHERE条件。这种改写消除了189504次依赖子查询执行、临时表物化和34个列的数据读取，大幅提升性能。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE hotel_price_adjustment (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), brand_code VARCHAR(50), brand_name VARCHAR(200), hotel_code VARCHAR(50), hotel_name VARCHAR(200), currency VARCHAR(10), category VARCHAR(50), rate_code VARCHAR(50), rate_name VARCHAR(200), price_array_type VARCHAR(50), price_array_code VARCHAR(50), price_array_sequence INT, price_array TEXT, price_array2 TEXT, date_segment VARCHAR(100), weeks VARCHAR(50), brand_maximum_price DECIMAL(18,2), brand_minimum_price DECIMAL(18,2), room_code VARCHAR(50), room_name VARCHAR(200), room_standard_price DECIMAL(18,2), pre_adjustment_price DECIMAL(18,2), adjusted_price DECIMAL(18,2), price_adjustment_range VARCHAR(50), occupancy INT, status VARCHAR(20), reason TEXT, approve_status VARCHAR(20), approve_reason TEXT, operator VARCHAR(100), create_time DATETIME, update_time DATETIME, CREATE_USER_ID BIGINT) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_hotel_code ON hotel_price_adjustment(HOTEL_CODE);\", \"CREATE INDEX idx_create_user_id ON hotel_price_adjustment(CREATE_USER_ID);\", \"CREATE INDEX idx_apply_id ON hotel_price_adjustment(apply_id);\", \"CREATE TABLE price_adjustment_audit_job (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), job_id VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_apply_id_job_id ON price_adjustment_audit_job(apply_id, job_id);\"], \"sql\": \"SELECT \\n  COUNT(*) \\nFROM \\n  (\\n  SELECT \\n   id, \\n   apply_id, \\n   brand_code, \\n   brand_name, \\n   hotel_code, \\n   hotel_name, \\n   currency, \\n   category, \\n   rate_code, \\n   rate_name, \\n   price_array_type, \\n   price_array_code, \\n   price_array_sequence, \\n   price_array, \\n   price_array2, \\n   date_segment, \\n   weeks, \\n   brand_maximum_price, \\n   brand_minimum_price, \\n   room_code, \\n   room_name, \\n   room_standard_price, \\n   pre_adjustment_price, \\n   adjusted_price, \\n   price_adjustment_range, \\n   occupancy, \\n   status, \\n   reason, \\n   approve_status, \\n   approve_reason, \\n   operator, \\n   create_time, \\n   update_time, \\n   CREATE_USER_ID, \\n   (\\n   SELECT \\n   count(paaj.id) \\n   FROM \\n   price_adjustment_audit_job paaj \\n   WHERE \\n   paaj.apply_id = pa1.apply_id \\n   AND paaj.job_id = '4_004'\\n   ) AS auditJobIdcounts \\n  FROM \\n   hotel_price_adjustment pa1 \\n  WHERE \\n   (\\n   HOTEL_CODE IN ('6199', 'JJXRSEH802967') \\n   OR CREATE_USER_ID = 289865\\n   )\\n  ) TOTAL;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t189504\\t100.0\\t\\n2\\tDERIVED\\tpa1\\t\\tALL\\tidx_hotel_code,idx_create_user_id\\t\\t\\t\\t947046\\t20.01\\tUsing where\\n3\\tDEPENDENT SUBQUERY\\tpaaj\\t\\tref\\tidx_apply_id_job_id\\tidx_apply_id_job_id\\t606\\ttest_db.pa1.apply_id,const\\t189\\t100.0\\tUsing index\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"21321.70\\\"\\n  },\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"TOTAL\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"rows_examined_per_scan\\\": 189504,\\n   \\\"rows_produced_per_join\\\": 189504,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"2371.30\\\",\\n   \\\"eval_cost\\\": \\\"18950.40\\\",\\n   \\\"prefix_cost\\\": \\\"21321.70\\\",\\n   \\\"data_read_per_join\\\": \\\"1G\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"id\\\",\\n   \\\"apply_id\\\",\\n   \\\"brand_code\\\",\\n   \\\"brand_name\\\",\\n   \\\"hotel_code\\\",\\n   \\\"hotel_name\\\",\\n   \\\"currency\\\",\\n   \\\"category\\\",\\n   \\\"rate_code\\\",\\n   \\\"rate_name\\\",\\n   \\\"price_array_type\\\",\\n   \\\"price_array_code\\\",\\n   \\\"price_array_sequence\\\",\\n   \\\"price_array\\\",\\n   \\\"price_array2\\\",\\n   \\\"date_segment\\\",\\n   \\\"weeks\\\",\\n   \\\"brand_maximum_price\\\",\\n   \\\"brand_minimum_price\\\",\\n   \\\"room_code\\\",\\n   \\\"room_name\\\",\\n   \\\"room_standard_price\\\",\\n   \\\"pre_adjustment_price\\\",\\n   \\\"adjusted_price\\\",\\n   \\\"price_adjustment_range\\\",\\n   \\\"occupancy\\\",\\n   \\\"status\\\",\\n   \\\"reason\\\",\\n   \\\"approve_status\\\",\\n   \\\"approve_reason\\\",\\n   \\\"operator\\\",\\n   \\\"create_time\\\",\\n   \\\"update_time\\\",\\n   \\\"CREATE_USER_ID\\\",\\n   \\\"auditJobIdcounts\\\"\\n   ],\\n   \\\"materialized_from_subquery\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"dependent\\\": false,\\n   \\\"cacheable\\\": true,\\n   \\\"query_block\\\": {\\n   \\\"select_id\\\": 2,\\n   \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"119328.41\\\"\\n   },\\n   \\\"table\\\": {\\n  \\\"table_name\\\": \\\"pa1\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_hotel_code\\\",\\n  \\\"idx_create_user_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 947046,\\n  \\\"rows_produced_per_join\\\": 189504,\\n  \\\"filtered\\\": \\\"20.01\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"100378.00\\\",\\n  \\\"eval_cost\\\": \\\"18950.41\\\",\\n  \\\"prefix_cost\\\": \\\"119328.41\\\",\\n  \\\"data_read_per_join\\\": \\\"1G\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"apply_id\\\",\\n  \\\"brand_code\\\",\\n  \\\"brand_name\\\",\\n  \\\"hotel_code\\\",\\n  \\\"hotel_name\\\",\\n  \\\"currency\\\",\\n  \\\"category\\\",\\n  \\\"rate_code\\\",\\n  \\\"rate_name\\\",\\n  \\\"price_array_type\\\",\\n  \\\"price_array_code\\\",\\n  \\\"price_array_sequence\\\",\\n  \\\"price_array\\\",\\n  \\\"price_array2\\\",\\n  \\\"date_segment\\\",\\n  \\\"weeks\\\",\\n  \\\"brand_maximum_price\\\",\\n  \\\"brand_minimum_price\\\",\\n  \\\"room_code\\\",\\n  \\\"room_name\\\",\\n  \\\"room_standard_price\\\",\\n  \\\"pre_adjustment_price\\\",\\n  \\\"adjusted_price\\\",\\n  \\\"price_adjustment_range\\\",\\n  \\\"occupancy\\\",\\n  \\\"status\\\",\\n  \\\"reason\\\",\\n  \\\"approve_status\\\",\\n  \\\"approve_reason\\\",\\n  \\\"operator\\\",\\n  \\\"create_time\\\",\\n  \\\"update_time\\\",\\n  \\\"CREATE_USER_ID\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`pa1`.`hotel_code` in ('6199','JJXRSEH802967')) or (`test_db`.`pa1`.`CREATE_USER_ID` = 289865))\\\"\\n   },\\n   \\\"select_list_subqueries\\\": [\\n  {\\n  \\\"dependent\\\": true,\\n  \\\"cacheable\\\": false,\\n  \\\"query_block\\\": {\\n   \\\"select_id\\\": 3,\\n   \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"22.55\\\"\\n   },\\n   \\\"table\\\": {\\n   \\\"table_name\\\": \\\"paaj\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"idx_apply_id_job_id\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_apply_id_job_id\\\",\\n   \\\"used_key_parts\\\": [\\n   \\\"apply_id\\\",\\n   \\\"job_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"606\\\",\\n   \\\"ref\\\": [\\n   \\\"test_db.pa1.apply_id\\\",\\n   \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 189,\\n   \\\"rows_produced_per_join\\\": 189,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"using_index\\\": true,\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"3.61\\\",\\n   \\\"eval_cost\\\": \\\"18.94\\\",\\n   \\\"prefix_cost\\\": \\\"22.55\\\",\\n   \\\"data_read_per_join\\\": \\\"113K\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"id\\\",\\n   \\\"apply_id\\\",\\n   \\\"job_id\\\"\\n   ]\\n   }\\n  }\\n  }\\n   ]\\n   }\\n   }\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE hotel_price_adjustment (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), brand_code VARCHAR(50), brand_name VARCHAR(200), hotel_code VARCHAR(50), hotel_name VARCHAR(200), currency VARCHAR(10), category VARCHAR(50), rate_code VARCHAR(50), rate_name VARCHAR(200), price_array_type VARCHAR(50), price_array_code VARCHAR(50), price_array_sequence INT, price_array TEXT, price_array2 TEXT, date_segment VARCHAR(100), weeks VARCHAR(50), brand_maximum_price DECIMAL(18,2), brand_minimum_price DECIMAL(18,2), room_code VARCHAR(50), room_name VARCHAR(200), room_standard_price DECIMAL(18,2), pre_adjustment_price DECIMAL(18,2), adjusted_price DECIMAL(18,2), price_adjustment_range VARCHAR(50), occupancy INT, status VARCHAR(20), reason TEXT, approve_status VARCHAR(20), approve_reason TEXT, operator VARCHAR(100), create_time DATETIME, update_time DATETIME, CREATE_USER_ID BIGINT) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_hotel_code ON hotel_price_adjustment(HOTEL_CODE);\nCREATE INDEX idx_create_user_id ON hotel_price_adjustment(CREATE_USER_ID);\nCREATE INDEX idx_apply_id ON hotel_price_adjustment(apply_id);\nCREATE TABLE price_adjustment_audit_job (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), job_id VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_apply_id_job_id ON price_adjustment_audit_job(apply_id, job_id);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t189504\t100.0\t\n2\tDERIVED\tpa1\t\tALL\tidx_hotel_code,idx_create_user_id\t\t\t\t947046\t20.01\tUsing where\n3\tDEPENDENT SUBQUERY\tpaaj\t\tref\tidx_apply_id_job_id\tidx_apply_id_job_id\t606\ttest_db.pa1.apply_id,const\t189\t100.0\tUsing index\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"21321.70\"\n  },\n  \"table\": {\n   \"table_name\": \"TOTAL\",\n   \"access_type\": \"ALL\",\n   \"rows_examined_per_scan\": 189504,\n   \"rows_produced_per_join\": 189504,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n   \"read_cost\": \"2371.30\",\n   \"eval_cost\": \"18950.40\",\n   \"prefix_cost\": \"21321.70\",\n   \"data_read_per_join\": \"1G\"\n   },\n   \"used_columns\": [\n   \"id\",\n   \"apply_id\",\n   \"brand_code\",\n   \"brand_name\",\n   \"hotel_code\",\n   \"hotel_name\",\n   \"currency\",\n   \"category\",\n   \"rate_code\",\n   \"rate_name\",\n   \"price_array_type\",\n   \"price_array_code\",\n   \"price_array_sequence\",\n   \"price_array\",\n   \"price_array2\",\n   \"date_segment\",\n   \"weeks\",\n   \"brand_maximum_price\",\n   \"brand_minimum_price\",\n   \"room_code\",\n   \"room_name\",\n   \"room_standard_price\",\n   \"pre_adjustment_price\",\n   \"adjusted_price\",\n   \"price_adjustment_range\",\n   \"occupancy\",\n   \"status\",\n   \"reason\",\n   \"approve_status\",\n   \"approve_reason\",\n   \"operator\",\n   \"create_time\",\n   \"update_time\",\n   \"CREATE_USER_ID\",\n   \"auditJobIdcounts\"\n   ],\n   \"materialized_from_subquery\": {\n   \"using_temporary_table\": true,\n   \"dependent\": false,\n   \"cacheable\": true,\n   \"query_block\": {\n   \"select_id\": 2,\n   \"cost_info\": {\n  \"query_cost\": \"119328.41\"\n   },\n   \"table\": {\n  \"table_name\": \"pa1\",\n  \"access_type\": \"ALL\",\n  \"possible_keys\": [\n  \"idx_hotel_code\",\n  \"idx_create_user_id\"\n  ],\n  \"rows_examined_per_scan\": 947046,\n  \"rows_produced_per_join\": 189504,\n  \"filtered\": \"20.01\",\n  \"cost_info\": {\n  \"read_cost\": \"100378.00\",\n  \"eval_cost\": \"18950.41\",\n  \"prefix_cost\": \"119328.41\",\n  \"data_read_per_join\": \"1G\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"apply_id\",\n  \"brand_code\",\n  \"brand_name\",\n  \"hotel_code\",\n  \"hotel_name\",\n  \"currency\",\n  \"category\",\n  \"rate_code\",\n  \"rate_name\",\n  \"price_array_type\",\n  \"price_array_code\",\n  \"price_array_sequence\",\n  \"price_array\",\n  \"price_array2\",\n  \"date_segment\",\n  \"weeks\",\n  \"brand_maximum_price\",\n  \"brand_minimum_price\",\n  \"room_code\",\n  \"room_name\",\n  \"room_standard_price\",\n  \"pre_adjustment_price\",\n  \"adjusted_price\",\n  \"price_adjustment_range\",\n  \"occupancy\",\n  \"status\",\n  \"reason\",\n  \"approve_status\",\n  \"approve_reason\",\n  \"operator\",\n  \"create_time\",\n  \"update_time\",\n  \"CREATE_USER_ID\"\n  ],\n  \"attached_condition\": \"((`test_db`.`pa1`.`hotel_code` in ('6199','JJXRSEH802967')) or (`test_db`.`pa1`.`CREATE_USER_ID` = 289865))\"\n   },\n   \"select_list_subqueries\": [\n  {\n  \"dependent\": true,\n  \"cacheable\": false,\n  \"query_block\": {\n   \"select_id\": 3,\n   \"cost_info\": {\n   \"query_cost\": \"22.55\"\n   },\n   \"table\": {\n   \"table_name\": \"paaj\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n   \"idx_apply_id_job_id\"\n   ],\n   \"key\": \"idx_apply_id_job_id\",\n   \"used_key_parts\": [\n   \"apply_id\",\n   \"job_id\"\n   ],\n   \"key_length\": \"606\",\n   \"ref\": [\n   \"test_db.pa1.apply_id\",\n   \"const\"\n   ],\n   \"rows_examined_per_scan\": 189,\n   \"rows_produced_per_join\": 189,\n   \"filtered\": \"100.00\",\n   \"using_index\": true,\n   \"cost_info\": {\n   \"read_cost\": \"3.61\",\n   \"eval_cost\": \"18.94\",\n   \"prefix_cost\": \"22.55\",\n   \"data_read_per_join\": \"113K\"\n   },\n   \"used_columns\": [\n   \"id\",\n   \"apply_id\",\n   \"job_id\"\n   ]\n   }\n  }\n  }\n   ]\n   }\n   }\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  COUNT(*) \nFROM \n  (\n  SELECT \n   id, \n   apply_id, \n   brand_code, \n   brand_name, \n   hotel_code, \n   hotel_name, \n   currency, \n   category, \n   rate_code, \n   rate_name, \n   price_array_type, \n   price_array_code, \n   price_array_sequence, \n   price_array, \n   price_array2, \n   date_segment, \n   weeks, \n   brand_maximum_price, \n   brand_minimum_price, \n   room_code, \n   room_name, \n   room_standard_price, \n   pre_adjustment_price, \n   adjusted_price, \n   price_adjustment_range, \n   occupancy, \n   status, \n   reason, \n   approve_status, \n   approve_reason, \n   operator, \n   create_time, \n   update_time, \n   CREATE_USER_ID, \n   (\n   SELECT \n   count(paaj.id) \n   FROM \n   price_adjustment_audit_job paaj \n   WHERE \n   paaj.apply_id = pa1.apply_id \n   AND paaj.job_id = '4_004'\n   ) AS auditJobIdcounts \n  FROM \n   hotel_price_adjustment pa1 \n  WHERE \n   (\n   HOTEL_CODE IN ('6199', 'JJXRSEH802967') \n   OR CREATE_USER_ID = 289865\n   )\n  ) TOTAL;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT COUNT(*) FROM (SELECT id FROM hotel_price_adjustment WHERE hotel_code IN ('6199','JJXRSEH802967') UNION SELECT id FROM hotel_price_adjustment WHERE CREATE_USER_ID = 289865) t"
                    }
                ]
            },
            {
                "case_id": "36",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"36\", \"db_type\": \"mysql\", \"description\": \"这种改写技术通过将OR条件拆分为多个UNION子查询，理论上可以让每个子查询更充分地利用索引。在某些数据库版本或特定场景下，当OR条件导致优化器无法有效使用索引时，这种改写可能带来性能提升。但在本案例中，MySQL的index_merge优化已经能够很好地处理OR条件，反而是UNION引入的额外开销导致性能下降\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE DOCUMENT (id INT PRIMARY KEY AUTO_INCREMENT, pdfKey VARCHAR(255), fileKey VARCHAR(255)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_pdfKey ON DOCUMENT(pdfKey);\", \"CREATE INDEX idx_fileKey ON DOCUMENT(fileKey);\"], \"sql\": \"SELECT \\n  * \\nfrom \\n  DOCUMENT \\nwhere \\n  (\\n  pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne' \\n  or fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'\\n  );\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tSIMPLE\\tDOCUMENT\\t\\tindex_merge\\tidx_pdfKey,idx_fileKey\\tidx_pdfKey,idx_fileKey\\t1023,1023\\t\\t2\\t100.0\\tUsing union(idx_pdfKey,idx_fileKey); Using where\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"3.55\\\"\\n  },\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"DOCUMENT\\\",\\n   \\\"access_type\\\": \\\"index_merge\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"idx_pdfKey\\\",\\n   \\\"idx_fileKey\\\"\\n   ],\\n   \\\"key\\\": \\\"union(idx_pdfKey,idx_fileKey)\\\",\\n   \\\"key_length\\\": \\\"1023,1023\\\",\\n   \\\"rows_examined_per_scan\\\": 2,\\n   \\\"rows_produced_per_join\\\": 2,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"3.35\\\",\\n   \\\"eval_cost\\\": \\\"0.20\\\",\\n   \\\"prefix_cost\\\": \\\"3.55\\\",\\n   \\\"data_read_per_join\\\": \\\"4K\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"id\\\",\\n   \\\"pdfKey\\\",\\n   \\\"fileKey\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`DOCUMENT`.`pdfKey` = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne') or (`test_db`.`DOCUMENT`.`fileKey` = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'))\\\"\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE DOCUMENT (id INT PRIMARY KEY AUTO_INCREMENT, pdfKey VARCHAR(255), fileKey VARCHAR(255)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_pdfKey ON DOCUMENT(pdfKey);\nCREATE INDEX idx_fileKey ON DOCUMENT(fileKey);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tSIMPLE\tDOCUMENT\t\tindex_merge\tidx_pdfKey,idx_fileKey\tidx_pdfKey,idx_fileKey\t1023,1023\t\t2\t100.0\tUsing union(idx_pdfKey,idx_fileKey); Using where\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"3.55\"\n  },\n  \"table\": {\n   \"table_name\": \"DOCUMENT\",\n   \"access_type\": \"index_merge\",\n   \"possible_keys\": [\n   \"idx_pdfKey\",\n   \"idx_fileKey\"\n   ],\n   \"key\": \"union(idx_pdfKey,idx_fileKey)\",\n   \"key_length\": \"1023,1023\",\n   \"rows_examined_per_scan\": 2,\n   \"rows_produced_per_join\": 2,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n   \"read_cost\": \"3.35\",\n   \"eval_cost\": \"0.20\",\n   \"prefix_cost\": \"3.55\",\n   \"data_read_per_join\": \"4K\"\n   },\n   \"used_columns\": [\n   \"id\",\n   \"pdfKey\",\n   \"fileKey\"\n   ],\n   \"attached_condition\": \"((`test_db`.`DOCUMENT`.`pdfKey` = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne') or (`test_db`.`DOCUMENT`.`fileKey` = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'))\"\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  * \nfrom \n  DOCUMENT \nwhere \n  (\n  pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne' \n  or fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'\n  );\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM DOCUMENT WHERE pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne' UNION ALL SELECT * FROM DOCUMENT WHERE fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'"
                    }
                ]
            },
            {
                "case_id": "37",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"37\", \"db_type\": \"oracle\", \"description\": \"问题概述：查询通过 CTE a1 对 FEE_LIST_D 做了大量的聚合（多个 LISTAGG、SUM、MIN 等），并在 a2 中使用 `a1.*` 再做计算和过滤后与 SETL_D_MERGED 连接。实际最终 SELECT 只使用了 a1 中的一部分列（例如 b_fee、min_amt 等列并未被外层查询引用），但由于使用了 `a1.*` 导致这些不必要的列在聚合阶段就被计算/传递，增加了 CPU、内存与 I/O 开销，同时阻止了投影下推优化。建议通过投影下推（在 a1 中仅输出外层实际需要的列，避免 a1.*）来减少中间数据量与聚合成本；同时可考虑在 a1 中下推过滤谓词并为连接列建索引以进一步降低成本。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE FEE_LIST_D (setl_id VARCHAR2(50), MEDINS_LIST_CODG VARCHAR2(100), medins_list_name VARCHAR2(200), hilist_code VARCHAR2(100), hilist_name VARCHAR2(200), MED_CHRGITM_TYPE_NAME VARCHAR2(100), CHRGITM_LV_NAME VARCHAR2(50), BILG_DEPT_NAME VARCHAR2(200), BILG_DR_NAME VARCHAR2(200), ACORD_DEPT_NAME VARCHAR2(200), ACORD_DR_NAME VARCHAR2(200), cnt NUMBER, det_item_fee_sumamt NUMBER(18,2), pric NUMBER(18,4), inscp_amt NUMBER(18,2));\", \"CREATE INDEX idx_fee_list_d_setl_id ON FEE_LIST_D(setl_id);\", \"CREATE INDEX idx_fee_list_d_cnt ON FEE_LIST_D(cnt);\", \"CREATE TABLE SETL_D_MERGED (setl_id VARCHAR2(50) PRIMARY KEY, fixmedins_code VARCHAR2(50), fixmedins_name VARCHAR2(200), HOSP_LV_NAME VARCHAR2(50), mdtrt_id VARCHAR2(50), ipt_otp_no VARCHAR2(50), psn_no VARCHAR2(50), psn_name VARCHAR2(200), certno VARCHAR2(30), GEND_NAME VARCHAR2(20), brdy DATE, age NUMBER, insu_admdvs VARCHAR2(50), INSUTYPE_NAME VARCHAR2(100), PSN_TYPE_NAME VARCHAR2(100), SP_PSN_TYPE_NAME VARCHAR2(100), med_type_name VARCHAR2(100), PAY_LOC_NAME VARCHAR2(100), setl_time DATE, adm_dept_name VARCHAR2(200), dscg_dept_name VARCHAR2(200), begntime DATE, endtime DATE, IPT_DAYS NUMBER, chfpdr_name VARCHAR2(200), adm_diag_dscr VARCHAR2(4000), dscg_maindiag_name VARCHAR2(4000), DIAG_NAME VARCHAR2(4000), dise_no VARCHAR2(50), dise_name VARCHAR2(200), OPRN_NAME VARCHAR2(4000), medfee_sumamt NUMBER(18,2), pool_prop_selfpay NUMBER, hifp_pay NUMBER, hifmi_pay NUMBER, maf_pay NUMBER, cvlserv_pay NUMBER, othfund_pay NUMBER, acct_pay NUMBER, cash_payamt NUMBER, fund_pay_sumamt NUMBER, insutype VARCHAR2(50));\", \"CREATE INDEX idx_setl_d_merged_setl_id ON SETL_D_MERGED(setl_id);\", \"CREATE INDEX idx_setl_d_fund_pay ON SETL_D_MERGED(FUND_PAY_SUMAMT)\"], \"sql\": \"with\\na1 as (\\n  select\\n  setl_id,\\n  -- 聚合项目信息\\n  listagg(distinct MEDINS_LIST_CODG, ',') within group (order by MEDINS_LIST_CODG) b_medins_list_codg,\\n  listagg(distinct medins_list_name, ',') within group (order by medins_list_name) b_medins_list_name,\\n  listagg(distinct f.hilist_code, ',') within group (order by f.hilist_code) b_hilist_code,\\n  listagg(distinct hilist_name, ',') within group (order by hilist_name) b_hilist_name,\\n  listagg(distinct MED_CHRGITM_TYPE_NAME, ',') within group (order by MED_CHRGITM_TYPE_NAME) MED_CHRGITM_TYPE,\\n  listagg(distinct CHRGITM_LV_NAME, ',') within group (order by CHRGITM_LV_NAME) CHRGITM_LV,\\n  listagg(distinct BILG_DEPT_NAME, ',') within group (order by BILG_DEPT_NAME) BILG_DEPT_NAME,\\n  listagg(distinct BILG_DR_NAME, ',') within group (order by BILG_DR_NAME) BILG_DR_NAME,\\n  listagg(distinct ACORD_DEPT_NAME, ',') within group (order by ACORD_DEPT_NAME) ACORD_DEPT_NAME,\\n  listagg(distinct ACORD_DR_NAME, ',') within group (order by ACORD_DR_NAME) ACORD_DR_NAME,\\n  -- 统一转换为“日”单位后的总数量\\n  sum(f.cnt ) as b_cnt,\\n  -- 总费用\\n  sum(f.det_item_fee_sumamt) as b_fee,\\n  -- 转换为“日”单位后的最小单价\\n  min(f.pric ) as min_pric,\\n  -- 转换为“日”单位后的最小金额\\n  min(abs(f.inscp_amt / f.cnt) ) as min_amt\\n  from FEE_LIST_D f\\n  -- 关联单位转换系数表\\n   where f.cnt <> 0\\n   and f.CHRGITM_LV_NAME in ('甲类','乙类')\\n  -- 按结算流水号分组\\n  group by f.setl_id\\n),\\na2 as (\\n  select a1.*,\\n  -- 违规数量\\n  case\\n   when a1.b_cnt > (s.ipt_days *12+24) then a1.b_cnt - (s.ipt_days *12+24)\\n   else 0\\n  end as break_cnt,\\n  -- 违规金额\\n  case\\n   when a1.b_cnt > (s.ipt_days *12+24) then (a1.b_cnt - (s.ipt_days *12+24)) * (a1.min_pric * 1)\\n   else 0\\n  end as break_fee,\\n  -- 违规范围内金额\\n  case\\n   when a1.b_cnt > (s.ipt_days *12+24) then (a1.b_cnt - (s.ipt_days *12+24)) * (a1.min_amt * 1)\\n   else 0\\n  end as break_amt\\n  from a1\\n  -- 关联结算表获取住院天数\\n  inner join SETL_D_MERGED s on a1.setl_id = s.setl_id\\n  -- 过滤违规数据\\n  where a1.b_cnt > (s.ipt_days *12+24)\\n   and s.FUND_PAY_SUMAMT <> 0\\n)\\nselect\\n  s.fixmedins_code 医院代码,\\n  s.fixmedins_name 医院名称,\\n  s.HOSP_LV_NAME 医院级别,\\n  s.setl_id 结算单据号,\\n  s.mdtrt_id 就诊ID,\\n  s.ipt_otp_no 住院号,\\n  s.psn_no 个人编号,\\n  s.psn_name 姓名,\\n  s.certno 身份证号,\\n  s.GEND_NAME 性别,\\n  s.brdy 出生日期,\\n  s.age 年龄,\\n  s.insu_admdvs 统筹区,\\n  s.INSUTYPE_NAME 险种类型,\\n  s.PSN_TYPE_NAME 医疗人员类别,\\n  s.SP_PSN_TYPE_NAME 特殊人员身份类别,\\n  s.med_type_name 就医类型,\\n  s.PAY_LOC_NAME 支付地点类别,\\n  s.setl_time 结算日期,\\n  s.adm_dept_name 入院科室,\\n  s.dscg_dept_name 出院科室,\\n  s.begntime 入院日期,\\n  s.endtime 出院日期,\\n  s.IPT_DAYS 天数,\\n  s.chfpdr_name 主治医生,\\n  s.adm_diag_dscr 入院诊断,\\n  s.dscg_maindiag_name 出院诊断,\\n  s.DIAG_NAME 其他诊断,\\n  s.dise_no 病种编码,\\n  s.dise_name 病种名称,\\n  s.OPRN_NAME 手术及操作名称,\\n  s.medfee_sumamt 总金额,\\n  concat(to_char(s.pool_prop_selfpay * 100), '%') 基本医疗统筹支付比例,\\n  s.hifp_pay 基本医保支付,\\n  s.hifmi_pay 大病报销,\\n  s.maf_pay 医疗救助,\\n  s.cvlserv_pay 公务员补充,\\n  s.othfund_pay 其他支付,\\n  s.acct_pay 个人帐户支付,\\n  s.cash_payamt 个人现金支付,\\n  s.fund_pay_sumamt 基金支付总额,\\n  fl.MED_CHRGITM_TYPE 费用类别,\\n  fl.BILG_DEPT_NAME 开单科室名称,\\n  fl.BILG_DR_NAME 开单医生姓名,\\n  fl.ACORD_DEPT_NAME 受单科室名称,\\n  fl.ACORD_DR_NAME 受单医生姓名,\\n  null 收费日期,\\n  fl.b_medins_list_codg 违规医院项目代码,\\n  fl.b_medins_list_name 违规医院项目名称,\\n  fl.b_hilist_code 违规医保项目代码,\\n  fl.b_hilist_name 违规医保项目名称,\\n  null 正常医院项目代码,\\n  null 正常医院项目名称,\\n  null 正常医保项目代码,\\n  null 正常医保项目名称,\\n  null 正常项目数量,\\n  null 正常项目金额,\\n  fl.b_cnt 违规项目收费数量,\\n  fl.min_pric 违规项目单价,\\n  fl.break_cnt 违规项目数量,\\n  fl.CHRGITM_LV 违规项目支付类别,\\n  fl.break_fee 违规项目金额,\\n  fl.break_amt 违规项目范围内金额,\\n  gettcamount(fl.break_amt, s.pool_prop_selfpay, s.hifp_pay, s.fund_pay_sumamt) 基本统筹违规金额,\\n  getdbamount(fl.break_amt, s.insutype, s.hifmi_pay, s.fund_pay_sumamt) 大病统筹违规金额,\\n  GETMAFAMOUNT(fl.break_amt, s.maf_pay, s.fund_pay_sumamt) 医疗救助违规金额,\\n  case when substr(s.INSU_ADMDVS,1,4) != '{pool_no}' then '是' else '否' end 是否异地,\\n  'CB_0020' 违规规则代码,\\n  '超标准收费' 违规类型,\\n  '按小时收费的血液净化类诊疗项目（如自动腹膜透析、连续性血液净化等），收费数量超过实际提供的诊疗服务数量。' 违规事项,\\n  '《江西省医疗服务价格项目目录（2023年修订版）》中血液净化类诊疗项目收费的真实性。' 违规依据\\nfrom SETL_D_MERGED s\\ninner join a2 fl on s.setl_id = fl.setl_id\\nwhere s.FUND_PAY_SUMAMT <> 0\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t1250\\t1000\\t800000\\t400000\\t1200\\n1\\t  NESTED LOOPS\\t1250\\t1000\\t800000\\t400000\\t1200\\n2\\t   VIEW (A2 - FILTER & JOIN)\\t1000\\t1000\\t600000\\t300000\\t800\\n3\\t  HASH GROUP BY (A1 aggregation)\\t1000\\t1000\\t600000\\t300000\\t800\\n4\\t   TABLE ACCESS FULL FEE_LIST_D\\t900\\t10000\\t5400000\\t270000\\t700\\n5\\t   TABLE ACCESS BY INDEX ROWID SETL_D_MERGED\\t200\\t1000\\t800000\\t80000\\t400\\n6\\t  INDEX UNIQUE SCAN IDX_SETL_D_MERGED_SETL_ID\\t5\\t1000\\t8000\\t2000\\t10\\n7\\t  FILTER (s.FUND_PAY_SUMAMT <> 0 AND a1.b_cnt > (s.ipt_days*12+24))\\t---\\t---\\t---\\t---\\t---\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE FEE_LIST_D (setl_id VARCHAR2(50), MEDINS_LIST_CODG VARCHAR2(100), medins_list_name VARCHAR2(200), hilist_code VARCHAR2(100), hilist_name VARCHAR2(200), MED_CHRGITM_TYPE_NAME VARCHAR2(100), CHRGITM_LV_NAME VARCHAR2(50), BILG_DEPT_NAME VARCHAR2(200), BILG_DR_NAME VARCHAR2(200), ACORD_DEPT_NAME VARCHAR2(200), ACORD_DR_NAME VARCHAR2(200), cnt NUMBER, det_item_fee_sumamt NUMBER(18,2), pric NUMBER(18,4), inscp_amt NUMBER(18,2));\nCREATE INDEX idx_fee_list_d_setl_id ON FEE_LIST_D(setl_id);\nCREATE INDEX idx_fee_list_d_cnt ON FEE_LIST_D(cnt);\nCREATE TABLE SETL_D_MERGED (setl_id VARCHAR2(50) PRIMARY KEY, fixmedins_code VARCHAR2(50), fixmedins_name VARCHAR2(200), HOSP_LV_NAME VARCHAR2(50), mdtrt_id VARCHAR2(50), ipt_otp_no VARCHAR2(50), psn_no VARCHAR2(50), psn_name VARCHAR2(200), certno VARCHAR2(30), GEND_NAME VARCHAR2(20), brdy DATE, age NUMBER, insu_admdvs VARCHAR2(50), INSUTYPE_NAME VARCHAR2(100), PSN_TYPE_NAME VARCHAR2(100), SP_PSN_TYPE_NAME VARCHAR2(100), med_type_name VARCHAR2(100), PAY_LOC_NAME VARCHAR2(100), setl_time DATE, adm_dept_name VARCHAR2(200), dscg_dept_name VARCHAR2(200), begntime DATE, endtime DATE, IPT_DAYS NUMBER, chfpdr_name VARCHAR2(200), adm_diag_dscr VARCHAR2(4000), dscg_maindiag_name VARCHAR2(4000), DIAG_NAME VARCHAR2(4000), dise_no VARCHAR2(50), dise_name VARCHAR2(200), OPRN_NAME VARCHAR2(4000), medfee_sumamt NUMBER(18,2), pool_prop_selfpay NUMBER, hifp_pay NUMBER, hifmi_pay NUMBER, maf_pay NUMBER, cvlserv_pay NUMBER, othfund_pay NUMBER, acct_pay NUMBER, cash_payamt NUMBER, fund_pay_sumamt NUMBER, insutype VARCHAR2(50));\nCREATE INDEX idx_setl_d_merged_setl_id ON SETL_D_MERGED(setl_id);\nCREATE INDEX idx_setl_d_fund_pay ON SETL_D_MERGED(FUND_PAY_SUMAMT)\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t1250\t1000\t800000\t400000\t1200\n1\t  NESTED LOOPS\t1250\t1000\t800000\t400000\t1200\n2\t   VIEW (A2 - FILTER & JOIN)\t1000\t1000\t600000\t300000\t800\n3\t  HASH GROUP BY (A1 aggregation)\t1000\t1000\t600000\t300000\t800\n4\t   TABLE ACCESS FULL FEE_LIST_D\t900\t10000\t5400000\t270000\t700\n5\t   TABLE ACCESS BY INDEX ROWID SETL_D_MERGED\t200\t1000\t800000\t80000\t400\n6\t  INDEX UNIQUE SCAN IDX_SETL_D_MERGED_SETL_ID\t5\t1000\t8000\t2000\t10\n7\t  FILTER (s.FUND_PAY_SUMAMT <> 0 AND a1.b_cnt > (s.ipt_days*12+24))\t---\t---\t---\t---\t---\n\n## Original SQL:\nwith\na1 as (\n  select\n  setl_id,\n  -- 聚合项目信息\n  listagg(distinct MEDINS_LIST_CODG, ',') within group (order by MEDINS_LIST_CODG) b_medins_list_codg,\n  listagg(distinct medins_list_name, ',') within group (order by medins_list_name) b_medins_list_name,\n  listagg(distinct f.hilist_code, ',') within group (order by f.hilist_code) b_hilist_code,\n  listagg(distinct hilist_name, ',') within group (order by hilist_name) b_hilist_name,\n  listagg(distinct MED_CHRGITM_TYPE_NAME, ',') within group (order by MED_CHRGITM_TYPE_NAME) MED_CHRGITM_TYPE,\n  listagg(distinct CHRGITM_LV_NAME, ',') within group (order by CHRGITM_LV_NAME) CHRGITM_LV,\n  listagg(distinct BILG_DEPT_NAME, ',') within group (order by BILG_DEPT_NAME) BILG_DEPT_NAME,\n  listagg(distinct BILG_DR_NAME, ',') within group (order by BILG_DR_NAME) BILG_DR_NAME,\n  listagg(distinct ACORD_DEPT_NAME, ',') within group (order by ACORD_DEPT_NAME) ACORD_DEPT_NAME,\n  listagg(distinct ACORD_DR_NAME, ',') within group (order by ACORD_DR_NAME) ACORD_DR_NAME,\n  -- 统一转换为“日”单位后的总数量\n  sum(f.cnt ) as b_cnt,\n  -- 总费用\n  sum(f.det_item_fee_sumamt) as b_fee,\n  -- 转换为“日”单位后的最小单价\n  min(f.pric ) as min_pric,\n  -- 转换为“日”单位后的最小金额\n  min(abs(f.inscp_amt / f.cnt) ) as min_amt\n  from FEE_LIST_D f\n  -- 关联单位转换系数表\n   where f.cnt <> 0\n   and f.CHRGITM_LV_NAME in ('甲类','乙类')\n  -- 按结算流水号分组\n  group by f.setl_id\n),\na2 as (\n  select a1.*,\n  -- 违规数量\n  case\n   when a1.b_cnt > (s.ipt_days *12+24) then a1.b_cnt - (s.ipt_days *12+24)\n   else 0\n  end as break_cnt,\n  -- 违规金额\n  case\n   when a1.b_cnt > (s.ipt_days *12+24) then (a1.b_cnt - (s.ipt_days *12+24)) * (a1.min_pric * 1)\n   else 0\n  end as break_fee,\n  -- 违规范围内金额\n  case\n   when a1.b_cnt > (s.ipt_days *12+24) then (a1.b_cnt - (s.ipt_days *12+24)) * (a1.min_amt * 1)\n   else 0\n  end as break_amt\n  from a1\n  -- 关联结算表获取住院天数\n  inner join SETL_D_MERGED s on a1.setl_id = s.setl_id\n  -- 过滤违规数据\n  where a1.b_cnt > (s.ipt_days *12+24)\n   and s.FUND_PAY_SUMAMT <> 0\n)\nselect\n  s.fixmedins_code 医院代码,\n  s.fixmedins_name 医院名称,\n  s.HOSP_LV_NAME 医院级别,\n  s.setl_id 结算单据号,\n  s.mdtrt_id 就诊ID,\n  s.ipt_otp_no 住院号,\n  s.psn_no 个人编号,\n  s.psn_name 姓名,\n  s.certno 身份证号,\n  s.GEND_NAME 性别,\n  s.brdy 出生日期,\n  s.age 年龄,\n  s.insu_admdvs 统筹区,\n  s.INSUTYPE_NAME 险种类型,\n  s.PSN_TYPE_NAME 医疗人员类别,\n  s.SP_PSN_TYPE_NAME 特殊人员身份类别,\n  s.med_type_name 就医类型,\n  s.PAY_LOC_NAME 支付地点类别,\n  s.setl_time 结算日期,\n  s.adm_dept_name 入院科室,\n  s.dscg_dept_name 出院科室,\n  s.begntime 入院日期,\n  s.endtime 出院日期,\n  s.IPT_DAYS 天数,\n  s.chfpdr_name 主治医生,\n  s.adm_diag_dscr 入院诊断,\n  s.dscg_maindiag_name 出院诊断,\n  s.DIAG_NAME 其他诊断,\n  s.dise_no 病种编码,\n  s.dise_name 病种名称,\n  s.OPRN_NAME 手术及操作名称,\n  s.medfee_sumamt 总金额,\n  concat(to_char(s.pool_prop_selfpay * 100), '%') 基本医疗统筹支付比例,\n  s.hifp_pay 基本医保支付,\n  s.hifmi_pay 大病报销,\n  s.maf_pay 医疗救助,\n  s.cvlserv_pay 公务员补充,\n  s.othfund_pay 其他支付,\n  s.acct_pay 个人帐户支付,\n  s.cash_payamt 个人现金支付,\n  s.fund_pay_sumamt 基金支付总额,\n  fl.MED_CHRGITM_TYPE 费用类别,\n  fl.BILG_DEPT_NAME 开单科室名称,\n  fl.BILG_DR_NAME 开单医生姓名,\n  fl.ACORD_DEPT_NAME 受单科室名称,\n  fl.ACORD_DR_NAME 受单医生姓名,\n  null 收费日期,\n  fl.b_medins_list_codg 违规医院项目代码,\n  fl.b_medins_list_name 违规医院项目名称,\n  fl.b_hilist_code 违规医保项目代码,\n  fl.b_hilist_name 违规医保项目名称,\n  null 正常医院项目代码,\n  null 正常医院项目名称,\n  null 正常医保项目代码,\n  null 正常医保项目名称,\n  null 正常项目数量,\n  null 正常项目金额,\n  fl.b_cnt 违规项目收费数量,\n  fl.min_pric 违规项目单价,\n  fl.break_cnt 违规项目数量,\n  fl.CHRGITM_LV 违规项目支付类别,\n  fl.break_fee 违规项目金额,\n  fl.break_amt 违规项目范围内金额,\n  gettcamount(fl.break_amt, s.pool_prop_selfpay, s.hifp_pay, s.fund_pay_sumamt) 基本统筹违规金额,\n  getdbamount(fl.break_amt, s.insutype, s.hifmi_pay, s.fund_pay_sumamt) 大病统筹违规金额,\n  GETMAFAMOUNT(fl.break_amt, s.maf_pay, s.fund_pay_sumamt) 医疗救助违规金额,\n  case when substr(s.INSU_ADMDVS,1,4) != '{pool_no}' then '是' else '否' end 是否异地,\n  'CB_0020' 违规规则代码,\n  '超标准收费' 违规类型,\n  '按小时收费的血液净化类诊疗项目（如自动腹膜透析、连续性血液净化等），收费数量超过实际提供的诊疗服务数量。' 违规事项,\n  '《江西省医疗服务价格项目目录（2023年修订版）》中血液净化类诊疗项目收费的真实性。' 违规依据\nfrom SETL_D_MERGED s\ninner join a2 fl on s.setl_id = fl.setl_id\nwhere s.FUND_PAY_SUMAMT <> 0\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "with a1 as (select setl_id,listagg(distinct MEDINS_LIST_CODG, ',') within group (order by MEDINS_LIST_CODG) b_medins_list_codg,listagg(distinct medins_list_name, ',') within group (order by medins_list_name) b_medins_list_name,listagg(distinct hilist_code, ',') within group (order by hilist_code) b_hilist_code,listagg(distinct hilist_name, ',') within group (order by hilist_name) b_hilist_name,listagg(distinct MED_CHRGITM_TYPE_NAME, ',') within group (order by MED_CHRGITM_TYPE_NAME) MED_CHRGITM_TYPE,listagg(distinct CHRGITM_LV_NAME, ',') within group (order by CHRGITM_LV_NAME) CHRGITM_LV,listagg(distinct BILG_DEPT_NAME, ',') within group (order by BILG_DEPT_NAME) BILG_DEPT_NAME,listagg(distinct BILG_DR_NAME, ',') within group (order by BILG_DR_NAME) BILG_DR_NAME,listagg(distinct ACORD_DEPT_NAME, ',') within group (order by ACORD_DEPT_NAME) ACORD_DEPT_NAME,listagg(distinct ACORD_DR_NAME, ',') within group (order by ACORD_DR_NAME) ACORD_DR_NAME,sum(cnt) as b_cnt,sum(det_item_fee_sumamt) as b_fee,min(pric) as min_pric,min(abs(inscp_amt/cnt)) as min_amt from FEE_LIST_D where cnt <> 0 and CHRGITM_LV_NAME in ('甲类','乙类') group by setl_id),a2 as (select a1.*,s.fixmedins_code,s.fixmedins_name,s.HOSP_LV_NAME,s.mdtrt_id,s.ipt_otp_no,s.psn_no,s.psn_name,s.certno,s.GEND_NAME,s.brdy,s.age,s.insu_admdvs,s.INSUTYPE_NAME,s.PSN_TYPE_NAME,s.SP_PSN_TYPE_NAME,s.med_type_name,s.PAY_LOC_NAME,s.setl_time,s.adm_dept_name,s.dscg_dept_name,s.begntime,s.endtime,s.IPT_DAYS,s.chfpdr_name,s.adm_diag_dscr,s.dscg_maindiag_name,s.DIAG_NAME,s.dise_no,s.dise_name,s.OPRN_NAME,s.medfee_sumamt,s.pool_prop_selfpay,s.hifp_pay,s.hifmi_pay,s.maf_pay,s.cvlserv_pay,s.othfund_pay,s.acct_pay,s.cash_payamt,s.fund_pay_sumamt,s.insutype,case when a1.b_cnt > (s.ipt_days*12+24) then a1.b_cnt - (s.ipt_days*12+24) else 0 end as break_cnt,case when a1.b_cnt > (s.ipt_days*12+24) then (a1.b_cnt - (s.ipt_days*12+24)) * (a1.min_pric * 1) else 0 end as break_fee,case when a1.b_cnt > (s.ipt_days*12+24) then (a1.b_cnt - (s.ipt_days*12+24)) * (a1.min_amt * 1) else 0 end as break_amt from a1 inner join SETL_D_MERGED s on a1.setl_id = s.setl_id where a1.b_cnt > (s.ipt_days*12+24) and s.FUND_PAY_SUMAMT <> 0) select a2.fixmedins_code 医院代码,a2.fixmedins_name 医院名称,a2.HOSP_LV_NAME 医院级别,a2.setl_id 结算单据号,a2.mdtrt_id 就诊ID,a2.ipt_otp_no 住院号,a2.psn_no 个人编号,a2.psn_name 姓名,a2.certno 身份证号,a2.GEND_NAME 性别,a2.brdy 出生日期,a2.age 年龄,a2.insu_admdvs 统筹区,a2.INSUTYPE_NAME 险种类型,a2.PSN_TYPE_NAME 医疗人员类别,a2.SP_PSN_TYPE_NAME 特殊人员身份类别,a2.med_type_name 就医类型,a2.PAY_LOC_NAME 支付地点类别,a2.setl_time 结算日期,a2.adm_dept_name 入院科室,a2.dscg_dept_name 出院科室,a2.begntime 入院日期,a2.endtime 出院日期,a2.IPT_DAYS 天数,a2.chfpdr_name 主治医生,a2.adm_diag_dscr 入院诊断,a2.dscg_maindiag_name 出院诊断,a2.DIAG_NAME 其他诊断,a2.dise_no 病种编码,a2.dise_name 病种名称,a2.OPRN_NAME 手术及操作名称,a2.medfee_sumamt 总金额,concat(to_char(a2.pool_prop_selfpay * 100), '%') 基本医疗统筹支付比例,a2.hifp_pay 基本医保支付,a2.hifmi_pay 大病报销,a2.maf_pay 医疗救助,a2.cvlserv_pay 公务员补充,a2.othfund_pay 其他支付,a2.acct_pay 个人帐户支付,a2.cash_payamt 个人现金支付,a2.fund_pay_sumamt 基金支付总额,a2.MED_CHRGITM_TYPE 费用类别,a2.BILG_DEPT_NAME 开单科室名称,a2.BILG_DR_NAME 开单医生姓名,a2.ACORD_DEPT_NAME 受单科室名称,a2.ACORD_DR_NAME 受单医生姓名,null 收费日期,a2.b_medins_list_codg 违规医院项目代码,a2.b_medins_list_name 违规医院项目名称,a2.b_hilist_code 违规医保项目代码,a2.b_hilist_name 违规医保项目名称,null 正常医院项目代码,null 正常医院项目名称,null 正常医保项目代码,null 正常医保项目名称,null 正常项目数量,null 正常项目金额,a2.b_cnt 违规项目收费数量,a2.min_pric 违规项目单价,a2.break_cnt 违规项目数量,a2.CHRGITM_LV 违规项目支付类别,a2.break_fee 违规项目金额,a2.break_amt 违规项目范围内金额,gettcamount(a2.break_amt, a2.pool_prop_selfpay, a2.hifp_pay, a2.fund_pay_sumamt) 基本统筹违规金额,getdbamount(a2.break_amt, a2.insutype, a2.hifmi_pay, a2.fund_pay_sumamt) 大病统筹违规金额,GETMAFAMOUNT(a2.break_amt, a2.maf_pay, a2.fund_pay_sumamt) 医疗救助违规金额,case when substr(a2.INSU_ADMDVS,1,4) != '{pool_no}' then '是' else '否' end 是否异地,'CB_0020' 违规规则代码,'超标准收费' 违规类型,'按小时收费的血液净化类诊疗项目（如自动腹膜透析、连续性血液净化等），收费数量超过实际提供的诊疗服务数量。' 违规事项,'《江西省医疗服务价格项目目录（2023年修订版）》中血液净化类诊疗项目收费的真实性。' 违规依据 from a2"
                    }
                ]
            },
            {
                "case_id": "38",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"38\", \"db_type\": \"oracle\", \"description\": \"问题概述：该查询在 HRM_FLOOR.C_BASE_STATION_T(B) 上有多重等值过滤（BU_ID、HAC_ID、KEY_STATION_ID 列和 MFG_PROCESS_ID、DEL_FLAG），并且在主表 P 上按 WORK_DATE 与 DEL_FLAG 进行筛选，同时包含一个关联的 EXISTS 子查询来确认员工在对应站点的有效执照记录。潜在性能问题包括：1) 如果用于比较的列与字面量类型不匹配（例如 WORK_DATE 字段若为 VARCHAR 则与 DATE 常量比较会发生隐式类型转换），会导致索引失效；2) 缺少覆盖这些谓词和关联列的复合索引，会使得优化器采用全表扫描或大量回表，增加 I/O；3) EXISTS 子查询使用逗号分隔的老式连接写法（F, H）且为相关子查询，会导致对每一行执行索引查找/范围扫描，若 H/F 没有在 (EMP_NO, LICENSE_ID) 与 (LICENSE_ID, STATION_ID) 上建立合适索引，会产生大量随机 I/O。建议：确认 WORK_DATE/相关列数据类型与谓词匹配以避免隐式转换；为 B 表建立复合索引覆盖 (BU_ID, HAC_ID, KEY_STATION_ID, MFG_PROCESS_ID, DEL_FLAG) 或拆分为多个选择性索引；为 P 表建立 (WORK_DATE, DEL_FLAG, STATION_ID, EMP_NO) 索引以支持主谓词和后续关联；为 R_KEY_STATION_MAN_T 与 R_KEY_STATION_LICENSE_T 分别建立针对 (EMP_NO, LICENSE_ID, LOSE_FLAG, DEL_FLAG) 与 (LICENSE_ID, STATION_ID, DEL_FLAG) 的索引；将 EXISTS 子查询改写为显式 JOIN 或至少使用关联索引以减少对每行的重复查找。同时建议将高选择性谓词（如 P.DEL_FLAG=0、B.DEL_FLAG=0、B.BU_ID 等）尽量作为最先评估的过滤条件，降低后续关联数据量。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE HRM_FLOOR.C_BASE_STATION_T (ID NUMBER PRIMARY KEY, STATION_NAME_ENG VARCHAR2(200), BU_ID NUMBER, HAC_ID NUMBER, KEY_STATION_ID NUMBER, MFG_PROCESS_ID NUMBER, DEL_FLAG NUMBER);\", \"CREATE INDEX IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL ON HRM_FLOOR.C_BASE_STATION_T(BU_ID, HAC_ID, KEY_STATION_ID, MFG_PROCESS_ID, DEL_FLAG);\", \"CREATE TABLE HRM_FLOOR.R_EMP_STATION_PLAN_T (ID NUMBER PRIMARY KEY, WORK_DATE DATE, DEL_FLAG NUMBER, HWT_TYPE_ID NUMBER, LINE_ID NUMBER, STATION_ID NUMBER, EMP_NO VARCHAR2(50));\", \"CREATE INDEX IDX_R_EMP_STATION_PLAN_WORKDATE ON HRM_FLOOR.R_EMP_STATION_PLAN_T(WORK_DATE, DEL_FLAG, STATION_ID, EMP_NO);\", \"CREATE TABLE HRM_FLOOR.R_KEY_STATION_MAN_T (ID NUMBER PRIMARY KEY, LICENSE_ID NUMBER, EMP_NO VARCHAR2(50), LOSE_FLAG NUMBER, DEL_FLAG NUMBER);\", \"CREATE INDEX IDX_R_KEY_STATION_MAN_EMP_LICENSE ON HRM_FLOOR.R_KEY_STATION_MAN_T(EMP_NO, LICENSE_ID, LOSE_FLAG, DEL_FLAG);\", \"CREATE TABLE HRM_FLOOR.R_KEY_STATION_LICENSE_T (LICENSE_ID NUMBER PRIMARY KEY, STATION_ID NUMBER, DEL_FLAG NUMBER);\", \"CREATE INDEX IDX_R_KEY_STATION_LICENSE_STATION ON HRM_FLOOR.R_KEY_STATION_LICENSE_T(LICENSE_ID, STATION_ID, DEL_FLAG);\"], \"sql\": \"SELECT P.HWT_TYPE_ID,   --班別ID\\n  HRM_EMP.GET_ID_TO_DESC (P.HWT_TYPE_ID) SHIFT,   --班別\\n  B.FAMILY_ID AS MODEL_ID,   --機種ID\\n  HRM_EMP.GET_ID_TO_DESC (B.FAMILY_ID) AS MODEL_NAME,  --機種名稱\\n  P.LINE_ID,  --線體ID\\n  GET_LOCATION_INFO (P.LINE_ID, '1') AS LINE_NAME,  --線體名稱\\n  P.STATION_ID,  --工站ID\\n  B.STATION_NAME_ENG,   --工站名稱\\n  HRM_EMP.GET_ID_TO_DESC (B.KEY_STATION_ID) KEY_STATION_TYPE,  --工站類型\\n  P.EMP_NO\\n  --,P.CONFIRM_FLAG, --確認狀態\\n  FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P\\n  -- 使用INNER,以便只要 同時符合預排配和工站基礎資訊的\\n  INNER JOIN HRM_FLOOR.C_BASE_STATION_T B\\n  ON  P.STATION_ID = B.ID\\n  AND B.DEL_FLAG = 0\\n  AND B.BU_ID = 245346  --iPad\\n  AND B.HAC_ID = 7137  --CD\\n  AND B.KEY_STATION_ID IN (4976, 8877, 38131)   --K/K+/K++\\n  AND B.MFG_PROCESS_ID = 140185  --製程為Mainline\\n   WHERE  P.WORK_DATE = DATE '2025-08-04'\\n  AND P.DEL_FLAG = 0\\n  -- 確認該員工有對應的「有效執照+在職」鑰匙站記錄（仍需站點一致）\\n  AND EXISTS\\n   (SELECT 1\\n  FROM HRM_FLOOR.R_KEY_STATION_LICENSE_T F,\\n  HRM_FLOOR.R_KEY_STATION_MAN_T H\\n   WHERE  H.LICENSE_ID = F.LICENSE_ID\\n  AND H.EMP_NO = P.EMP_NO\\n  AND H.LOSE_FLAG = 10078\\n  AND H.DEL_FLAG = 0\\n  AND F.DEL_FLAG = 0\\n  AND F.STATION_ID = P.STATION_ID)\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t120\\t200\\t16000\\t8000\\t40\\n1\\t  NESTED LOOPS\\t120\\t200\\t16000\\t8000\\t40\\n2\\t   INDEX RANGE SCAN IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL\\t10\\t200\\t8000\\t1000\\t5\\n3\\t  TABLE ACCESS BY INDEX ROWID C_BASE_STATION_T\\t30\\t200\\t8000\\t2000\\t10\\n4\\t   INDEX RANGE SCAN IDX_R_EMP_STATION_PLAN_WORKDATE\\t20\\t200\\t2000\\t1000\\t5\\n5\\t  TABLE ACCESS BY INDEX ROWID R_EMP_STATION_PLAN_T\\t70\\t200\\t8000\\t5000\\t20\\n6\\t   FILTER (P.WORK_DATE = DATE '2025-08-04' AND P.DEL_FLAG = 0)\\t---\\t---\\t---\\t---\\t---\\n7\\t   NESTED LOOPS (correlated) -- EXISTS subquery\\t20\\t200\\t4000\\t2000\\t5\\n8\\t  INDEX RANGE SCAN IDX_R_KEY_STATION_MAN_EMP_LICENSE (H)\\t2\\t1\\t40\\t10\\t1\\n9\\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_MAN_T\\t5\\t1\\t40\\t20\\t1\\n10\\t  INDEX RANGE SCAN IDX_R_KEY_STATION_LICENSE_STATION (F)\\t5\\t2\\t80\\t20\\t1\\n11\\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_LICENSE_T\\t8\\t2\\t80\\t30\\t1\\n12\\t  FILTER (EXISTS-subquery conditions applied per outer row)\\t---\\t---\\t---\\t---\\t---\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE HRM_FLOOR.C_BASE_STATION_T (ID NUMBER PRIMARY KEY, STATION_NAME_ENG VARCHAR2(200), BU_ID NUMBER, HAC_ID NUMBER, KEY_STATION_ID NUMBER, MFG_PROCESS_ID NUMBER, DEL_FLAG NUMBER);\nCREATE INDEX IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL ON HRM_FLOOR.C_BASE_STATION_T(BU_ID, HAC_ID, KEY_STATION_ID, MFG_PROCESS_ID, DEL_FLAG);\nCREATE TABLE HRM_FLOOR.R_EMP_STATION_PLAN_T (ID NUMBER PRIMARY KEY, WORK_DATE DATE, DEL_FLAG NUMBER, HWT_TYPE_ID NUMBER, LINE_ID NUMBER, STATION_ID NUMBER, EMP_NO VARCHAR2(50));\nCREATE INDEX IDX_R_EMP_STATION_PLAN_WORKDATE ON HRM_FLOOR.R_EMP_STATION_PLAN_T(WORK_DATE, DEL_FLAG, STATION_ID, EMP_NO);\nCREATE TABLE HRM_FLOOR.R_KEY_STATION_MAN_T (ID NUMBER PRIMARY KEY, LICENSE_ID NUMBER, EMP_NO VARCHAR2(50), LOSE_FLAG NUMBER, DEL_FLAG NUMBER);\nCREATE INDEX IDX_R_KEY_STATION_MAN_EMP_LICENSE ON HRM_FLOOR.R_KEY_STATION_MAN_T(EMP_NO, LICENSE_ID, LOSE_FLAG, DEL_FLAG);\nCREATE TABLE HRM_FLOOR.R_KEY_STATION_LICENSE_T (LICENSE_ID NUMBER PRIMARY KEY, STATION_ID NUMBER, DEL_FLAG NUMBER);\nCREATE INDEX IDX_R_KEY_STATION_LICENSE_STATION ON HRM_FLOOR.R_KEY_STATION_LICENSE_T(LICENSE_ID, STATION_ID, DEL_FLAG);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t120\t200\t16000\t8000\t40\n1\t  NESTED LOOPS\t120\t200\t16000\t8000\t40\n2\t   INDEX RANGE SCAN IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL\t10\t200\t8000\t1000\t5\n3\t  TABLE ACCESS BY INDEX ROWID C_BASE_STATION_T\t30\t200\t8000\t2000\t10\n4\t   INDEX RANGE SCAN IDX_R_EMP_STATION_PLAN_WORKDATE\t20\t200\t2000\t1000\t5\n5\t  TABLE ACCESS BY INDEX ROWID R_EMP_STATION_PLAN_T\t70\t200\t8000\t5000\t20\n6\t   FILTER (P.WORK_DATE = DATE '2025-08-04' AND P.DEL_FLAG = 0)\t---\t---\t---\t---\t---\n7\t   NESTED LOOPS (correlated) -- EXISTS subquery\t20\t200\t4000\t2000\t5\n8\t  INDEX RANGE SCAN IDX_R_KEY_STATION_MAN_EMP_LICENSE (H)\t2\t1\t40\t10\t1\n9\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_MAN_T\t5\t1\t40\t20\t1\n10\t  INDEX RANGE SCAN IDX_R_KEY_STATION_LICENSE_STATION (F)\t5\t2\t80\t20\t1\n11\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_LICENSE_T\t8\t2\t80\t30\t1\n12\t  FILTER (EXISTS-subquery conditions applied per outer row)\t---\t---\t---\t---\t---\n\n## Original SQL:\nSELECT P.HWT_TYPE_ID,   --班別ID\n  HRM_EMP.GET_ID_TO_DESC (P.HWT_TYPE_ID) SHIFT,   --班別\n  B.FAMILY_ID AS MODEL_ID,   --機種ID\n  HRM_EMP.GET_ID_TO_DESC (B.FAMILY_ID) AS MODEL_NAME,  --機種名稱\n  P.LINE_ID,  --線體ID\n  GET_LOCATION_INFO (P.LINE_ID, '1') AS LINE_NAME,  --線體名稱\n  P.STATION_ID,  --工站ID\n  B.STATION_NAME_ENG,   --工站名稱\n  HRM_EMP.GET_ID_TO_DESC (B.KEY_STATION_ID) KEY_STATION_TYPE,  --工站類型\n  P.EMP_NO\n  --,P.CONFIRM_FLAG, --確認狀態\n  FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P\n  -- 使用INNER,以便只要 同時符合預排配和工站基礎資訊的\n  INNER JOIN HRM_FLOOR.C_BASE_STATION_T B\n  ON  P.STATION_ID = B.ID\n  AND B.DEL_FLAG = 0\n  AND B.BU_ID = 245346  --iPad\n  AND B.HAC_ID = 7137  --CD\n  AND B.KEY_STATION_ID IN (4976, 8877, 38131)   --K/K+/K++\n  AND B.MFG_PROCESS_ID = 140185  --製程為Mainline\n   WHERE  P.WORK_DATE = DATE '2025-08-04'\n  AND P.DEL_FLAG = 0\n  -- 確認該員工有對應的「有效執照+在職」鑰匙站記錄（仍需站點一致）\n  AND EXISTS\n   (SELECT 1\n  FROM HRM_FLOOR.R_KEY_STATION_LICENSE_T F,\n  HRM_FLOOR.R_KEY_STATION_MAN_T H\n   WHERE  H.LICENSE_ID = F.LICENSE_ID\n  AND H.EMP_NO = P.EMP_NO\n  AND H.LOSE_FLAG = 10078\n  AND H.DEL_FLAG = 0\n  AND F.DEL_FLAG = 0\n  AND F.STATION_ID = P.STATION_ID)\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT DISTINCT P.HWT_TYPE_ID,HRM_EMP.GET_ID_TO_DESC(P.HWT_TYPE_ID) SHIFT,B.FAMILY_ID AS MODEL_ID,HRM_EMP.GET_ID_TO_DESC(B.FAMILY_ID) AS MODEL_NAME,P.LINE_ID,GET_LOCATION_INFO(P.LINE_ID,'1') AS LINE_NAME,P.STATION_ID,B.STATION_NAME_ENG,HRM_EMP.GET_ID_TO_DESC(B.KEY_STATION_ID) KEY_STATION_TYPE,P.EMP_NO FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P INNER JOIN HRM_FLOOR.C_BASE_STATION_T B ON P.STATION_ID=B.ID AND B.DEL_FLAG=0 AND B.BU_ID=245346 AND B.HAC_ID=7137 AND B.KEY_STATION_ID IN(4976,8877,38131) AND B.MFG_PROCESS_ID=140185 INNER JOIN HRM_FLOOR.R_KEY_STATION_MAN_T H ON H.EMP_NO=P.EMP_NO AND H.LOSE_FLAG=10078 AND H.DEL_FLAG=0 INNER JOIN HRM_FLOOR.R_KEY_STATION_LICENSE_T F ON F.LICENSE_ID=H.LICENSE_ID AND F.STATION_ID=P.STATION_ID AND F.DEL_FLAG=0 WHERE P.WORK_DATE=DATE'2025-08-04' AND P.DEL_FLAG=0"
                    }
                ]
            },
            {
                "case_id": "39",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"39\", \"db_type\": \"sqlserver\", \"description\": \"问题概述：原始查询包含一个全表聚合 + 窗口函数的 CTE（rank_general），多个 LEFT JOIN 与一个 CROSS JOIN(me 子查询)，以及对 otr.otr_consulta 的行级展开 (CROSS APPLY (VALUES ...)) 再做 GROUP BY。性能瓶颈可能来自几处：\\n1) rank_general 需要对 flashdeventas.vetas_y_formas_de_pago 做 GROUP BY 并按 SUM 排序再计算 ROW_NUMBER，若无合适索引/预聚合会导致全表扫描与昂贵的排序；\\n2) me 使用常量筛选但被 CROSS JOIN 到主查，若 me 返回多行会乘扩大外层行数；即使 me 仅返回一行，保留未被外层使用的列会造成不必要的数据传递（可用投影下推移除 proveedor 与 estilo）；\\n3) otr 子查询对 otr.otr_consulta 做了 VALUES 展开后 GROUP BY，若不把高选择性谓词（c.tienda = 3064）下推，会扫描大量无关行并产生大规模聚合中间结果；\\n4) 多个 LEFT JOIN（例如 ranking_tda_jerarquia、control_asignacion_matrices）若缺乏覆盖索引，会引发大量回表和随机 I/O。\\n\\n建议（与实习生给出的规则一致）：\\n- 进行投影下推：在 me 子查询中移除未被外层用到的列（如 proveedor、estilo），减少中间结果宽度；\\n- 进行谓词下推：把高选择性条件 c.tienda = 3064 下推至 otr 的扫描/聚合子查询（即 WHERE oc.id_tienda = 3064），显著降低 otr 聚合量；\\n- 检查并建立必要索引：例如 otr.otr_consulta 上应有 (id_tienda, id_departamento, id_subdepartamento, id_clase, id_subclase, tipo_articulo) 的复合索引或至少 id_tienda 的索引；catalogos.maestro_estilos 可在 (proveedor, estilo) 建索引；catalogos.ranking_tda_jerarquia 在 (id_tienda, departamento, subdepartamento, clase, subclase) 上建索引；clusters.tienda_atributos 在 (centro_comercial, clima, tienda) 建复合/前缀索引；catalogos.tiendas 在 TIENDA 列建主键/索引。 \\n- 对 rank_general 的全表排序开销敏感时，考虑离线物化/周期维护排名表或限制计算范围（若业务允许）。\\n\\n在满足语义前提下（确保移除的列确实不被外层引用，且 c.tienda 为强选择性过滤），方式1 的投影与谓词下推是低风险且立即见效的改进；方式2（更激进的提前过滤/LEFT→INNER 等）若要采用需严格验证不会改变结果。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE catalogos.tiendas (TIENDA INT PRIMARY KEY, nombre NVARCHAR(200), tipo CHAR(1), estatus CHAR(1), marca INT, ciudad NVARCHAR(100), estado NVARCHAR(100), m2 DECIMAL(10,2));\", \"CREATE INDEX IDX_TIENDA_TIPO_MARCA ON catalogos.tiendas(tipo, estatus, marca);\", \"CREATE TABLE flashdeventas.vetas_y_formas_de_pago (ID BIGINT PRIMARY KEY, TIENDA INT, MERCANCIASINIVA DECIMAL(18,4), FECHA DATETIME);\", \"CREATE INDEX IDX_VETAS_TIENDA ON flashdeventas.vetas_y_formas_de_pago(TIENDA);\", \"CREATE TABLE clusters.tienda_atributos (tienda INT PRIMARY KEY, centro_comercial INT, clima NVARCHAR(200));\", \"CREATE INDEX IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos(centro_comercial, clima, tienda);\", \"CREATE TABLE catalogos.maestro_estilos (departamento INT, subdepartamento INT, clase INT, subclase INT, proveedor INT, estilo NVARCHAR(100), tipo_articulo INT);\", \"CREATE INDEX IDX_MAESTRO_ESTILOS_PROV_ESTILO ON catalogos.maestro_estilos(proveedor, estilo);\", \"CREATE TABLE catalogos.ranking_tda_jerarquia (id_tienda INT, departamento INT, subdepartamento INT, clase INT, subclase INT, ranking INT);\", \"CREATE INDEX IDX_RJ_IDTIENDA_DEPT ON catalogos.ranking_tda_jerarquia(id_tienda, departamento, subdepartamento, clase, subclase);\", \"CREATE TABLE catalogos.control_asignacion_matrices (clasificacion INT, matrices_min INT);\", \"CREATE INDEX IDX_CAM_CLASIFICACION ON catalogos.control_asignacion_matrices(clasificacion);\", \"CREATE TABLE otr.otr_consulta (id_tienda INT, id_departamento INT, id_subdepartamento INT, id_clase INT, id_subclase INT, tipo_articulo INT, mes1_compra_adicional DECIMAL(18,4), mes2_compra_adicional DECIMAL(18,4), mes3_compra_adicional DECIMAL(18,4), mes4_compra_adicional DECIMAL(18,4), mes5_compra_adicional DECIMAL(18,4), mes6_compra_adicional DECIMAL(18,4), mes7_compra_adicional DECIMAL(18,4), mes8_compra_adicional DECIMAL(18,4), mes9_compra_adicional DECIMAL(18,4), mes10_compra_adicional DECIMAL(18,4), mes11_compra_adicional DECIMAL(18,4), mes12_compra_adicional DECIMAL(18,4));\", \"CREATE INDEX IDX_OTR_ID_TIENDA_FULL ON otr.otr_consulta(id_tienda, id_departamento, id_subdepartamento, id_clase, id_subclase, tipo_articulo);\", \"CREATE VIEW catalogos.vw_supervisores AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\", \"CREATE VIEW catalogos.vw_regionales AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\"], \"sql\": \";WITH rank_general AS (\\n  SELECT \\n  ta.TIENDA AS id,\\n  ROW_NUMBER() OVER (\\n  ORDER BY SUM(v.MERCANCIASINIVA) DESC\\n  ) AS actual_rank_global\\n  FROM catalogos.tiendas ta\\n  LEFT JOIN flashdeventas.vetas_y_formas_de_pago v ON v.TIENDA = ta.TIENDA\\n  WHERE ta.tipo = 'S' AND estatus = 'A' AND ta.marca = 30\\n  GROUP BY ta.TIENDA\\n) \\nSELECT \\n  rg.actual_rank_global   \\n  ,t.nombre\\n  ,vw_r.nombre as regional\\n  ,vw_s.nombre as supervisor\\n  ,t.estado\\n  ,'RUTA' as ruta  ----\\n  ,t.m2 as tienda_m2\\n  ,'TAMAÑO' as tamanio   ----\\n  ,rj.ranking as rank_jerarquia_n4\\n  ,t.ciudad\\n  ,cam.matrices_min as propuesta\\n  ,otr.abierto_otr as abierto_otr\\n  ,c.* \\nFROM clusters.tienda_atributos c\\nLEFT JOIN catalogos.tiendas t ON c.tienda = t.tienda\\nLEFT JOIN catalogos.vw_supervisores vw_s ON c.tienda = vw_s.tienda\\nLEFT JOIN catalogos.vw_regionales vw_r ON c.tienda = vw_r.tienda\\nLEFT JOIN rank_general rg ON c.tienda = rg.id\\nCROSS JOIN (\\n  SELECT departamento, subdepartamento, clase, subclase, proveedor, estilo, tipo_articulo\\n  FROM catalogos.maestro_estilos me\\n  WHERE me.proveedor = 1162 AND me.estilo = 'C21031101'\\n) me\\nLEFT JOIN catalogos.ranking_tda_jerarquia rj \\n  ON c.tienda = rj.id_tienda\\n  AND rj.departamento = me.departamento\\n  AND rj.subdepartamento = me.subdepartamento\\n  AND rj.clase = me.clase\\n  AND rj.subclase = me.subclase\\nLEFT JOIN catalogos.control_asignacion_matrices cam\\n  ON rj.ranking = cam.clasificacion\\nLEFT JOIN (\\n  SELECT\\n  oc.id_tienda,\\n  oc.id_departamento,\\n  oc.id_subdepartamento,\\n  oc.id_clase,\\n  oc.id_subclase,\\n  oc.tipo_articulo,\\n  SUM(CASE WHEN n >= MONTH(GETDATE()) THEN ISNULL(val, 0) ELSE 0 END) AS abierto_otr\\n  FROM otr.otr_consulta oc\\n  CROSS APPLY (VALUES\\n  (1,  oc.mes1_compra_adicional),\\n  (2,  oc.mes2_compra_adicional),\\n  (3,  oc.mes3_compra_adicional),\\n  (4,  oc.mes4_compra_adicional),\\n  (5,  oc.mes5_compra_adicional),\\n  (6,  oc.mes6_compra_adicional),\\n  (7,  oc.mes7_compra_adicional),\\n  (8,  oc.mes8_compra_adicional),\\n  (9,  oc.mes9_compra_adicional),\\n  (10, oc.mes10_compra_adicional),\\n  (11, oc.mes11_compra_adicional),\\n  (12, oc.mes12_compra_adicional)\\n  ) m(n, val)\\n  GROUP BY\\n  oc.id_tienda,\\n  oc.id_departamento,\\n  oc.id_subdepartamento,\\n  oc.id_clase,\\n  oc.id_subclase,\\n  oc.tipo_articulo\\n) otr\\n  ON  otr.id_tienda = c.tienda\\n  AND otr.id_departamento = me.departamento\\n  AND otr.id_subdepartamento = me.subdepartamento\\n  AND otr.id_clase = me.clase\\n  AND otr.id_subclase = me.subclase\\n  AND otr.tipo_articulo = me.tipo_articulo\\nWHERE 1=1  AND c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t15200\\t10000\\t1200000\\t452000\\t14800\\n1\\t  MERGE JOIN\\t15200\\t10000\\t1200000\\t452000\\t14800\\n2\\t   HASH AGGREGATE (rank_general: SUM + SORT for ROW_NUMBER)\\t9200\\t10000\\t600000\\t300000\\t9000\\n3\\t  TABLE SCAN flashdeventas.vetas_y_formas_de_pago\\t4800\\t10000\\t480000\\t240000\\t4800\\n4\\t   INDEX SEEK catalogos.tiendas (type/estatus/marca filter)\\t200\\t5000\\t80000\\t20000\\t200\\n5\\t   SORT\\t3000\\t10000\\t200000\\t80000\\t3000\\n6\\t   HASH MATCH (left outer join rj/cam/others)\\t2400\\t5000\\t300000\\t100000\\t2400\\n7\\t  VIEW (me CROSS JOIN) -- expands outer rows when me has >1 row\\t50\\t10\\t800\\t500\\t50\\n8\\t  HASH AGGREGATE (otr subquery grouping)\\t6800\\t8000\\t400000\\t160000\\t6800\\n9\\t   TABLE SCAN otr.otr_consulta\\t6600\\t8000\\t380000\\t150000\\t6600\\n10\\t  CROSS APPLY (VALUES ...) expansion per row\\t---\\t---\\t---\\t---\\t---\\n11\\t   NESTED LOOPS (apply joins to clusters.tienda_atributos filtered by centro_comercial/clima/tiena)\\t1200\\t1\\t160\\t600\\t120\\n12\\t  INDEX SEEK IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos (centro_comercial,clima,tienda)\\t10\\t1\\t80\\t20\\t5\\n13\\t  TABLE ACCESS BY INDEX ROWID catalogos.tiendas / vw_supervisores / vw_regionales\\t300\\t1\\t320\\t100\\t30\\n14\\t  FILTER (c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064)\\t---\\t---\\t---\\t---\\t---\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE catalogos.tiendas (TIENDA INT PRIMARY KEY, nombre NVARCHAR(200), tipo CHAR(1), estatus CHAR(1), marca INT, ciudad NVARCHAR(100), estado NVARCHAR(100), m2 DECIMAL(10,2));\nCREATE INDEX IDX_TIENDA_TIPO_MARCA ON catalogos.tiendas(tipo, estatus, marca);\nCREATE TABLE flashdeventas.vetas_y_formas_de_pago (ID BIGINT PRIMARY KEY, TIENDA INT, MERCANCIASINIVA DECIMAL(18,4), FECHA DATETIME);\nCREATE INDEX IDX_VETAS_TIENDA ON flashdeventas.vetas_y_formas_de_pago(TIENDA);\nCREATE TABLE clusters.tienda_atributos (tienda INT PRIMARY KEY, centro_comercial INT, clima NVARCHAR(200));\nCREATE INDEX IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos(centro_comercial, clima, tienda);\nCREATE TABLE catalogos.maestro_estilos (departamento INT, subdepartamento INT, clase INT, subclase INT, proveedor INT, estilo NVARCHAR(100), tipo_articulo INT);\nCREATE INDEX IDX_MAESTRO_ESTILOS_PROV_ESTILO ON catalogos.maestro_estilos(proveedor, estilo);\nCREATE TABLE catalogos.ranking_tda_jerarquia (id_tienda INT, departamento INT, subdepartamento INT, clase INT, subclase INT, ranking INT);\nCREATE INDEX IDX_RJ_IDTIENDA_DEPT ON catalogos.ranking_tda_jerarquia(id_tienda, departamento, subdepartamento, clase, subclase);\nCREATE TABLE catalogos.control_asignacion_matrices (clasificacion INT, matrices_min INT);\nCREATE INDEX IDX_CAM_CLASIFICACION ON catalogos.control_asignacion_matrices(clasificacion);\nCREATE TABLE otr.otr_consulta (id_tienda INT, id_departamento INT, id_subdepartamento INT, id_clase INT, id_subclase INT, tipo_articulo INT, mes1_compra_adicional DECIMAL(18,4), mes2_compra_adicional DECIMAL(18,4), mes3_compra_adicional DECIMAL(18,4), mes4_compra_adicional DECIMAL(18,4), mes5_compra_adicional DECIMAL(18,4), mes6_compra_adicional DECIMAL(18,4), mes7_compra_adicional DECIMAL(18,4), mes8_compra_adicional DECIMAL(18,4), mes9_compra_adicional DECIMAL(18,4), mes10_compra_adicional DECIMAL(18,4), mes11_compra_adicional DECIMAL(18,4), mes12_compra_adicional DECIMAL(18,4));\nCREATE INDEX IDX_OTR_ID_TIENDA_FULL ON otr.otr_consulta(id_tienda, id_departamento, id_subdepartamento, id_clase, id_subclase, tipo_articulo);\nCREATE VIEW catalogos.vw_supervisores AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\nCREATE VIEW catalogos.vw_regionales AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t15200\t10000\t1200000\t452000\t14800\n1\t  MERGE JOIN\t15200\t10000\t1200000\t452000\t14800\n2\t   HASH AGGREGATE (rank_general: SUM + SORT for ROW_NUMBER)\t9200\t10000\t600000\t300000\t9000\n3\t  TABLE SCAN flashdeventas.vetas_y_formas_de_pago\t4800\t10000\t480000\t240000\t4800\n4\t   INDEX SEEK catalogos.tiendas (type/estatus/marca filter)\t200\t5000\t80000\t20000\t200\n5\t   SORT\t3000\t10000\t200000\t80000\t3000\n6\t   HASH MATCH (left outer join rj/cam/others)\t2400\t5000\t300000\t100000\t2400\n7\t  VIEW (me CROSS JOIN) -- expands outer rows when me has >1 row\t50\t10\t800\t500\t50\n8\t  HASH AGGREGATE (otr subquery grouping)\t6800\t8000\t400000\t160000\t6800\n9\t   TABLE SCAN otr.otr_consulta\t6600\t8000\t380000\t150000\t6600\n10\t  CROSS APPLY (VALUES ...) expansion per row\t---\t---\t---\t---\t---\n11\t   NESTED LOOPS (apply joins to clusters.tienda_atributos filtered by centro_comercial/clima/tiena)\t1200\t1\t160\t600\t120\n12\t  INDEX SEEK IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos (centro_comercial,clima,tienda)\t10\t1\t80\t20\t5\n13\t  TABLE ACCESS BY INDEX ROWID catalogos.tiendas / vw_supervisores / vw_regionales\t300\t1\t320\t100\t30\n14\t  FILTER (c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064)\t---\t---\t---\t---\t---\n\n## Original SQL:\n;WITH rank_general AS (\n  SELECT \n  ta.TIENDA AS id,\n  ROW_NUMBER() OVER (\n  ORDER BY SUM(v.MERCANCIASINIVA) DESC\n  ) AS actual_rank_global\n  FROM catalogos.tiendas ta\n  LEFT JOIN flashdeventas.vetas_y_formas_de_pago v ON v.TIENDA = ta.TIENDA\n  WHERE ta.tipo = 'S' AND estatus = 'A' AND ta.marca = 30\n  GROUP BY ta.TIENDA\n) \nSELECT \n  rg.actual_rank_global   \n  ,t.nombre\n  ,vw_r.nombre as regional\n  ,vw_s.nombre as supervisor\n  ,t.estado\n  ,'RUTA' as ruta  ----\n  ,t.m2 as tienda_m2\n  ,'TAMAÑO' as tamanio   ----\n  ,rj.ranking as rank_jerarquia_n4\n  ,t.ciudad\n  ,cam.matrices_min as propuesta\n  ,otr.abierto_otr as abierto_otr\n  ,c.* \nFROM clusters.tienda_atributos c\nLEFT JOIN catalogos.tiendas t ON c.tienda = t.tienda\nLEFT JOIN catalogos.vw_supervisores vw_s ON c.tienda = vw_s.tienda\nLEFT JOIN catalogos.vw_regionales vw_r ON c.tienda = vw_r.tienda\nLEFT JOIN rank_general rg ON c.tienda = rg.id\nCROSS JOIN (\n  SELECT departamento, subdepartamento, clase, subclase, proveedor, estilo, tipo_articulo\n  FROM catalogos.maestro_estilos me\n  WHERE me.proveedor = 1162 AND me.estilo = 'C21031101'\n) me\nLEFT JOIN catalogos.ranking_tda_jerarquia rj \n  ON c.tienda = rj.id_tienda\n  AND rj.departamento = me.departamento\n  AND rj.subdepartamento = me.subdepartamento\n  AND rj.clase = me.clase\n  AND rj.subclase = me.subclase\nLEFT JOIN catalogos.control_asignacion_matrices cam\n  ON rj.ranking = cam.clasificacion\nLEFT JOIN (\n  SELECT\n  oc.id_tienda,\n  oc.id_departamento,\n  oc.id_subdepartamento,\n  oc.id_clase,\n  oc.id_subclase,\n  oc.tipo_articulo,\n  SUM(CASE WHEN n >= MONTH(GETDATE()) THEN ISNULL(val, 0) ELSE 0 END) AS abierto_otr\n  FROM otr.otr_consulta oc\n  CROSS APPLY (VALUES\n  (1,  oc.mes1_compra_adicional),\n  (2,  oc.mes2_compra_adicional),\n  (3,  oc.mes3_compra_adicional),\n  (4,  oc.mes4_compra_adicional),\n  (5,  oc.mes5_compra_adicional),\n  (6,  oc.mes6_compra_adicional),\n  (7,  oc.mes7_compra_adicional),\n  (8,  oc.mes8_compra_adicional),\n  (9,  oc.mes9_compra_adicional),\n  (10, oc.mes10_compra_adicional),\n  (11, oc.mes11_compra_adicional),\n  (12, oc.mes12_compra_adicional)\n  ) m(n, val)\n  GROUP BY\n  oc.id_tienda,\n  oc.id_departamento,\n  oc.id_subdepartamento,\n  oc.id_clase,\n  oc.id_subclase,\n  oc.tipo_articulo\n) otr\n  ON  otr.id_tienda = c.tienda\n  AND otr.id_departamento = me.departamento\n  AND otr.id_subdepartamento = me.subdepartamento\n  AND otr.id_clase = me.clase\n  AND otr.id_subclase = me.subclase\n  AND otr.tipo_articulo = me.tipo_articulo\nWHERE 1=1  AND c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": ";WITH rank_general AS (SELECT ta.TIENDA AS id, ROW_NUMBER() OVER (ORDER BY SUM(v.MERCANCIASINIVA) DESC) AS actual_rank_global FROM catalogos.tiendas ta LEFT JOIN flashdeventas.vetas_y_formas_de_pago v ON v.TIENDA = ta.TIENDA WHERE ta.tipo = 'S' AND ta.estatus = 'A' AND ta.marca = 30 GROUP BY ta.TIENDA) SELECT rg.actual_rank_global, t.nombre, vw_r.nombre as regional, vw_s.nombre as supervisor, t.estado, 'RUTA' as ruta, t.m2 as tienda_m2, 'TAMAÑO' as tamanio, rj.ranking as rank_jerarquia_n4, t.ciudad, cam.matrices_min as propuesta, otr.abierto_otr, c.* FROM clusters.tienda_atributos c LEFT JOIN catalogos.tiendas t ON c.tienda = t.tienda LEFT JOIN catalogos.vw_supervisores vw_s ON c.tienda = vw_s.tienda LEFT JOIN catalogos.vw_regionales vw_r ON c.tienda = vw_r.tienda LEFT JOIN rank_general rg ON c.tienda = rg.id CROSS JOIN (SELECT departamento, subdepartamento, clase, subclase, proveedor, estilo, tipo_articulo FROM catalogos.maestro_estilos WHERE proveedor = 1162 AND estilo = 'C21031101') me LEFT JOIN catalogos.ranking_tda_jerarquia rj ON c.tienda = rj.id_tienda AND rj.departamento = me.departamento AND rj.subdepartamento = me.subdepartamento AND rj.clase = me.clase AND rj.subclase = me.subclase LEFT JOIN catalogos.control_asignacion_matrices cam ON rj.ranking = cam.clasificacion LEFT JOIN (SELECT oc.id_tienda, oc.id_departamento, oc.id_subdepartamento, oc.id_clase, oc.id_subclase, oc.tipo_articulo, SUM(CASE WHEN n >= MONTH(GETDATE()) THEN ISNULL(val, 0) ELSE 0 END) AS abierto_otr FROM otr.otr_consulta oc WHERE oc.id_tienda = 3064 CROSS APPLY (VALUES (1, oc.mes1_compra_adicional), (2, oc.mes2_compra_adicional), (3, oc.mes3_compra_adicional), (4, oc.mes4_compra_adicional), (5, oc.mes5_compra_adicional), (6, oc.mes6_compra_adicional), (7, oc.mes7_compra_adicional), (8, oc.mes8_compra_adicional), (9, oc.mes9_compra_adicional), (10, oc.mes10_compra_adicional), (11, oc.mes11_compra_adicional), (12, oc.mes12_compra_adicional)) m(n, val) GROUP BY oc.id_tienda, oc.id_departamento, oc.id_subdepartamento, oc.id_clase, oc.id_subclase, oc.tipo_articulo) otr ON otr.id_tienda = c.tienda AND otr.id_departamento = me.departamento AND otr.id_subdepartamento = me.subdepartamento AND otr.id_clase = me.clase AND otr.id_subclase = me.subclase AND otr.tipo_articulo = me.tipo_articulo WHERE c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064"
                    }
                ]
            },
            {
                "case_id": "40",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"40\", \"db_type\": \"oracle\", \"description\": \"问题概述：此查询包含三层嵌套用于实现基于 ROWNUM 的分页（最内层包含大范围的 SELECT + 多个 LEFT JOIN + 多个标量子查询与函数调用；中间一层再包一层并限制 ROWNUM<=10；最外层再按 rn>0 过滤），导致不必要的视图物化与数据传递开销。主要性能隐患还有：1) 大量标量子查询（例如从 RES_SYS.PUB_MFR、RES_SYS.PUB_DIC_EQP_TYPE、RES_SYS.PUB_RME_EQP_MODEL 等按 ID 查询名称）会对每一行触发独立索引/表访问，开销成倍放大；2) 频繁调用的行级函数（RES_ENTITY.SF_GET_DESC_CHINA / SF_GET_STAFF_NAME 等）若未缓存，会导致大量 CPU 时间；3) IN 子查询包含 CONNECT BY 的递归层次查询，若不先将其物化为较小集合，会使主表筛选成本增高；4) 宽表 SELECT *（以及许多未必要的列和文本转换）增加了 I/O 与网络传输量。建议：删除最外层冗余的 `where rn > 0` 并把分页逻辑简化；把 `ROWNUM <= 10` 的限制尽量下推或改为 `FETCH FIRST 10 ROWS` / 使用 FIRST_ROWS 优化；将标量子查询改写为 LEFT JOIN（或事先使用单表缓存/物化视图）以避免每行重复访问；为常用的连接/过滤列（ENT_ENTITY.ENTITY_ID、ENT_ROOM.ENTITY_ID、ENT_ENTITY.STATION_CODE、STA_STATION.STATION_CODE/ STATION_ID、STA_APP_INFO.STATION_ID、STA_BIZ_INFO.STATION_CODE、REG_MANAGE.REGION_ID）建立合适索引；对昂贵的行级函数考虑结果缓存或提前物化；对 CONNECT BY 结果先计算并临时表化以减少重复计算。这样可显著减少全表扫描、嵌套循环和重复的随机 I/O。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE RES_ENTITY.ENT_ENTITY (ENTITY_ID VARCHAR2(50) PRIMARY KEY, DELETE_STATE VARCHAR2(2), RES_TYPE_ID NUMBER, STATION_CODE VARCHAR2(50), TIME_TO_OVERDUE VARCHAR2(50), CHECK_MODE_ID NUMBER, BUSINESS_ID NUMBER, SUB_BUSINESS_ID NUMBER, PROP_ID NUMBER, OLD_PROP_ID NUMBER, PROPERTY_ID NUMBER, ENTITY_STATE_ID NUMBER, IS_LOCKED_ID NUMBER, IS_FAULT_ID NUMBER, IS_OVERDUE NUMBER, WARRANTY_GRADE_ID NUMBER, IS_OUTMAINTENANCE_ID NUMBER, ASSETS_RECEIVE_TYPE_ID NUMBER, ENTITY_CREATE_SOURCE_ID NUMBER, SOURCE_SYSTEM_ID NUMBER, CHECK_RESULT_ID NUMBER, SERVICE_STATE_ID NUMBER, IS_MONITOR_ID NUMBER, MONITOR_STYLE_ID NUMBER, IS_UPLOAD_PHOTO NUMBER, STORAGE_STATE_ID NUMBER, IS_STORAGE NUMBER, RES_FROM_PROJBUILDTYPE_ID NUMBER, SPLIT_MERGE_REASON_ID NUMBER, SOURCE_RES_NO VARCHAR2(100), ROOM_ID VARCHAR2(50), RES_TYPE_ID_TEXT VARCHAR2(100), DEV_TYPE_ID NUMBER, DEV_MODEL_ID NUMBER, OLD_DEV_MODEL_ID NUMBER, MFR_ID NUMBER, DW_MFR_ID NUMBER, OLD_DW_MFR_ID NUMBER, MNT_MFR_ID NUMBER, MODIFY_OP VARCHAR2(50), CREATE_OP VARCHAR2(50), CHECK_PERSON VARCHAR2(50), STATION_CODE_ALT VARCHAR2(50));\", \"CREATE INDEX IDX_ENT_ENTITY_DELETE_RES_TYPE_STCODE ON RES_ENTITY.ENT_ENTITY(DELETE_STATE, RES_TYPE_ID, STATION_CODE);\", \"CREATE TABLE RES_ENTITY.ENT_ROOM (ENTITY_ID VARCHAR2(50), WIDTH NUMBER, LENGTH NUMBER, HEIGHT NUMBER, AREA NUMBER, FLOOR_NO NUMBER, IS_OIL_MACH_ROOM NUMBER, IS_HAVE_WALL NUMBER, STRUCTURE_ID NUMBER, ADDRESS VARCHAR2(400), AIRBLAST_STYLE NUMBER, VACANT_CABLE_SEAT NUMBER, CONTACTS VARCHAR2(200), LINK_TEL VARCHAR2(50), NUM_HOLE_FEED NUMBER, NUM_HOLE_FEED_OCCU NUMBER, NUM_HOLE_FEED_FREE NUMBER, LIGHT_PROTECTION_BRAND VARCHAR2(200), LIGHT_PROTECTION_MODE VARCHAR2(200), FIRE_EXTINGUISHER_TYPE VARCHAR2(100), NUM_FIRE_EXTINGUISHER NUMBER, STATION_ROAD_ID NUMBER, DEGREE_ARRIVAL_ID NUMBER, REASON_UNARRIVAL VARCHAR2(400), IS_ARRIVEL NUMBER, IS_POWER NUMBER, REASON_UNPOWER VARCHAR2(400), INOUT_MODE NUMBER, PLATE_DRAWINGS_ID VARCHAR2(50), DECORATION_DRAWINGS_ID VARCHAR2(50), DESIGN_DRAWINGS_ID VARCHAR2(50), GROUND_SYSTEM_DRAWINGS_ID VARCHAR2(50), IS_EXPAND_OIL_ROOM NUMBER, SECURITY_ENVIRONMENT_ID NUMBER, GENERATION_TIME DATE, WNG_STYLE NUMBER, ROOM_GRADE_ID NUMBER, NUM_RMEBAY_TOTAL NUMBER, NUM_RMEBAY_FREE NUMBER, PRODUCT_TYPE NUMBER, ENT_AUDIT_RESULT_ID NUMBER, AUDIT_FLOW_RESULT_ID NUMBER, MANUAL_IDENT_RESULT_ID NUMBER, AGENT_MNT_CONTACT VARCHAR2(50), IS_VR_FULLSCENE_ID NUMBER, IS_SHARE NUMBER, SHARE_UNIT_ID VARCHAR2(50), INTEG_CABINET_SPACE_NUM NUMBER, INTEG_CABINET_AC_BRAND VARCHAR2(200), INTEG_CABINET_AC_MODEL_DC VARCHAR2(200), INTEG_CABINET_AC_NUM_DC NUMBER, INTEG_CABINET_AC_MODEL VARCHAR2(200), INTEG_CABINET_AC_NUM_DC_AC NUMBER, INTEG_CABINET_AC_NUM_ID VARCHAR2(50), INTEG_CABINET_AC_MFR_ID NUMBER, INTEG_CABINET_AC_NUM_ID_TEXT VARCHAR2(200));\", \"CREATE INDEX IDX_ENT_ROOM_ENTITY_ID ON RES_ENTITY.ENT_ROOM(ENTITY_ID);\", \"CREATE TABLE RES_ENTITY.STA_STATION (STATION_ID NUMBER PRIMARY KEY, STATION_CODE VARCHAR2(50), DISTRICT_PROVINCE_ID VARCHAR2(50), DISTRICT_REGION_ID VARCHAR2(50), DISTRICT_COUNTY_ID VARCHAR2(50), STATION_NAME VARCHAR2(200));\", \"CREATE INDEX IDX_STA_STATION_STATION_CODE ON RES_ENTITY.STA_STATION(STATION_CODE);\", \"CREATE TABLE RES_ENTITY.STA_APP_INFO (STATION_ID NUMBER, APP_REGION_ID VARCHAR2(50));\", \"CREATE INDEX IDX_STA_APP_INFO_STATION_ID ON RES_ENTITY.STA_APP_INFO(STATION_ID);\", \"CREATE TABLE RES_ENTITY.STA_BIZ_INFO (STATION_CODE VARCHAR2(50), REGION_ID VARCHAR2(50));\", \"CREATE INDEX IDX_STA_BIZ_INFO_REGION_ID ON RES_ENTITY.STA_BIZ_INFO(REGION_ID);\", \"CREATE TABLE RES_ENTITY.REG_MANAGE (REGION_ID VARCHAR2(50) PRIMARY KEY, SUPER_REGION_ID VARCHAR2(50), REGION_NAME VARCHAR2(200), DELETE_STATE VARCHAR2(2));\", \"CREATE INDEX IDX_REG_MANAGE_REGION_ID ON RES_ENTITY.REG_MANAGE(REGION_ID);\", \"CREATE TABLE RES_SYS.PUB_MFR (MFR_ID NUMBER PRIMARY KEY, MFR VARCHAR2(200), DELETE_STATE VARCHAR2(2));\", \"CREATE INDEX IDX_PUB_MFR_MFR_ID ON RES_SYS.PUB_MFR(MFR_ID);\", \"CREATE TABLE RES_SYS.PUB_DIC_EQP_TYPE (EQP_TYPE_ID NUMBER PRIMARY KEY, EQP_TYPE VARCHAR2(200), DELETE_STATE VARCHAR2(2));\", \"CREATE INDEX IDX_PUB_DIC_EQP_TYPE_ID ON RES_SYS.PUB_DIC_EQP_TYPE(EQP_TYPE_ID);\", \"CREATE TABLE RES_SYS.PUB_RME_EQP_MODEL (EQP_MODEL_ID NUMBER PRIMARY KEY, EQP_MODEL VARCHAR2(200), DELETE_STATE VARCHAR2(2));\", \"CREATE INDEX IDX_PUB_RME_EQP_MODEL_ID ON RES_SYS.PUB_RME_EQP_MODEL(EQP_MODEL_ID);\"], \"sql\": \"select *  from (select t.*,ROWNUM AS rn  from (SELECT\\n\\tEE.*,\\n\\tB.WIDTH,\\n\\tB.LENGTH,\\n\\tB.HEIGHT,\\n\\tB.AREA,\\n\\tB.FLOOR_NO,\\n\\tB.IS_OIL_MACH_ROOM,\\n\\tB.IS_HAVE_WALL,\\n\\tB.STRUCTURE_ID,\\n\\tB.ADDRESS,\\n\\tB.AIRBLAST_STYLE,\\n\\tB.VACANT_CABLE_SEAT,\\n\\tB.CONTACTS,\\n\\tB.LINK_TEL,\\n\\tB.NUM_HOLE_FEED,\\n\\tB.NUM_HOLE_FEED_OCCU,\\n\\tB.NUM_HOLE_FEED_FREE,\\n\\tB.LIGHT_PROTECTION_BRAND,\\n\\tB.LIGHT_PROTECTION_MODE,\\n\\tB.FIRE_EXTINGUISHER_TYPE,\\n\\tB.NUM_FIRE_EXTINGUISHER,\\n\\tB.STATION_ROAD_ID,\\n\\tB.DEGREE_ARRIVAL_ID,\\n\\tB.REASON_UNARRIVAL,\\n\\tB.IS_ARRIVEL,\\n\\tB.IS_POWER,\\n\\tB.REASON_UNPOWER,\\n\\tB.INOUT_MODE,\\n\\tB.PLATE_DRAWINGS_ID,\\n\\tB.DECORATION_DRAWINGS_ID,\\n\\tB.DESIGN_DRAWINGS_ID,\\n\\tB.GROUND_SYSTEM_DRAWINGS_ID,\\n\\tB.IS_EXPAND_OIL_ROOM,\\n\\tB.SECURITY_ENVIRONMENT_ID,\\n\\tB.GENERATION_TIME,\\n\\tB.WNG_STYLE,\\n\\tB.ROOM_GRADE_ID,\\n\\tB.NUM_RMEBAY_TOTAL,\\n\\tB.NUM_RMEBAY_FREE,\\n\\tB.PRODUCT_TYPE,\\n\\tB.ENT_AUDIT_RESULT_ID,\\n\\tB.AUDIT_FLOW_RESULT_ID,\\n\\tB.MANUAL_IDENT_RESULT_ID,\\n\\tB.AGENT_MNT_CONTACT,\\n\\tB.IS_VR_FULLSCENE_ID,\\n\\tB.IS_SHARE,\\n\\tB.SHARE_UNIT_ID,\\n\\tB.INTEG_CABINET_SPACE_NUM,\\n\\tB.INTEG_CABINET_AC_BRAND,\\n\\tB.INTEG_CABINET_AC_MODEL_DC,\\n\\tB.INTEG_CABINET_AC_NUM_DC,\\n\\tB.INTEG_CABINET_AC_MODEL,\\n\\tB.INTEG_CABINET_AC_NUM_DC_AC,\\n\\tB.INTEG_CABINET_SPACE_NUM AS INTEG_CABINET_SPACE_NUM_TEXT,\\n\\tEE.RES_FROM_PROJECT_NAME AS RES_FROM_PROJECT_NAME_TEXT,\\n\\tB.INTEG_CABINET_AC_NUM_ID,\\n\\tres_entity.SF_GET_DESC_CHINA(B.INTEG_CABINET_AC_NUM_ID) AS INTEG_CABINET_AC_NUM_ID_TEXT,\\n\\tB.INTEG_CABINET_AC_MFR_ID,\\n\\tB.INTEG_CABINET_AC_MODEL,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=B.INTEG_CABINET_AC_MFR_ID and delete_state='0') AS INTEG_CABINET_AC_MFR_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.TIME_TO_OVERDUE) AS TIME_TO_OVERDUE_TEXT,\\n\\t(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=B.MANUAL_IDENT_RESULT_ID AND DELETE_STATE = '0') AS MANUAL_IDENT_RESULT_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_STAFF_NAME(B.AGENT_MNT_CONTACT) AS AGENT_MNT_CONTACT_TEXT,\\n\\tCASE WHEN B.IS_VR_FULLSCENE_ID = 1 THEN '有' WHEN B.IS_VR_FULLSCENE_ID= 0 THEN '无' END AS IS_VR_FULLSCENE_ID_TEXT,\\n\\tCASE WHEN B.AIRBLAST_STYLE = 1 THEN '下送风' WHEN B.AIRBLAST_STYLE= 0 THEN '上送风' END AS AIRBLAST_STYLE_TEXT,\\n\\tCASE WHEN B.WNG_STYLE = 1 THEN '上走线' WHEN B.WNG_STYLE= 0 THEN '下走线' END AS WNG_STYLE_STYLE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_SHARE) AS IS_SHARE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.SHARE_UNIT_ID) AS SHARE_UNIT_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.AUDIT_FLOW_RESULT_ID) AS AUDIT_FLOW_RESULT_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.ENT_AUDIT_RESULT_ID) AS ENT_AUDIT_RESULT_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.PRODUCT_TYPE) AS PRODUCT_TYPE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_OIL_MACH_ROOM) AS IS_OIL_MACH_ROOM_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_HAVE_WALL) AS IS_HAVE_WALL_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.STRUCTURE_ID) AS STRUCTURE_ID_TEXT, \\n\\tres_entity.SF_GET_DESC_CHINA(B.VACANT_CABLE_SEAT) AS VACANT_CABLE_SEAT_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.STATION_ROAD_ID) AS STATION_ROAD_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.DEGREE_ARRIVAL_ID) AS DEGREE_ARRIVAL_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_ARRIVEL) AS IS_ARRIVEL_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_POWER) AS IS_POWER_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.INOUT_MODE) AS INOUT_MODE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_EXPAND_OIL_ROOM) AS IS_EXPAND_OIL_ROOM_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.SECURITY_ENVIRONMENT_ID) AS SECURITY_ENVIRONMENT_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.WNG_STYLE) AS WNG_STYLE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.ROOM_GRADE_ID) AS ROOM_GRADE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_MODE_ID) AS CHECK_MODE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.BUSINESS_ID) AS BUSINESS_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SUB_BUSINESS_ID) AS SUB_BUSINESS_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.PROP_ID) AS PROP_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.OLD_PROP_ID) AS OLD_PROP_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.PROPERTY_ID) AS PROPERTY_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_STATE_ID) AS ENTITY_STATE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_LOCKED_ID) AS IS_LOCKED_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_FAULT_ID) AS IS_FAULT_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OVERDUE) AS IS_OVERDUE_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.WARRANTY_GRADE_ID) AS WARRANTY_GRADE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OUTMAINTENANCE_ID) AS IS_OUTMAINTENANCE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ASSETS_RECEIVE_TYPE_ID) AS ASSETS_RECEIVE_TYPE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_CREATE_SOURCE_ID) AS ENTITY_CREATE_SOURCE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SOURCE_SYSTEM_ID) AS SOURCE_SYSTEM_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_RESULT_ID) AS CHECK_RESULT_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SERVICE_STATE_ID) AS SERVICE_STATE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_MONITOR_ID) AS IS_MONITOR_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.MONITOR_STYLE_ID) AS MONITOR_STYLE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_UPLOAD_PHOTO) AS IS_UPLOAD_PHOTO_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.STORAGE_STATE_ID) AS STORAGE_STATE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_STORAGE) AS IS_STORAGE_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.RES_FROM_PROJBUILDTYPE_ID) AS RES_FROM_PROJBUILDTYPE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SPLIT_MERGE_REASON_ID) AS SPLIT_MERGE_REASON_ID_TEXT,\\n\\tEE.SOURCE_RES_NO AS SOURCE_RES_NO_TEXT,\\n\\t(SELECT ENTITY_NAME FROM res_entity.ent_entity WHERE ENTITY_ID=EE.ROOM_ID and res_type_id='205' and delete_state='0') AS ROOM_ID_TEXT,\\n\\t(SELECT RES_TYPE FROM RES_SYS.PUB_DIC_RES_TYPE WHERE RES_TYPE_ID=EE.RES_TYPE_ID and delete_state='0') AS RES_TYPE_ID_TEXT,\\n\\t(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=EE.DEV_TYPE_ID and delete_state='0') AS DEV_TYPE_ID_TEXT,\\n\\t(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.DEV_MODEL_ID and delete_state='0') AS DEV_MODEL_ID_TEXT,\\n\\t(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.OLD_DEV_MODEL_ID and delete_state='0') AS OLD_DEV_MODEL_ID_TEXT,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MFR_ID and delete_state='0') AS MFR_ID_TEXT,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.DW_MFR_ID and delete_state='0') AS DW_MFR_ID_TEXT,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.OLD_DW_MFR_ID and delete_state='0') AS OLD_DW_MFR_ID_TEXT,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MNT_MFR_ID and delete_state='0') AS MNT_MFR_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_STAFF_NAME(EE.MODIFY_OP) AS MODIFY_OP_TEXT,\\n\\tRES_ENTITY.SF_GET_STAFF_NAME(EE.CREATE_OP) AS CREATE_OP_TEXT,\\n\\tRES_ENTITY.SF_GET_STAFF_NAME(EE.CHECK_PERSON) AS CHECK_PERSON_TEXT,\\n\\tST.DISTRICT_PROVINCE_ID,\\n\\tST.DISTRICT_REGION_ID,\\n\\tST.DISTRICT_COUNTY_ID,\\n\\tST.STATION_NAME,\\n\\tST.STATION_NAME AS STATION_ID_TEXT,\\n\\tD.APP_REGION_ID,\\n\\t(SELECT REGION_NAME FROM res_entity.REG_MANAGE WHERE REGION_ID = D.APP_REGION_ID AND delete_state = '0') AS APP_REGION_ID_TEXT,\\n\\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) AS DISTRICT_PROVINCE_ID_TEXT,\\n\\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) AS DISTRICT_REGION_ID_TEXT,\\n\\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS DISTRICT_COUNTY_ID_TEXT,\\n\\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS REGION_ID_TEXT \\nFROM RES_ENTITY.ENT_ENTITY EE \\nLEFT JOIN RES_ENTITY.ENT_ROOM B ON B.ENTITY_ID = EE.ENTITY_ID\\nLEFT JOIN RES_ENTITY.STA_STATION ST ON ST.STATION_CODE = EE.STATION_CODE  \\nLEFT JOIN RES_ENTITY.STA_APP_INFO D ON ST.STATION_ID=D.STATION_ID\\nWHERE EE.DELETE_STATE = '0' AND EE.RES_TYPE_ID=205  \\nAND EE.STATION_CODE in  (select station_code  from res_entity.sta_biz_info  where  REGION_ID in (  select REGION_ID from res_entity.reg_manage  connect by prior REGION_ID = SUPER_REGION_ID and nvl(delete_state, '0') = '0' start with region_id in ('000102000000000000370100') ) ) \\n)t where ROWNUM <= 10) where rn > 0;\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t4200\\t10\\t120000\\t360000\\t14000\\n1\\t  NESTED LOOPS\\t4200\\t10\\t120000\\t360000\\t14000\\n2\\t   TABLE ACCESS FULL RES_ENTITY.ENT_ENTITY\\t3000\\t10000\\t800000\\t240000\\t10000\\n3\\t  FILTER (EE.DELETE_STATE='0' AND EE.RES_TYPE_ID=205 AND EE.STATION_CODE IN (... CONNECT BY result ...))\\t---\\t---\\t---\\t---\\t---\\n4\\t   NESTED LOOPS\\t1200\\t10\\t24000\\t80000\\t4000\\n5\\t  INDEX UNIQUE SCAN IDX_ENT_ROOM_ENTITY_ID (ENT_ROOM)\\t10\\t10\\t800\\t4000\\t50\\n6\\t   TABLE ACCESS BY INDEX ROWID RES_ENTITY.ENT_ROOM\\t20\\t10\\t800\\t2000\\t100\\n7\\t  INDEX RANGE SCAN IDX_STA_STATION_STATION_CODE (STA_STATION)\\t50\\t10\\t2000\\t5000\\t200\\n8\\t   TABLE ACCESS BY INDEX ROWID RES_ENTITY.STA_STATION\\t60\\t10\\t2000\\t4000\\t200\\n9\\t  TABLE ACCESS BY INDEX ROWID RES_ENTITY.STA_APP_INFO\\t40\\t10\\t1600\\t3000\\t150\\n10\\t  NESTED LOOPS (correlated scalar subquery evaluations)\\t800\\t10\\t20000\\t60000\\t3000\\n11\\t   INDEX RANGE SCAN IDX_PUB_MFR_MFR_ID (RES_SYS.PUB_MFR)\\t5\\t10\\t800\\t2000\\t20\\n12\\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_MFR\\t10\\t10\\t800\\t2000\\t30\\n13\\t   INDEX RANGE SCAN IDX_PUB_DIC_EQP_TYPE_ID (RES_SYS.PUB_DIC_EQP_TYPE)\\t5\\t10\\t800\\t2000\\t20\\n14\\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_DIC_EQP_TYPE\\t10\\t10\\t800\\t2000\\t30\\n15\\t   INDEX RANGE SCAN IDX_PUB_RME_EQP_MODEL_ID (RES_SYS.PUB_RME_EQP_MODEL)\\t5\\t10\\t800\\t2000\\t20\\n16\\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_RME_EQP_MODEL\\t10\\t10\\t800\\t2000\\t30\\n17\\t  FILTER (ROWNUM <= 10 applied in inner view)\\t---\\t---\\t---\\t---\\t---\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE RES_ENTITY.ENT_ENTITY (ENTITY_ID VARCHAR2(50) PRIMARY KEY, DELETE_STATE VARCHAR2(2), RES_TYPE_ID NUMBER, STATION_CODE VARCHAR2(50), TIME_TO_OVERDUE VARCHAR2(50), CHECK_MODE_ID NUMBER, BUSINESS_ID NUMBER, SUB_BUSINESS_ID NUMBER, PROP_ID NUMBER, OLD_PROP_ID NUMBER, PROPERTY_ID NUMBER, ENTITY_STATE_ID NUMBER, IS_LOCKED_ID NUMBER, IS_FAULT_ID NUMBER, IS_OVERDUE NUMBER, WARRANTY_GRADE_ID NUMBER, IS_OUTMAINTENANCE_ID NUMBER, ASSETS_RECEIVE_TYPE_ID NUMBER, ENTITY_CREATE_SOURCE_ID NUMBER, SOURCE_SYSTEM_ID NUMBER, CHECK_RESULT_ID NUMBER, SERVICE_STATE_ID NUMBER, IS_MONITOR_ID NUMBER, MONITOR_STYLE_ID NUMBER, IS_UPLOAD_PHOTO NUMBER, STORAGE_STATE_ID NUMBER, IS_STORAGE NUMBER, RES_FROM_PROJBUILDTYPE_ID NUMBER, SPLIT_MERGE_REASON_ID NUMBER, SOURCE_RES_NO VARCHAR2(100), ROOM_ID VARCHAR2(50), RES_TYPE_ID_TEXT VARCHAR2(100), DEV_TYPE_ID NUMBER, DEV_MODEL_ID NUMBER, OLD_DEV_MODEL_ID NUMBER, MFR_ID NUMBER, DW_MFR_ID NUMBER, OLD_DW_MFR_ID NUMBER, MNT_MFR_ID NUMBER, MODIFY_OP VARCHAR2(50), CREATE_OP VARCHAR2(50), CHECK_PERSON VARCHAR2(50), STATION_CODE_ALT VARCHAR2(50));\nCREATE INDEX IDX_ENT_ENTITY_DELETE_RES_TYPE_STCODE ON RES_ENTITY.ENT_ENTITY(DELETE_STATE, RES_TYPE_ID, STATION_CODE);\nCREATE TABLE RES_ENTITY.ENT_ROOM (ENTITY_ID VARCHAR2(50), WIDTH NUMBER, LENGTH NUMBER, HEIGHT NUMBER, AREA NUMBER, FLOOR_NO NUMBER, IS_OIL_MACH_ROOM NUMBER, IS_HAVE_WALL NUMBER, STRUCTURE_ID NUMBER, ADDRESS VARCHAR2(400), AIRBLAST_STYLE NUMBER, VACANT_CABLE_SEAT NUMBER, CONTACTS VARCHAR2(200), LINK_TEL VARCHAR2(50), NUM_HOLE_FEED NUMBER, NUM_HOLE_FEED_OCCU NUMBER, NUM_HOLE_FEED_FREE NUMBER, LIGHT_PROTECTION_BRAND VARCHAR2(200), LIGHT_PROTECTION_MODE VARCHAR2(200), FIRE_EXTINGUISHER_TYPE VARCHAR2(100), NUM_FIRE_EXTINGUISHER NUMBER, STATION_ROAD_ID NUMBER, DEGREE_ARRIVAL_ID NUMBER, REASON_UNARRIVAL VARCHAR2(400), IS_ARRIVEL NUMBER, IS_POWER NUMBER, REASON_UNPOWER VARCHAR2(400), INOUT_MODE NUMBER, PLATE_DRAWINGS_ID VARCHAR2(50), DECORATION_DRAWINGS_ID VARCHAR2(50), DESIGN_DRAWINGS_ID VARCHAR2(50), GROUND_SYSTEM_DRAWINGS_ID VARCHAR2(50), IS_EXPAND_OIL_ROOM NUMBER, SECURITY_ENVIRONMENT_ID NUMBER, GENERATION_TIME DATE, WNG_STYLE NUMBER, ROOM_GRADE_ID NUMBER, NUM_RMEBAY_TOTAL NUMBER, NUM_RMEBAY_FREE NUMBER, PRODUCT_TYPE NUMBER, ENT_AUDIT_RESULT_ID NUMBER, AUDIT_FLOW_RESULT_ID NUMBER, MANUAL_IDENT_RESULT_ID NUMBER, AGENT_MNT_CONTACT VARCHAR2(50), IS_VR_FULLSCENE_ID NUMBER, IS_SHARE NUMBER, SHARE_UNIT_ID VARCHAR2(50), INTEG_CABINET_SPACE_NUM NUMBER, INTEG_CABINET_AC_BRAND VARCHAR2(200), INTEG_CABINET_AC_MODEL_DC VARCHAR2(200), INTEG_CABINET_AC_NUM_DC NUMBER, INTEG_CABINET_AC_MODEL VARCHAR2(200), INTEG_CABINET_AC_NUM_DC_AC NUMBER, INTEG_CABINET_AC_NUM_ID VARCHAR2(50), INTEG_CABINET_AC_MFR_ID NUMBER, INTEG_CABINET_AC_NUM_ID_TEXT VARCHAR2(200));\nCREATE INDEX IDX_ENT_ROOM_ENTITY_ID ON RES_ENTITY.ENT_ROOM(ENTITY_ID);\nCREATE TABLE RES_ENTITY.STA_STATION (STATION_ID NUMBER PRIMARY KEY, STATION_CODE VARCHAR2(50), DISTRICT_PROVINCE_ID VARCHAR2(50), DISTRICT_REGION_ID VARCHAR2(50), DISTRICT_COUNTY_ID VARCHAR2(50), STATION_NAME VARCHAR2(200));\nCREATE INDEX IDX_STA_STATION_STATION_CODE ON RES_ENTITY.STA_STATION(STATION_CODE);\nCREATE TABLE RES_ENTITY.STA_APP_INFO (STATION_ID NUMBER, APP_REGION_ID VARCHAR2(50));\nCREATE INDEX IDX_STA_APP_INFO_STATION_ID ON RES_ENTITY.STA_APP_INFO(STATION_ID);\nCREATE TABLE RES_ENTITY.STA_BIZ_INFO (STATION_CODE VARCHAR2(50), REGION_ID VARCHAR2(50));\nCREATE INDEX IDX_STA_BIZ_INFO_REGION_ID ON RES_ENTITY.STA_BIZ_INFO(REGION_ID);\nCREATE TABLE RES_ENTITY.REG_MANAGE (REGION_ID VARCHAR2(50) PRIMARY KEY, SUPER_REGION_ID VARCHAR2(50), REGION_NAME VARCHAR2(200), DELETE_STATE VARCHAR2(2));\nCREATE INDEX IDX_REG_MANAGE_REGION_ID ON RES_ENTITY.REG_MANAGE(REGION_ID);\nCREATE TABLE RES_SYS.PUB_MFR (MFR_ID NUMBER PRIMARY KEY, MFR VARCHAR2(200), DELETE_STATE VARCHAR2(2));\nCREATE INDEX IDX_PUB_MFR_MFR_ID ON RES_SYS.PUB_MFR(MFR_ID);\nCREATE TABLE RES_SYS.PUB_DIC_EQP_TYPE (EQP_TYPE_ID NUMBER PRIMARY KEY, EQP_TYPE VARCHAR2(200), DELETE_STATE VARCHAR2(2));\nCREATE INDEX IDX_PUB_DIC_EQP_TYPE_ID ON RES_SYS.PUB_DIC_EQP_TYPE(EQP_TYPE_ID);\nCREATE TABLE RES_SYS.PUB_RME_EQP_MODEL (EQP_MODEL_ID NUMBER PRIMARY KEY, EQP_MODEL VARCHAR2(200), DELETE_STATE VARCHAR2(2));\nCREATE INDEX IDX_PUB_RME_EQP_MODEL_ID ON RES_SYS.PUB_RME_EQP_MODEL(EQP_MODEL_ID);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t4200\t10\t120000\t360000\t14000\n1\t  NESTED LOOPS\t4200\t10\t120000\t360000\t14000\n2\t   TABLE ACCESS FULL RES_ENTITY.ENT_ENTITY\t3000\t10000\t800000\t240000\t10000\n3\t  FILTER (EE.DELETE_STATE='0' AND EE.RES_TYPE_ID=205 AND EE.STATION_CODE IN (... CONNECT BY result ...))\t---\t---\t---\t---\t---\n4\t   NESTED LOOPS\t1200\t10\t24000\t80000\t4000\n5\t  INDEX UNIQUE SCAN IDX_ENT_ROOM_ENTITY_ID (ENT_ROOM)\t10\t10\t800\t4000\t50\n6\t   TABLE ACCESS BY INDEX ROWID RES_ENTITY.ENT_ROOM\t20\t10\t800\t2000\t100\n7\t  INDEX RANGE SCAN IDX_STA_STATION_STATION_CODE (STA_STATION)\t50\t10\t2000\t5000\t200\n8\t   TABLE ACCESS BY INDEX ROWID RES_ENTITY.STA_STATION\t60\t10\t2000\t4000\t200\n9\t  TABLE ACCESS BY INDEX ROWID RES_ENTITY.STA_APP_INFO\t40\t10\t1600\t3000\t150\n10\t  NESTED LOOPS (correlated scalar subquery evaluations)\t800\t10\t20000\t60000\t3000\n11\t   INDEX RANGE SCAN IDX_PUB_MFR_MFR_ID (RES_SYS.PUB_MFR)\t5\t10\t800\t2000\t20\n12\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_MFR\t10\t10\t800\t2000\t30\n13\t   INDEX RANGE SCAN IDX_PUB_DIC_EQP_TYPE_ID (RES_SYS.PUB_DIC_EQP_TYPE)\t5\t10\t800\t2000\t20\n14\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_DIC_EQP_TYPE\t10\t10\t800\t2000\t30\n15\t   INDEX RANGE SCAN IDX_PUB_RME_EQP_MODEL_ID (RES_SYS.PUB_RME_EQP_MODEL)\t5\t10\t800\t2000\t20\n16\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_RME_EQP_MODEL\t10\t10\t800\t2000\t30\n17\t  FILTER (ROWNUM <= 10 applied in inner view)\t---\t---\t---\t---\t---\n\n## Original SQL:\nselect *  from (select t.*,ROWNUM AS rn  from (SELECT\n\tEE.*,\n\tB.WIDTH,\n\tB.LENGTH,\n\tB.HEIGHT,\n\tB.AREA,\n\tB.FLOOR_NO,\n\tB.IS_OIL_MACH_ROOM,\n\tB.IS_HAVE_WALL,\n\tB.STRUCTURE_ID,\n\tB.ADDRESS,\n\tB.AIRBLAST_STYLE,\n\tB.VACANT_CABLE_SEAT,\n\tB.CONTACTS,\n\tB.LINK_TEL,\n\tB.NUM_HOLE_FEED,\n\tB.NUM_HOLE_FEED_OCCU,\n\tB.NUM_HOLE_FEED_FREE,\n\tB.LIGHT_PROTECTION_BRAND,\n\tB.LIGHT_PROTECTION_MODE,\n\tB.FIRE_EXTINGUISHER_TYPE,\n\tB.NUM_FIRE_EXTINGUISHER,\n\tB.STATION_ROAD_ID,\n\tB.DEGREE_ARRIVAL_ID,\n\tB.REASON_UNARRIVAL,\n\tB.IS_ARRIVEL,\n\tB.IS_POWER,\n\tB.REASON_UNPOWER,\n\tB.INOUT_MODE,\n\tB.PLATE_DRAWINGS_ID,\n\tB.DECORATION_DRAWINGS_ID,\n\tB.DESIGN_DRAWINGS_ID,\n\tB.GROUND_SYSTEM_DRAWINGS_ID,\n\tB.IS_EXPAND_OIL_ROOM,\n\tB.SECURITY_ENVIRONMENT_ID,\n\tB.GENERATION_TIME,\n\tB.WNG_STYLE,\n\tB.ROOM_GRADE_ID,\n\tB.NUM_RMEBAY_TOTAL,\n\tB.NUM_RMEBAY_FREE,\n\tB.PRODUCT_TYPE,\n\tB.ENT_AUDIT_RESULT_ID,\n\tB.AUDIT_FLOW_RESULT_ID,\n\tB.MANUAL_IDENT_RESULT_ID,\n\tB.AGENT_MNT_CONTACT,\n\tB.IS_VR_FULLSCENE_ID,\n\tB.IS_SHARE,\n\tB.SHARE_UNIT_ID,\n\tB.INTEG_CABINET_SPACE_NUM,\n\tB.INTEG_CABINET_AC_BRAND,\n\tB.INTEG_CABINET_AC_MODEL_DC,\n\tB.INTEG_CABINET_AC_NUM_DC,\n\tB.INTEG_CABINET_AC_MODEL,\n\tB.INTEG_CABINET_AC_NUM_DC_AC,\n\tB.INTEG_CABINET_SPACE_NUM AS INTEG_CABINET_SPACE_NUM_TEXT,\n\tEE.RES_FROM_PROJECT_NAME AS RES_FROM_PROJECT_NAME_TEXT,\n\tB.INTEG_CABINET_AC_NUM_ID,\n\tres_entity.SF_GET_DESC_CHINA(B.INTEG_CABINET_AC_NUM_ID) AS INTEG_CABINET_AC_NUM_ID_TEXT,\n\tB.INTEG_CABINET_AC_MFR_ID,\n\tB.INTEG_CABINET_AC_MODEL,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=B.INTEG_CABINET_AC_MFR_ID and delete_state='0') AS INTEG_CABINET_AC_MFR_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.TIME_TO_OVERDUE) AS TIME_TO_OVERDUE_TEXT,\n\t(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=B.MANUAL_IDENT_RESULT_ID AND DELETE_STATE = '0') AS MANUAL_IDENT_RESULT_ID_TEXT,\n\tRES_ENTITY.SF_GET_STAFF_NAME(B.AGENT_MNT_CONTACT) AS AGENT_MNT_CONTACT_TEXT,\n\tCASE WHEN B.IS_VR_FULLSCENE_ID = 1 THEN '有' WHEN B.IS_VR_FULLSCENE_ID= 0 THEN '无' END AS IS_VR_FULLSCENE_ID_TEXT,\n\tCASE WHEN B.AIRBLAST_STYLE = 1 THEN '下送风' WHEN B.AIRBLAST_STYLE= 0 THEN '上送风' END AS AIRBLAST_STYLE_TEXT,\n\tCASE WHEN B.WNG_STYLE = 1 THEN '上走线' WHEN B.WNG_STYLE= 0 THEN '下走线' END AS WNG_STYLE_STYLE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_SHARE) AS IS_SHARE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.SHARE_UNIT_ID) AS SHARE_UNIT_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.AUDIT_FLOW_RESULT_ID) AS AUDIT_FLOW_RESULT_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.ENT_AUDIT_RESULT_ID) AS ENT_AUDIT_RESULT_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.PRODUCT_TYPE) AS PRODUCT_TYPE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_OIL_MACH_ROOM) AS IS_OIL_MACH_ROOM_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_HAVE_WALL) AS IS_HAVE_WALL_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.STRUCTURE_ID) AS STRUCTURE_ID_TEXT, \n\tres_entity.SF_GET_DESC_CHINA(B.VACANT_CABLE_SEAT) AS VACANT_CABLE_SEAT_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.STATION_ROAD_ID) AS STATION_ROAD_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.DEGREE_ARRIVAL_ID) AS DEGREE_ARRIVAL_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_ARRIVEL) AS IS_ARRIVEL_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_POWER) AS IS_POWER_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.INOUT_MODE) AS INOUT_MODE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_EXPAND_OIL_ROOM) AS IS_EXPAND_OIL_ROOM_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.SECURITY_ENVIRONMENT_ID) AS SECURITY_ENVIRONMENT_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.WNG_STYLE) AS WNG_STYLE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.ROOM_GRADE_ID) AS ROOM_GRADE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_MODE_ID) AS CHECK_MODE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.BUSINESS_ID) AS BUSINESS_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SUB_BUSINESS_ID) AS SUB_BUSINESS_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.PROP_ID) AS PROP_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.OLD_PROP_ID) AS OLD_PROP_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.PROPERTY_ID) AS PROPERTY_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_STATE_ID) AS ENTITY_STATE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_LOCKED_ID) AS IS_LOCKED_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_FAULT_ID) AS IS_FAULT_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OVERDUE) AS IS_OVERDUE_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.WARRANTY_GRADE_ID) AS WARRANTY_GRADE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OUTMAINTENANCE_ID) AS IS_OUTMAINTENANCE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ASSETS_RECEIVE_TYPE_ID) AS ASSETS_RECEIVE_TYPE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_CREATE_SOURCE_ID) AS ENTITY_CREATE_SOURCE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SOURCE_SYSTEM_ID) AS SOURCE_SYSTEM_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_RESULT_ID) AS CHECK_RESULT_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SERVICE_STATE_ID) AS SERVICE_STATE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_MONITOR_ID) AS IS_MONITOR_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.MONITOR_STYLE_ID) AS MONITOR_STYLE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_UPLOAD_PHOTO) AS IS_UPLOAD_PHOTO_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.STORAGE_STATE_ID) AS STORAGE_STATE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_STORAGE) AS IS_STORAGE_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.RES_FROM_PROJBUILDTYPE_ID) AS RES_FROM_PROJBUILDTYPE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SPLIT_MERGE_REASON_ID) AS SPLIT_MERGE_REASON_ID_TEXT,\n\tEE.SOURCE_RES_NO AS SOURCE_RES_NO_TEXT,\n\t(SELECT ENTITY_NAME FROM res_entity.ent_entity WHERE ENTITY_ID=EE.ROOM_ID and res_type_id='205' and delete_state='0') AS ROOM_ID_TEXT,\n\t(SELECT RES_TYPE FROM RES_SYS.PUB_DIC_RES_TYPE WHERE RES_TYPE_ID=EE.RES_TYPE_ID and delete_state='0') AS RES_TYPE_ID_TEXT,\n\t(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=EE.DEV_TYPE_ID and delete_state='0') AS DEV_TYPE_ID_TEXT,\n\t(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.DEV_MODEL_ID and delete_state='0') AS DEV_MODEL_ID_TEXT,\n\t(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.OLD_DEV_MODEL_ID and delete_state='0') AS OLD_DEV_MODEL_ID_TEXT,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MFR_ID and delete_state='0') AS MFR_ID_TEXT,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.DW_MFR_ID and delete_state='0') AS DW_MFR_ID_TEXT,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.OLD_DW_MFR_ID and delete_state='0') AS OLD_DW_MFR_ID_TEXT,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MNT_MFR_ID and delete_state='0') AS MNT_MFR_ID_TEXT,\n\tRES_ENTITY.SF_GET_STAFF_NAME(EE.MODIFY_OP) AS MODIFY_OP_TEXT,\n\tRES_ENTITY.SF_GET_STAFF_NAME(EE.CREATE_OP) AS CREATE_OP_TEXT,\n\tRES_ENTITY.SF_GET_STAFF_NAME(EE.CHECK_PERSON) AS CHECK_PERSON_TEXT,\n\tST.DISTRICT_PROVINCE_ID,\n\tST.DISTRICT_REGION_ID,\n\tST.DISTRICT_COUNTY_ID,\n\tST.STATION_NAME,\n\tST.STATION_NAME AS STATION_ID_TEXT,\n\tD.APP_REGION_ID,\n\t(SELECT REGION_NAME FROM res_entity.REG_MANAGE WHERE REGION_ID = D.APP_REGION_ID AND delete_state = '0') AS APP_REGION_ID_TEXT,\n\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) AS DISTRICT_PROVINCE_ID_TEXT,\n\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) AS DISTRICT_REGION_ID_TEXT,\n\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS DISTRICT_COUNTY_ID_TEXT,\n\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS REGION_ID_TEXT \nFROM RES_ENTITY.ENT_ENTITY EE \nLEFT JOIN RES_ENTITY.ENT_ROOM B ON B.ENTITY_ID = EE.ENTITY_ID\nLEFT JOIN RES_ENTITY.STA_STATION ST ON ST.STATION_CODE = EE.STATION_CODE  \nLEFT JOIN RES_ENTITY.STA_APP_INFO D ON ST.STATION_ID=D.STATION_ID\nWHERE EE.DELETE_STATE = '0' AND EE.RES_TYPE_ID=205  \nAND EE.STATION_CODE in  (select station_code  from res_entity.sta_biz_info  where  REGION_ID in (  select REGION_ID from res_entity.reg_manage  connect by prior REGION_ID = SUPER_REGION_ID and nvl(delete_state, '0') = '0' start with region_id in ('000102000000000000370100') ) ) \n)t where ROWNUM <= 10) where rn > 0;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select * from (select t.*,row_number()over(order by t.entity_id)as rn from(select/*+use_hash(ee sb rm dt em rt)*/ee.*,b.width,b.length,b.height,b.area,b.floor_no,b.is_oil_mach_room,b.is_have_wall,b.structure_id,b.address,b.airblast_style,b.vacant_cable_seat,b.contacts,b.link_tel,b.num_hole_feed,b.num_hole_feed_occu,b.num_hole_feed_free,b.light_protection_brand,b.light_protection_mode,b.fire_extinguisher_type,b.num_fire_extinguisher,b.station_road_id,b.degree_arrival_id,b.reason_unarrival,b.is_arrivel,b.is_power,b.reason_unpower,b.inout_mode,b.plate_drawings_id,b.decoration_drawings_id,b.design_drawings_id,b.ground_system_drawings_id,b.is_expand_oil_room,b.security_environment_id,b.generation_time,b.wng_style,b.room_grade_id,b.num_rmebay_total,b.num_rmebay_free,b.product_type,b.ent_audit_result_id,b.audit_flow_result_id,b.manual_ident_result_id,b.agent_mnt_contact,b.is_vr_fullscene_id,b.is_share,b.share_unit_id,b.integ_cabinet_space_num,b.integ_cabinet_ac_brand,b.integ_cabinet_ac_model_dc,b.integ_cabinet_ac_num_dc,b.integ_cabinet_ac_model,b.integ_cabinet_ac_num_dc_ac,b.integ_cabinet_space_num,ee.res_from_project_name,b.integ_cabinet_ac_num_id,res_entity.sf_get_desc_china(b.integ_cabinet_ac_num_id),b.integ_cabinet_ac_mfr_id,b.integ_cabinet_ac_model,mf1.mfr,res_entity.sf_get_desc_china(ee.time_to_overdue),eqt1.eqp_type,res_entity.sf_get_staff_name(b.agent_mnt_contact),case when b.is_vr_fullscene_id=1then'有'when b.is_vr_fullscene_id=0then'无'end,case when b.airblast_style=1then'下送风'when b.airblast_style=0then'上送风'end,case when b.wng_style=1then'上走线'when b.wng_style=0then'下走线'end,res_entity.sf_get_desc_china(b.is_share),res_entity.sf_get_desc_china(b.share_unit_id),res_entity.sf_get_desc_china(b.audit_flow_result_id),res_entity.sf_get_desc_china(b.ent_audit_result_id),res_entity.sf_get_desc_china(b.product_type),res_entity.sf_get_desc_china(b.is_oil_mach_room),res_entity.sf_get_desc_china(b.is_have_wall),res_entity.sf_get_desc_china(b.structure_id),res_entity.sf_get_desc_china(b.vacant_cable_seat),res_entity.sf_get_desc_china(b.station_road_id),res_entity.sf_get_desc_china(b.degree_arrival_id),res_entity.sf_get_desc_china(b.is_arrivel),res_entity.sf_get_desc_china(b.is_power),res_entity.sf_get_desc_china(b.inout_mode),res_entity.sf_get_desc_china(b.is_expand_oil_room),res_entity.sf_get_desc_china(b.security_environment_id),res_entity.sf_get_desc_china(b.wng_style),res_entity.sf_get_desc_china(b.room_grade_id),res_entity.sf_get_desc_china(ee.check_mode_id),res_entity.sf_get_desc_china(ee.business_id),res_entity.sf_get_desc_china(ee.sub_business_id),res_entity.sf_get_desc_china(ee.prop_id),res_entity.sf_get_desc_china(ee.old_prop_id),res_entity.sf_get_desc_china(ee.property_id),res_entity.sf_get_desc_china(ee.entity_state_id),res_entity.sf_get_desc_china(ee.is_locked_id),res_entity.sf_get_desc_china(ee.is_fault_id),res_entity.sf_get_desc_china(ee.is_overdue),res_entity.sf_get_desc_china(ee.warranty_grade_id),res_entity.sf_get_desc_china(ee.is_outmaintenance_id),res_entity.sf_get_desc_china(ee.assets_receive_type_id),res_entity.sf_get_desc_china(ee.entity_create_source_id),res_entity.sf_get_desc_china(ee.source_system_id),res_entity.sf_get_desc_china(ee.check_result_id),res_entity.sf_get_desc_china(ee.service_state_id),res_entity.sf_get_desc_china(ee.is_monitor_id),res_entity.sf_get_desc_china(ee.monitor_style_id),res_entity.sf_get_desc_china(ee.is_upload_photo),res_entity.sf_get_desc_china(ee.storage_state_id),res_entity.sf_get_desc_china(ee.is_storage),res_entity.sf_get_desc_china(ee.res_from_projbuildtype_id),res_entity.sf_get_desc_china(ee.split_merge_reason_id),ee.source_res_no,(select entity_name from res_entity.ent_entity where entity_id=ee.room_id and res_type_id='205'and delete_state='0'),rt.res_type,eqt2.eqp_type,em1.eqp_model,em2.eqp_model,mf2.mfr,mf3.mfr,mf4.mfr,mf5.mfr,res_entity.sf_get_staff_name(ee.modify_op),res_entity.sf_get_staff_name(ee.create_op),res_entity.sf_get_staff_name(ee.check_person),st.district_province_id,st.district_region_id,st.district_county_id,st.station_name,st.station_name,d.app_region_id,(select region_name from res_entity.reg_manage where region_id=d.app_region_id and delete_state='0'),res_entity.sf_get_district_name(st.district_province_id),res_entity.sf_get_district_name(st.district_region_id),res_entity.sf_get_district_name(st.district_county_id),res_entity.sf_get_district_name(st.district_province_id)||res_entity.sf_get_district_name(st.district_region_id)||res_entity.sf_get_district_name(st.district_county_id)from res_entity.ent_entity ee left join res_entity.ent_room b on b.entity_id=ee.entity_id left join res_entity.sta_station st on st.station_code=ee.station_code left join res_entity.sta_app_info d on st.station_id=d.station_id left join res_sys.pub_mfr mf1 on mf1.mfr_id=b.integ_cabinet_ac_mfr_id and mf1.delete_state='0'left join res_sys.pub_dic_eqp_type eqt1 on eqt1.eqp_type_id=b.manual_ident_result_id and eqt1.delete_state='0'left join res_sys.pub_dic_res_type rt on rt.res_type_id=ee.res_type_id and rt.delete_state='0'left join res_sys.pub_dic_eqp_type eqt2 on eqt2.eqp_type_id=ee.dev_type_id and eqt2.delete_state='0'left join res_sys.pub_rme_eqp_model em1 on em1.eqp_model_id=ee.dev_model_id and em1.delete_state='0'left join res_sys.pub_rme_eqp_model em2 on em2.eqp_model_id=ee.old_dev_model_id and em2.delete_state='0'left join res_sys.pub_mfr mf2 on mf2.mfr_id=ee.mfr_id and mf2.delete_state='0'left join res_sys.pub_mfr mf3 on mf3.mfr_id=ee.dw_mfr_id and mf3.delete_state='0'left join res_sys.pub_mfr mf4 on mf4.mfr_id=ee.old_dw_mfr_id and mf4.delete_state='0'left join res_sys.pub_mfr mf5 on mf5.mfr_id=ee.mnt_mfr_id and mf5.delete_state='0'where ee.delete_state='0'and ee.res_type_id=205 and ee.station_code in(select distinct station_code from res_entity.sta_biz_info where region_id in(select region_id from res_entity.reg_manage where delete_state='0'connect by prior region_id=super_region_id start with region_id in('000102000000000000370100'))))t where rn<=10"
                    }
                ]
            },
            {
                "case_id": "41",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"41\", \"db_type\": \"postgresql\", \"description\": \"该SQL旨在统计四个不同时间窗口内（过去7、13、25、2小时），各行政区划的'zdjs'指标最大值。存在显著的性能问题：1. **冗余列投影**：最内层查询选取了`zdbh`、`zxjs`等后续聚合不需要的字段，增加了不必要的I/O和内存开销。2. **无效排序**：四个作为JOIN源表的子查询（Derived Table）内部均包含`ORDER BY \\\"zdjs\\\" desc`但无`LIMIT`，这种排序在关联操作中是无意义的，且可能触发额外的排序操作。3. **多层嵌套**：存在冗余的子查询层级，导致生成不必要的临时结果集。优化方向包括移除无效排序、裁剪非必要列以及子查询扁平化。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE SCHEMA IF NOT EXISTS WHYJ_SJZL;\", \"CREATE TABLE WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" (\\\"xzqhdm\\\" VARCHAR(50), \\\"zdbh\\\" VARCHAR(50), \\\"zdjs\\\" NUMERIC, \\\"zxjs\\\" NUMERIC, \\\"gxsj\\\" TIMESTAMP);\", \"CREATE INDEX idx_ds_dm_tqyj_jssk_gxsj ON WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\"(\\\"gxsj\\\");\", \"CREATE INDEX idx_ds_dm_tqyj_jssk_xzqhdm ON WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\"(\\\"xzqhdm\\\");\"], \"sql\": \"select \\\"a\\\".\\\"qh\\\" as \\\"qhmc\\\",\\\"d\\\".\\\"zdjs\\\" as \\\"1xszdjs\\\",\\\"a\\\".\\\"zdjs\\\" as \\\"6xszdjs\\\",\\\"b\\\".\\\"zdjs\\\" as \\\"12xszdjs\\\",\\\"c\\\".\\\"zdjs\\\" as \\\"24xszdjs\\\" from\\n(select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '7' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"a\\\" \\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '13' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"b\\\" on \\\"a\\\".\\\"qh\\\" = \\\"b\\\".\\\"qh\\\" \\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '25' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"c\\\" on \\\"a\\\".\\\"qh\\\" = \\\"c\\\".\\\"qh\\\"\\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '2' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"d\\\" on \\\"a\\\".\\\"qh\\\" = \\\"d\\\".\\\"qh\\\"\\norder by \\\"6xszdjs\\\" desc\", \"explain\": \"Sort  (cost=10890.12..10890.62 rows=200 width=160)\\n  Sort Key: a.zdjs DESC\\n  ->  Hash Left Join  (cost=8167.58..10882.48 rows=200 width=160)\\n  Hash Cond: (a.qh = d.qh)\\n  ->  Hash Left Join  (cost=5445.05..8159.95 rows=200 width=128)\\n  Hash Cond: (a.qh = c.qh)\\n  ->  Hash Left Join  (cost=2722.53..5437.43 rows=200 width=96)\\n  Hash Cond: (a.qh = b.qh)\\n  ->  Subquery Scan on a  (cost=0.00..2714.90 rows=200 width=64)\\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\\n  Sort Key: (max(sum(ds_dm_tqyj_jssk.zdjs))) DESC\\n  ->  HashAggregate  (cost=2704.40..2706.90 rows=200 width=42)\\n  Group Key: CASE substr(ds_dm_tqyj_jssk.xzqhdm, 1, 6) ... END\\n  ->  HashAggregate  (cost=2500.00..2600.00 rows=2000 width=18)\\n  Group Key: ds_dm_tqyj_jssk.xzqhdm\\n  ->  Seq Scan on ds_dm_tqyj_jssk  (cost=0.00..2200.00 rows=100000 width=58)\\n  Filter: (gxsj >= (now() - '07:00:00'::interval))\\n  ->  Hash  (cost=2714.90..2714.90 rows=200 width=64)\\n  ->  Subquery Scan on b  (cost=0.00..2714.90 rows=200 width=64)\\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\\n  ->  HashAggregate ...\\n  ->  Seq Scan on ds_dm_tqyj_jssk ...\\n  ->  Hash ...\\n  ->  Subquery Scan on c ...\\n  ->  Hash ...\\n  ->  Subquery Scan on d ...\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SCHEMA IF NOT EXISTS WHYJ_SJZL;\nCREATE TABLE WHYJ_SJZL.\"ds_dm_tqyj_jssk\" (\"xzqhdm\" VARCHAR(50), \"zdbh\" VARCHAR(50), \"zdjs\" NUMERIC, \"zxjs\" NUMERIC, \"gxsj\" TIMESTAMP);\nCREATE INDEX idx_ds_dm_tqyj_jssk_gxsj ON WHYJ_SJZL.\"ds_dm_tqyj_jssk\"(\"gxsj\");\nCREATE INDEX idx_ds_dm_tqyj_jssk_xzqhdm ON WHYJ_SJZL.\"ds_dm_tqyj_jssk\"(\"xzqhdm\");\n\n## Explain Output in JSON:\nSort  (cost=10890.12..10890.62 rows=200 width=160)\n  Sort Key: a.zdjs DESC\n  ->  Hash Left Join  (cost=8167.58..10882.48 rows=200 width=160)\n  Hash Cond: (a.qh = d.qh)\n  ->  Hash Left Join  (cost=5445.05..8159.95 rows=200 width=128)\n  Hash Cond: (a.qh = c.qh)\n  ->  Hash Left Join  (cost=2722.53..5437.43 rows=200 width=96)\n  Hash Cond: (a.qh = b.qh)\n  ->  Subquery Scan on a  (cost=0.00..2714.90 rows=200 width=64)\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\n  Sort Key: (max(sum(ds_dm_tqyj_jssk.zdjs))) DESC\n  ->  HashAggregate  (cost=2704.40..2706.90 rows=200 width=42)\n  Group Key: CASE substr(ds_dm_tqyj_jssk.xzqhdm, 1, 6) ... END\n  ->  HashAggregate  (cost=2500.00..2600.00 rows=2000 width=18)\n  Group Key: ds_dm_tqyj_jssk.xzqhdm\n  ->  Seq Scan on ds_dm_tqyj_jssk  (cost=0.00..2200.00 rows=100000 width=58)\n  Filter: (gxsj >= (now() - '07:00:00'::interval))\n  ->  Hash  (cost=2714.90..2714.90 rows=200 width=64)\n  ->  Subquery Scan on b  (cost=0.00..2714.90 rows=200 width=64)\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\n  ->  HashAggregate ...\n  ->  Seq Scan on ds_dm_tqyj_jssk ...\n  ->  Hash ...\n  ->  Subquery Scan on c ...\n  ->  Hash ...\n  ->  Subquery Scan on d ...\n\n## Original SQL:\nselect \"a\".\"qh\" as \"qhmc\",\"d\".\"zdjs\" as \"1xszdjs\",\"a\".\"zdjs\" as \"6xszdjs\",\"b\".\"zdjs\" as \"12xszdjs\",\"c\".\"zdjs\" as \"24xszdjs\" from\n(select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '7' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"a\" \nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '13' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"b\" on \"a\".\"qh\" = \"b\".\"qh\" \nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '25' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"c\" on \"a\".\"qh\" = \"c\".\"qh\"\nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '2' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"d\" on \"a\".\"qh\" = \"d\".\"qh\"\norder by \"6xszdjs\" desc\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH district_map AS (SELECT '420102' as \"code\", '江岸区' as \"name\" UNION ALL SELECT '420103', '江汉区' UNION ALL SELECT '420104', '硚口区' UNION ALL SELECT '420105', '汉阳区' UNION ALL SELECT '420106', '武昌区' UNION ALL SELECT '420107', '青山区' UNION ALL SELECT '420111', '洪山区' UNION ALL SELECT '420112', '东西湖区' UNION ALL SELECT '420113', '汉南区' UNION ALL SELECT '420114', '蔡甸区' UNION ALL SELECT '420115', '江夏区' UNION ALL SELECT '420116', '黄陂区' UNION ALL SELECT '420117', '新洲区'), window_sums AS (SELECT \"xzqhdm\", SUBSTR(\"xzqhdm\", 1, 6) as \"district_code\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '7' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_7h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '13' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_13h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '25' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_25h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '2' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_2h\" FROM WHYJ_SJZL.\"ds_dm_tqyj_jssk\" WHERE \"gxsj\" >= NOW() - INTERVAL '25' HOUR GROUP BY \"xzqhdm\", SUBSTR(\"xzqhdm\", 1, 6)), district_results AS (SELECT d.\"name\" as \"qh\", MAX(\"sum_7h\") as \"max_7h\", MAX(\"sum_13h\") as \"max_13h\", MAX(\"sum_25h\") as \"max_25h\", MAX(\"sum_2h\") as \"max_2h\" FROM window_sums ws JOIN district_map d ON ws.\"district_code\" = d.\"code\" GROUP BY d.\"name\") SELECT \"qh\" as \"qhmc\", \"max_2h\" as \"1xszdjs\", \"max_7h\" as \"6xszdjs\", \"max_13h\" as \"12xszdjs\", \"max_25h\" as \"24xszdjs\" FROM district_results ORDER BY \"6xszdjs\" DESC;"
                    }
                ]
            },
            {
                "case_id": "42",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"42\", \"db_type\": \"mysql\", \"description\": \"该SQL查询存在显著的性能瓶颈，主要体现为：1. **谓词未下推**：核心过滤条件`CUSTOMER_ID`位于最外层，导致内部巨大的UNION ALL派生表（由四部分组成）必须先全量物化及聚合，无法利用索引提前过滤数据。2. **隐式内连接**：对LEFT JOIN表`t_dgm_send_info`的字段进行了`SEND_STATE='70'`的等值过滤，语义上已变为内连接，但写法可能误导优化器或导致低效的执行路径。3. **冗余的聚合与排序**：外层的`GROUP BY temp.MIXED_NO`在业务逻辑上可能是冗余的（子查询已确保唯一性或JOIN关系未导致膨胀），且`HAVING`子句中包含了本应在WHERE中过滤的非聚合条件，导致了不必要的临时表和排序开销。4. **宽表投影**：派生表输出了大量后续未使用的列，增加了内存和I/O负担。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE DATABASE IF NOT EXISTS zjjs_mpm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_rmm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_qdm;\", \"CREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\", \"CREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\", \"CREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\", \"CREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\", \"CREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\", \"CREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\", \"CREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\", \"CREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\", \"CREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\", \"CREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\", \"CREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\"], \"sql\": \"SELECT\\n  temp.*,\\n  t_rmm_store.STORE_NAME,\\n  t_rmm_location.LOCATION_NAME,\\n  t_qdm_standard.STANDARD_NAME,\\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\\n  ) AS `SEND_NUMBER`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\\n  ) AS `RETURN_NUMBER`\\nFROM\\n  t_dgm_send_info_detail\\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\\n  LEFT JOIN (\\n  SELECT\\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\\n   IFNULL(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   ) AS MIXED_NO,\\n   '30' AS SPOT_TYPE,\\n   v_pre_product_material.MATERIAL_NO,\\n   v_pre_product_material.PACKAGE_NO,\\n   v_pre_product_material.PSR_ID,\\n   v_pre_product_material.CUSTOMER_ID,\\n   v_pre_product_material.CONTRACT_ID,\\n   v_pre_product_material.CONTRACT_NO,\\n   v_pre_product_material.NUMBER,\\n   v_pre_product_material.NET_WEIGHT,\\n   v_pre_product_material.GROSS_WT,\\n   v_pre_product_material.STORE_ID,\\n   v_pre_product_material.LOCATION_ID,\\n   v_pre_product_material.STANDARD_ID,\\n   v_pre_product_material.STEEL_GRADE,\\n   v_pre_product_material.SURFACE_GROUP_DESC,\\n   v_pre_product_material.CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (v_pre_product_material.LENGTH IS NOT NULL)\\n  AND (v_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*',\\n  v_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   SUM(\\n  IF (\\n  t_sam_contract_detail.BUY_UNIT = '10',\\n  -- 单位测试\\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\\n  )\\n   ) AS `PRICE`\\n  FROM\\n   v_pre_product_material\\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\\n  WHERE\\n   v_pre_product_material.IS_ISSUED = '1'\\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\\n   AND v_pre_product_material.NI36_TAG = '0'\\n   AND v_pre_product_material.MATERIAL_STATE != '110'\\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\\n   AND NOT EXISTS (\\n  SELECT\\n  1\\n  FROM\\n  v_pre_product_material v2\\n  WHERE\\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\\n  GROUP BY\\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\\n  HAVING\\n  SUM(\\n   CASE\\n  WHEN IS_ISSUED != '1' THEN 1\\n  ELSE 0\\n   END\\n  ) > 0\\n   )\\n  GROUP BY\\n   COALESCE(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   )\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '10' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   NULL AS `PACKAGE_NO`,\\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   1 AS NUMBER,\\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\\n   t_inm_store_info.STORE_ID AS STORE_ID,\\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_inm_store_info.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   t_inm_store_info.VARIETY_ID,\\n   IF (\\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  t_inm_store_info.MATERIAL_LENGTH\\n  ),\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  'C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '30' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\\n   t_pre_product_material.PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   t_pre_product_material.NUMBER AS NUMBER,\\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\\n   t_pre_product_material.STORE_ID AS STORE_ID,\\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\\n   t_pre_product_material.STEEL_GRADE,\\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (t_pre_product_material.LENGTH IS NOT NULL)\\n  AND (t_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*',\\n  t_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   NULL AS NUMBER,\\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\\n   NULL AS GROSS_WT,\\n   '/' AS STORE_ID,\\n   '/' AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_pre_scrap.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   NULL AS specs,\\n   -- 单位测试\\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_pre_scrap.BATCH_NO\\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\\nWHERE\\n  t_dgm_send_info.SEND_STATE = '70'\\n  AND temp.CUSTOMER_ID = '1930921074703462401'\\ngroup by\\n  temp.MIXED_NO\\nhaving\\n  SEND_NUMBER > RETURN_NUMBER\\nLIMIT\\n  100\", \"explain\": \"id\\tselect_type\\ttable\\ttype\\tkey\\trows\\tExtra\\n1\\tPRIMARY\\tt_dgm_send_info\\tALL\\tPRIMARY\\t1000\\tUsing where; Using temporary; Using filesort\\n1\\tPRIMARY\\tt_dgm_send_info_detail\\tref\\tSEND_ID\\t10\\tUsing where\\n1\\tPRIMARY\\t<derived2>\\tref\\t<auto_key0>\\t150\\tUsing where\\n1\\tPRIMARY\\tt_rmm_store\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_rmm_location\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_qdm_standard\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_bdm_column\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_dgm_send_info_return_detail\\tref\\tCONNECT_DETAIL_ID\\t1\\tUsing where\\n2\\tDERIVED\\tv_pre_product_material\\tALL\\tNULL\\t50000\\tUsing where; Using temporary; Using filesort\\n2\\tDERIVED\\tmaterial\\tref\\tMATERIAL_NO\\t1\\tUsing index\\n2\\tDERIVED\\tpackage\\tref\\tPACKAGE_NO\\t1\\tUsing index\\n3\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n3\\tUNION\\tt_sam_contract\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n4\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n5\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t10000\\tUsing where\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE DATABASE IF NOT EXISTS zjjs_mpm;\nCREATE DATABASE IF NOT EXISTS zjjs_rmm;\nCREATE DATABASE IF NOT EXISTS zjjs_qdm;\nCREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\nCREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\nCREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\nCREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\nCREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\nCREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\nCREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\nCREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\nCREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\nCREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\nCREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\nCREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\nCREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\nCREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\nCREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\n\n## Explain Output in JSON:\nid\tselect_type\ttable\ttype\tkey\trows\tExtra\n1\tPRIMARY\tt_dgm_send_info\tALL\tPRIMARY\t1000\tUsing where; Using temporary; Using filesort\n1\tPRIMARY\tt_dgm_send_info_detail\tref\tSEND_ID\t10\tUsing where\n1\tPRIMARY\t<derived2>\tref\t<auto_key0>\t150\tUsing where\n1\tPRIMARY\tt_rmm_store\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_rmm_location\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_qdm_standard\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_bdm_column\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_dgm_send_info_return_detail\tref\tCONNECT_DETAIL_ID\t1\tUsing where\n2\tDERIVED\tv_pre_product_material\tALL\tNULL\t50000\tUsing where; Using temporary; Using filesort\n2\tDERIVED\tmaterial\tref\tMATERIAL_NO\t1\tUsing index\n2\tDERIVED\tpackage\tref\tPACKAGE_NO\t1\tUsing index\n3\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n3\tUNION\tt_sam_contract\teq_ref\tPRIMARY\t1\tUsing where\n4\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n5\tUNION\tt_sam_contract_detail\tALL\tNULL\t10000\tUsing where\n\n## Original SQL:\nSELECT\n  temp.*,\n  t_rmm_store.STORE_NAME,\n  t_rmm_location.LOCATION_NAME,\n  t_qdm_standard.STANDARD_NAME,\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\n  ) AS `SEND_NUMBER`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\n  ) AS `RETURN_NUMBER`\nFROM\n  t_dgm_send_info_detail\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\n  LEFT JOIN (\n  SELECT\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\n   IFNULL(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   ) AS MIXED_NO,\n   '30' AS SPOT_TYPE,\n   v_pre_product_material.MATERIAL_NO,\n   v_pre_product_material.PACKAGE_NO,\n   v_pre_product_material.PSR_ID,\n   v_pre_product_material.CUSTOMER_ID,\n   v_pre_product_material.CONTRACT_ID,\n   v_pre_product_material.CONTRACT_NO,\n   v_pre_product_material.NUMBER,\n   v_pre_product_material.NET_WEIGHT,\n   v_pre_product_material.GROSS_WT,\n   v_pre_product_material.STORE_ID,\n   v_pre_product_material.LOCATION_ID,\n   v_pre_product_material.STANDARD_ID,\n   v_pre_product_material.STEEL_GRADE,\n   v_pre_product_material.SURFACE_GROUP_DESC,\n   v_pre_product_material.CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (v_pre_product_material.LENGTH IS NOT NULL)\n  AND (v_pre_product_material.LENGTH != 0),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*',\n  v_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   SUM(\n  IF (\n  t_sam_contract_detail.BUY_UNIT = '10',\n  -- 单位测试\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\n  )\n   ) AS `PRICE`\n  FROM\n   v_pre_product_material\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\n  WHERE\n   v_pre_product_material.IS_ISSUED = '1'\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\n   AND v_pre_product_material.NI36_TAG = '0'\n   AND v_pre_product_material.MATERIAL_STATE != '110'\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\n   AND NOT EXISTS (\n  SELECT\n  1\n  FROM\n  v_pre_product_material v2\n  WHERE\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\n  GROUP BY\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\n  HAVING\n  SUM(\n   CASE\n  WHEN IS_ISSUED != '1' THEN 1\n  ELSE 0\n   END\n  ) > 0\n   )\n  GROUP BY\n   COALESCE(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   )\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '10' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   NULL AS `PACKAGE_NO`,\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   1 AS NUMBER,\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\n   t_inm_store_info.STORE_ID AS STORE_ID,\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_inm_store_info.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   t_inm_store_info.VARIETY_ID,\n   IF (\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  t_inm_store_info.MATERIAL_LENGTH\n  ),\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  'C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '30' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\n   t_pre_product_material.PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   t_pre_product_material.NUMBER AS NUMBER,\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\n   t_pre_product_material.STORE_ID AS STORE_ID,\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\n   t_pre_product_material.STEEL_GRADE,\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (t_pre_product_material.LENGTH IS NOT NULL)\n  AND (t_pre_product_material.LENGTH != 0),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*',\n  t_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   NULL AS NUMBER,\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\n   NULL AS GROSS_WT,\n   '/' AS STORE_ID,\n   '/' AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_pre_scrap.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   NULL AS specs,\n   -- 单位测试\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_pre_scrap.BATCH_NO\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\nWHERE\n  t_dgm_send_info.SEND_STATE = '70'\n  AND temp.CUSTOMER_ID = '1930921074703462401'\ngroup by\n  temp.MIXED_NO\nhaving\n  SEND_NUMBER > RETURN_NUMBER\nLIMIT\n  100\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT temp.*,t_rmm_store.STORE_NAME,t_rmm_location.LOCATION_NAME,t_qdm_standard.STANDARD_NAME,t_bdm_column.COLUMN_NAME AS STEEL_GRADE_NAME,t_dgm_send_info.SEND_ID AS CONNECT_ID,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS CONNECT_DETAIL_ID,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0)) AS SEND_NUMBER,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) AS RETURN_NUMBER FROM t_dgm_send_info_detail INNER JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID=t_dgm_send_info_detail.SEND_ID AND t_dgm_send_info.SEND_STATE='70' LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID=t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID INNER JOIN (SELECT v_pre_product_material.PRODUCE_MATERIAL_ID,IFNULL(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) AS MIXED_NO,'30' AS SPOT_TYPE,v_pre_product_material.MATERIAL_NO,v_pre_product_material.PACKAGE_NO,v_pre_product_material.PSR_ID,v_pre_product_material.CUSTOMER_ID,v_pre_product_material.CONTRACT_ID,v_pre_product_material.CONTRACT_NO,v_pre_product_material.NUMBER,v_pre_product_material.NET_WEIGHT,v_pre_product_material.GROSS_WT,v_pre_product_material.STORE_ID,v_pre_product_material.LOCATION_ID,v_pre_product_material.STANDARD_ID,v_pre_product_material.STEEL_GRADE,v_pre_product_material.SURFACE_GROUP_DESC,v_pre_product_material.CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((v_pre_product_material.LENGTH IS NOT NULL) AND (v_pre_product_material.LENGTH!=0),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*',v_pre_product_material.LENGTH),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*C')) AS specs,SUM(IF(t_sam_contract_detail.BUY_UNIT='10',t_sam_contract_detail.TAX_PRICE*v_pre_product_material.NET_WEIGHT,t_sam_contract_detail.TAX_PRICE*IFNULL(t_sam_contract_detail.NUMBER,1))) AS PRICE FROM v_pre_product_material LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID=v_pre_product_material.CONTRACT_DELIVERY_ID LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID=t_sam_contract_detail.CONTRACT_DETAILS_ID WHERE v_pre_product_material.IS_ISSUED='1' AND v_pre_product_material.IS_SPOT_RESOURCE='0' AND v_pre_product_material.NI36_TAG='0' AND v_pre_product_material.MATERIAL_STATE!='110' AND v_pre_product_material.CONTRACT_TYPE!='60' AND v_pre_product_material.CUSTOMER_ID='1930921074703462401' GROUP BY COALESCE(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) UNION ALL SELECT t_sam_contract_detail.CONTRACT_DETAILS_ID AS PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'10' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,NULL AS PACKAGE_NO,t_bdm_column.COLUMN_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,1 AS NUMBER,t_inm_store_info.NEW_WEIGHT AS NET_WEIGHT,t_inm_store_info.GROSS_WT,t_inm_store_info.STORE_ID,t_inm_store_info.LOCATION_ID,NULL AS STANDARD_ID,t_inm_store_info.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,t_inm_store_info.VARIETY_ID,IF(t_inm_store_info.MATERIAL_LENGTH IS NOT NULL AND t_inm_store_info.MATERIAL_LENGTH!=0,CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,t_inm_store_info.MATERIAL_LENGTH),CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,'C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='10' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO=t_sam_contract_detail.PRODUCT_MATERIAL_NO AND t_inm_store_info.STOCK_ID IS NOT NULL LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID=t_bdm_column.COLUMN_ID GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_pre_product_material.PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'30' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,t_pre_product_material.PACKAGE_NO,t_pre_product_material.PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,t_pre_product_material.NUMBER,t_pre_product_material.NET_WEIGHT,t_pre_product_material.GROSS_WT,t_pre_product_material.STORE_ID,t_pre_product_material.LOCATION_ID,t_pre_product_material.STANDARD_ID,t_pre_product_material.STEEL_GRADE,t_pre_product_material.SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((t_pre_product_material.LENGTH IS NOT NULL) AND (t_pre_product_material.LENGTH!=0),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*',t_pre_product_material.LENGTH),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE IN('20','30') AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' INNER JOIN t_pre_product_material ON(t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.PACKAGE_NO OR t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.MATERIAL_NO) AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_sam_contract_detail.SCRAP_INFO_ID AS PRODUCE_MATERIAL_ID,t_pre_scrap.BATCH_NO AS MIXED_NO,t_sam_contract_detail.SPOT_TYPE,t_pre_scrap.BATCH_NO AS MATERIAL_NO,t_pre_scrap.BATCH_NO AS PACKAGE_NO,t_pre_scrap.PRODUCT_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,NULL AS NUMBER,t_pre_scrap.WEIGHT AS NET_WEIGHT,NULL AS GROSS_WT,'/' AS STORE_ID,'/' AS LOCATION_ID,NULL AS STANDARD_ID,t_pre_scrap.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID,NULL AS VARIETY_ID,NULL AS specs,t_pre_scrap.WEIGHT*t_sam_contract_detail.TAX_PRICE AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='40' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID=t_sam_contract_detail.SCRAP_INFO_ID GROUP BY t_pre_scrap.BATCH_NO) as temp ON temp.MIXED_NO=t_dgm_send_info_detail.MIXED_NO LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store ON t_rmm_store.STORE_ID=temp.STORE_ID LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location ON t_rmm_location.LOCATION_ID=temp.LOCATION_ID LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard ON t_qdm_standard.STANDARD_ID=temp.STANDARD_ID LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_bdm_column.COLUMN_ID=temp.STEEL_GRADE GROUP BY temp.MIXED_NO,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID HAVING IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0))>IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) LIMIT 100"
                    }
                ]
            },
            {
                "case_id": "43",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"43\", \"db_type\": \"mysql\", \"description\": \"改写前的SQL在子查询条件（col_pk_varchar）中使用了数值字面量进行范围查询（BETWEEN 192 AND 171），而col_pk_varchar列是VARCHAR类型。MySQL在比较不同类型时可能触发类型隐式转换，导致索引失效（本次场景中未失效但引发了多余扫描）。改写后显式使用字符串字面量（BETWEEN '192' AND '171'），确保类型一致，使优化器能准确评估区间有效性。同时，由于数字192大于171，字符集下同样不成立，优化器能立即识别并跳过该子查询扫描。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE dble_jumpstringhash_int_1 (col_int_auto_increment INT NOT NULL AUTO_INCREMENT, col_pk_char CHAR(1) NOT NULL, col_pk_varchar VARCHAR(100) NOT NULL, col_pk_date DATE NOT NULL, col_pk_decimal_not_null DECIMAL(10,0) NOT NULL, col_pk_numeric_not_null DECIMAL(10,0) NOT NULL, col_int_not_null INT NOT NULL, col_int_not_null__1 INT NOT NULL, col_int_8_not_null TINYINT NOT NULL, col_int_8_not_null__1 TINYINT NOT NULL, col_bigint_not_null BIGINT NOT NULL, col_smallint_not_null SMALLINT NOT NULL, col_tinyint_not_null TINYINT NOT NULL, col_float_not_null FLOAT NOT NULL, col_double_not_null DOUBLE NOT NULL, col_decimal_not_null DECIMAL(10,0) NOT NULL, col_numeric_not_null DECIMAL(10,0) NOT NULL, col_bit_not_null BIT(1) NOT NULL, col_bit_not_null__1 BIT(1) NOT NULL, col_char_3_not_null CHAR(3) NOT NULL, col_char_255_not_null CHAR(255) NOT NULL, col_varchar_1_not_null VARCHAR(1) NOT NULL, col_varchar_64_not_null VARCHAR(64) NOT NULL, col_varchar_2048_not_null VARCHAR(2048) NOT NULL, col_binary_8_not_null BINARY(8) NOT NULL, col_varbinary_8_not_null VARBINARY(8) NOT NULL, col_date_not_null DATE NOT NULL, col_time_not_null TIME NOT NULL, col_datetime_not_null DATETIME NOT NULL, col_year_not_null YEAR NOT NULL, col_text_not_null TEXT NOT NULL, col_bool_not_null TINYINT(1) NOT NULL, col_boolean_not_null TINYINT(1) NOT NULL, col_longtext_not_null LONGTEXT NOT NULL, col_mediumtext_not_null MEDIUMTEXT NOT NULL, col_tinyblob_not_null TINYBLOB NOT NULL, col_mediumblob_not_null MEDIUMBLOB NOT NULL, col_longblob_not_null LONGBLOB NOT NULL, col_blob_not_null BLOB NOT NULL, PRIMARY KEY (col_int_auto_increment, col_pk_char, col_pk_varchar, col_pk_date, col_pk_decimal_not_null, col_pk_numeric_not_null)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_dble_jumpstringhash_int_1_col_varchar_64_not_null ON dble_jumpstringhash_int_1(col_varchar_64_not_null);\", \"CREATE TABLE dble_stringhash_datetime_2 (col_pk_varchar VARCHAR(100) NOT NULL, PRIMARY KEY (col_pk_varchar)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_dble_stringhash_datetime_2_col_pk_varchar ON dble_stringhash_datetime_2(col_pk_varchar);\"], \"sql\": \"SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM ( SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM dble_jumpstringhash_int_1 WHERE NOT EXISTS (SELECT 1 FROM dble_stringhash_datetime_2 WHERE col_pk_varchar BETWEEN 192 AND 171) ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39 LIMIT 97 OFFSET 5) AS t WHERE col_varchar_64_not_null LIKE '%p%' ORDER BY col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null DESC LIMIT 215 OFFSET 3;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t102\\t11.11\\tUsing where; Using temporary; Using filesort\\n2\\tDERIVED\\tdble_jumpstringhash_int_1\\t\\tALL\\t\\t\\t\\t\\t416710\\t100.0\\tUsing filesort\\n3\\tSUBQUERY\\tdble_stringhash_datetime_2\\t\\tindex\\tPRIMARY,idx_dble_stringhash_datetime_2_col_pk_varchar\\tPRIMARY\\t402\\t\\t505934\\t11.11\\tUsing where; Using index\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"25.31\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_filesort\\\": false,\\n  \\\"duplicates_removal\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"11.33\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"t\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 102,\\n  \\\"rows_produced_per_join\\\": 11,\\n  \\\"filtered\\\": \\\"11.11\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"12.84\\\",\\n  \\\"eval_cost\\\": \\\"1.13\\\",\\n  \\\"prefix_cost\\\": \\\"13.98\\\",\\n  \\\"data_read_per_join\\\": \\\"111K\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"col_int_auto_increment\\\",\\n  \\\"col_pk_char\\\",\\n  \\\"col_pk_varchar\\\",\\n  \\\"col_pk_date\\\",\\n  \\\"col_pk_decimal_not_null\\\",\\n  \\\"col_pk_numeric_not_null\\\",\\n  \\\"col_int_not_null\\\",\\n  \\\"col_int_not_null__1\\\",\\n  \\\"col_int_8_not_null\\\",\\n  \\\"col_int_8_not_null__1\\\",\\n  \\\"col_bigint_not_null\\\",\\n  \\\"col_smallint_not_null\\\",\\n  \\\"col_tinyint_not_null\\\",\\n  \\\"col_float_not_null\\\",\\n  \\\"col_double_not_null\\\",\\n  \\\"col_decimal_not_null\\\",\\n  \\\"col_numeric_not_null\\\",\\n  \\\"col_bit_not_null\\\",\\n  \\\"col_bit_not_null__1\\\",\\n  \\\"col_char_3_not_null\\\",\\n  \\\"col_char_255_not_null\\\",\\n  \\\"col_varchar_1_not_null\\\",\\n  \\\"col_varchar_64_not_null\\\",\\n  \\\"col_varchar_2048_not_null\\\",\\n  \\\"col_binary_8_not_null\\\",\\n  \\\"col_varbinary_8_not_null\\\",\\n  \\\"col_date_not_null\\\",\\n  \\\"col_time_not_null\\\",\\n  \\\"col_datetime_not_null\\\",\\n  \\\"col_year_not_null\\\",\\n  \\\"col_text_not_null\\\",\\n  \\\"col_bool_not_null\\\",\\n  \\\"col_boolean_not_null\\\",\\n  \\\"col_longtext_not_null\\\",\\n  \\\"col_mediumtext_not_null\\\",\\n  \\\"col_tinyblob_not_null\\\",\\n  \\\"col_mediumblob_not_null\\\",\\n  \\\"col_longblob_not_null\\\",\\n  \\\"col_blob_not_null\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`t`.`col_varchar_64_not_null` like '%p%')\\\",\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"121752.86\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_filesort\\\": true,\\n  \\\"duplicates_removal\\\": {\\n  \\\"using_filesort\\\": false,\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"dble_jumpstringhash_int_1\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 416710,\\n  \\\"rows_produced_per_join\\\": 416710,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"80081.86\\\",\\n  \\\"eval_cost\\\": \\\"41671.00\\\",\\n  \\\"prefix_cost\\\": \\\"121752.86\\\",\\n  \\\"data_read_per_join\\\": \\\"3G\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"col_int_auto_increment\\\",\\n  \\\"col_pk_char\\\",\\n  \\\"col_pk_varchar\\\",\\n  \\\"col_pk_date\\\",\\n  \\\"col_pk_decimal_not_null\\\",\\n  \\\"col_pk_numeric_not_null\\\",\\n  \\\"col_int_not_null\\\",\\n  \\\"col_int_not_null__1\\\",\\n  \\\"col_int_8_not_null\\\",\\n  \\\"col_int_8_not_null__1\\\",\\n  \\\"col_bigint_not_null\\\",\\n  \\\"col_smallint_not_null\\\",\\n  \\\"col_tinyint_not_null\\\",\\n  \\\"col_float_not_null\\\",\\n  \\\"col_double_not_null\\\",\\n  \\\"col_decimal_not_null\\\",\\n  \\\"col_numeric_not_null\\\",\\n  \\\"col_bit_not_null\\\",\\n  \\\"col_bit_not_null__1\\\",\\n  \\\"col_char_3_not_null\\\",\\n  \\\"col_char_255_not_null\\\",\\n  \\\"col_varchar_1_not_null\\\",\\n  \\\"col_varchar_64_not_null\\\",\\n  \\\"col_varchar_2048_not_null\\\",\\n  \\\"col_binary_8_not_null\\\",\\n  \\\"col_varbinary_8_not_null\\\",\\n  \\\"col_date_not_null\\\",\\n  \\\"col_time_not_null\\\",\\n  \\\"col_datetime_not_null\\\",\\n  \\\"col_year_not_null\\\",\\n  \\\"col_text_not_null\\\",\\n  \\\"col_bool_not_null\\\",\\n  \\\"col_boolean_not_null\\\",\\n  \\\"col_longtext_not_null\\\",\\n  \\\"col_mediumtext_not_null\\\",\\n  \\\"col_tinyblob_not_null\\\",\\n  \\\"col_mediumblob_not_null\\\",\\n  \\\"col_longblob_not_null\\\",\\n  \\\"col_blob_not_null\\\"\\n  ]\\n  },\\n  \\\"optimized_away_subqueries\\\": [\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"51146.65\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"dble_stringhash_datetime_2\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_dble_stringhash_datetime_2_col_pk_varchar\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"col_pk_varchar\\\"\\n  ],\\n  \\\"key_length\\\": \\\"402\\\",\\n  \\\"rows_examined_per_scan\\\": 505934,\\n  \\\"rows_produced_per_join\\\": 56209,\\n  \\\"filtered\\\": \\\"11.11\\\",\\n  \\\"using_index\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"45525.72\\\",\\n  \\\"eval_cost\\\": \\\"5620.93\\\",\\n  \\\"prefix_cost\\\": \\\"51146.65\\\",\\n  \\\"data_read_per_join\\\": \\\"21M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"col_pk_varchar\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`dble_jumpstringhash_int`.`dble_stringhash_datetime_2`.`col_pk_varchar` between 192 and 171)\\\"\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE dble_jumpstringhash_int_1 (col_int_auto_increment INT NOT NULL AUTO_INCREMENT, col_pk_char CHAR(1) NOT NULL, col_pk_varchar VARCHAR(100) NOT NULL, col_pk_date DATE NOT NULL, col_pk_decimal_not_null DECIMAL(10,0) NOT NULL, col_pk_numeric_not_null DECIMAL(10,0) NOT NULL, col_int_not_null INT NOT NULL, col_int_not_null__1 INT NOT NULL, col_int_8_not_null TINYINT NOT NULL, col_int_8_not_null__1 TINYINT NOT NULL, col_bigint_not_null BIGINT NOT NULL, col_smallint_not_null SMALLINT NOT NULL, col_tinyint_not_null TINYINT NOT NULL, col_float_not_null FLOAT NOT NULL, col_double_not_null DOUBLE NOT NULL, col_decimal_not_null DECIMAL(10,0) NOT NULL, col_numeric_not_null DECIMAL(10,0) NOT NULL, col_bit_not_null BIT(1) NOT NULL, col_bit_not_null__1 BIT(1) NOT NULL, col_char_3_not_null CHAR(3) NOT NULL, col_char_255_not_null CHAR(255) NOT NULL, col_varchar_1_not_null VARCHAR(1) NOT NULL, col_varchar_64_not_null VARCHAR(64) NOT NULL, col_varchar_2048_not_null VARCHAR(2048) NOT NULL, col_binary_8_not_null BINARY(8) NOT NULL, col_varbinary_8_not_null VARBINARY(8) NOT NULL, col_date_not_null DATE NOT NULL, col_time_not_null TIME NOT NULL, col_datetime_not_null DATETIME NOT NULL, col_year_not_null YEAR NOT NULL, col_text_not_null TEXT NOT NULL, col_bool_not_null TINYINT(1) NOT NULL, col_boolean_not_null TINYINT(1) NOT NULL, col_longtext_not_null LONGTEXT NOT NULL, col_mediumtext_not_null MEDIUMTEXT NOT NULL, col_tinyblob_not_null TINYBLOB NOT NULL, col_mediumblob_not_null MEDIUMBLOB NOT NULL, col_longblob_not_null LONGBLOB NOT NULL, col_blob_not_null BLOB NOT NULL, PRIMARY KEY (col_int_auto_increment, col_pk_char, col_pk_varchar, col_pk_date, col_pk_decimal_not_null, col_pk_numeric_not_null)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_dble_jumpstringhash_int_1_col_varchar_64_not_null ON dble_jumpstringhash_int_1(col_varchar_64_not_null);\nCREATE TABLE dble_stringhash_datetime_2 (col_pk_varchar VARCHAR(100) NOT NULL, PRIMARY KEY (col_pk_varchar)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_dble_stringhash_datetime_2_col_pk_varchar ON dble_stringhash_datetime_2(col_pk_varchar);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t102\t11.11\tUsing where; Using temporary; Using filesort\n2\tDERIVED\tdble_jumpstringhash_int_1\t\tALL\t\t\t\t\t416710\t100.0\tUsing filesort\n3\tSUBQUERY\tdble_stringhash_datetime_2\t\tindex\tPRIMARY,idx_dble_stringhash_datetime_2_col_pk_varchar\tPRIMARY\t402\t\t505934\t11.11\tUsing where; Using index\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"25.31\"\n  },\n  \"ordering_operation\": {\n  \"using_filesort\": false,\n  \"duplicates_removal\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": true,\n  \"cost_info\": {\n  \"sort_cost\": \"11.33\"\n  },\n  \"table\": {\n  \"table_name\": \"t\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 102,\n  \"rows_produced_per_join\": 11,\n  \"filtered\": \"11.11\",\n  \"cost_info\": {\n  \"read_cost\": \"12.84\",\n  \"eval_cost\": \"1.13\",\n  \"prefix_cost\": \"13.98\",\n  \"data_read_per_join\": \"111K\"\n  },\n  \"used_columns\": [\n  \"col_int_auto_increment\",\n  \"col_pk_char\",\n  \"col_pk_varchar\",\n  \"col_pk_date\",\n  \"col_pk_decimal_not_null\",\n  \"col_pk_numeric_not_null\",\n  \"col_int_not_null\",\n  \"col_int_not_null__1\",\n  \"col_int_8_not_null\",\n  \"col_int_8_not_null__1\",\n  \"col_bigint_not_null\",\n  \"col_smallint_not_null\",\n  \"col_tinyint_not_null\",\n  \"col_float_not_null\",\n  \"col_double_not_null\",\n  \"col_decimal_not_null\",\n  \"col_numeric_not_null\",\n  \"col_bit_not_null\",\n  \"col_bit_not_null__1\",\n  \"col_char_3_not_null\",\n  \"col_char_255_not_null\",\n  \"col_varchar_1_not_null\",\n  \"col_varchar_64_not_null\",\n  \"col_varchar_2048_not_null\",\n  \"col_binary_8_not_null\",\n  \"col_varbinary_8_not_null\",\n  \"col_date_not_null\",\n  \"col_time_not_null\",\n  \"col_datetime_not_null\",\n  \"col_year_not_null\",\n  \"col_text_not_null\",\n  \"col_bool_not_null\",\n  \"col_boolean_not_null\",\n  \"col_longtext_not_null\",\n  \"col_mediumtext_not_null\",\n  \"col_tinyblob_not_null\",\n  \"col_mediumblob_not_null\",\n  \"col_longblob_not_null\",\n  \"col_blob_not_null\"\n  ],\n  \"attached_condition\": \"(`t`.`col_varchar_64_not_null` like '%p%')\",\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"121752.86\"\n  },\n  \"ordering_operation\": {\n  \"using_filesort\": true,\n  \"duplicates_removal\": {\n  \"using_filesort\": false,\n  \"table\": {\n  \"table_name\": \"dble_jumpstringhash_int_1\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 416710,\n  \"rows_produced_per_join\": 416710,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"80081.86\",\n  \"eval_cost\": \"41671.00\",\n  \"prefix_cost\": \"121752.86\",\n  \"data_read_per_join\": \"3G\"\n  },\n  \"used_columns\": [\n  \"col_int_auto_increment\",\n  \"col_pk_char\",\n  \"col_pk_varchar\",\n  \"col_pk_date\",\n  \"col_pk_decimal_not_null\",\n  \"col_pk_numeric_not_null\",\n  \"col_int_not_null\",\n  \"col_int_not_null__1\",\n  \"col_int_8_not_null\",\n  \"col_int_8_not_null__1\",\n  \"col_bigint_not_null\",\n  \"col_smallint_not_null\",\n  \"col_tinyint_not_null\",\n  \"col_float_not_null\",\n  \"col_double_not_null\",\n  \"col_decimal_not_null\",\n  \"col_numeric_not_null\",\n  \"col_bit_not_null\",\n  \"col_bit_not_null__1\",\n  \"col_char_3_not_null\",\n  \"col_char_255_not_null\",\n  \"col_varchar_1_not_null\",\n  \"col_varchar_64_not_null\",\n  \"col_varchar_2048_not_null\",\n  \"col_binary_8_not_null\",\n  \"col_varbinary_8_not_null\",\n  \"col_date_not_null\",\n  \"col_time_not_null\",\n  \"col_datetime_not_null\",\n  \"col_year_not_null\",\n  \"col_text_not_null\",\n  \"col_bool_not_null\",\n  \"col_boolean_not_null\",\n  \"col_longtext_not_null\",\n  \"col_mediumtext_not_null\",\n  \"col_tinyblob_not_null\",\n  \"col_mediumblob_not_null\",\n  \"col_longblob_not_null\",\n  \"col_blob_not_null\"\n  ]\n  },\n  \"optimized_away_subqueries\": [\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"51146.65\"\n  },\n  \"table\": {\n  \"table_name\": \"dble_stringhash_datetime_2\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_dble_stringhash_datetime_2_col_pk_varchar\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"col_pk_varchar\"\n  ],\n  \"key_length\": \"402\",\n  \"rows_examined_per_scan\": 505934,\n  \"rows_produced_per_join\": 56209,\n  \"filtered\": \"11.11\",\n  \"using_index\": true,\n  \"cost_info\": {\n  \"read_cost\": \"45525.72\",\n  \"eval_cost\": \"5620.93\",\n  \"prefix_cost\": \"51146.65\",\n  \"data_read_per_join\": \"21M\"\n  },\n  \"used_columns\": [\n  \"col_pk_varchar\"\n  ],\n  \"attached_condition\": \"(`dble_jumpstringhash_int`.`dble_stringhash_datetime_2`.`col_pk_varchar` between 192 and 171)\"\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n}\n\n## Original SQL:\nSELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM ( SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM dble_jumpstringhash_int_1 WHERE NOT EXISTS (SELECT 1 FROM dble_stringhash_datetime_2 WHERE col_pk_varchar BETWEEN 192 AND 171) ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39 LIMIT 97 OFFSET 5) AS t WHERE col_varchar_64_not_null LIKE '%p%' ORDER BY col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null DESC LIMIT 215 OFFSET 3;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM (SELECT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM dble_jumpstringhash_int_1 ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39 LIMIT 97 OFFSET 5) AS t WHERE col_varchar_64_not_null LIKE '%p%' ORDER BY col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null DESC LIMIT 215 OFFSET 3;"
                    }
                ]
            },
            {
                "case_id": "44",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"44\", \"db_type\": \"mysql\", \"description\": \"该改写方法消除了UNION ALL结构，避免了重复扫描表和创建临时表的开销。核心策略是将两个分支的冲突条件（一个包含特定uuid列表且无视private，另一个排除该列表且要求private=0）用OR组合起来，集成到同一个查询中。同时保持非重复性过滤条件（如全文检索和标签过滤）在最外层执行一次，避免了冗余操作。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE document_template (id VARCHAR(36) PRIMARY KEY, title VARCHAR(255) NOT NULL, owner_id VARCHAR(36) NOT NULL, private TINYINT(1) NOT NULL DEFAULT 0, deleted_at TIMESTAMP NULL DEFAULT NULL, FULLTEXT INDEX idx_title (title)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_owner_id ON document_template(owner_id);\", \"CREATE INDEX idx_deleted_at ON document_template(deleted_at);\", \"CREATE INDEX idx_private ON document_template(private);\", \"CREATE TABLE `user` (id VARCHAR(36) PRIMARY KEY, uuid VARCHAR(36) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_uuid ON `user`(uuid);\", \"CREATE TABLE tag_thing (document_template_id VARCHAR(36) NOT NULL, tag_id VARCHAR(36) NOT NULL, deleted_at TIMESTAMP NULL DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_document_template_id ON tag_thing(document_template_id);\", \"CREATE INDEX idx_tag_id ON tag_thing(tag_id);\", \"CREATE INDEX idx_deleted_at ON tag_thing(deleted_at);\"], \"sql\": \"(SELECT d.id, d.title\\r\\n  FROM document_template d\\r\\n  JOIN `user` u ON u.id = d.owner_id\\r\\n  WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\\r\\n  SELECT 1 FROM tag_thing tt0\\r\\n  WHERE tt0.document_template_id = d.id\\r\\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\\r\\n  AND tt0.deleted_at IS NULL\\r\\n  )) UNION ALL (SELECT d.id, d.title\\r\\n  FROM document_template d\\r\\n  JOIN `user` u ON u.id = d.owner_id\\r\\n  WHERE d.private = 0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\\r\\n  SELECT 1 FROM tag_thing tt0\\r\\n  WHERE tt0.document_template_id = d.id\\r\\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\\r\\n  AND tt0.deleted_at IS NULL\\r\\n  )) ORDER BY title ASC LIMIT 10 OFFSET 0;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\td\\t\\tfulltext\\tPRIMARY,idx_owner_id,idx_deleted_at,idx_title\\tidx_title\\t0\\tconst\\t1\\t18.14\\tUsing where; Ft_hints: rank > 0\\n1\\tPRIMARY\\tu\\t\\teq_ref\\tPRIMARY,idx_uuid\\tPRIMARY\\t146\\ttest_db.d.owner_id\\t1\\t5.0\\tUsing where\\n1\\tPRIMARY\\ttt0\\t\\tref\\tidx_document_template_id,idx_tag_id,idx_deleted_at\\tidx_document_template_id\\t146\\ttest_db.d.id\\t4\\t25.0\\tUsing where; FirstMatch(u)\\n3\\tUNION\\td\\t\\tfulltext\\tPRIMARY,idx_owner_id,idx_deleted_at,idx_private,idx_title\\tidx_title\\t0\\tconst\\t1\\t9.07\\tUsing where; Ft_hints: rank > 0\\n3\\tUNION\\tu\\t\\teq_ref\\tPRIMARY,idx_uuid\\tPRIMARY\\t146\\ttest_db.d.owner_id\\t1\\t50.0\\tUsing where\\n3\\tUNION\\ttt0\\t\\tref\\tidx_document_template_id,idx_tag_id,idx_deleted_at\\tidx_document_template_id\\t146\\ttest_db.d.id\\t4\\t25.0\\tUsing where; FirstMatch(u)\\n5\\tUNION RESULT\\t<union1,3>\\t\\tALL\\t\\t\\t\\t\\t\\t\\tUsing temporary; Using filesort\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"union_result\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"select_id\\\": 5,\\n  \\\"table_name\\\": \\\"<union1,3>\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"using_filesort\\\": true,\\n  \\\"query_specifications\\\": [\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"1.31\\\"\\n  },\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"d\\\",\\n  \\\"access_type\\\": \\\"fulltext\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_owner_id\\\",\\n  \\\"idx_deleted_at\\\",\\n  \\\"idx_title\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_title\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"title\\\"\\n  ],\\n  \\\"key_length\\\": \\\"0\\\",\\n  \\\"ref\\\": [\\n  \\\"const\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"18.14\\\",\\n  \\\"ft_hints\\\": \\\"rank > 0\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1.00\\\",\\n  \\\"eval_cost\\\": \\\"0.02\\\",\\n  \\\"prefix_cost\\\": \\\"1.10\\\",\\n  \\\"data_read_per_join\\\": \\\"239\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"title\\\",\\n  \\\"owner_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_uuid\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.owner_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"5.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.18\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.29\\\",\\n  \\\"data_read_per_join\\\": \\\"2\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"uuid\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`uuid` in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"tt0\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_document_template_id\\\",\\n  \\\"idx_tag_id\\\",\\n  \\\"idx_deleted_at\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_document_template_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"document_template_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 4,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"25.00\\\",\\n  \\\"first_match\\\": \\\"u\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.02\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.31\\\",\\n  \\\"data_read_per_join\\\": \\\"2\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"document_template_id\\\",\\n  \\\"tag_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\\\"\\n  }\\n  }\\n  ]\\n  }\\n  },\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"1.29\\\"\\n  },\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"d\\\",\\n  \\\"access_type\\\": \\\"fulltext\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_owner_id\\\",\\n  \\\"idx_deleted_at\\\",\\n  \\\"idx_private\\\",\\n  \\\"idx_title\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_title\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"title\\\"\\n  ],\\n  \\\"key_length\\\": \\\"0\\\",\\n  \\\"ref\\\": [\\n  \\\"const\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"9.07\\\",\\n  \\\"ft_hints\\\": \\\"rank > 0\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1.00\\\",\\n  \\\"eval_cost\\\": \\\"0.01\\\",\\n  \\\"prefix_cost\\\": \\\"1.10\\\",\\n  \\\"data_read_per_join\\\": \\\"119\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"title\\\",\\n  \\\"owner_id\\\",\\n  \\\"private\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`d`.`private` = 0) and (`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_uuid\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.owner_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"50.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.09\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.19\\\",\\n  \\\"data_read_per_join\\\": \\\"13\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"uuid\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`uuid` not in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"tt0\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_document_template_id\\\",\\n  \\\"idx_tag_id\\\",\\n  \\\"idx_deleted_at\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_document_template_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"document_template_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 4,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"25.00\\\",\\n  \\\"first_match\\\": \\\"u\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.08\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.30\\\",\\n  \\\"data_read_per_join\\\": \\\"13\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"document_template_id\\\",\\n  \\\"tag_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\\\"\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  ]\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE document_template (id VARCHAR(36) PRIMARY KEY, title VARCHAR(255) NOT NULL, owner_id VARCHAR(36) NOT NULL, private TINYINT(1) NOT NULL DEFAULT 0, deleted_at TIMESTAMP NULL DEFAULT NULL, FULLTEXT INDEX idx_title (title)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_owner_id ON document_template(owner_id);\nCREATE INDEX idx_deleted_at ON document_template(deleted_at);\nCREATE INDEX idx_private ON document_template(private);\nCREATE TABLE `user` (id VARCHAR(36) PRIMARY KEY, uuid VARCHAR(36) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_uuid ON `user`(uuid);\nCREATE TABLE tag_thing (document_template_id VARCHAR(36) NOT NULL, tag_id VARCHAR(36) NOT NULL, deleted_at TIMESTAMP NULL DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_document_template_id ON tag_thing(document_template_id);\nCREATE INDEX idx_tag_id ON tag_thing(tag_id);\nCREATE INDEX idx_deleted_at ON tag_thing(deleted_at);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\td\t\tfulltext\tPRIMARY,idx_owner_id,idx_deleted_at,idx_title\tidx_title\t0\tconst\t1\t18.14\tUsing where; Ft_hints: rank > 0\n1\tPRIMARY\tu\t\teq_ref\tPRIMARY,idx_uuid\tPRIMARY\t146\ttest_db.d.owner_id\t1\t5.0\tUsing where\n1\tPRIMARY\ttt0\t\tref\tidx_document_template_id,idx_tag_id,idx_deleted_at\tidx_document_template_id\t146\ttest_db.d.id\t4\t25.0\tUsing where; FirstMatch(u)\n3\tUNION\td\t\tfulltext\tPRIMARY,idx_owner_id,idx_deleted_at,idx_private,idx_title\tidx_title\t0\tconst\t1\t9.07\tUsing where; Ft_hints: rank > 0\n3\tUNION\tu\t\teq_ref\tPRIMARY,idx_uuid\tPRIMARY\t146\ttest_db.d.owner_id\t1\t50.0\tUsing where\n3\tUNION\ttt0\t\tref\tidx_document_template_id,idx_tag_id,idx_deleted_at\tidx_document_template_id\t146\ttest_db.d.id\t4\t25.0\tUsing where; FirstMatch(u)\n5\tUNION RESULT\t<union1,3>\t\tALL\t\t\t\t\t\t\tUsing temporary; Using filesort\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"union_result\": {\n  \"using_temporary_table\": true,\n  \"select_id\": 5,\n  \"table_name\": \"<union1,3>\",\n  \"access_type\": \"ALL\",\n  \"using_filesort\": true,\n  \"query_specifications\": [\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"1.31\"\n  },\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"d\",\n  \"access_type\": \"fulltext\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_owner_id\",\n  \"idx_deleted_at\",\n  \"idx_title\"\n  ],\n  \"key\": \"idx_title\",\n  \"used_key_parts\": [\n  \"title\"\n  ],\n  \"key_length\": \"0\",\n  \"ref\": [\n  \"const\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"18.14\",\n  \"ft_hints\": \"rank > 0\",\n  \"cost_info\": {\n  \"read_cost\": \"1.00\",\n  \"eval_cost\": \"0.02\",\n  \"prefix_cost\": \"1.10\",\n  \"data_read_per_join\": \"239\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"title\",\n  \"owner_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_uuid\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.owner_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"5.00\",\n  \"cost_info\": {\n  \"read_cost\": \"0.18\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.29\",\n  \"data_read_per_join\": \"2\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"uuid\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`uuid` in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"tt0\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_document_template_id\",\n  \"idx_tag_id\",\n  \"idx_deleted_at\"\n  ],\n  \"key\": \"idx_document_template_id\",\n  \"used_key_parts\": [\n  \"document_template_id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.id\"\n  ],\n  \"rows_examined_per_scan\": 4,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"25.00\",\n  \"first_match\": \"u\",\n  \"cost_info\": {\n  \"read_cost\": \"0.02\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.31\",\n  \"data_read_per_join\": \"2\"\n  },\n  \"used_columns\": [\n  \"document_template_id\",\n  \"tag_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\"\n  }\n  }\n  ]\n  }\n  },\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"1.29\"\n  },\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"d\",\n  \"access_type\": \"fulltext\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_owner_id\",\n  \"idx_deleted_at\",\n  \"idx_private\",\n  \"idx_title\"\n  ],\n  \"key\": \"idx_title\",\n  \"used_key_parts\": [\n  \"title\"\n  ],\n  \"key_length\": \"0\",\n  \"ref\": [\n  \"const\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"9.07\",\n  \"ft_hints\": \"rank > 0\",\n  \"cost_info\": {\n  \"read_cost\": \"1.00\",\n  \"eval_cost\": \"0.01\",\n  \"prefix_cost\": \"1.10\",\n  \"data_read_per_join\": \"119\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"title\",\n  \"owner_id\",\n  \"private\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`d`.`private` = 0) and (`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_uuid\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.owner_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"50.00\",\n  \"cost_info\": {\n  \"read_cost\": \"0.09\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.19\",\n  \"data_read_per_join\": \"13\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"uuid\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`uuid` not in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"tt0\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_document_template_id\",\n  \"idx_tag_id\",\n  \"idx_deleted_at\"\n  ],\n  \"key\": \"idx_document_template_id\",\n  \"used_key_parts\": [\n  \"document_template_id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.id\"\n  ],\n  \"rows_examined_per_scan\": 4,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"25.00\",\n  \"first_match\": \"u\",\n  \"cost_info\": {\n  \"read_cost\": \"0.08\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.30\",\n  \"data_read_per_join\": \"13\"\n  },\n  \"used_columns\": [\n  \"document_template_id\",\n  \"tag_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\"\n  }\n  }\n  ]\n  }\n  }\n  ]\n  }\n  }\n}\n\n## Original SQL:\n(SELECT d.id, d.title\r\n  FROM document_template d\r\n  JOIN `user` u ON u.id = d.owner_id\r\n  WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\r\n  SELECT 1 FROM tag_thing tt0\r\n  WHERE tt0.document_template_id = d.id\r\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\r\n  AND tt0.deleted_at IS NULL\r\n  )) UNION ALL (SELECT d.id, d.title\r\n  FROM document_template d\r\n  JOIN `user` u ON u.id = d.owner_id\r\n  WHERE d.private = 0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\r\n  SELECT 1 FROM tag_thing tt0\r\n  WHERE tt0.document_template_id = d.id\r\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\r\n  AND tt0.deleted_at IS NULL\r\n  )) ORDER BY title ASC LIMIT 10 OFFSET 0;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "(SELECT d.id, d.title FROM document_template d INNER JOIN `user` u ON u.id = d.owner_id INNER JOIN tag_thing tt ON tt.document_template_id = d.id AND tt.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204' AND tt.deleted_at IS NULL WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0) UNION ALL (SELECT d.id, d.title FROM document_template d INNER JOIN `user` u ON u.id = d.owner_id INNER JOIN tag_thing tt ON tt.document_template_id = d.id AND tt.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204' AND tt.deleted_at IS NULL WHERE d.private=0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0) ORDER BY title ASC LIMIT 10 OFFSET 0;"
                    }
                ]
            },
            {
                "case_id": "45",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"45\", \"db_type\": \"postgresql\", \"description\": \"改写后的SQL直接将原始SQL中的WITH子句直接在句同为一层的查询中，移除了不必要的子查询结构（CTE），这是优化SQL编写方式的常用方法。在PostgreSQL处理用例，对于非递归的CTE，查询优化器通常能够直接优化内部逻辑，故改写可能带来可见提升效果不明显。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE Student (s_id SERIAL PRIMARY KEY, s_name VARCHAR(100) NOT NULL, s_sex CHAR(1) NOT NULL);\", \"CREATE TABLE Score (id SERIAL PRIMARY KEY, s_id INTEGER NOT NULL, c_id INTEGER NOT NULL, s_score NUMERIC(5,2) NOT NULL, FOREIGN KEY (s_id) REFERENCES Student (s_id));\", \"CREATE INDEX idx_score_s_id ON Score(s_id);\", \"CREATE INDEX idx_score_s_score ON Score(s_score);\", \"CREATE INDEX idx_score_c_id ON Score(c_id);\"], \"sql\": \"WITH StudentStats AS (\\r\\n  SELECT \\r\\n  s.s_id,\\r\\n  s.s_name,\\r\\n  s.s_sex,\\r\\n  COUNT(DISTINCT sc.c_id) AS course_count,\\r\\n  AVG(sc.s_score) AS avg_score,\\r\\n  SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) AS excellent_course_count\\r\\n  FROM Student s\\r\\n  JOIN Score sc ON s.s_id = sc.s_id\\r\\n  GROUP BY s.s_id, s.s_name, s.s_sex\\r\\n  HAVING AVG(sc.s_score) > 80 AND SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) >= 2\\r\\n)\\r\\nSELECT \\r\\n  ss.s_id,\\r\\n  ss.s_name,\\r\\n  ss.s_sex,\\r\\n  ss.course_count,\\r\\n  ss.avg_score,\\r\\n  ss.excellent_course_count,\\r\\n  RANK() OVER (PARTITION BY ss.s_sex ORDER BY ss.avg_score DESC) AS gender_rank\\r\\nFROM StudentStats ss\\r\\nORDER BY ss.avg_score DESC;\", \"explain\": \"QUERY PLAN\\nSort  (cost=87015.43..87154.32 rows=55556 width=74)\\n  Sort Key: ss.avg_score DESC\\n  ->  WindowAgg  (cost=79055.04..80166.16 rows=55556 width=74)\\n  ->  Sort  (cost=79055.04..79193.93 rows=55556 width=66)\\n  Sort Key: ss.s_sex, ss.avg_score DESC\\n  ->  Subquery Scan on ss  (cost=3.35..72394.76 rows=55556 width=66)\\n  ->  GroupAggregate  (cost=3.35..72394.76 rows=55556 width=66)\\n  Group Key: s.s_id\\n  Filter: ((avg(sc.s_score) > '80'::numeric) AND (sum(CASE WHEN (sc.s_score > '90'::numeric) THEN 1 ELSE 0 END) >= 2))\\n  ->  Incremental Sort  (cost=3.35..57394.76 rows=500000 width=27)\\n  Sort Key: s.s_id, sc.c_id\\n  Presorted Key: s.s_id\\n  ->  Merge Join  (cost=3.27..34894.76 rows=500000 width=27)\\n  Merge Cond: (s.s_id = sc.s_id)\\n  ->  Index Scan using student_pkey on student s  (cost=0.42..16184.42 rows=500000 width=18)\\n  ->  Index Scan using idx_score_s_id on score sc  (cost=0.42..25147.43 rows=500000 width=13)\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 87015.43, 'Total Cost': 87154.32, 'Plan Rows': 55556, 'Plan Width': 74, 'Sort Key': ['ss.avg_score DESC'], 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 79055.04, 'Total Cost': 80166.16, 'Plan Rows': 55556, 'Plan Width': 74, 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 79055.04, 'Total Cost': 79193.93, 'Plan Rows': 55556, 'Plan Width': 66, 'Sort Key': ['ss.s_sex', 'ss.avg_score DESC'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'ss', 'Startup Cost': 3.35, 'Total Cost': 72394.76, 'Plan Rows': 55556, 'Plan Width': 66, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 3.35, 'Total Cost': 72394.76, 'Plan Rows': 55556, 'Plan Width': 66, 'Group Key': ['s.s_id'], 'Filter': \\\"((avg(sc.s_score) > '80'::numeric) AND (sum(CASE WHEN (sc.s_score > '90'::numeric) THEN 1 ELSE 0 END) >= 2))\\\", 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 3.35, 'Total Cost': 57394.76, 'Plan Rows': 500000, 'Plan Width': 27, 'Sort Key': ['s.s_id', 'sc.c_id'], 'Presorted Key': ['s.s_id'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 3.27, 'Total Cost': 34894.76, 'Plan Rows': 500000, 'Plan Width': 27, 'Inner Unique': False, 'Merge Cond': '(s.s_id = sc.s_id)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'student_pkey', 'Relation Name': 'student', 'Alias': 's', 'Startup Cost': 0.42, 'Total Cost': 16184.42, 'Plan Rows': 500000, 'Plan Width': 18}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_score_s_id', 'Relation Name': 'score', 'Alias': 'sc', 'Startup Cost': 0.42, 'Total Cost': 25147.43, 'Plan Rows': 500000, 'Plan Width': 13}]}]}]}]}]}]}]}}]\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE Student (s_id SERIAL PRIMARY KEY, s_name VARCHAR(100) NOT NULL, s_sex CHAR(1) NOT NULL);\nCREATE TABLE Score (id SERIAL PRIMARY KEY, s_id INTEGER NOT NULL, c_id INTEGER NOT NULL, s_score NUMERIC(5,2) NOT NULL, FOREIGN KEY (s_id) REFERENCES Student (s_id));\nCREATE INDEX idx_score_s_id ON Score(s_id);\nCREATE INDEX idx_score_s_score ON Score(s_score);\nCREATE INDEX idx_score_c_id ON Score(c_id);\n\n## Explain Output in JSON:\nQUERY PLAN\nSort  (cost=87015.43..87154.32 rows=55556 width=74)\n  Sort Key: ss.avg_score DESC\n  ->  WindowAgg  (cost=79055.04..80166.16 rows=55556 width=74)\n  ->  Sort  (cost=79055.04..79193.93 rows=55556 width=66)\n  Sort Key: ss.s_sex, ss.avg_score DESC\n  ->  Subquery Scan on ss  (cost=3.35..72394.76 rows=55556 width=66)\n  ->  GroupAggregate  (cost=3.35..72394.76 rows=55556 width=66)\n  Group Key: s.s_id\n  Filter: ((avg(sc.s_score) > '80'::numeric) AND (sum(CASE WHEN (sc.s_score > '90'::numeric) THEN 1 ELSE 0 END) >= 2))\n  ->  Incremental Sort  (cost=3.35..57394.76 rows=500000 width=27)\n  Sort Key: s.s_id, sc.c_id\n  Presorted Key: s.s_id\n  ->  Merge Join  (cost=3.27..34894.76 rows=500000 width=27)\n  Merge Cond: (s.s_id = sc.s_id)\n  ->  Index Scan using student_pkey on student s  (cost=0.42..16184.42 rows=500000 width=18)\n  ->  Index Scan using idx_score_s_id on score sc  (cost=0.42..25147.43 rows=500000 width=13)\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 87015.43, 'Total Cost': 87154.32, 'Plan Rows': 55556, 'Plan Width': 74, 'Sort Key': ['ss.avg_score DESC'], 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 79055.04, 'Total Cost': 80166.16, 'Plan Rows': 55556, 'Plan Width': 74, 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 79055.04, 'Total Cost': 79193.93, 'Plan Rows': 55556, 'Plan Width': 66, 'Sort Key': ['ss.s_sex', 'ss.avg_score DESC'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'ss', 'Startup Cost': 3.35, 'Total Cost': 72394.76, 'Plan Rows': 55556, 'Plan Width': 66, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 3.35, 'Total Cost': 72394.76, 'Plan Rows': 55556, 'Plan Width': 66, 'Group Key': ['s.s_id'], 'Filter': \"((avg(sc.s_score) > '80'::numeric) AND (sum(CASE WHEN (sc.s_score > '90'::numeric) THEN 1 ELSE 0 END) >= 2))\", 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 3.35, 'Total Cost': 57394.76, 'Plan Rows': 500000, 'Plan Width': 27, 'Sort Key': ['s.s_id', 'sc.c_id'], 'Presorted Key': ['s.s_id'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 3.27, 'Total Cost': 34894.76, 'Plan Rows': 500000, 'Plan Width': 27, 'Inner Unique': False, 'Merge Cond': '(s.s_id = sc.s_id)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'student_pkey', 'Relation Name': 'student', 'Alias': 's', 'Startup Cost': 0.42, 'Total Cost': 16184.42, 'Plan Rows': 500000, 'Plan Width': 18}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_score_s_id', 'Relation Name': 'score', 'Alias': 'sc', 'Startup Cost': 0.42, 'Total Cost': 25147.43, 'Plan Rows': 500000, 'Plan Width': 13}]}]}]}]}]}]}]}}]\n\n## Original SQL:\nWITH StudentStats AS (\r\n  SELECT \r\n  s.s_id,\r\n  s.s_name,\r\n  s.s_sex,\r\n  COUNT(DISTINCT sc.c_id) AS course_count,\r\n  AVG(sc.s_score) AS avg_score,\r\n  SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) AS excellent_course_count\r\n  FROM Student s\r\n  JOIN Score sc ON s.s_id = sc.s_id\r\n  GROUP BY s.s_id, s.s_name, s.s_sex\r\n  HAVING AVG(sc.s_score) > 80 AND SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) >= 2\r\n)\r\nSELECT \r\n  ss.s_id,\r\n  ss.s_name,\r\n  ss.s_sex,\r\n  ss.course_count,\r\n  ss.avg_score,\r\n  ss.excellent_course_count,\r\n  RANK() OVER (PARTITION BY ss.s_sex ORDER BY ss.avg_score DESC) AS gender_rank\r\nFROM StudentStats ss\r\nORDER BY ss.avg_score DESC;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT ss.s_id, ss.s_name, ss.s_sex, ss.course_count, ss.avg_score, ss.excellent_course_count, RANK() OVER (PARTITION BY ss.s_sex ORDER BY ss.avg_score DESC) AS gender_rank FROM (SELECT s.s_id, s.s_name, s.s_sex, COUNT(DISTINCT sc.c_id) AS course_count, AVG(sc.s_score) AS avg_score, COUNT(*) FILTER (WHERE sc.s_score > 90) AS excellent_course_count FROM Student s JOIN Score sc ON s.s_id = sc.s_id GROUP BY s.s_id, s.s_name, s.s_sex HAVING AVG(sc.s_score) > 80 AND COUNT(*) FILTER (WHERE sc.s_score > 90) >= 2) ss ORDER BY ss.avg_score DESC;"
                    }
                ]
            },
            {
                "case_id": "46",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"46\", \"db_type\": \"mysql\", \"description\": \"此改写技术通过将外层过滤条件下推到子查询内部，减少子查询需要处理的数据规模，尤其对于需要聚合（group by）和窗口计算（row_number）的操作，避免对无效数据进行计算，从而提升整体性能。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE users (user_id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) NOT NULL, status VARCHAR(50) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_users_status ON users(status);\", \"CREATE TABLE orders (order_id INT PRIMARY KEY AUTO_INCREMENT, user_id INT NOT NULL, order_date DATE NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_orders_user_id ON orders(user_id);\", \"CREATE INDEX idx_orders_order_date ON orders(order_date);\", \"CREATE INDEX idx_orders_user_id_order_date ON orders(user_id, order_date);\", \"CREATE TABLE order_items (order_item_id INT PRIMARY KEY AUTO_INCREMENT, order_id INT NOT NULL, product_id INT NOT NULL, quantity DECIMAL(10,2) NOT NULL, unit_price DECIMAL(10,2) NOT NULL, discount DECIMAL(5,2) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_order_items_order_id ON order_items(order_id);\", \"CREATE INDEX idx_order_items_product_id ON order_items(product_id);\", \"CREATE TABLE products (product_id INT PRIMARY KEY AUTO_INCREMENT, product_name VARCHAR(255) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\"], \"sql\": \"select /*QB_1*/ u.user_id,\\r\\n  u.username, COUNT(distinct o.order_id) as total_orders,\\r\\n  SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent,\\r\\n  AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value,\\r\\n  MAX(o.order_date) as last_order_date,\\r\\n  SQ_1758176107425.GROUP_CONCAT_ as top_products\\r\\nfrom users as u\\r\\ninner join orders as o\\r\\non u.user_id = o.user_id \\r\\nleft outer join order_items as oi\\r\\non o.order_id = oi.order_id \\r\\nleft outer join (\\r\\n  select /*SQ_1758176107425*/ oi2.user_id,\\r\\n  GROUP_CONCAT(distinct oi2.product_name order by oi2.product_name separator ', ') as GROUP_CONCAT_\\r\\n  from (\\r\\n  select /*QB_2*/ o3.user_id,\\r\\n  p.product_name,\\r\\n  row_number() over (partition by o3.user_id order by sum(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num\\r\\n  from order_items as oi2\\r\\n  inner join products as p\\r\\n  on oi2.product_id = p.product_id\\r\\n  inner join orders as o3\\r\\n  on o3.order_id = oi2.order_id\\r\\n  group by o3.user_id,\\r\\n  p.product_name\\r\\n  ) as oi2\\r\\n  where oi2.rank_num <= 3 \\r\\n  group by oi2.user_id \\r\\n  ) as SQ_1758176107425\\r\\non SQ_1758176107425.user_id = u.user_id\\r\\nwhere u.status = 'active'\\r\\n  and o.order_date >= DATE_SUB(CURRENT_DATE(),\\r\\n  interval '3' YEAR)\\r\\ngroup by u.user_id, u.username\\r\\nhaving COUNT(distinct o.order_id) > 0\\r\\norder by total_spent desc;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\to\\t\\tindex\\tidx_orders_user_id,idx_orders_order_date,idx_orders_user_id_order_date\\tidx_orders_user_id_order_date\\t7\\t\\t499550\\t50.0\\tUsing where; Using index; Using temporary; Using filesort\\n1\\tPRIMARY\\tu\\t\\teq_ref\\tPRIMARY,idx_users_status\\tPRIMARY\\t4\\ttest_db.o.user_id\\t1\\t50.0\\tUsing where\\n1\\tPRIMARY\\toi\\t\\tref\\tidx_order_items_order_id\\tidx_order_items_order_id\\t4\\ttest_db.o.order_id\\t5\\t100.0\\t\\n1\\tPRIMARY\\t<derived2>\\t\\tref\\t<auto_key0>\\t<auto_key0>\\t4\\ttest_db.o.user_id\\t10\\t100.0\\t\\n2\\tDERIVED\\t<derived3>\\t\\tALL\\t\\t\\t\\t\\t499070\\t33.33\\tUsing where; Using filesort\\n3\\tDERIVED\\toi2\\t\\tALL\\tidx_order_items_order_id,idx_order_items_product_id\\t\\t\\t\\t499070\\t100.0\\tUsing temporary; Using filesort\\n3\\tDERIVED\\tp\\t\\teq_ref\\tPRIMARY\\tPRIMARY\\t4\\ttest_db.oi2.product_id\\t1\\t100.0\\t\\n3\\tDERIVED\\to3\\t\\teq_ref\\tPRIMARY\\tPRIMARY\\t4\\ttest_db.oi2.order_id\\t1\\t100.0\\t\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"2701392.56\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_filesort\\\": true,\\n  \\\"grouping_operation\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": true,\\n  \\\"buffer_result\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"o\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_orders_user_id\\\",\\n  \\\"idx_orders_order_date\\\",\\n  \\\"idx_orders_user_id_order_date\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_orders_user_id_order_date\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"user_id\\\",\\n  \\\"order_date\\\"\\n  ],\\n  \\\"key_length\\\": \\\"7\\\",\\n  \\\"rows_examined_per_scan\\\": 499550,\\n  \\\"rows_produced_per_join\\\": 249775,\\n  \\\"filtered\\\": \\\"50.00\\\",\\n  \\\"using_index\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"25225.75\\\",\\n  \\\"eval_cost\\\": \\\"24977.50\\\",\\n  \\\"prefix_cost\\\": \\\"50203.25\\\",\\n  \\\"data_read_per_join\\\": \\\"3M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_id\\\",\\n  \\\"user_id\\\",\\n  \\\"order_date\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`o`.`order_date` >= <cache>((curdate() - interval '3' year)))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_users_status\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"user_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.o.user_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 124887,\\n  \\\"filtered\\\": \\\"50.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"205251.09\\\",\\n  \\\"eval_cost\\\": \\\"12488.72\\\",\\n  \\\"prefix_cost\\\": \\\"280431.84\\\",\\n  \\\"data_read_per_join\\\": \\\"72M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"user_id\\\",\\n  \\\"username\\\",\\n  \\\"status\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`status` = 'active')\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"oi\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_order_items_order_id\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_order_items_order_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"order_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.o.order_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 5,\\n  \\\"rows_produced_per_join\\\": 628820,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"157205.24\\\",\\n  \\\"eval_cost\\\": \\\"62882.10\\\",\\n  \\\"prefix_cost\\\": \\\"500519.18\\\",\\n  \\\"data_read_per_join\\\": \\\"19M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_item_id\\\",\\n  \\\"order_id\\\",\\n  \\\"quantity\\\",\\n  \\\"unit_price\\\",\\n  \\\"discount\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"SQ_1758176107425\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"<auto_key0>\\\"\\n  ],\\n  \\\"key\\\": \\\"<auto_key0>\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"user_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.o.user_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 10,\\n  \\\"rows_produced_per_join\\\": 6288209,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1572052.41\\\",\\n  \\\"eval_cost\\\": \\\"628820.97\\\",\\n  \\\"prefix_cost\\\": \\\"2701392.56\\\",\\n  \\\"data_read_per_join\\\": \\\"143M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"user_id\\\",\\n  \\\"GROUP_CONCAT_\\\"\\n  ],\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"222487.90\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n  \\\"using_filesort\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"166340.03\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"oi2\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 499070,\\n  \\\"rows_produced_per_join\\\": 166340,\\n  \\\"filtered\\\": \\\"33.33\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"39513.87\\\",\\n  \\\"eval_cost\\\": \\\"16634.00\\\",\\n  \\\"prefix_cost\\\": \\\"56147.88\\\",\\n  \\\"data_read_per_join\\\": \\\"164M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"user_id\\\",\\n  \\\"product_name\\\",\\n  \\\"rank_num\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`oi2`.`rank_num` <= 3)\\\",\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"898686.75\\\"\\n  },\\n  \\\"windowing\\\": {\\n  \\\"windows\\\": [\\n  {\\n  \\\"name\\\": \\\"<unnamed window>\\\",\\n  \\\"using_filesort\\\": true,\\n  \\\"filesort_key\\\": [\\n  \\\"`user_id`\\\",\\n  \\\"sum(((`quantity` * `unit_price`) * (1 - (`discount` / 100)))) desc\\\"\\n  ],\\n  \\\"functions\\\": [\\n  \\\"row_number\\\"\\n  ]\\n  }\\n  ],\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"499070.00\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": false,\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"oi2\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_order_items_order_id\\\",\\n  \\\"idx_order_items_product_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 499070,\\n  \\\"rows_produced_per_join\\\": 499070,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"360.75\\\",\\n  \\\"eval_cost\\\": \\\"49907.00\\\",\\n  \\\"prefix_cost\\\": \\\"50267.75\\\",\\n  \\\"data_read_per_join\\\": \\\"15M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_item_id\\\",\\n  \\\"order_id\\\",\\n  \\\"product_id\\\",\\n  \\\"quantity\\\",\\n  \\\"unit_price\\\",\\n  \\\"discount\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"p\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"product_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.oi2.product_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 499070,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"124767.50\\\",\\n  \\\"eval_cost\\\": \\\"49907.00\\\",\\n  \\\"prefix_cost\\\": \\\"224942.25\\\",\\n  \\\"data_read_per_join\\\": \\\"491M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"product_id\\\",\\n  \\\"product_name\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"o3\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"order_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.oi2.order_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 499070,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"124767.50\\\",\\n  \\\"eval_cost\\\": \\\"49907.00\\\",\\n  \\\"prefix_cost\\\": \\\"399616.75\\\",\\n  \\\"data_read_per_join\\\": \\\"7M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_id\\\",\\n  \\\"user_id\\\"\\n  ]\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE users (user_id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) NOT NULL, status VARCHAR(50) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_users_status ON users(status);\nCREATE TABLE orders (order_id INT PRIMARY KEY AUTO_INCREMENT, user_id INT NOT NULL, order_date DATE NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_orders_user_id ON orders(user_id);\nCREATE INDEX idx_orders_order_date ON orders(order_date);\nCREATE INDEX idx_orders_user_id_order_date ON orders(user_id, order_date);\nCREATE TABLE order_items (order_item_id INT PRIMARY KEY AUTO_INCREMENT, order_id INT NOT NULL, product_id INT NOT NULL, quantity DECIMAL(10,2) NOT NULL, unit_price DECIMAL(10,2) NOT NULL, discount DECIMAL(5,2) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_order_items_order_id ON order_items(order_id);\nCREATE INDEX idx_order_items_product_id ON order_items(product_id);\nCREATE TABLE products (product_id INT PRIMARY KEY AUTO_INCREMENT, product_name VARCHAR(255) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\to\t\tindex\tidx_orders_user_id,idx_orders_order_date,idx_orders_user_id_order_date\tidx_orders_user_id_order_date\t7\t\t499550\t50.0\tUsing where; Using index; Using temporary; Using filesort\n1\tPRIMARY\tu\t\teq_ref\tPRIMARY,idx_users_status\tPRIMARY\t4\ttest_db.o.user_id\t1\t50.0\tUsing where\n1\tPRIMARY\toi\t\tref\tidx_order_items_order_id\tidx_order_items_order_id\t4\ttest_db.o.order_id\t5\t100.0\t\n1\tPRIMARY\t<derived2>\t\tref\t<auto_key0>\t<auto_key0>\t4\ttest_db.o.user_id\t10\t100.0\t\n2\tDERIVED\t<derived3>\t\tALL\t\t\t\t\t499070\t33.33\tUsing where; Using filesort\n3\tDERIVED\toi2\t\tALL\tidx_order_items_order_id,idx_order_items_product_id\t\t\t\t499070\t100.0\tUsing temporary; Using filesort\n3\tDERIVED\tp\t\teq_ref\tPRIMARY\tPRIMARY\t4\ttest_db.oi2.product_id\t1\t100.0\t\n3\tDERIVED\to3\t\teq_ref\tPRIMARY\tPRIMARY\t4\ttest_db.oi2.order_id\t1\t100.0\t\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"2701392.56\"\n  },\n  \"ordering_operation\": {\n  \"using_filesort\": true,\n  \"grouping_operation\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": true,\n  \"buffer_result\": {\n  \"using_temporary_table\": true,\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"o\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"idx_orders_user_id\",\n  \"idx_orders_order_date\",\n  \"idx_orders_user_id_order_date\"\n  ],\n  \"key\": \"idx_orders_user_id_order_date\",\n  \"used_key_parts\": [\n  \"user_id\",\n  \"order_date\"\n  ],\n  \"key_length\": \"7\",\n  \"rows_examined_per_scan\": 499550,\n  \"rows_produced_per_join\": 249775,\n  \"filtered\": \"50.00\",\n  \"using_index\": true,\n  \"cost_info\": {\n  \"read_cost\": \"25225.75\",\n  \"eval_cost\": \"24977.50\",\n  \"prefix_cost\": \"50203.25\",\n  \"data_read_per_join\": \"3M\"\n  },\n  \"used_columns\": [\n  \"order_id\",\n  \"user_id\",\n  \"order_date\"\n  ],\n  \"attached_condition\": \"(`test_db`.`o`.`order_date` >= <cache>((curdate() - interval '3' year)))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_users_status\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"user_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.o.user_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 124887,\n  \"filtered\": \"50.00\",\n  \"cost_info\": {\n  \"read_cost\": \"205251.09\",\n  \"eval_cost\": \"12488.72\",\n  \"prefix_cost\": \"280431.84\",\n  \"data_read_per_join\": \"72M\"\n  },\n  \"used_columns\": [\n  \"user_id\",\n  \"username\",\n  \"status\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`status` = 'active')\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"oi\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_order_items_order_id\"\n  ],\n  \"key\": \"idx_order_items_order_id\",\n  \"used_key_parts\": [\n  \"order_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.o.order_id\"\n  ],\n  \"rows_examined_per_scan\": 5,\n  \"rows_produced_per_join\": 628820,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"157205.24\",\n  \"eval_cost\": \"62882.10\",\n  \"prefix_cost\": \"500519.18\",\n  \"data_read_per_join\": \"19M\"\n  },\n  \"used_columns\": [\n  \"order_item_id\",\n  \"order_id\",\n  \"quantity\",\n  \"unit_price\",\n  \"discount\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"SQ_1758176107425\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"<auto_key0>\"\n  ],\n  \"key\": \"<auto_key0>\",\n  \"used_key_parts\": [\n  \"user_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.o.user_id\"\n  ],\n  \"rows_examined_per_scan\": 10,\n  \"rows_produced_per_join\": 6288209,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"1572052.41\",\n  \"eval_cost\": \"628820.97\",\n  \"prefix_cost\": \"2701392.56\",\n  \"data_read_per_join\": \"143M\"\n  },\n  \"used_columns\": [\n  \"user_id\",\n  \"GROUP_CONCAT_\"\n  ],\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"222487.90\"\n  },\n  \"grouping_operation\": {\n  \"using_filesort\": true,\n  \"cost_info\": {\n  \"sort_cost\": \"166340.03\"\n  },\n  \"table\": {\n  \"table_name\": \"oi2\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 499070,\n  \"rows_produced_per_join\": 166340,\n  \"filtered\": \"33.33\",\n  \"cost_info\": {\n  \"read_cost\": \"39513.87\",\n  \"eval_cost\": \"16634.00\",\n  \"prefix_cost\": \"56147.88\",\n  \"data_read_per_join\": \"164M\"\n  },\n  \"used_columns\": [\n  \"user_id\",\n  \"product_name\",\n  \"rank_num\"\n  ],\n  \"attached_condition\": \"(`oi2`.`rank_num` <= 3)\",\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"898686.75\"\n  },\n  \"windowing\": {\n  \"windows\": [\n  {\n  \"name\": \"<unnamed window>\",\n  \"using_filesort\": true,\n  \"filesort_key\": [\n  \"`user_id`\",\n  \"sum(((`quantity` * `unit_price`) * (1 - (`discount` / 100)))) desc\"\n  ],\n  \"functions\": [\n  \"row_number\"\n  ]\n  }\n  ],\n  \"cost_info\": {\n  \"sort_cost\": \"499070.00\"\n  },\n  \"grouping_operation\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": false,\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"oi2\",\n  \"access_type\": \"ALL\",\n  \"possible_keys\": [\n  \"idx_order_items_order_id\",\n  \"idx_order_items_product_id\"\n  ],\n  \"rows_examined_per_scan\": 499070,\n  \"rows_produced_per_join\": 499070,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"360.75\",\n  \"eval_cost\": \"49907.00\",\n  \"prefix_cost\": \"50267.75\",\n  \"data_read_per_join\": \"15M\"\n  },\n  \"used_columns\": [\n  \"order_item_id\",\n  \"order_id\",\n  \"product_id\",\n  \"quantity\",\n  \"unit_price\",\n  \"discount\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"p\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"product_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.oi2.product_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 499070,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"124767.50\",\n  \"eval_cost\": \"49907.00\",\n  \"prefix_cost\": \"224942.25\",\n  \"data_read_per_join\": \"491M\"\n  },\n  \"used_columns\": [\n  \"product_id\",\n  \"product_name\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"o3\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"order_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.oi2.order_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 499070,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"124767.50\",\n  \"eval_cost\": \"49907.00\",\n  \"prefix_cost\": \"399616.75\",\n  \"data_read_per_join\": \"7M\"\n  },\n  \"used_columns\": [\n  \"order_id\",\n  \"user_id\"\n  ]\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n}\n\n## Original SQL:\nselect /*QB_1*/ u.user_id,\r\n  u.username, COUNT(distinct o.order_id) as total_orders,\r\n  SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent,\r\n  AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value,\r\n  MAX(o.order_date) as last_order_date,\r\n  SQ_1758176107425.GROUP_CONCAT_ as top_products\r\nfrom users as u\r\ninner join orders as o\r\non u.user_id = o.user_id \r\nleft outer join order_items as oi\r\non o.order_id = oi.order_id \r\nleft outer join (\r\n  select /*SQ_1758176107425*/ oi2.user_id,\r\n  GROUP_CONCAT(distinct oi2.product_name order by oi2.product_name separator ', ') as GROUP_CONCAT_\r\n  from (\r\n  select /*QB_2*/ o3.user_id,\r\n  p.product_name,\r\n  row_number() over (partition by o3.user_id order by sum(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num\r\n  from order_items as oi2\r\n  inner join products as p\r\n  on oi2.product_id = p.product_id\r\n  inner join orders as o3\r\n  on o3.order_id = oi2.order_id\r\n  group by o3.user_id,\r\n  p.product_name\r\n  ) as oi2\r\n  where oi2.rank_num <= 3 \r\n  group by oi2.user_id \r\n  ) as SQ_1758176107425\r\non SQ_1758176107425.user_id = u.user_id\r\nwhere u.status = 'active'\r\n  and o.order_date >= DATE_SUB(CURRENT_DATE(),\r\n  interval '3' YEAR)\r\ngroup by u.user_id, u.username\r\nhaving COUNT(distinct o.order_id) > 0\r\norder by total_spent desc;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select u.user_id, u.username, COUNT(distinct o.order_id) as total_orders, SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent, AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value, MAX(o.order_date) as last_order_date, tp.top_products from users u inner join orders o on u.user_id = o.user_id and o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 YEAR) left join order_items oi on o.order_id = oi.order_id left join (select user_id, GROUP_CONCAT(distinct product_name order by product_name separator ', ') as top_products from (select o3.user_id, p.product_name, row_number() over (partition by o3.user_id order by SUM(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num from orders o3 inner join order_items oi2 on o3.order_id = oi2.order_id inner join products p on oi2.product_id = p.product_id where o3.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 YEAR) group by o3.user_id, p.product_name) ranked_products where rank_num <= 3 group by user_id) tp on tp.user_id = u.user_id where u.status = 'active' group by u.user_id, u.username having COUNT(distinct o.order_id) > 0 order by total_spent desc;"
                    }
                ]
            },
            {
                "case_id": "47",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"47\", \"db_type\": \"mysql\", \"description\": \"通过分析业务逻辑：avg_cust_rate子查询基于vehicle_type, booking_status, payment_method分组，而base表在JOIN时使用相同的字段组合匹配，因此不可能存在base记录在avg_cust_rate中找不到对应分组的情况。同时，WHERE条件要求字段差值的绝对值>=1，强制avg_cust_rate.avg_v必须有值，故LEFT JOIN时保留的NULL记录必然被WHERE过滤。改为INNER JOIN排除了这些无效记录，减少了中间结果集大小。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE ride_bookings (id BIGINT PRIMARY KEY AUTO_INCREMENT, vehicle_type VARCHAR(50) NOT NULL, booking_status VARCHAR(50) NOT NULL, payment_method VARCHAR(50) NOT NULL, ride_distance NUMERIC(10,2) NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_grouping ON ride_bookings (vehicle_type, booking_status, payment_method);\", \"CREATE INDEX idx_ride_distance ON ride_bookings (ride_distance);\"], \"sql\": \"select * \\r\\nfrom (\\r\\nselect base.vehicle_type, base.booking_status, base.payment_method, base.ride_distance, coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0) as rate, \\r\\n row_number() over(partition by base.vehicle_type order by abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) desc ) as rank_num \\r\\nfrom ride_bookings base \\r\\nleft join (\\r\\n\\tselect vehicle_type, booking_status,payment_method,coalesce(avg(ride_distance), 0) as avg_v\\r\\n\\tfrom ride_bookings \\r\\n\\tgroup by vehicle_type, booking_status,payment_method\\r\\n) avg_cust_rate \\r\\non base.vehicle_type = avg_cust_rate.vehicle_type and base.booking_status = avg_cust_rate.booking_status and base.payment_method = avg_cust_rate.payment_method \\r\\nwhere abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) >= 1 \\r\\n) fn \\r\\nwhere rank_num <=5;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t4987160\\t33.33\\tUsing where\\n2\\tDERIVED\\tbase\\t\\tALL\\t\\t\\t\\t\\t498713\\t100.0\\tUsing temporary; Using filesort\\n2\\tDERIVED\\t<derived3>\\t\\tref\\t<auto_key0>\\t<auto_key0>\\t606\\ttest_db.base.vehicle_type,test_db.base.booking_status,test_db.base.payment_method\\t10\\t100.0\\tUsing where\\n3\\tDERIVED\\tride_bookings\\t\\tindex\\tidx_grouping\\tidx_grouping\\t606\\t\\t498713\\t100.0\\t\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"561058.00\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"fn\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 4987160,\\n  \\\"rows_produced_per_join\\\": 1662220,\\n  \\\"filtered\\\": \\\"33.33\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"394835.96\\\",\\n  \\\"eval_cost\\\": \\\"166222.04\\\",\\n  \\\"prefix_cost\\\": \\\"561058.00\\\",\\n  \\\"data_read_per_join\\\": \\\"1001M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\",\\n  \\\"ride_distance\\\",\\n  \\\"rate\\\",\\n  \\\"rank_num\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`fn`.`rank_num` <= 5)\\\",\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"6783026.30\\\"\\n  },\\n  \\\"windowing\\\": {\\n  \\\"windows\\\": [\\n  {\\n  \\\"name\\\": \\\"<unnamed window>\\\",\\n  \\\"using_filesort\\\": true,\\n  \\\"filesort_key\\\": [\\n  \\\"`vehicle_type`\\\",\\n  \\\"abs((coalesce(`ride_distance`,0) - coalesce(`avg_v`,0))) desc\\\"\\n  ],\\n  \\\"functions\\\": [\\n  \\\"row_number\\\"\\n  ]\\n  }\\n  ],\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"4987160.00\\\"\\n  },\\n  \\\"buffer_result\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"base\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 498713,\\n  \\\"rows_produced_per_join\\\": 498713,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"489.00\\\",\\n  \\\"eval_cost\\\": \\\"49871.30\\\",\\n  \\\"prefix_cost\\\": \\\"50360.30\\\",\\n  \\\"data_read_per_join\\\": \\\"296M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\",\\n  \\\"ride_distance\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"avg_cust_rate\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"<auto_key0>\\\"\\n  ],\\n  \\\"key\\\": \\\"<auto_key0>\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\"\\n  ],\\n  \\\"key_length\\\": \\\"606\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.base.vehicle_type\\\",\\n  \\\"test_db.base.booking_status\\\",\\n  \\\"test_db.base.payment_method\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 10,\\n  \\\"rows_produced_per_join\\\": 4987160,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1246790.00\\\",\\n  \\\"eval_cost\\\": \\\"498716.00\\\",\\n  \\\"prefix_cost\\\": \\\"1795866.30\\\",\\n  \\\"data_read_per_join\\\": \\\"2G\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\",\\n  \\\"avg_v\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"<if>(found_match(avg_cust_rate), (abs((coalesce(`test_db`.`base`.`ride_distance`,0) - coalesce(`avg_cust_rate`.`avg_v`,0))) >= 1), true)\\\",\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"50360.30\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n  \\\"using_filesort\\\": false,\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"ride_bookings\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_grouping\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_grouping\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\"\\n  ],\\n  \\\"key_length\\\": \\\"606\\\",\\n  \\\"rows_examined_per_scan\\\": 498713,\\n  \\\"rows_produced_per_join\\\": 498713,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"489.00\\\",\\n  \\\"eval_cost\\\": \\\"49871.30\\\",\\n  \\\"prefix_cost\\\": \\\"50360.30\\\",\\n  \\\"data_read_per_join\\\": \\\"296M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\",\\n  \\\"ride_distance\\\"\\n  ]\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE ride_bookings (id BIGINT PRIMARY KEY AUTO_INCREMENT, vehicle_type VARCHAR(50) NOT NULL, booking_status VARCHAR(50) NOT NULL, payment_method VARCHAR(50) NOT NULL, ride_distance NUMERIC(10,2) NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_grouping ON ride_bookings (vehicle_type, booking_status, payment_method);\nCREATE INDEX idx_ride_distance ON ride_bookings (ride_distance);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t4987160\t33.33\tUsing where\n2\tDERIVED\tbase\t\tALL\t\t\t\t\t498713\t100.0\tUsing temporary; Using filesort\n2\tDERIVED\t<derived3>\t\tref\t<auto_key0>\t<auto_key0>\t606\ttest_db.base.vehicle_type,test_db.base.booking_status,test_db.base.payment_method\t10\t100.0\tUsing where\n3\tDERIVED\tride_bookings\t\tindex\tidx_grouping\tidx_grouping\t606\t\t498713\t100.0\t\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"561058.00\"\n  },\n  \"table\": {\n  \"table_name\": \"fn\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 4987160,\n  \"rows_produced_per_join\": 1662220,\n  \"filtered\": \"33.33\",\n  \"cost_info\": {\n  \"read_cost\": \"394835.96\",\n  \"eval_cost\": \"166222.04\",\n  \"prefix_cost\": \"561058.00\",\n  \"data_read_per_join\": \"1001M\"\n  },\n  \"used_columns\": [\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\",\n  \"ride_distance\",\n  \"rate\",\n  \"rank_num\"\n  ],\n  \"attached_condition\": \"(`fn`.`rank_num` <= 5)\",\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"6783026.30\"\n  },\n  \"windowing\": {\n  \"windows\": [\n  {\n  \"name\": \"<unnamed window>\",\n  \"using_filesort\": true,\n  \"filesort_key\": [\n  \"`vehicle_type`\",\n  \"abs((coalesce(`ride_distance`,0) - coalesce(`avg_v`,0))) desc\"\n  ],\n  \"functions\": [\n  \"row_number\"\n  ]\n  }\n  ],\n  \"cost_info\": {\n  \"sort_cost\": \"4987160.00\"\n  },\n  \"buffer_result\": {\n  \"using_temporary_table\": true,\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"base\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 498713,\n  \"rows_produced_per_join\": 498713,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"489.00\",\n  \"eval_cost\": \"49871.30\",\n  \"prefix_cost\": \"50360.30\",\n  \"data_read_per_join\": \"296M\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\",\n  \"ride_distance\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"avg_cust_rate\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"<auto_key0>\"\n  ],\n  \"key\": \"<auto_key0>\",\n  \"used_key_parts\": [\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\"\n  ],\n  \"key_length\": \"606\",\n  \"ref\": [\n  \"test_db.base.vehicle_type\",\n  \"test_db.base.booking_status\",\n  \"test_db.base.payment_method\"\n  ],\n  \"rows_examined_per_scan\": 10,\n  \"rows_produced_per_join\": 4987160,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"1246790.00\",\n  \"eval_cost\": \"498716.00\",\n  \"prefix_cost\": \"1795866.30\",\n  \"data_read_per_join\": \"2G\"\n  },\n  \"used_columns\": [\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\",\n  \"avg_v\"\n  ],\n  \"attached_condition\": \"<if>(found_match(avg_cust_rate), (abs((coalesce(`test_db`.`base`.`ride_distance`,0) - coalesce(`avg_cust_rate`.`avg_v`,0))) >= 1), true)\",\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"50360.30\"\n  },\n  \"grouping_operation\": {\n  \"using_filesort\": false,\n  \"table\": {\n  \"table_name\": \"ride_bookings\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"idx_grouping\"\n  ],\n  \"key\": \"idx_grouping\",\n  \"used_key_parts\": [\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\"\n  ],\n  \"key_length\": \"606\",\n  \"rows_examined_per_scan\": 498713,\n  \"rows_produced_per_join\": 498713,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"489.00\",\n  \"eval_cost\": \"49871.30\",\n  \"prefix_cost\": \"50360.30\",\n  \"data_read_per_join\": \"296M\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\",\n  \"ride_distance\"\n  ]\n  }\n  }\n  }\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n  }\n  }\n}\n\n## Original SQL:\nselect * \r\nfrom (\r\nselect base.vehicle_type, base.booking_status, base.payment_method, base.ride_distance, coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0) as rate, \r\n row_number() over(partition by base.vehicle_type order by abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) desc ) as rank_num \r\nfrom ride_bookings base \r\nleft join (\r\n\tselect vehicle_type, booking_status,payment_method,coalesce(avg(ride_distance), 0) as avg_v\r\n\tfrom ride_bookings \r\n\tgroup by vehicle_type, booking_status,payment_method\r\n) avg_cust_rate \r\non base.vehicle_type = avg_cust_rate.vehicle_type and base.booking_status = avg_cust_rate.booking_status and base.payment_method = avg_cust_rate.payment_method \r\nwhere abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) >= 1 \r\n) fn \r\nwhere rank_num <=5;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM (SELECT vehicle_type, booking_status, payment_method, ride_distance, rate, row_number() over(partition by vehicle_type order by abs(rate) desc) as rank_num FROM (SELECT vehicle_type, booking_status, payment_method, ride_distance, coalesce(ride_distance, 0) - coalesce(avg(ride_distance) over (partition by vehicle_type, booking_status, payment_method), 0) as rate FROM ride_bookings) t WHERE abs(rate) >= 1) fn WHERE rank_num <= 5;"
                    }
                ]
            },
            {
                "case_id": "48",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"48\", \"db_type\": \"mysql\", \"description\": \"改写前的SQL对每个分组结果（每个customer_id）执行两个相关子查询，导致对每个成组的customer_id都要额外扫描两次表。改写后将子查询逻辑合并到主查询的聚合函数中，利用主查询的分组直接计算平均值和最大值，避免了N+1查询问题，大幅减少了重复扫描次数。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE ride_bookings (booking_id INT PRIMARY KEY AUTO_INCREMENT, customer_id INT NOT NULL, booking_value DECIMAL(10,2) NOT NULL, driver_rating DECIMAL(3,2), booking_status VARCHAR(50) NOT NULL, booking_date DATETIME NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_customer_id ON ride_bookings(customer_id);\", \"CREATE INDEX idx_booking_status_date ON ride_bookings(booking_status, booking_date);\"], \"sql\": \"SELECT \\r\\n  rb.customer_id,\\r\\n  COUNT(DISTINCT rb.booking_id) AS total_bookings,\\r\\n  SUM(rb.booking_value) AS total_revenue,\\r\\n  (SELECT AVG(driver_rating) FROM ride_bookings WHERE customer_id = rb.customer_id) AS avg_driver_rating,\\r\\n  (SELECT MAX(booking_date) FROM ride_bookings WHERE customer_id = rb.customer_id) AS last_booking_date\\r\\nFROM \\r\\n  ride_bookings rb\\r\\nWHERE \\r\\n  rb.booking_status IN ('Completed', 'Cancelled', 'No Show')\\r\\n  AND rb.booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY)\\r\\nGROUP BY \\r\\n  rb.customer_id\\r\\nHAVING \\r\\n  total_bookings > 10\\r\\nORDER BY \\r\\n  total_revenue DESC,\\r\\n  avg_driver_rating ASC;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\trb\\t\\tindex\\tidx_customer_id,idx_booking_status_date\\tidx_customer_id\\t4\\t\\t498576\\t100.0\\tUsing where; Using temporary; Using filesort\\n3\\tDEPENDENT SUBQUERY\\tride_bookings\\t\\tref\\tidx_customer_id\\tidx_customer_id\\t4\\tfunc\\t25\\t100.0\\t\\n2\\tDEPENDENT SUBQUERY\\tride_bookings\\t\\tref\\tidx_customer_id\\tidx_customer_id\\t4\\tfunc\\t25\\t100.0\\t\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"50266.35\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": true,\\n  \\\"grouping_operation\\\": {\\n  \\\"using_filesort\\\": false,\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"rb\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_customer_id\\\",\\n  \\\"idx_booking_status_date\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_customer_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"customer_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"rows_examined_per_scan\\\": 498576,\\n  \\\"rows_produced_per_join\\\": 498576,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"408.75\\\",\\n  \\\"eval_cost\\\": \\\"49857.60\\\",\\n  \\\"prefix_cost\\\": \\\"50266.35\\\",\\n  \\\"data_read_per_join\\\": \\\"106M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"booking_id\\\",\\n  \\\"customer_id\\\",\\n  \\\"booking_value\\\",\\n  \\\"booking_status\\\",\\n  \\\"booking_date\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`rb`.`booking_status` in ('Completed','Cancelled','No Show')) and (`test_db`.`rb`.`booking_date` >= <cache>((curdate() - interval 180 day))))\\\"\\n  },\\n  \\\"select_list_subqueries\\\": [\\n  {\\n  \\\"dependent\\\": true,\\n  \\\"cacheable\\\": false,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"8.82\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"ride_bookings\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_customer_id\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_customer_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"customer_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"func\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 25,\\n  \\\"rows_produced_per_join\\\": 25,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"6.30\\\",\\n  \\\"eval_cost\\\": \\\"2.52\\\",\\n  \\\"prefix_cost\\\": \\\"8.82\\\",\\n  \\\"data_read_per_join\\\": \\\"5K\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"customer_id\\\",\\n  \\\"booking_date\\\"\\n  ]\\n  }\\n  }\\n  },\\n  {\\n  \\\"dependent\\\": true,\\n  \\\"cacheable\\\": false,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"8.82\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"ride_bookings\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_customer_id\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_customer_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"customer_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"func\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 25,\\n  \\\"rows_produced_per_join\\\": 25,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"6.30\\\",\\n  \\\"eval_cost\\\": \\\"2.52\\\",\\n  \\\"prefix_cost\\\": \\\"8.82\\\",\\n  \\\"data_read_per_join\\\": \\\"5K\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"customer_id\\\",\\n  \\\"driver_rating\\\"\\n  ]\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE ride_bookings (booking_id INT PRIMARY KEY AUTO_INCREMENT, customer_id INT NOT NULL, booking_value DECIMAL(10,2) NOT NULL, driver_rating DECIMAL(3,2), booking_status VARCHAR(50) NOT NULL, booking_date DATETIME NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_customer_id ON ride_bookings(customer_id);\nCREATE INDEX idx_booking_status_date ON ride_bookings(booking_status, booking_date);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\trb\t\tindex\tidx_customer_id,idx_booking_status_date\tidx_customer_id\t4\t\t498576\t100.0\tUsing where; Using temporary; Using filesort\n3\tDEPENDENT SUBQUERY\tride_bookings\t\tref\tidx_customer_id\tidx_customer_id\t4\tfunc\t25\t100.0\t\n2\tDEPENDENT SUBQUERY\tride_bookings\t\tref\tidx_customer_id\tidx_customer_id\t4\tfunc\t25\t100.0\t\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"50266.35\"\n  },\n  \"ordering_operation\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": true,\n  \"grouping_operation\": {\n  \"using_filesort\": false,\n  \"table\": {\n  \"table_name\": \"rb\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"idx_customer_id\",\n  \"idx_booking_status_date\"\n  ],\n  \"key\": \"idx_customer_id\",\n  \"used_key_parts\": [\n  \"customer_id\"\n  ],\n  \"key_length\": \"4\",\n  \"rows_examined_per_scan\": 498576,\n  \"rows_produced_per_join\": 498576,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"408.75\",\n  \"eval_cost\": \"49857.60\",\n  \"prefix_cost\": \"50266.35\",\n  \"data_read_per_join\": \"106M\"\n  },\n  \"used_columns\": [\n  \"booking_id\",\n  \"customer_id\",\n  \"booking_value\",\n  \"booking_status\",\n  \"booking_date\"\n  ],\n  \"attached_condition\": \"((`test_db`.`rb`.`booking_status` in ('Completed','Cancelled','No Show')) and (`test_db`.`rb`.`booking_date` >= <cache>((curdate() - interval 180 day))))\"\n  },\n  \"select_list_subqueries\": [\n  {\n  \"dependent\": true,\n  \"cacheable\": false,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"8.82\"\n  },\n  \"table\": {\n  \"table_name\": \"ride_bookings\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_customer_id\"\n  ],\n  \"key\": \"idx_customer_id\",\n  \"used_key_parts\": [\n  \"customer_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"func\"\n  ],\n  \"rows_examined_per_scan\": 25,\n  \"rows_produced_per_join\": 25,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"6.30\",\n  \"eval_cost\": \"2.52\",\n  \"prefix_cost\": \"8.82\",\n  \"data_read_per_join\": \"5K\"\n  },\n  \"used_columns\": [\n  \"customer_id\",\n  \"booking_date\"\n  ]\n  }\n  }\n  },\n  {\n  \"dependent\": true,\n  \"cacheable\": false,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"8.82\"\n  },\n  \"table\": {\n  \"table_name\": \"ride_bookings\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_customer_id\"\n  ],\n  \"key\": \"idx_customer_id\",\n  \"used_key_parts\": [\n  \"customer_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"func\"\n  ],\n  \"rows_examined_per_scan\": 25,\n  \"rows_produced_per_join\": 25,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"6.30\",\n  \"eval_cost\": \"2.52\",\n  \"prefix_cost\": \"8.82\",\n  \"data_read_per_join\": \"5K\"\n  },\n  \"used_columns\": [\n  \"customer_id\",\n  \"driver_rating\"\n  ]\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n}\n\n## Original SQL:\nSELECT \r\n  rb.customer_id,\r\n  COUNT(DISTINCT rb.booking_id) AS total_bookings,\r\n  SUM(rb.booking_value) AS total_revenue,\r\n  (SELECT AVG(driver_rating) FROM ride_bookings WHERE customer_id = rb.customer_id) AS avg_driver_rating,\r\n  (SELECT MAX(booking_date) FROM ride_bookings WHERE customer_id = rb.customer_id) AS last_booking_date\r\nFROM \r\n  ride_bookings rb\r\nWHERE \r\n  rb.booking_status IN ('Completed', 'Cancelled', 'No Show')\r\n  AND rb.booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY)\r\nGROUP BY \r\n  rb.customer_id\r\nHAVING \r\n  total_bookings > 10\r\nORDER BY \r\n  total_revenue DESC,\r\n  avg_driver_rating ASC;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT t1.customer_id, t1.total_bookings, t1.total_revenue, t2.avg_driver_rating, t2.last_booking_date FROM (SELECT customer_id, COUNT(DISTINCT booking_id) AS total_bookings, SUM(booking_value) AS total_revenue FROM ride_bookings WHERE booking_status IN ('Completed', 'Cancelled', 'No Show') AND booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY) GROUP BY customer_id HAVING COUNT(DISTINCT booking_id) > 10) t1 LEFT JOIN (SELECT customer_id, AVG(driver_rating) AS avg_driver_rating, MAX(booking_date) AS last_booking_date FROM ride_bookings GROUP BY customer_id) t2 ON t1.customer_id = t2.customer_id ORDER BY t1.total_revenue DESC, t2.avg_driver_rating ASC;"
                    }
                ]
            },
            {
                "case_id": "49",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"49\", \"db_type\": \"mysql\", \"description\": \"该SQL用于统计库存车辆数及首次入库数，涉及近20个表的LEFT JOIN。主要性能问题有：1. **投影冗余**：作为连接源的两个子查询（Derived Tables `mo` 和 `purchase`）输出了大量外部查询不需要的列（如`AUDIT_STATUS`、`NEW_HOUSE_ID`、`PURCHASE_ORDER_CODE`等）。这导致中间结果集（临时表）宽度过大，显著增加了内存消耗和I/O开销。2. **子查询效率低**：`mo`子查询内部嵌套了分组聚合和IN子查询，且未有效过滤数据。3. **谓词下推机会**：主表`t_mdm_dlr_car_store`的过滤条件`IS_ENABLE='1'`位于WHERE子句，虽然优化器通常处理，但在复杂宽表连接中，显式下推或精简数据源能获得更稳定的执行计划。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE t_mdm_dlr_car_store (CAR_ID INT, SALES_PLAN_CODE VARCHAR(50), DLR_ID INT, CAR_STOCK_HOUSE_ID INT, CAR_SALE_HOUSE_ID INT, IS_ENABLE CHAR(1), FIRST_IN_HOSTSTOCK_DATE DATETIME, INDEX(CAR_ID), INDEX(SALES_PLAN_CODE));\", \"CREATE TABLE t_mdm_dlr_car (CAR_ID INT PRIMARY KEY, CAR_CONFIG_ID INT, OPTIONAL_PAG_ID INT, CAR_COLOR_ID INT, CAR_INCOLOR_ID INT);\", \"CREATE TABLE t_ve_bu_sale_order_d (SALE_PLAN_CODE VARCHAR(50), SALE_ORDER_ID INT, DELIVERY_FAC_HW_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE), INDEX(SALE_ORDER_ID));\", \"CREATE TABLE t_ve_bu_sale_order (SALE_ORDER_ID INT PRIMARY KEY);\", \"CREATE TABLE t_mdm_ve_car_config (CAR_CONFIG_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_bu_inv_apply_d (link_order_id INT, is_Enable CHAR(1), INDEX(link_order_id));\", \"CREATE TABLE t_ve_bu_movestock_order (MOVESTOCK_ORDER_CODE VARCHAR(50), CAR_ID INT, VIN VARCHAR(50), AUDIT_STATUS VARCHAR(20), NEW_HOUSE_ID INT, NEW_DLR_ID INT, INDEX(CAR_ID), INDEX(VIN));\", \"CREATE TABLE t_ve_bu_month_plan_d (SALES_PLAN_CODE VARCHAR(50), INSTORE_TIME DATETIME, INDEX(SALES_PLAN_CODE));\", \"CREATE TABLE t_usc_mdm_org_dlr (DLR_ID INT PRIMARY KEY, CITY_ID INT);\", \"CREATE TABLE T_USC_MDM_ORG_CITY (CITY_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_db_zb_stock (ZB_STOCK_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_db_car_stock_house (CAR_STOCK_HOUSE_ID INT PRIMARY KEY, CAR_HOUSE_CODE VARCHAR(50));\", \"CREATE TABLE t_mdm_ve_car_optionalpag (OPTIONAL_PAG_ID INT PRIMARY KEY);\", \"CREATE TABLE t_mdm_car_color (CAR_COLOR_ID INT PRIMARY KEY);\", \"CREATE TABLE t_mdm_car_incolor (CAR_INCOLOR_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_finance_wholesale_purchase_order (SALES_PLAN_CODE VARCHAR(50), WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), ORDER_STATUS VARCHAR(50), INDEX(SALES_PLAN_CODE));\", \"CREATE TABLE t_ve_bu_invoice_info_upload (WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), IS_ENABLE CHAR(1), INDEX(WHOLESALE_PURCHASE_ORDER_CODE));\", \"CREATE TABLE t_prc_mds_lookup_value (LOOKUP_VALUE_CODE VARCHAR(50), LOOKUP_TYPE_CODE VARCHAR(50), INDEX(LOOKUP_VALUE_CODE));\", \"CREATE TABLE t_ve_bu_purchase_order (PURCHASE_ORDER_CODE VARCHAR(50), SALE_PLAN_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE));\"], \"sql\": \"SELECT count(1) stockNum, COUNT(c.FIRST_IN_HOSTSTOCK_DATE ) hostStockNum -- , -- DATE_FORMAT( Max(mpd.INSTORE_TIME), '%Y-%m-%d %H%:%i:%s') maxStoreTime FROM t_mdm_dlr_car_store c LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID = SO.SALE_ORDER_ID LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID = car.CAR_CONFIG_ID LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id = iad.link_order_id and iad.is_Enable='1' LEFT JOIN (SELECT MOVESTOCK_ORDER_CODE,CAR_ID,AUDIT_STATUS,NEW_HOUSE_ID,NEW_DLR_ID from t_ve_bu_movestock_order WHERE MOVESTOCK_ORDER_CODE in ( SELECT max(MOVESTOCK_ORDER_CODE) from t_ve_bu_movestock_order GROUP BY VIN )) mo ON mo.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID = tumod.DLR_ID LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID = tumod.CITY_ID LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID = c.CAR_SALE_HOUSE_ID LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID = optionl.OPTIONAL_PAG_ID LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID = cols.CAR_COLOR_ID LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID = incol.CAR_INCOLOR_ID left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE = SOD.DELIVERY_FAC_HW_CODE left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE = c.SALES_PLAN_CODE left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE = tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE = '1' left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE = ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE = 'VE1414' left join (select max(PURCHASE_ORDER_CODE) PURCHASE_ORDER_CODE ,SALE_PLAN_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE ) purchase on purchase.SALE_PLAN_CODE =c.SALES_PLAN_CODE WHERE c.IS_ENABLE = '1'\", \"explain\": \"id\\tselect_type\\ttable\\ttype\\tkey\\trows\\tExtra\\n1\\tPRIMARY\\tc\\tALL\\tNULL\\t1000\\tUsing where\\n1\\tPRIMARY\\tCAR\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tSOD\\tref\\tSALE_PLAN_CODE\\t1\\tUsing index\\n1\\tPRIMARY\\tSO\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tcon\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tiad\\tref\\tlink_order_id\\t1\\tUsing where\\n1\\tPRIMARY\\t<derived2>\\tref\\t<auto_key0>\\t10\\tUsing where\\n1\\tPRIMARY\\tmpd\\tref\\tSALES_PLAN_CODE\\t1\\tUsing index\\n1\\tPRIMARY\\ttumod\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tCI\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\ttvdzs\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\ttvdcsh\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tSHd\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\toptionl\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tcols\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tincol\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\toge\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tord\\tref\\tSALES_PLAN_CODE\\t1\\tUsing index\\n1\\tPRIMARY\\ttvbiiu\\tref\\tWHOLESALE_PURCHASE_ORDER_CODE\\t1\\tUsing where\\n1\\tPRIMARY\\tv5\\tref\\tLOOKUP_VALUE_CODE\\t1\\tUsing where\\n1\\tPRIMARY\\t<derived4>\\tref\\t<auto_key0>\\t10\\tUsing where\\n2\\tDERIVED\\tt_ve_bu_movestock_order\\tALL\\tNULL\\t5000\\tUsing where\\n3\\tDEPENDENT SUBQUERY\\tt_ve_bu_movestock_order\\tindex\\tVIN\\t5000\\tUsing index\\n4\\tDERIVED\\tt_ve_bu_purchase_order\\tindex\\tSALE_PLAN_CODE\\t2000\\tUsing index\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE t_mdm_dlr_car_store (CAR_ID INT, SALES_PLAN_CODE VARCHAR(50), DLR_ID INT, CAR_STOCK_HOUSE_ID INT, CAR_SALE_HOUSE_ID INT, IS_ENABLE CHAR(1), FIRST_IN_HOSTSTOCK_DATE DATETIME, INDEX(CAR_ID), INDEX(SALES_PLAN_CODE));\nCREATE TABLE t_mdm_dlr_car (CAR_ID INT PRIMARY KEY, CAR_CONFIG_ID INT, OPTIONAL_PAG_ID INT, CAR_COLOR_ID INT, CAR_INCOLOR_ID INT);\nCREATE TABLE t_ve_bu_sale_order_d (SALE_PLAN_CODE VARCHAR(50), SALE_ORDER_ID INT, DELIVERY_FAC_HW_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE), INDEX(SALE_ORDER_ID));\nCREATE TABLE t_ve_bu_sale_order (SALE_ORDER_ID INT PRIMARY KEY);\nCREATE TABLE t_mdm_ve_car_config (CAR_CONFIG_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_bu_inv_apply_d (link_order_id INT, is_Enable CHAR(1), INDEX(link_order_id));\nCREATE TABLE t_ve_bu_movestock_order (MOVESTOCK_ORDER_CODE VARCHAR(50), CAR_ID INT, VIN VARCHAR(50), AUDIT_STATUS VARCHAR(20), NEW_HOUSE_ID INT, NEW_DLR_ID INT, INDEX(CAR_ID), INDEX(VIN));\nCREATE TABLE t_ve_bu_month_plan_d (SALES_PLAN_CODE VARCHAR(50), INSTORE_TIME DATETIME, INDEX(SALES_PLAN_CODE));\nCREATE TABLE t_usc_mdm_org_dlr (DLR_ID INT PRIMARY KEY, CITY_ID INT);\nCREATE TABLE T_USC_MDM_ORG_CITY (CITY_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_db_zb_stock (ZB_STOCK_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_db_car_stock_house (CAR_STOCK_HOUSE_ID INT PRIMARY KEY, CAR_HOUSE_CODE VARCHAR(50));\nCREATE TABLE t_mdm_ve_car_optionalpag (OPTIONAL_PAG_ID INT PRIMARY KEY);\nCREATE TABLE t_mdm_car_color (CAR_COLOR_ID INT PRIMARY KEY);\nCREATE TABLE t_mdm_car_incolor (CAR_INCOLOR_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_finance_wholesale_purchase_order (SALES_PLAN_CODE VARCHAR(50), WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), ORDER_STATUS VARCHAR(50), INDEX(SALES_PLAN_CODE));\nCREATE TABLE t_ve_bu_invoice_info_upload (WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), IS_ENABLE CHAR(1), INDEX(WHOLESALE_PURCHASE_ORDER_CODE));\nCREATE TABLE t_prc_mds_lookup_value (LOOKUP_VALUE_CODE VARCHAR(50), LOOKUP_TYPE_CODE VARCHAR(50), INDEX(LOOKUP_VALUE_CODE));\nCREATE TABLE t_ve_bu_purchase_order (PURCHASE_ORDER_CODE VARCHAR(50), SALE_PLAN_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE));\n\n## Explain Output in JSON:\nid\tselect_type\ttable\ttype\tkey\trows\tExtra\n1\tPRIMARY\tc\tALL\tNULL\t1000\tUsing where\n1\tPRIMARY\tCAR\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tSOD\tref\tSALE_PLAN_CODE\t1\tUsing index\n1\tPRIMARY\tSO\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tcon\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tiad\tref\tlink_order_id\t1\tUsing where\n1\tPRIMARY\t<derived2>\tref\t<auto_key0>\t10\tUsing where\n1\tPRIMARY\tmpd\tref\tSALES_PLAN_CODE\t1\tUsing index\n1\tPRIMARY\ttumod\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tCI\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\ttvdzs\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\ttvdcsh\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tSHd\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\toptionl\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tcols\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tincol\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\toge\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tord\tref\tSALES_PLAN_CODE\t1\tUsing index\n1\tPRIMARY\ttvbiiu\tref\tWHOLESALE_PURCHASE_ORDER_CODE\t1\tUsing where\n1\tPRIMARY\tv5\tref\tLOOKUP_VALUE_CODE\t1\tUsing where\n1\tPRIMARY\t<derived4>\tref\t<auto_key0>\t10\tUsing where\n2\tDERIVED\tt_ve_bu_movestock_order\tALL\tNULL\t5000\tUsing where\n3\tDEPENDENT SUBQUERY\tt_ve_bu_movestock_order\tindex\tVIN\t5000\tUsing index\n4\tDERIVED\tt_ve_bu_purchase_order\tindex\tSALE_PLAN_CODE\t2000\tUsing index\n\n## Original SQL:\nSELECT count(1) stockNum, COUNT(c.FIRST_IN_HOSTSTOCK_DATE ) hostStockNum -- , -- DATE_FORMAT( Max(mpd.INSTORE_TIME), '%Y-%m-%d %H%:%i:%s') maxStoreTime FROM t_mdm_dlr_car_store c LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID = SO.SALE_ORDER_ID LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID = car.CAR_CONFIG_ID LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id = iad.link_order_id and iad.is_Enable='1' LEFT JOIN (SELECT MOVESTOCK_ORDER_CODE,CAR_ID,AUDIT_STATUS,NEW_HOUSE_ID,NEW_DLR_ID from t_ve_bu_movestock_order WHERE MOVESTOCK_ORDER_CODE in ( SELECT max(MOVESTOCK_ORDER_CODE) from t_ve_bu_movestock_order GROUP BY VIN )) mo ON mo.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID = tumod.DLR_ID LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID = tumod.CITY_ID LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID = c.CAR_SALE_HOUSE_ID LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID = optionl.OPTIONAL_PAG_ID LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID = cols.CAR_COLOR_ID LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID = incol.CAR_INCOLOR_ID left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE = SOD.DELIVERY_FAC_HW_CODE left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE = c.SALES_PLAN_CODE left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE = tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE = '1' left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE = ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE = 'VE1414' left join (select max(PURCHASE_ORDER_CODE) PURCHASE_ORDER_CODE ,SALE_PLAN_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE ) purchase on purchase.SALE_PLAN_CODE =c.SALES_PLAN_CODE WHERE c.IS_ENABLE = '1'\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT count(1) stockNum,COUNT(c.FIRST_IN_HOSTSTOCK_DATE) hostStockNum FROM t_mdm_dlr_car_store c LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID=c.CAR_ID LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE=c.SALES_PLAN_CODE LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID=SO.SALE_ORDER_ID LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID=car.CAR_CONFIG_ID LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id=iad.link_order_id and iad.is_Enable='1' LEFT JOIN(SELECT m.MOVESTOCK_ORDER_CODE,m.CAR_ID,m.AUDIT_STATUS,m.NEW_HOUSE_ID,m.NEW_DLR_ID FROM t_ve_bu_movestock_order m INNER JOIN(SELECT VIN,MAX(MOVESTOCK_ORDER_CODE) max_code FROM t_ve_bu_movestock_order GROUP BY VIN)mm ON m.VIN=mm.VIN AND m.MOVESTOCK_ORDER_CODE=mm.max_code)mo ON mo.CAR_ID=c.CAR_ID LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE=c.SALES_PLAN_CODE LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID=tumod.DLR_ID LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID=tumod.CITY_ID LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID=c.CAR_STOCK_HOUSE_ID LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID=c.CAR_STOCK_HOUSE_ID LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID=c.CAR_SALE_HOUSE_ID LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID=optionl.OPTIONAL_PAG_ID LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID=cols.CAR_COLOR_ID LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID=incol.CAR_INCOLOR_ID left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE=SOD.DELIVERY_FAC_HW_CODE left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE=c.SALES_PLAN_CODE left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE=tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE='1' left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE=ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE='VE1414' left join(select SALE_PLAN_CODE,MAX(PURCHASE_ORDER_CODE) PURCHASE_ORDER_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE)purchase on purchase.SALE_PLAN_CODE=c.SALES_PLAN_CODE WHERE c.IS_ENABLE='1'"
                    }
                ]
            },
            {
                "case_id": "50",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"50\", \"db_type\": \"sqlserver\", \"description\": \"该SQL查询用于筛选特定的索赔记录（claim），逻辑上包含复杂的`OR`条件关联查询和用于去重的关联子查询。存在的主要性能瓶颈：1. **无输出的JOIN操作**：查询对`serie`表进行了两次LEFT JOIN（分别作为`serie`和`exchange_serie`），但在SELECT列表中并未请求这些表的任何字段，仅用于WHERE子句的过滤。这种写法增加了不必要的连接开销。2. **谓词未下推**：WHERE子句中包含跨表的`OR`逻辑 `(A AND B) OR (C AND D)`，这通常阻止优化器有效地利用索引进行过滤，导致优化器可能选择扫描整个`claim`表后再进行过滤，而不是先通过索引定位。3. **昂贵的关联子查询**：为了保留每个`claim_folder_id`下的最新记录，使用了关联子查询 `c.id = (SELECT MAX(...) ...)`，这会导致对每一行结果都执行一次子查询（N+1问题），在数据量大时性能急剧下降。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE claim (id int PRIMARY KEY, sap_code nvarchar(4000), claim_folder_id int, repair_date datetime, claim_status_id int, is_e2e bit, serie_id int, exchange_serie_id int, serial_number nvarchar(4000), production_code nvarchar(4000), exchange_serial_number nvarchar(4000), exchange_production_code nvarchar(4000));\", \"CREATE TABLE serie (id int PRIMARY KEY, sap_code nvarchar(4000));\", \"CREATE INDEX idx_claim_folder ON claim(claim_folder_id);\", \"CREATE INDEX idx_claim_serial ON claim(serial_number);\", \"CREATE INDEX idx_serie_sap ON serie(sap_code);\"], \"sql\": \"SELECT c.id, \\r\\n   c.sap_code, \\r\\n   c.claim_folder_id, \\r\\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, \\r\\n   c.claim_status_id AS status, \\r\\n   c.is_e2e AS e2e \\r\\nFROM claim c \\r\\nLEFT JOIN serie \\r\\nON serie.id = c.serie_id \\r\\nLEFT JOIN serie exchange_serie \\r\\nON exchange_serie.id = c.exchange_serie_id \\r\\nWHERE ( ((serie.sap_code = @P0 \\r\\nOR serie.sap_code = CONCAT('4000', @P1)) \\r\\nAND c.serial_number = @P2 \\r\\nAND c.production_code = @P3) \\r\\nOR ((exchange_serie.sap_code = @P4 \\r\\nOR exchange_serie.sap_code = CONCAT('4000', @P5)) \\r\\nAND c.exchange_serial_number = @P6 \\r\\nAND c.exchange_production_code = @P7) ) \\r\\nAND (c.serial_number NOT IN (@P8) \\r\\nAND c.production_code NOT IN (@P9, @P10, @P11)) \\r\\nAND c.id = \\r\\n   (\\r\\n   SELECT MAX(c2.id) \\r\\n   FROM claim c2 \\r\\n   WHERE c2.claim_folder_id = c.claim_folder_id \\r\\n   OR (c.claim_folder_id IS NULL \\r\\n  AND c2.id = c.id)\\r\\n   ) \\r\\nORDER BY c.id DESC\\r\\n\\r\\n*/\\r\\n(@P0 nvarchar(4000),@P1 nvarchar(4000),@P2 nvarchar(4000),@P3 nvarchar(4000),@P4 nvarchar(4000),@P5 \\r\\nnvarchar(4000),@P6 nvarchar(4000),@P7 nvarchar(4000),@P8 nvarchar(4000),@P9 nvarchar(4000),@P10  \\r\\nnvarchar(4000),@P11 nvarchar(4000)) \\r\\n/* BEGIN ACTIVE SECTION (comment inserted by DPA) */  \\r\\nSELECT c.id,  \\r\\n   c.sap_code,  \\r\\n   c.claim_folder_id,  \\r\\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF,  \\r\\n   c.claim_status_id AS status,  \\r\\n   c.is_e2e AS e2e  \\r\\nFROM claim c  \\r\\nLEFT JOIN serie  \\r\\nON serie.id = c.serie_id  \\r\\nLEFT JOIN serie exchange_serie  \\r\\nON exchange_serie.id = c.exchange_serie_id  \\r\\nWHERE ( ((serie.sap_code = @P0  \\r\\nOR serie.sap_code = CONCAT('4000', @P1))  \\r\\nAND c.serial_number = @P2  \\r\\nAND c.production_code = @P3)  \\r\\nOR ((exchange_serie.sap_code = @P4  \\r\\nOR exchange_serie.sap_code = CONCAT('4000', @P5))  \\r\\nAND c.exchange_serial_number = @P6  \\r\\nAND c.exchange_production_code = @P7) )  \\r\\nAND (c.serial_number NOT IN (@P8)  \\r\\nAND c.production_code NOT IN (@P9, @P10, @P11))  \\r\\nAND c.id =  \\r\\n   ( \\r\\n   SELECT MAX(c2.id)  \\r\\n   FROM claim c2  \\r\\n   WHERE c2.claim_folder_id = c.claim_folder_id  \\r\\n   OR (c.claim_folder_id IS NULL  \\r\\n  AND c2.id = c.id) \\r\\n   )  \\r\\nORDER BY c.id DESC\", \"explain\": \"  |--Sort(ORDER BY:([c].[id] DESC))\\n       |--Filter(WHERE:([c].[id]=[Expr1009]))\\n            |--Nested Loops(Left Outer Join, WHERE:(... OR ...))\\n                 |--Nested Loops(Left Outer Join, WHERE:(...))\\n                 |    |--Table Scan(OBJECT:([claim] AS [c]), WHERE:([c].[serial_number] NOT IN (@P8) AND [c].[production_code] NOT IN (@P9, @P10, @P11)))\\n                 |    |--Index Seek(OBJECT:([serie] AS [serie]), SEEK:([serie].[id]=[c].[serie_id]))\\n                 |--Index Seek(OBJECT:([serie] AS [exchange_serie]), SEEK:([exchange_serie].[id]=[c].[exchange_serie_id]))\\n            |--Stream Aggregate(DEFINE:([Expr1009]=MAX([c2].[id])))\\n                 |--Index Seek(OBJECT:([claim] AS [c2]), SEEK:([c2].[claim_folder_id]=[c].[claim_folder_id]))\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE claim (id int PRIMARY KEY, sap_code nvarchar(4000), claim_folder_id int, repair_date datetime, claim_status_id int, is_e2e bit, serie_id int, exchange_serie_id int, serial_number nvarchar(4000), production_code nvarchar(4000), exchange_serial_number nvarchar(4000), exchange_production_code nvarchar(4000));\nCREATE TABLE serie (id int PRIMARY KEY, sap_code nvarchar(4000));\nCREATE INDEX idx_claim_folder ON claim(claim_folder_id);\nCREATE INDEX idx_claim_serial ON claim(serial_number);\nCREATE INDEX idx_serie_sap ON serie(sap_code);\n\n## Explain Output in JSON:\n  |--Sort(ORDER BY:([c].[id] DESC))\n       |--Filter(WHERE:([c].[id]=[Expr1009]))\n            |--Nested Loops(Left Outer Join, WHERE:(... OR ...))\n                 |--Nested Loops(Left Outer Join, WHERE:(...))\n                 |    |--Table Scan(OBJECT:([claim] AS [c]), WHERE:([c].[serial_number] NOT IN (@P8) AND [c].[production_code] NOT IN (@P9, @P10, @P11)))\n                 |    |--Index Seek(OBJECT:([serie] AS [serie]), SEEK:([serie].[id]=[c].[serie_id]))\n                 |--Index Seek(OBJECT:([serie] AS [exchange_serie]), SEEK:([exchange_serie].[id]=[c].[exchange_serie_id]))\n            |--Stream Aggregate(DEFINE:([Expr1009]=MAX([c2].[id])))\n                 |--Index Seek(OBJECT:([claim] AS [c2]), SEEK:([c2].[claim_folder_id]=[c].[claim_folder_id]))\n\n## Original SQL:\nSELECT c.id, \r\n   c.sap_code, \r\n   c.claim_folder_id, \r\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, \r\n   c.claim_status_id AS status, \r\n   c.is_e2e AS e2e \r\nFROM claim c \r\nLEFT JOIN serie \r\nON serie.id = c.serie_id \r\nLEFT JOIN serie exchange_serie \r\nON exchange_serie.id = c.exchange_serie_id \r\nWHERE ( ((serie.sap_code = @P0 \r\nOR serie.sap_code = CONCAT('4000', @P1)) \r\nAND c.serial_number = @P2 \r\nAND c.production_code = @P3) \r\nOR ((exchange_serie.sap_code = @P4 \r\nOR exchange_serie.sap_code = CONCAT('4000', @P5)) \r\nAND c.exchange_serial_number = @P6 \r\nAND c.exchange_production_code = @P7) ) \r\nAND (c.serial_number NOT IN (@P8) \r\nAND c.production_code NOT IN (@P9, @P10, @P11)) \r\nAND c.id = \r\n   (\r\n   SELECT MAX(c2.id) \r\n   FROM claim c2 \r\n   WHERE c2.claim_folder_id = c.claim_folder_id \r\n   OR (c.claim_folder_id IS NULL \r\n  AND c2.id = c.id)\r\n   ) \r\nORDER BY c.id DESC\r\n\r\n*/\r\n(@P0 nvarchar(4000),@P1 nvarchar(4000),@P2 nvarchar(4000),@P3 nvarchar(4000),@P4 nvarchar(4000),@P5 \r\nnvarchar(4000),@P6 nvarchar(4000),@P7 nvarchar(4000),@P8 nvarchar(4000),@P9 nvarchar(4000),@P10  \r\nnvarchar(4000),@P11 nvarchar(4000)) \r\n/* BEGIN ACTIVE SECTION (comment inserted by DPA) */  \r\nSELECT c.id,  \r\n   c.sap_code,  \r\n   c.claim_folder_id,  \r\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF,  \r\n   c.claim_status_id AS status,  \r\n   c.is_e2e AS e2e  \r\nFROM claim c  \r\nLEFT JOIN serie  \r\nON serie.id = c.serie_id  \r\nLEFT JOIN serie exchange_serie  \r\nON exchange_serie.id = c.exchange_serie_id  \r\nWHERE ( ((serie.sap_code = @P0  \r\nOR serie.sap_code = CONCAT('4000', @P1))  \r\nAND c.serial_number = @P2  \r\nAND c.production_code = @P3)  \r\nOR ((exchange_serie.sap_code = @P4  \r\nOR exchange_serie.sap_code = CONCAT('4000', @P5))  \r\nAND c.exchange_serial_number = @P6  \r\nAND c.exchange_production_code = @P7) )  \r\nAND (c.serial_number NOT IN (@P8)  \r\nAND c.production_code NOT IN (@P9, @P10, @P11))  \r\nAND c.id =  \r\n   ( \r\n   SELECT MAX(c2.id)  \r\n   FROM claim c2  \r\n   WHERE c2.claim_folder_id = c.claim_folder_id  \r\n   OR (c.claim_folder_id IS NULL  \r\n  AND c2.id = c.id) \r\n   )  \r\nORDER BY c.id DESC\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH ranked_claims AS (SELECT c.*, ROW_NUMBER() OVER (PARTITION BY ISNULL(c.claim_folder_id, c.id) ORDER BY c.id DESC) AS rn FROM claim c WHERE c.serial_number NOT IN (@P8) AND c.production_code NOT IN (@P9, @P10, @P11)) SELECT rc.id, rc.sap_code, rc.claim_folder_id, DATEDIFF(day, rc.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, rc.claim_status_id AS status, rc.is_e2e AS e2e FROM ranked_claims rc LEFT JOIN serie ON serie.id = rc.serie_id LEFT JOIN serie exchange_serie ON exchange_serie.id = rc.exchange_serie_id WHERE rc.rn = 1 AND (((serie.sap_code = @P0 OR serie.sap_code = CONCAT('4000', @P1)) AND rc.serial_number = @P2 AND rc.production_code = @P3) OR ((exchange_serie.sap_code = @P4 OR exchange_serie.sap_code = CONCAT('4000', @P5)) AND rc.exchange_serial_number = @P6 AND rc.exchange_production_code = @P7)) ORDER BY rc.id DESC"
                    }
                ]
            }
        ]
    },
    {
        "indicator_name": "optimization_depth.jsonl",
        "indicator_weight": 2,
        "evaluation_type": "subjective",
        "case_pass_count": 40,
        "case_wrong_count": 54,
        "correct_rate": 0.43,
        "case_datas": [
            {
                "case_id": "1",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"1\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，子查询中存在多余的投影列，这些列在外层查询中没有被使用。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\"], \"sql\": \"SELECT student_name FROM students WHERE student_id IN ( SELECT student_id FROM ( SELECT student_id, gender FROM ( SELECT student_id, gender FROM ( SELECT student_id, gender FROM students ) AS inner_dt2 ) AS inner_dt1 ) AS outer_dt );\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.40\\\"}, \\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\"]}}, {\\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [\\\"test_db_case_1_1748591779.students.student_id\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"using_index\\\": true, \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"2.40\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\"]}}]}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"1\", \"rationale\": \"投影下推：子查询 `SELECT student_id, gender FROM (SELECT student_id, gender FROM students) AS inner_dt2` 中的 `gender` 列在外层 `SELECT student_id FROM outer_dt` 子查询中没有被使用，因此可以移除。同样，更内层的子查询也可以移除冗余的 `gender` 列，以减少IO和网络代价。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"2.40\"}, \"nested_loop\": [{\"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"possible_keys\": [\"PRIMARY\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"student_name\"]}}, {\"table\": {\"table_name\": \"students\", \"access_type\": \"eq_ref\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"4\", \"ref\": [\"test_db_case_1_1748591779.students.student_id\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"using_index\": true, \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"2.40\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\"]}}]}}\n\n## Original SQL:\nSELECT student_name FROM students WHERE student_id IN ( SELECT student_id FROM ( SELECT student_id, gender FROM ( SELECT student_id, gender FROM ( SELECT student_id, gender FROM students ) AS inner_dt2 ) AS inner_dt1 ) AS outer_dt );\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_name FROM students;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "2",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"2\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，其中外部的WHERE子句条件可以下推到最内层的子查询中。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\"], \"sql\": \"SELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM teachers WHERE teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!' ) AS inner_dt1 ) AS inner_dt2 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.40\\\"}, \\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"teacher_id\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_2_1749458126`.`students`.`teacher_id` is not null)\\\"}}, {\\\"table\\\": {\\\"table_name\\\": \\\"teachers\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"teacher_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [\\\"test_db_case_2_1749458126.students.teacher_id\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"2.40\\\", \\\"data_read_per_join\\\": \\\"208\\\"}, \\\"used_columns\\\": [\\\"teacher_id\\\", \\\"teacher_name\\\"], \\\"attached_condition\\\": \\\"((`test_db_case_2_1749458126`.`teachers`.`teacher_name` >= 'Dr. ') and (`test_db_case_2_1749458126`.`teachers`.`teacher_name` < 'Dr.!'))\\\"}}]}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"谓词下推：外部查询的 `WHERE teacher_name LIKE 'Dr. %'` 条件被替换为 `WHERE teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!'`。这个新的范围条件依然可以下推到最内层的子查询 `SELECT teacher_id, teacher_name FROM teachers` 中，从而在数据源处尽早过滤不必要的数据，减少处理量。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"LIKE前缀查询优化：原始SQL文本中存在`LIKE 'Dr.%'`形式的前缀匹配条件，符合`rule0012`的改写流程，可以将其显式改写为`teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!'`的范围查询，以利用索引的有序性。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"2.40\"}, \"nested_loop\": [{\"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"teacher_id\"], \"attached_condition\": \"(`test_db_case_2_1749458126`.`students`.`teacher_id` is not null)\"}}, {\"table\": {\"table_name\": \"teachers\", \"access_type\": \"eq_ref\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"teacher_id\"], \"key_length\": \"4\", \"ref\": [\"test_db_case_2_1749458126.students.teacher_id\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"2.40\", \"data_read_per_join\": \"208\"}, \"used_columns\": [\"teacher_id\", \"teacher_name\"], \"attached_condition\": \"((`test_db_case_2_1749458126`.`teachers`.`teacher_name` >= 'Dr. ') and (`test_db_case_2_1749458126`.`teachers`.`teacher_name` < 'Dr.!'))\"}}]}}\n\n## Original SQL:\nSELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM teachers WHERE teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!' ) AS inner_dt1 ) AS inner_dt2 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT students.teacher_id, teachers.teacher_name FROM students JOIN teachers ON students.teacher_id = teachers.teacher_id WHERE teachers.teacher_name >= 'Dr. ' AND teachers.teacher_name < 'Dr.!'"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "2",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"2\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，其中外部的WHERE子句条件可以下推到最内层的子查询中。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\"], \"sql\": \"SELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM teachers WHERE teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!' ) AS inner_dt1 ) AS inner_dt2 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.40\\\"}, \\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"teacher_id\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_2_1749458126`.`students`.`teacher_id` is not null)\\\"}}, {\\\"table\\\": {\\\"table_name\\\": \\\"teachers\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"teacher_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [\\\"test_db_case_2_1749458126.students.teacher_id\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"2.40\\\", \\\"data_read_per_join\\\": \\\"208\\\"}, \\\"used_columns\\\": [\\\"teacher_id\\\", \\\"teacher_name\\\"], \\\"attached_condition\\\": \\\"((`test_db_case_2_1749458126`.`teachers`.`teacher_name` >= 'Dr. ') and (`test_db_case_2_1749458126`.`teachers`.`teacher_name` < 'Dr.!'))\\\"}}]}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"谓词下推：外部查询的 `WHERE teacher_name LIKE 'Dr. %'` 条件被替换为 `WHERE teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!'`。这个新的范围条件依然可以下推到最内层的子查询 `SELECT teacher_id, teacher_name FROM teachers` 中，从而在数据源处尽早过滤不必要的数据，减少处理量。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"LIKE前缀查询优化：原始SQL文本中存在`LIKE 'Dr.%'`形式的前缀匹配条件，符合`rule0012`的改写流程，可以将其显式改写为`teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!'`的范围查询，以利用索引的有序性。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"2.40\"}, \"nested_loop\": [{\"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"teacher_id\"], \"attached_condition\": \"(`test_db_case_2_1749458126`.`students`.`teacher_id` is not null)\"}}, {\"table\": {\"table_name\": \"teachers\", \"access_type\": \"eq_ref\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"teacher_id\"], \"key_length\": \"4\", \"ref\": [\"test_db_case_2_1749458126.students.teacher_id\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"2.40\", \"data_read_per_join\": \"208\"}, \"used_columns\": [\"teacher_id\", \"teacher_name\"], \"attached_condition\": \"((`test_db_case_2_1749458126`.`teachers`.`teacher_name` >= 'Dr. ') and (`test_db_case_2_1749458126`.`teachers`.`teacher_name` < 'Dr.!'))\"}}]}}\n\n## Original SQL:\nSELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM teachers WHERE teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!' ) AS inner_dt1 ) AS inner_dt2 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT students.teacher_id, teachers.teacher_name FROM students JOIN teachers ON students.teacher_id = teachers.teacher_id WHERE teachers.teacher_name >= 'Dr. ' AND teachers.teacher_name < 'Dr.!'"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "3",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"3\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的JOIN语句，其中外部的WHERE子句条件可以下推到最内层的子查询中，同时存在可以投影下推的冗余列和可以进行LIKE前缀优化的条件。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, major VARCHAR(100), enroll_count INT );\", \"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE, enrollment_year INT );\", \"CREATE TABLE courses ( course_id INT AUTO_INCREMENT PRIMARY KEY, course_name VARCHAR(255) NOT NULL, course_credits INT, department_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department_id INT );\", \"CREATE TABLE departments ( department_id INT AUTO_INCREMENT PRIMARY KEY, department_name VARCHAR(100), location VARCHAR(100) );\"], \"sql\": \"SELECT initial_students.student_id, initial_students.student_name, final_courses.course_name, final_enrollments.enrollment_date, final_teachers.teacher_name FROM (SELECT student_id, student_name, major, enroll_count FROM students WHERE enroll_count > 5) AS initial_students JOIN (SELECT e.student_id, e.course_id, e.enrollment_date FROM enrollments e WHERE e.enrollment_year = 2024) AS final_enrollments ON initial_students.student_id = final_enrollments.student_id JOIN (SELECT course_id, course_name, department_id FROM courses WHERE course_credits >= 3) AS final_courses ON final_enrollments.course_id = final_courses.course_id LEFT JOIN (SELECT t.teacher_id, t.teacher_name FROM teachers t JOIN departments d ON t.department_id = d.department_id WHERE d.location = 'Building A') AS final_teachers ON final_courses.department_id = final_teachers.teacher_id WHERE initial_students.major = 'Physics' AND final_enrollments.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30' AND final_courses.course_name LIKE 'Advanced %';\", \"explain\": \"{\\\"query_block\\\": { \\\"select_id\\\": 1, \\\"cost_info\\\": { \\\"query_cost\\\": \\\"6.00\\\" }, \\\"nested_loop\\\": [ { \\\"table\\\": { \\\"table_name\\\": \\\"e\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"24\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"course_id\\\", \\\"enrollment_date\\\", \\\"enrollment_year\\\" ], \\\"attached_condition\\\": \\\"(((`test_db_case_5_1749718637`.`e`.`enrollment_year` = 2024) and (`test_db_case_5_1749718637`.`e`.`enrollment_date` between '2024-01-01' and '2024-06-30')) and (`test_db_case_5_1749718637`.`e`.`course_id` is not null))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"student_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.e.student_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"2.40\\\", \\\"data_read_per_join\\\": \\\"216\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"student_name\\\", \\\"major\\\", \\\"enroll_count\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_5_1749718637`.`students`.`major` = 'Physics') and (`test_db_case_5_1749718637`.`students`.`enroll_count` > 5))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"courses\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"course_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.e.course_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"3.60\\\", \\\"data_read_per_join\\\": \\\"272\\\" }, \\\"used_columns\\\": [ \\\"course_id\\\", \\\"course_name\\\", \\\"course_credits\\\", \\\"department_id\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_5_1749718637`.`courses`.`course_name` like 'Advanced %') and (`test_db_case_5_1749718637`.`courses`.`course_credits` >= 3))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"t\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"teacher_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.courses.department_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"4.80\\\", \\\"data_read_per_join\\\": \\\"112\\\" }, \\\"used_columns\\\": [ \\\"teacher_id\\\", \\\"teacher_name\\\", \\\"department_id\\\" ] } }, { \\\"table\\\": { \\\"table_name\\\": \\\"d\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"department_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.t.department_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"6.00\\\", \\\"data_read_per_join\\\": \\\"208\\\" }, \\\"used_columns\\\": [ \\\"department_id\\\", \\\"location\\\" ], \\\"attached_condition\\\": \\\"<if>(is_not_null_compl(t..d), (`test_db_case_5_1749718637`.`d`.`location` = 'Building A'), true)\\\" } } ] } }\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"谓词下推：外部查询的 `WHERE initial_students.major = 'Physics'` 条件可以下推到 `initial_students` 子查询的 `students` 表中。同样，`final_enrollments.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30'` 可以下推到 `final_enrollments` 子查询的 `enrollments` 表中。`final_courses.course_name LIKE 'Advanced %'` 可以下推到 `final_courses` 子查询的 `courses` 表中。以及 `final_teachers` 子查询中的 `d.location = 'Building A'` 也是谓词下推的体现。这些下推操作旨在尽早过滤数据，减少处理量。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"LIKE前缀查询优化：`final_courses.course_name LIKE 'Advanced %'` 形式的前缀匹配在下推到 `final_courses` 子查询内部后，可以改写为 `course_name >= 'Advanced ' AND course_name < 'Advancee'`（假设下一个字典序值为'Advancee'）的范围查询，以利用索引的有序性，提升查询性能。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"1\", \"rationale\": \"投影下推：检查各个子查询的投影列，例如 `initial_students` 子查询中的 `enroll_count`，如果它仅用于子查询内部的过滤而未在最终 `SELECT` 列表中或外部关联中使用，则可以从投影中移除。类似地，`final_teachers` 子查询中如果 `teacher_id` 仅用于关联而未在最终SELECT列表中使用，并且 `departments` 表的 `department_name` 和 `location` 仅用于子查询内部过滤，则这些冗余列可以移除，以减少IO和网络代价。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, major VARCHAR(100), enroll_count INT );\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE, enrollment_year INT );\nCREATE TABLE courses ( course_id INT AUTO_INCREMENT PRIMARY KEY, course_name VARCHAR(255) NOT NULL, course_credits INT, department_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department_id INT );\nCREATE TABLE departments ( department_id INT AUTO_INCREMENT PRIMARY KEY, department_name VARCHAR(100), location VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": { \"select_id\": 1, \"cost_info\": { \"query_cost\": \"6.00\" }, \"nested_loop\": [ { \"table\": { \"table_name\": \"e\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"24\" }, \"used_columns\": [ \"student_id\", \"course_id\", \"enrollment_date\", \"enrollment_year\" ], \"attached_condition\": \"(((`test_db_case_5_1749718637`.`e`.`enrollment_year` = 2024) and (`test_db_case_5_1749718637`.`e`.`enrollment_date` between '2024-01-01' and '2024-06-30')) and (`test_db_case_5_1749718637`.`e`.`course_id` is not null))\" } }, { \"table\": { \"table_name\": \"students\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"student_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.e.student_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"2.40\", \"data_read_per_join\": \"216\" }, \"used_columns\": [ \"student_id\", \"student_name\", \"major\", \"enroll_count\" ], \"attached_condition\": \"((`test_db_case_5_1749718637`.`students`.`major` = 'Physics') and (`test_db_case_5_1749718637`.`students`.`enroll_count` > 5))\" } }, { \"table\": { \"table_name\": \"courses\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"course_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.e.course_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"3.60\", \"data_read_per_join\": \"272\" }, \"used_columns\": [ \"course_id\", \"course_name\", \"course_credits\", \"department_id\" ], \"attached_condition\": \"((`test_db_case_5_1749718637`.`courses`.`course_name` like 'Advanced %') and (`test_db_case_5_1749718637`.`courses`.`course_credits` >= 3))\" } }, { \"table\": { \"table_name\": \"t\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"teacher_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.courses.department_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"4.80\", \"data_read_per_join\": \"112\" }, \"used_columns\": [ \"teacher_id\", \"teacher_name\", \"department_id\" ] } }, { \"table\": { \"table_name\": \"d\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"department_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.t.department_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"6.00\", \"data_read_per_join\": \"208\" }, \"used_columns\": [ \"department_id\", \"location\" ], \"attached_condition\": \"<if>(is_not_null_compl(t..d), (`test_db_case_5_1749718637`.`d`.`location` = 'Building A'), true)\" } } ] } }\n\n## Original SQL:\nSELECT initial_students.student_id, initial_students.student_name, final_courses.course_name, final_enrollments.enrollment_date, final_teachers.teacher_name FROM (SELECT student_id, student_name, major, enroll_count FROM students WHERE enroll_count > 5) AS initial_students JOIN (SELECT e.student_id, e.course_id, e.enrollment_date FROM enrollments e WHERE e.enrollment_year = 2024) AS final_enrollments ON initial_students.student_id = final_enrollments.student_id JOIN (SELECT course_id, course_name, department_id FROM courses WHERE course_credits >= 3) AS final_courses ON final_enrollments.course_id = final_courses.course_id LEFT JOIN (SELECT t.teacher_id, t.teacher_name FROM teachers t JOIN departments d ON t.department_id = d.department_id WHERE d.location = 'Building A') AS final_teachers ON final_courses.department_id = final_teachers.teacher_id WHERE initial_students.major = 'Physics' AND final_enrollments.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30' AND final_courses.course_name LIKE 'Advanced %';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT s.student_id, s.student_name, c.course_name, e.enrollment_date, t.teacher_name FROM enrollments e INNER JOIN students s ON e.student_id = s.student_id AND s.major = 'Physics' AND s.enroll_count > 5 INNER JOIN courses c ON e.course_id = c.course_id AND c.course_credits >= 3 AND c.course_name LIKE 'Advanced %' LEFT JOIN teachers t ON c.department_id = t.teacher_id AND EXISTS (SELECT 1 FROM departments WHERE department_id = t.department_id AND location = 'Building A') WHERE e.enrollment_year = 2024 AND e.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30'"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "3",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"3\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的JOIN语句，其中外部的WHERE子句条件可以下推到最内层的子查询中，同时存在可以投影下推的冗余列和可以进行LIKE前缀优化的条件。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, major VARCHAR(100), enroll_count INT );\", \"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE, enrollment_year INT );\", \"CREATE TABLE courses ( course_id INT AUTO_INCREMENT PRIMARY KEY, course_name VARCHAR(255) NOT NULL, course_credits INT, department_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department_id INT );\", \"CREATE TABLE departments ( department_id INT AUTO_INCREMENT PRIMARY KEY, department_name VARCHAR(100), location VARCHAR(100) );\"], \"sql\": \"SELECT initial_students.student_id, initial_students.student_name, final_courses.course_name, final_enrollments.enrollment_date, final_teachers.teacher_name FROM (SELECT student_id, student_name, major, enroll_count FROM students WHERE enroll_count > 5) AS initial_students JOIN (SELECT e.student_id, e.course_id, e.enrollment_date FROM enrollments e WHERE e.enrollment_year = 2024) AS final_enrollments ON initial_students.student_id = final_enrollments.student_id JOIN (SELECT course_id, course_name, department_id FROM courses WHERE course_credits >= 3) AS final_courses ON final_enrollments.course_id = final_courses.course_id LEFT JOIN (SELECT t.teacher_id, t.teacher_name FROM teachers t JOIN departments d ON t.department_id = d.department_id WHERE d.location = 'Building A') AS final_teachers ON final_courses.department_id = final_teachers.teacher_id WHERE initial_students.major = 'Physics' AND final_enrollments.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30' AND final_courses.course_name LIKE 'Advanced %';\", \"explain\": \"{\\\"query_block\\\": { \\\"select_id\\\": 1, \\\"cost_info\\\": { \\\"query_cost\\\": \\\"6.00\\\" }, \\\"nested_loop\\\": [ { \\\"table\\\": { \\\"table_name\\\": \\\"e\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"24\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"course_id\\\", \\\"enrollment_date\\\", \\\"enrollment_year\\\" ], \\\"attached_condition\\\": \\\"(((`test_db_case_5_1749718637`.`e`.`enrollment_year` = 2024) and (`test_db_case_5_1749718637`.`e`.`enrollment_date` between '2024-01-01' and '2024-06-30')) and (`test_db_case_5_1749718637`.`e`.`course_id` is not null))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"student_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.e.student_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"2.40\\\", \\\"data_read_per_join\\\": \\\"216\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"student_name\\\", \\\"major\\\", \\\"enroll_count\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_5_1749718637`.`students`.`major` = 'Physics') and (`test_db_case_5_1749718637`.`students`.`enroll_count` > 5))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"courses\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"course_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.e.course_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"3.60\\\", \\\"data_read_per_join\\\": \\\"272\\\" }, \\\"used_columns\\\": [ \\\"course_id\\\", \\\"course_name\\\", \\\"course_credits\\\", \\\"department_id\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_5_1749718637`.`courses`.`course_name` like 'Advanced %') and (`test_db_case_5_1749718637`.`courses`.`course_credits` >= 3))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"t\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"teacher_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.courses.department_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"4.80\\\", \\\"data_read_per_join\\\": \\\"112\\\" }, \\\"used_columns\\\": [ \\\"teacher_id\\\", \\\"teacher_name\\\", \\\"department_id\\\" ] } }, { \\\"table\\\": { \\\"table_name\\\": \\\"d\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"department_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.t.department_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"6.00\\\", \\\"data_read_per_join\\\": \\\"208\\\" }, \\\"used_columns\\\": [ \\\"department_id\\\", \\\"location\\\" ], \\\"attached_condition\\\": \\\"<if>(is_not_null_compl(t..d), (`test_db_case_5_1749718637`.`d`.`location` = 'Building A'), true)\\\" } } ] } }\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"谓词下推：外部查询的 `WHERE initial_students.major = 'Physics'` 条件可以下推到 `initial_students` 子查询的 `students` 表中。同样，`final_enrollments.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30'` 可以下推到 `final_enrollments` 子查询的 `enrollments` 表中。`final_courses.course_name LIKE 'Advanced %'` 可以下推到 `final_courses` 子查询的 `courses` 表中。以及 `final_teachers` 子查询中的 `d.location = 'Building A'` 也是谓词下推的体现。这些下推操作旨在尽早过滤数据，减少处理量。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"LIKE前缀查询优化：`final_courses.course_name LIKE 'Advanced %'` 形式的前缀匹配在下推到 `final_courses` 子查询内部后，可以改写为 `course_name >= 'Advanced ' AND course_name < 'Advancee'`（假设下一个字典序值为'Advancee'）的范围查询，以利用索引的有序性，提升查询性能。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"1\", \"rationale\": \"投影下推：检查各个子查询的投影列，例如 `initial_students` 子查询中的 `enroll_count`，如果它仅用于子查询内部的过滤而未在最终 `SELECT` 列表中或外部关联中使用，则可以从投影中移除。类似地，`final_teachers` 子查询中如果 `teacher_id` 仅用于关联而未在最终SELECT列表中使用，并且 `departments` 表的 `department_name` 和 `location` 仅用于子查询内部过滤，则这些冗余列可以移除，以减少IO和网络代价。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, major VARCHAR(100), enroll_count INT );\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE, enrollment_year INT );\nCREATE TABLE courses ( course_id INT AUTO_INCREMENT PRIMARY KEY, course_name VARCHAR(255) NOT NULL, course_credits INT, department_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department_id INT );\nCREATE TABLE departments ( department_id INT AUTO_INCREMENT PRIMARY KEY, department_name VARCHAR(100), location VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": { \"select_id\": 1, \"cost_info\": { \"query_cost\": \"6.00\" }, \"nested_loop\": [ { \"table\": { \"table_name\": \"e\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"24\" }, \"used_columns\": [ \"student_id\", \"course_id\", \"enrollment_date\", \"enrollment_year\" ], \"attached_condition\": \"(((`test_db_case_5_1749718637`.`e`.`enrollment_year` = 2024) and (`test_db_case_5_1749718637`.`e`.`enrollment_date` between '2024-01-01' and '2024-06-30')) and (`test_db_case_5_1749718637`.`e`.`course_id` is not null))\" } }, { \"table\": { \"table_name\": \"students\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"student_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.e.student_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"2.40\", \"data_read_per_join\": \"216\" }, \"used_columns\": [ \"student_id\", \"student_name\", \"major\", \"enroll_count\" ], \"attached_condition\": \"((`test_db_case_5_1749718637`.`students`.`major` = 'Physics') and (`test_db_case_5_1749718637`.`students`.`enroll_count` > 5))\" } }, { \"table\": { \"table_name\": \"courses\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"course_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.e.course_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"3.60\", \"data_read_per_join\": \"272\" }, \"used_columns\": [ \"course_id\", \"course_name\", \"course_credits\", \"department_id\" ], \"attached_condition\": \"((`test_db_case_5_1749718637`.`courses`.`course_name` like 'Advanced %') and (`test_db_case_5_1749718637`.`courses`.`course_credits` >= 3))\" } }, { \"table\": { \"table_name\": \"t\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"teacher_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.courses.department_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"4.80\", \"data_read_per_join\": \"112\" }, \"used_columns\": [ \"teacher_id\", \"teacher_name\", \"department_id\" ] } }, { \"table\": { \"table_name\": \"d\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"department_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.t.department_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"6.00\", \"data_read_per_join\": \"208\" }, \"used_columns\": [ \"department_id\", \"location\" ], \"attached_condition\": \"<if>(is_not_null_compl(t..d), (`test_db_case_5_1749718637`.`d`.`location` = 'Building A'), true)\" } } ] } }\n\n## Original SQL:\nSELECT initial_students.student_id, initial_students.student_name, final_courses.course_name, final_enrollments.enrollment_date, final_teachers.teacher_name FROM (SELECT student_id, student_name, major, enroll_count FROM students WHERE enroll_count > 5) AS initial_students JOIN (SELECT e.student_id, e.course_id, e.enrollment_date FROM enrollments e WHERE e.enrollment_year = 2024) AS final_enrollments ON initial_students.student_id = final_enrollments.student_id JOIN (SELECT course_id, course_name, department_id FROM courses WHERE course_credits >= 3) AS final_courses ON final_enrollments.course_id = final_courses.course_id LEFT JOIN (SELECT t.teacher_id, t.teacher_name FROM teachers t JOIN departments d ON t.department_id = d.department_id WHERE d.location = 'Building A') AS final_teachers ON final_courses.department_id = final_teachers.teacher_id WHERE initial_students.major = 'Physics' AND final_enrollments.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30' AND final_courses.course_name LIKE 'Advanced %';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT s.student_id, s.student_name, c.course_name, e.enrollment_date, t.teacher_name FROM enrollments e INNER JOIN students s ON e.student_id = s.student_id AND s.major = 'Physics' AND s.enroll_count > 5 INNER JOIN courses c ON e.course_id = c.course_id AND c.course_credits >= 3 AND c.course_name LIKE 'Advanced %' LEFT JOIN teachers t ON c.department_id = t.teacher_id AND EXISTS (SELECT 1 FROM departments WHERE department_id = t.department_id AND location = 'Building A') WHERE e.enrollment_year = 2024 AND e.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30'"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "3",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"3\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的JOIN语句，其中外部的WHERE子句条件可以下推到最内层的子查询中，同时存在可以投影下推的冗余列和可以进行LIKE前缀优化的条件。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, major VARCHAR(100), enroll_count INT );\", \"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE, enrollment_year INT );\", \"CREATE TABLE courses ( course_id INT AUTO_INCREMENT PRIMARY KEY, course_name VARCHAR(255) NOT NULL, course_credits INT, department_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department_id INT );\", \"CREATE TABLE departments ( department_id INT AUTO_INCREMENT PRIMARY KEY, department_name VARCHAR(100), location VARCHAR(100) );\"], \"sql\": \"SELECT initial_students.student_id, initial_students.student_name, final_courses.course_name, final_enrollments.enrollment_date, final_teachers.teacher_name FROM (SELECT student_id, student_name, major, enroll_count FROM students WHERE enroll_count > 5) AS initial_students JOIN (SELECT e.student_id, e.course_id, e.enrollment_date FROM enrollments e WHERE e.enrollment_year = 2024) AS final_enrollments ON initial_students.student_id = final_enrollments.student_id JOIN (SELECT course_id, course_name, department_id FROM courses WHERE course_credits >= 3) AS final_courses ON final_enrollments.course_id = final_courses.course_id LEFT JOIN (SELECT t.teacher_id, t.teacher_name FROM teachers t JOIN departments d ON t.department_id = d.department_id WHERE d.location = 'Building A') AS final_teachers ON final_courses.department_id = final_teachers.teacher_id WHERE initial_students.major = 'Physics' AND final_enrollments.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30' AND final_courses.course_name LIKE 'Advanced %';\", \"explain\": \"{\\\"query_block\\\": { \\\"select_id\\\": 1, \\\"cost_info\\\": { \\\"query_cost\\\": \\\"6.00\\\" }, \\\"nested_loop\\\": [ { \\\"table\\\": { \\\"table_name\\\": \\\"e\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"24\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"course_id\\\", \\\"enrollment_date\\\", \\\"enrollment_year\\\" ], \\\"attached_condition\\\": \\\"(((`test_db_case_5_1749718637`.`e`.`enrollment_year` = 2024) and (`test_db_case_5_1749718637`.`e`.`enrollment_date` between '2024-01-01' and '2024-06-30')) and (`test_db_case_5_1749718637`.`e`.`course_id` is not null))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"student_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.e.student_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"2.40\\\", \\\"data_read_per_join\\\": \\\"216\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"student_name\\\", \\\"major\\\", \\\"enroll_count\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_5_1749718637`.`students`.`major` = 'Physics') and (`test_db_case_5_1749718637`.`students`.`enroll_count` > 5))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"courses\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"course_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.e.course_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"3.60\\\", \\\"data_read_per_join\\\": \\\"272\\\" }, \\\"used_columns\\\": [ \\\"course_id\\\", \\\"course_name\\\", \\\"course_credits\\\", \\\"department_id\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_5_1749718637`.`courses`.`course_name` like 'Advanced %') and (`test_db_case_5_1749718637`.`courses`.`course_credits` >= 3))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"t\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"teacher_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.courses.department_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"4.80\\\", \\\"data_read_per_join\\\": \\\"112\\\" }, \\\"used_columns\\\": [ \\\"teacher_id\\\", \\\"teacher_name\\\", \\\"department_id\\\" ] } }, { \\\"table\\\": { \\\"table_name\\\": \\\"d\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"department_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.t.department_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"6.00\\\", \\\"data_read_per_join\\\": \\\"208\\\" }, \\\"used_columns\\\": [ \\\"department_id\\\", \\\"location\\\" ], \\\"attached_condition\\\": \\\"<if>(is_not_null_compl(t..d), (`test_db_case_5_1749718637`.`d`.`location` = 'Building A'), true)\\\" } } ] } }\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"谓词下推：外部查询的 `WHERE initial_students.major = 'Physics'` 条件可以下推到 `initial_students` 子查询的 `students` 表中。同样，`final_enrollments.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30'` 可以下推到 `final_enrollments` 子查询的 `enrollments` 表中。`final_courses.course_name LIKE 'Advanced %'` 可以下推到 `final_courses` 子查询的 `courses` 表中。以及 `final_teachers` 子查询中的 `d.location = 'Building A'` 也是谓词下推的体现。这些下推操作旨在尽早过滤数据，减少处理量。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"LIKE前缀查询优化：`final_courses.course_name LIKE 'Advanced %'` 形式的前缀匹配在下推到 `final_courses` 子查询内部后，可以改写为 `course_name >= 'Advanced ' AND course_name < 'Advancee'`（假设下一个字典序值为'Advancee'）的范围查询，以利用索引的有序性，提升查询性能。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"1\", \"rationale\": \"投影下推：检查各个子查询的投影列，例如 `initial_students` 子查询中的 `enroll_count`，如果它仅用于子查询内部的过滤而未在最终 `SELECT` 列表中或外部关联中使用，则可以从投影中移除。类似地，`final_teachers` 子查询中如果 `teacher_id` 仅用于关联而未在最终SELECT列表中使用，并且 `departments` 表的 `department_name` 和 `location` 仅用于子查询内部过滤，则这些冗余列可以移除，以减少IO和网络代价。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, major VARCHAR(100), enroll_count INT );\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE, enrollment_year INT );\nCREATE TABLE courses ( course_id INT AUTO_INCREMENT PRIMARY KEY, course_name VARCHAR(255) NOT NULL, course_credits INT, department_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department_id INT );\nCREATE TABLE departments ( department_id INT AUTO_INCREMENT PRIMARY KEY, department_name VARCHAR(100), location VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": { \"select_id\": 1, \"cost_info\": { \"query_cost\": \"6.00\" }, \"nested_loop\": [ { \"table\": { \"table_name\": \"e\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"24\" }, \"used_columns\": [ \"student_id\", \"course_id\", \"enrollment_date\", \"enrollment_year\" ], \"attached_condition\": \"(((`test_db_case_5_1749718637`.`e`.`enrollment_year` = 2024) and (`test_db_case_5_1749718637`.`e`.`enrollment_date` between '2024-01-01' and '2024-06-30')) and (`test_db_case_5_1749718637`.`e`.`course_id` is not null))\" } }, { \"table\": { \"table_name\": \"students\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"student_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.e.student_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"2.40\", \"data_read_per_join\": \"216\" }, \"used_columns\": [ \"student_id\", \"student_name\", \"major\", \"enroll_count\" ], \"attached_condition\": \"((`test_db_case_5_1749718637`.`students`.`major` = 'Physics') and (`test_db_case_5_1749718637`.`students`.`enroll_count` > 5))\" } }, { \"table\": { \"table_name\": \"courses\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"course_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.e.course_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"3.60\", \"data_read_per_join\": \"272\" }, \"used_columns\": [ \"course_id\", \"course_name\", \"course_credits\", \"department_id\" ], \"attached_condition\": \"((`test_db_case_5_1749718637`.`courses`.`course_name` like 'Advanced %') and (`test_db_case_5_1749718637`.`courses`.`course_credits` >= 3))\" } }, { \"table\": { \"table_name\": \"t\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"teacher_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.courses.department_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"4.80\", \"data_read_per_join\": \"112\" }, \"used_columns\": [ \"teacher_id\", \"teacher_name\", \"department_id\" ] } }, { \"table\": { \"table_name\": \"d\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"department_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.t.department_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"6.00\", \"data_read_per_join\": \"208\" }, \"used_columns\": [ \"department_id\", \"location\" ], \"attached_condition\": \"<if>(is_not_null_compl(t..d), (`test_db_case_5_1749718637`.`d`.`location` = 'Building A'), true)\" } } ] } }\n\n## Original SQL:\nSELECT initial_students.student_id, initial_students.student_name, final_courses.course_name, final_enrollments.enrollment_date, final_teachers.teacher_name FROM (SELECT student_id, student_name, major, enroll_count FROM students WHERE enroll_count > 5) AS initial_students JOIN (SELECT e.student_id, e.course_id, e.enrollment_date FROM enrollments e WHERE e.enrollment_year = 2024) AS final_enrollments ON initial_students.student_id = final_enrollments.student_id JOIN (SELECT course_id, course_name, department_id FROM courses WHERE course_credits >= 3) AS final_courses ON final_enrollments.course_id = final_courses.course_id LEFT JOIN (SELECT t.teacher_id, t.teacher_name FROM teachers t JOIN departments d ON t.department_id = d.department_id WHERE d.location = 'Building A') AS final_teachers ON final_courses.department_id = final_teachers.teacher_id WHERE initial_students.major = 'Physics' AND final_enrollments.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30' AND final_courses.course_name LIKE 'Advanced %';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT s.student_id, s.student_name, c.course_name, e.enrollment_date, t.teacher_name FROM enrollments e INNER JOIN students s ON e.student_id = s.student_id AND s.major = 'Physics' AND s.enroll_count > 5 INNER JOIN courses c ON e.course_id = c.course_id AND c.course_credits >= 3 AND c.course_name LIKE 'Advanced %' LEFT JOIN teachers t ON c.department_id = t.teacher_id AND EXISTS (SELECT 1 FROM departments WHERE department_id = t.department_id AND location = 'Building A') WHERE e.enrollment_year = 2024 AND e.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30'"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "4",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"4\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，子查询中存在多余的投影列，同时内层子查询有ORDER BY和LIMIT，但最外层查询仍可进行投影下推。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\"], \"sql\": \"SELECT s.student_id, s.student_name, s.date_of_birth FROM students s JOIN ( SELECT student_id, gender FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM students ORDER BY student_id DESC ) AS inner_dt3 ) AS inner_dt2 ORDER BY student_id DESC LIMIT 1 ) AS inner_dt1 ) dt ON s.student_id = dt.student_id WHERE dt.gender = 'MALE'\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"message\\\": \\\"no matching row in const table\\\", \\\"table\\\": {\\\"materialized_from_subquery\\\": {\\\"using_temporary_table\\\": true, \\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 3, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"ordering_operation\\\": {\\\"using_filesort\\\": false, \\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"index\\\", \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"gender\\\", \\\"date_of_birth\\\"]}}}}}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"1\", \"rationale\": \"投影下推：子查询 `SELECT student_id, gender FROM (SELECT student_id, gender, date_of_birth FROM inner_dt2 ORDER BY student_id DESC LIMIT 1) AS inner_dt1` 返回了 `gender` 列，但外部 JOIN 仅使用了 `student_id` 进行关联。因此，`gender` 可以从 `inner_dt1` 的投影中移除。同理，更内层的子查询 `inner_dt2` 和 `inner_dt3` 中的 `date_of_birth` 列也未被外层引用，可以进行下推。虽然内层有`ORDER BY`和`LIMIT`，但并不影响投影下推的适用性。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"没有LIMIT的子查询排序消除：仅移除最内层子查询中无LIMIT却存在的ORDER BY子句, 其余层级因包含LIMIT或不含ORDER BY无需改写\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"message\": \"no matching row in const table\", \"table\": {\"materialized_from_subquery\": {\"using_temporary_table\": true, \"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 3, \"cost_info\": {\"query_cost\": \"1.20\"}, \"ordering_operation\": {\"using_filesort\": false, \"table\": {\"table_name\": \"students\", \"access_type\": \"index\", \"key\": \"PRIMARY\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"gender\", \"date_of_birth\"]}}}}}}}\n\n## Original SQL:\nSELECT s.student_id, s.student_name, s.date_of_birth FROM students s JOIN ( SELECT student_id, gender FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM students ORDER BY student_id DESC ) AS inner_dt3 ) AS inner_dt2 ORDER BY student_id DESC LIMIT 1 ) AS inner_dt1 ) dt ON s.student_id = dt.student_id WHERE dt.gender = 'MALE'\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id, student_name, date_of_birth FROM students WHERE gender = 'Male' ORDER BY student_id DESC LIMIT 1"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "4",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"4\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，子查询中存在多余的投影列，同时内层子查询有ORDER BY和LIMIT，但最外层查询仍可进行投影下推。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\"], \"sql\": \"SELECT s.student_id, s.student_name, s.date_of_birth FROM students s JOIN ( SELECT student_id, gender FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM students ORDER BY student_id DESC ) AS inner_dt3 ) AS inner_dt2 ORDER BY student_id DESC LIMIT 1 ) AS inner_dt1 ) dt ON s.student_id = dt.student_id WHERE dt.gender = 'MALE'\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"message\\\": \\\"no matching row in const table\\\", \\\"table\\\": {\\\"materialized_from_subquery\\\": {\\\"using_temporary_table\\\": true, \\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 3, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"ordering_operation\\\": {\\\"using_filesort\\\": false, \\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"index\\\", \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"gender\\\", \\\"date_of_birth\\\"]}}}}}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"1\", \"rationale\": \"投影下推：子查询 `SELECT student_id, gender FROM (SELECT student_id, gender, date_of_birth FROM inner_dt2 ORDER BY student_id DESC LIMIT 1) AS inner_dt1` 返回了 `gender` 列，但外部 JOIN 仅使用了 `student_id` 进行关联。因此，`gender` 可以从 `inner_dt1` 的投影中移除。同理，更内层的子查询 `inner_dt2` 和 `inner_dt3` 中的 `date_of_birth` 列也未被外层引用，可以进行下推。虽然内层有`ORDER BY`和`LIMIT`，但并不影响投影下推的适用性。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"没有LIMIT的子查询排序消除：仅移除最内层子查询中无LIMIT却存在的ORDER BY子句, 其余层级因包含LIMIT或不含ORDER BY无需改写\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"message\": \"no matching row in const table\", \"table\": {\"materialized_from_subquery\": {\"using_temporary_table\": true, \"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 3, \"cost_info\": {\"query_cost\": \"1.20\"}, \"ordering_operation\": {\"using_filesort\": false, \"table\": {\"table_name\": \"students\", \"access_type\": \"index\", \"key\": \"PRIMARY\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"gender\", \"date_of_birth\"]}}}}}}}\n\n## Original SQL:\nSELECT s.student_id, s.student_name, s.date_of_birth FROM students s JOIN ( SELECT student_id, gender FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM students ORDER BY student_id DESC ) AS inner_dt3 ) AS inner_dt2 ORDER BY student_id DESC LIMIT 1 ) AS inner_dt1 ) dt ON s.student_id = dt.student_id WHERE dt.gender = 'MALE'\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id, student_name, date_of_birth FROM students WHERE gender = 'Male' ORDER BY student_id DESC LIMIT 1"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "5",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"5\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的JOIN语句，其中外部的WHERE子句条件可以下推到最内层的子查询中，同时存在可以投影下推的冗余列和可以进行LIKE前缀优化的条件。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\"], \"sql\": \"SELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM teachers ) AS inner_dt1 ) AS inner_dt2 ) AS inner_dt3 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id WHERE outer_dt.teacher_name LIKE 'Dr. %';\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.40\\\"},\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"students\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"teacher_id\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"teachers\\\",\\\"access_type\\\": \\\"eq_ref\\\",\\\"possible_keys\\\": [\\\"PRIMARY\\\"],\\\"key\\\": \\\"PRIMARY\\\",\\\"used_key_parts\\\": [\\\"teacher_id\\\"],\\\"key_length\\\": \\\"4\\\",\\\"ref\\\": [\\\"test_db_case_5_1749537373.students.teacher_id\\\"],\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"208\\\"},\\\"used_columns\\\": [\\\"teacher_id\\\",\\\"teacher_name\\\",\\\"department\\\"],\\\"attached_condition\\\": \\\"(`test_db_case_5_1749537373`.`teachers`.`teacher_name` LIKE 'Dr. %')\\\"}}]}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"谓词下推：外部查询的 `WHERE outer_dt.teacher_name LIKE 'Dr. %'` 条件可以下推到最内层的 `teachers` 表，从而在数据源处尽早过滤不必要的数据，减少处理量。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"LIKE前缀查询优化：`WHERE outer_dt.teacher_name LIKE 'Dr. %'` 形式的前缀匹配可以改写为 `outer_dt.teacher_name >= 'Dr. ' AND outer_dt.teacher_name < 'Ds.'`（假设下一个字典序值为'Ds.'）的范围查询，以利用索引的有序性，提升查询性能。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"1\", \"rationale\": \"投影下推：子查询 `SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM teachers ) AS inner_dt1 ) AS inner_dt2` 中的 `department` 列在外层 `SELECT teacher_id, teacher_name FROM inner_dt3` 子查询中没有被使用，因此可以移除。同样，更内层的子查询也可以移除冗余的 `department` 列，以减少IO和网络代价。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"2.40\"},\"nested_loop\": [{\"table\": {\"table_name\": \"students\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"teacher_id\"]}},{\"table\": {\"table_name\": \"teachers\",\"access_type\": \"eq_ref\",\"possible_keys\": [\"PRIMARY\"],\"key\": \"PRIMARY\",\"used_key_parts\": [\"teacher_id\"],\"key_length\": \"4\",\"ref\": [\"test_db_case_5_1749537373.students.teacher_id\"],\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"208\"},\"used_columns\": [\"teacher_id\",\"teacher_name\",\"department\"],\"attached_condition\": \"(`test_db_case_5_1749537373`.`teachers`.`teacher_name` LIKE 'Dr. %')\"}}]}}}\n\n## Original SQL:\nSELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM teachers ) AS inner_dt1 ) AS inner_dt2 ) AS inner_dt3 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id WHERE outer_dt.teacher_name LIKE 'Dr. %';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT t.teacher_id, t.teacher_name FROM students JOIN teachers t ON students.teacher_id = t.teacher_id WHERE t.teacher_name LIKE 'Dr. %'"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "5",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"5\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的JOIN语句，其中外部的WHERE子句条件可以下推到最内层的子查询中，同时存在可以投影下推的冗余列和可以进行LIKE前缀优化的条件。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\"], \"sql\": \"SELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM teachers ) AS inner_dt1 ) AS inner_dt2 ) AS inner_dt3 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id WHERE outer_dt.teacher_name LIKE 'Dr. %';\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.40\\\"},\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"students\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"teacher_id\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"teachers\\\",\\\"access_type\\\": \\\"eq_ref\\\",\\\"possible_keys\\\": [\\\"PRIMARY\\\"],\\\"key\\\": \\\"PRIMARY\\\",\\\"used_key_parts\\\": [\\\"teacher_id\\\"],\\\"key_length\\\": \\\"4\\\",\\\"ref\\\": [\\\"test_db_case_5_1749537373.students.teacher_id\\\"],\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"208\\\"},\\\"used_columns\\\": [\\\"teacher_id\\\",\\\"teacher_name\\\",\\\"department\\\"],\\\"attached_condition\\\": \\\"(`test_db_case_5_1749537373`.`teachers`.`teacher_name` LIKE 'Dr. %')\\\"}}]}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"谓词下推：外部查询的 `WHERE outer_dt.teacher_name LIKE 'Dr. %'` 条件可以下推到最内层的 `teachers` 表，从而在数据源处尽早过滤不必要的数据，减少处理量。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"LIKE前缀查询优化：`WHERE outer_dt.teacher_name LIKE 'Dr. %'` 形式的前缀匹配可以改写为 `outer_dt.teacher_name >= 'Dr. ' AND outer_dt.teacher_name < 'Ds.'`（假设下一个字典序值为'Ds.'）的范围查询，以利用索引的有序性，提升查询性能。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"1\", \"rationale\": \"投影下推：子查询 `SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM teachers ) AS inner_dt1 ) AS inner_dt2` 中的 `department` 列在外层 `SELECT teacher_id, teacher_name FROM inner_dt3` 子查询中没有被使用，因此可以移除。同样，更内层的子查询也可以移除冗余的 `department` 列，以减少IO和网络代价。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"2.40\"},\"nested_loop\": [{\"table\": {\"table_name\": \"students\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"teacher_id\"]}},{\"table\": {\"table_name\": \"teachers\",\"access_type\": \"eq_ref\",\"possible_keys\": [\"PRIMARY\"],\"key\": \"PRIMARY\",\"used_key_parts\": [\"teacher_id\"],\"key_length\": \"4\",\"ref\": [\"test_db_case_5_1749537373.students.teacher_id\"],\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"208\"},\"used_columns\": [\"teacher_id\",\"teacher_name\",\"department\"],\"attached_condition\": \"(`test_db_case_5_1749537373`.`teachers`.`teacher_name` LIKE 'Dr. %')\"}}]}}}\n\n## Original SQL:\nSELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM teachers ) AS inner_dt1 ) AS inner_dt2 ) AS inner_dt3 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id WHERE outer_dt.teacher_name LIKE 'Dr. %';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT t.teacher_id, t.teacher_name FROM students JOIN teachers t ON students.teacher_id = t.teacher_id WHERE t.teacher_name LIKE 'Dr. %'"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "5",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"5\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的JOIN语句，其中外部的WHERE子句条件可以下推到最内层的子查询中，同时存在可以投影下推的冗余列和可以进行LIKE前缀优化的条件。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\"], \"sql\": \"SELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM teachers ) AS inner_dt1 ) AS inner_dt2 ) AS inner_dt3 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id WHERE outer_dt.teacher_name LIKE 'Dr. %';\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.40\\\"},\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"students\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"teacher_id\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"teachers\\\",\\\"access_type\\\": \\\"eq_ref\\\",\\\"possible_keys\\\": [\\\"PRIMARY\\\"],\\\"key\\\": \\\"PRIMARY\\\",\\\"used_key_parts\\\": [\\\"teacher_id\\\"],\\\"key_length\\\": \\\"4\\\",\\\"ref\\\": [\\\"test_db_case_5_1749537373.students.teacher_id\\\"],\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"208\\\"},\\\"used_columns\\\": [\\\"teacher_id\\\",\\\"teacher_name\\\",\\\"department\\\"],\\\"attached_condition\\\": \\\"(`test_db_case_5_1749537373`.`teachers`.`teacher_name` LIKE 'Dr. %')\\\"}}]}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"谓词下推：外部查询的 `WHERE outer_dt.teacher_name LIKE 'Dr. %'` 条件可以下推到最内层的 `teachers` 表，从而在数据源处尽早过滤不必要的数据，减少处理量。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"LIKE前缀查询优化：`WHERE outer_dt.teacher_name LIKE 'Dr. %'` 形式的前缀匹配可以改写为 `outer_dt.teacher_name >= 'Dr. ' AND outer_dt.teacher_name < 'Ds.'`（假设下一个字典序值为'Ds.'）的范围查询，以利用索引的有序性，提升查询性能。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"1\", \"rationale\": \"投影下推：子查询 `SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM teachers ) AS inner_dt1 ) AS inner_dt2` 中的 `department` 列在外层 `SELECT teacher_id, teacher_name FROM inner_dt3` 子查询中没有被使用，因此可以移除。同样，更内层的子查询也可以移除冗余的 `department` 列，以减少IO和网络代价。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"2.40\"},\"nested_loop\": [{\"table\": {\"table_name\": \"students\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"teacher_id\"]}},{\"table\": {\"table_name\": \"teachers\",\"access_type\": \"eq_ref\",\"possible_keys\": [\"PRIMARY\"],\"key\": \"PRIMARY\",\"used_key_parts\": [\"teacher_id\"],\"key_length\": \"4\",\"ref\": [\"test_db_case_5_1749537373.students.teacher_id\"],\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"208\"},\"used_columns\": [\"teacher_id\",\"teacher_name\",\"department\"],\"attached_condition\": \"(`test_db_case_5_1749537373`.`teachers`.`teacher_name` LIKE 'Dr. %')\"}}]}}}\n\n## Original SQL:\nSELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM teachers ) AS inner_dt1 ) AS inner_dt2 ) AS inner_dt3 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id WHERE outer_dt.teacher_name LIKE 'Dr. %';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT t.teacher_id, t.teacher_name FROM students JOIN teachers t ON students.teacher_id = t.teacher_id WHERE t.teacher_name LIKE 'Dr. %'"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "6",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"6\", \"db_type\": \"mysql\", \"description\": \"一个简单的SELECT语句，其中WHERE子句对字段使用了函数，导致隐式转换。\", \"create_table_statements\": [\"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT student_id, CONCAT(\\\"id_\\\", student_id) as student_id2 FROM enrollments WHERE CONCAT(\\\"id_\\\", student_id) >= \\\"id_1000\\\" LIMIT 10;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"enrollments\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"24\\\"}, \\\"used_columns\\\": [\\\"student_id\\\"], \\\"attached_condition\\\": \\\"(concat('id_',`test_db_case_6_1748591779`.`enrollments`.`student_id`) >= 'id_1000')\\\"}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"1\", \"rationale\": \"隐式转换：WHERE子句中的 `CONCAT(\\\"id_\\\", student_id) >= \\\"id_1000\\\"` 对字段 `student_id` 使用了 `CONCAT` 函数。这可能导致无法有效使用索引。虽然无法直接消除`CONCAT`函数并保持等价，但此处旨在识别字段上使用了函数的场景。在某些情况下，如果可以推导出等价的条件，例如`student_id >= 1000`，则可以消除函数以利用索引。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"enrollments\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"24\"}, \"used_columns\": [\"student_id\"], \"attached_condition\": \"(concat('id_',`test_db_case_6_1748591779`.`enrollments`.`student_id`) >= 'id_1000')\"}}}\n\n## Original SQL:\nSELECT student_id, CONCAT(\"id_\", student_id) as student_id2 FROM enrollments WHERE CONCAT(\"id_\", student_id) >= \"id_1000\" LIMIT 10;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id, CONCAT(\"id_\", student_id) as student_id2 FROM enrollments WHERE student_id >= 1000 LIMIT 10;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "7",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"7\", \"db_type\": \"mysql\", \"description\": \"一个包含COUNT标量子查询的SELECT语句，可以将其改写为IN子查询以利用SEMI JOIN特性。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) );\", \"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT * FROM students WHERE NOT ( SELECT count(*) FROM enrollments WHERE students.student_id = enrollments.student_id AND enrollment_id > 1000 ) > 0;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\"], \\\"attached_condition\\\": \\\"((/* select#2 */ select count(0) from `test_db_case_7_1748591779`.`enrollments` where ((`test_db_case_7_1748591779`.`students`.`student_id` = `test_db_case_7_1748591779`.`enrollments`.`student_id`) and (`test_db_case_7_1748591779`.`enrollment_id` > 1000))) <= 0)\\\", \\\"attached_subqueries\\\": [{\\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.41\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"enrollments\\\", \\\"access_type\\\": \\\"range\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"enrollment_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.21\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.41\\\", \\\"data_read_per_join\\\": \\\"24\\\"}, \\\"used_columns\\\": [\\\"enrollment_id\\\", \\\"student_id\\\"], \\\"attached_condition\\\": \\\"((`test_db_case_7_1748591779`.`students`.`student_id` = `test_db_case_7_1748591779`.`enrollments`.`student_id`) and (`test_db_case_7_1748591779`.`enrollment_id` > 1000))\\\"}}}]}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"COUNT 标量子查询优化：子查询 `SELECT count(*) FROM enrollments WHERE students.student_id = enrollments.student_id AND enrollment_id > 1000` 是一个关联子查询，且其内部没有 `GROUP BY`、`LIMIT`、`UNION` 等，并且外部对其结果进行了 `> 0` 的存在性判断。这满足了COUNT标量子查询的定义。由于外部条件是 `NOT (...) > 0`，这意味着 `COUNT(*) <= 0`，即不存在匹配记录。因此，可以将其改写为 `NOT IN` 的形式，以利用MySQL的SEMI JOIN特性，提高查询性能。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) );\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"student_name\"], \"attached_condition\": \"((/* select#2 */ select count(0) from `test_db_case_7_1748591779`.`enrollments` where ((`test_db_case_7_1748591779`.`students`.`student_id` = `test_db_case_7_1748591779`.`enrollments`.`student_id`) and (`test_db_case_7_1748591779`.`enrollment_id` > 1000))) <= 0)\", \"attached_subqueries\": [{\"dependent\": true, \"cacheable\": false, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.41\"}, \"table\": {\"table_name\": \"enrollments\", \"access_type\": \"range\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"enrollment_id\"], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.21\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.41\", \"data_read_per_join\": \"24\"}, \"used_columns\": [\"enrollment_id\", \"student_id\"], \"attached_condition\": \"((`test_db_case_7_1748591779`.`students`.`student_id` = `test_db_case_7_1748591779`.`enrollments`.`student_id`) and (`test_db_case_7_1748591779`.`enrollment_id` > 1000))\"}}}]}}\n\n## Original SQL:\nSELECT * FROM students WHERE NOT ( SELECT count(*) FROM enrollments WHERE students.student_id = enrollments.student_id AND enrollment_id > 1000 ) > 0;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM students WHERE NOT EXISTS (SELECT 1 FROM enrollments WHERE students.student_id = enrollments.student_id AND enrollment_id > 1000)"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "8",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"8\", \"db_type\": \"mysql\", \"description\": \"一个包含HAVING子句的SELECT语句，其中HAVING条件不依赖聚合函数，可以下推到WHERE子句。\", \"create_table_statements\": [\"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE enrollment_date > '1993-11-26' OR enrollment_date < '1991-11-26' GROUP BY student_id HAVING student_id = 1999\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.20\\\"},\\\"grouping_operation\\\": {\\\"using_temporary_table\\\": true,\\\"using_filesort\\\": true,\\\"cost_info\\\": {\\\"sort_cost\\\": \\\"1.00\\\"},\\\"table\\\": {\\\"table_name\\\": \\\"enrollments\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"24\\\"},\\\"used_columns\\\": [\\\"enrollment_id\\\",\\\"student_id\\\",\\\"enrollment_date\\\"],\\\"attached_condition\\\": \\\"((`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` > '1993-11-26') or (`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` < '1991-11-26'))\\\"}}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"HAVING 条件下推：`HAVING student_id = 1999` 这个条件不依赖于任何聚合函数。将这个条件从 `HAVING` 子句移动到 `WHERE` 子句中，可以在分组和聚合操作之前过滤数据，从而减少处理的数据量，提高查询性能。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"隐式转换：WHERE子句中的 `enrollment_date > '1993-11-26'` 和 `enrollment_date < '1991-11-26'` 存在隐式类型转换，因为 `enrollment_date` 字段类型为 `DATE` 而 '1993-11-26' 和 '1991-11-26' 是字符串。这可能导致索引失效，可以通过显式转换值来解决。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"2.20\"},\"grouping_operation\": {\"using_temporary_table\": true,\"using_filesort\": true,\"cost_info\": {\"sort_cost\": \"1.00\"},\"table\": {\"table_name\": \"enrollments\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"24\"},\"used_columns\": [\"enrollment_id\",\"student_id\",\"enrollment_date\"],\"attached_condition\": \"((`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` > '1993-11-26') or (`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` < '1991-11-26'))\"}}}}\n\n## Original SQL:\nSELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE enrollment_date > '1993-11-26' OR enrollment_date < '1991-11-26' GROUP BY student_id HAVING student_id = 1999\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE student_id = 1999 AND (enrollment_date > '1993-11-26' OR enrollment_date < '1991-11-26') GROUP BY student_id"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "8",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"8\", \"db_type\": \"mysql\", \"description\": \"一个包含HAVING子句的SELECT语句，其中HAVING条件不依赖聚合函数，可以下推到WHERE子句。\", \"create_table_statements\": [\"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE enrollment_date > '1993-11-26' OR enrollment_date < '1991-11-26' GROUP BY student_id HAVING student_id = 1999\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.20\\\"},\\\"grouping_operation\\\": {\\\"using_temporary_table\\\": true,\\\"using_filesort\\\": true,\\\"cost_info\\\": {\\\"sort_cost\\\": \\\"1.00\\\"},\\\"table\\\": {\\\"table_name\\\": \\\"enrollments\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"24\\\"},\\\"used_columns\\\": [\\\"enrollment_id\\\",\\\"student_id\\\",\\\"enrollment_date\\\"],\\\"attached_condition\\\": \\\"((`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` > '1993-11-26') or (`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` < '1991-11-26'))\\\"}}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"HAVING 条件下推：`HAVING student_id = 1999` 这个条件不依赖于任何聚合函数。将这个条件从 `HAVING` 子句移动到 `WHERE` 子句中，可以在分组和聚合操作之前过滤数据，从而减少处理的数据量，提高查询性能。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"隐式转换：WHERE子句中的 `enrollment_date > '1993-11-26'` 和 `enrollment_date < '1991-11-26'` 存在隐式类型转换，因为 `enrollment_date` 字段类型为 `DATE` 而 '1993-11-26' 和 '1991-11-26' 是字符串。这可能导致索引失效，可以通过显式转换值来解决。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"2.20\"},\"grouping_operation\": {\"using_temporary_table\": true,\"using_filesort\": true,\"cost_info\": {\"sort_cost\": \"1.00\"},\"table\": {\"table_name\": \"enrollments\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"24\"},\"used_columns\": [\"enrollment_id\",\"student_id\",\"enrollment_date\"],\"attached_condition\": \"((`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` > '1993-11-26') or (`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` < '1991-11-26'))\"}}}}\n\n## Original SQL:\nSELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE enrollment_date > '1993-11-26' OR enrollment_date < '1991-11-26' GROUP BY student_id HAVING student_id = 1999\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE student_id = 1999 AND (enrollment_date > '1993-11-26' OR enrollment_date < '1991-11-26') GROUP BY student_id"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "9",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"9\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，最内层的GROUP BY子句是不必要的，可以被消除。\", \"sql\": \"SELECT student_id FROM students s WHERE EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id) AND s.gender = 'Female' AND s.date_of_birth <= CAST('2000-01-01' AS DATE) AND s.student_name != '张凯' GROUP BY student_id LIMIT 10;\", \"create_table_statements\": [\"CREATE TABLE students (student_id INT PRIMARY KEY, student_name VARCHAR(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL, gender VARCHAR(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci, date_of_birth DATE) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\", \"CREATE TABLE enrollments (enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, enrollment_date DATE, FOREIGN KEY (student_id) REFERENCES students(student_id)) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\"], \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"grouping_operation\\\": {\\\"using_filesort\\\": false, \\\"table\\\": {\\\"table_name\\\": \\\"s\\\", \\\"access_type\\\": \\\"index\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"1K\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\", \\\"gender\\\", \\\"date_of_birth\\\"], \\\"attached_condition\\\": \\\"(exists(/* select#2 */ select 1 from `test_db_case_9_1749465373`.`enrollments` `e` where (`test_db_case_9_1749465373`.`e`.`student_id` = `test_db_case_9_1749465373`.`s`.`student_id`)) and (`test_db_case_9_1749465373`.`s`.`gender` = 'Female') and (`test_db_case_9_1749465373`.`s`.`date_of_birth` <= <cache>(cast('2000-01-01' as date))) and (`test_db_case_9_1749465373`.`s`.`student_name` <> '张凯'))\\\", \\\"attached_subqueries\\\": [{\\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"e\\\", \\\"access_type\\\": \\\"ref\\\", \\\"possible_keys\\\": [\\\"student_id\\\"], \\\"key\\\": \\\"student_id\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"5\\\", \\\"ref\\\": [\\\"test_db_case_9_1749465373.s.student_id\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"using_index\\\": true, \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"24\\\"}, \\\"used_columns\\\": [\\\"student_id\\\"]}}}]}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"1\", \"rationale\": \"GROUP BY 子句消除：主查询的 `GROUP BY student_id` 是不必要的。因为 `student_id` 是 `students` 表的主键，其列值是唯一的，并且在该 `SELECT` 语句的投影中没有使用聚合函数。因此可以消除这个 `GROUP BY` 子句，减少排序和分组的开销，提高查询性能。此外，`EXISTS` 子查询可以转换为 `INNER JOIN` 来优化查询。隐式转换已通过 `CAST` 显式转换日期字符串消除。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students (student_id INT PRIMARY KEY, student_name VARCHAR(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL, gender VARCHAR(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci, date_of_birth DATE) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\nCREATE TABLE enrollments (enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, enrollment_date DATE, FOREIGN KEY (student_id) REFERENCES students(student_id)) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"1.20\"}, \"grouping_operation\": {\"using_filesort\": false, \"table\": {\"table_name\": \"s\", \"access_type\": \"index\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"1K\"}, \"used_columns\": [\"student_id\", \"student_name\", \"gender\", \"date_of_birth\"], \"attached_condition\": \"(exists(/* select#2 */ select 1 from `test_db_case_9_1749465373`.`enrollments` `e` where (`test_db_case_9_1749465373`.`e`.`student_id` = `test_db_case_9_1749465373`.`s`.`student_id`)) and (`test_db_case_9_1749465373`.`s`.`gender` = 'Female') and (`test_db_case_9_1749465373`.`s`.`date_of_birth` <= <cache>(cast('2000-01-01' as date))) and (`test_db_case_9_1749465373`.`s`.`student_name` <> '张凯'))\", \"attached_subqueries\": [{\"dependent\": true, \"cacheable\": false, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"e\", \"access_type\": \"ref\", \"possible_keys\": [\"student_id\"], \"key\": \"student_id\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"5\", \"ref\": [\"test_db_case_9_1749465373.s.student_id\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"using_index\": true, \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"24\"}, \"used_columns\": [\"student_id\"]}}}]}}}\n\n## Original SQL:\nSELECT student_id FROM students s WHERE EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id) AND s.gender = 'Female' AND s.date_of_birth <= CAST('2000-01-01' AS DATE) AND s.student_name != '张凯' GROUP BY student_id LIMIT 10;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id FROM students s WHERE EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id) AND s.gender = 'Female' AND s.date_of_birth <= '2000-01-01' AND s.student_name != '张凯' LIMIT 10;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "10",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"10\", \"db_type\": \"mysql\", \"description\": \"一个包含非关联子查询的SELECT语句，可以将子查询转换为关联子查询。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) );\", \"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT );\"], \"sql\": \"SELECT * FROM students WHERE student_id IN ( SELECT student_id FROM enrollments AS inner_dt );\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"4.80\\\"}, \\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"<subquery2>\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"materialized_from_subquery\\\": {\\\"using_temporary_table\\\": true, \\\"query_block\\\": {\\\"table\\\": {\\\"table_name\\\": \\\"inner_dt\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"16\\\"}, \\\"used_columns\\\": [\\\"student_id\\\"]}}}}}, {\\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [\\\"<subquery2>.student_id\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"4.80\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\"]}}]}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"非关联子查询优化：`WHERE student_id IN (SELECT student_id FROM enrollments)` 是一个非关联子查询。由于 `students` 表和 `enrollments` 表都包含 `student_id` 字段，可以建立关联条件。通过将外部查询的 `student_id` 关联到子查询的 `student_id`，将其改写为关联子查询，可以减少重复计算，提升查询性能。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) );\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"4.80\"}, \"nested_loop\": [{\"table\": {\"table_name\": \"<subquery2>\", \"access_type\": \"ALL\", \"materialized_from_subquery\": {\"using_temporary_table\": true, \"query_block\": {\"table\": {\"table_name\": \"inner_dt\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"16\"}, \"used_columns\": [\"student_id\"]}}}}}, {\"table\": {\"table_name\": \"students\", \"access_type\": \"eq_ref\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"4\", \"ref\": [\"<subquery2>.student_id\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"4.80\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"student_name\"]}}]}}\n\n## Original SQL:\nSELECT * FROM students WHERE student_id IN ( SELECT student_id FROM enrollments AS inner_dt );\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT s.* FROM students s WHERE EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id);"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "11",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"11\", \"db_type\": \"mysql\", \"description\": \"一个包含多个ROW_NUMBER()窗口函数和过滤条件的SELECT语句\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), date_of_birth DATE );\"], \"sql\": \"SELECT T1.student_name, T1.date_of_birth FROM students AS T1 WHERE (SELECT COUNT(*) FROM students AS T2 WHERE T2.student_name <= T1.student_name) <= 3 AND (SELECT COUNT(*) FROM students AS T3 WHERE T3.date_of_birth <= T1.date_of_birth) <= 2 ORDER BY T1.student_name, T1.date_of_birth;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.20\\\"}, \\\"ordering_operation\\\": {\\\"using_filesort\\\": true, \\\"cost_info\\\": {\\\"sort_cost\\\": \\\"1.00\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"T1\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\", \\\"date_of_birth\\\"], \\\"attached_condition\\\": \\\"(((/* select#2 */ select count(0) from `test_db_case_11_1748591779`.`students` `T2` where (`test_db_case_11_1748591779`.`T2`.`student_name` <= `test_db_case_11_1748591779`.`T1`.`student_name`)) <= 3) and ((/* select#3 */ select count(0) from `test_db_case_11_1748591779`.`students` `T3` where (`test_db_case_11_1748591779`.`T3`.`date_of_birth` <= `test_db_case_11_1748591779`.`T1`.`date_of_birth`)) <= 2))\\\", \\\"attached_subqueries\\\": [{\\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": {\\\"select_id\\\": 3, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"T3\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"date_of_birth\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_11_1748591779`.`T3`.`date_of_birth` <= `test_db_case_11_1748591779`.`T1`.`date_of_birth`)\\\"}}}, {\\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"T2\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_name\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_11_1748591779`.`T2`.`student_name` <= `test_db_case_11_1748591779`.`T1`.`student_name`)\\\"}}}]}}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"子查询聚合改写为窗口函数：存在子查询聚合`COUNT(*)`，且存在自连接，内表和外表都是`students`表，且通过`student_name`和`date_of_birth`字段进行等值关联。这些子查询可以改写为窗口函数`COUNT(*) OVER (PARTITION BY student_name ORDER BY student_name)`和`COUNT(*) OVER (PARTITION BY date_of_birth ORDER BY date_of_birth)`，以提升查询性能。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), date_of_birth DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"2.20\"}, \"ordering_operation\": {\"using_filesort\": true, \"cost_info\": {\"sort_cost\": \"1.00\"}, \"table\": {\"table_name\": \"T1\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"student_name\", \"date_of_birth\"], \"attached_condition\": \"(((/* select#2 */ select count(0) from `test_db_case_11_1748591779`.`students` `T2` where (`test_db_case_11_1748591779`.`T2`.`student_name` <= `test_db_case_11_1748591779`.`T1`.`student_name`)) <= 3) and ((/* select#3 */ select count(0) from `test_db_case_11_1748591779`.`students` `T3` where (`test_db_case_11_1748591779`.`T3`.`date_of_birth` <= `test_db_case_11_1748591779`.`T1`.`date_of_birth`)) <= 2))\", \"attached_subqueries\": [{\"dependent\": true, \"cacheable\": false, \"query_block\": {\"select_id\": 3, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"T3\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"date_of_birth\"], \"attached_condition\": \"(`test_db_case_11_1748591779`.`T3`.`date_of_birth` <= `test_db_case_11_1748591779`.`T1`.`date_of_birth`)\"}}}, {\"dependent\": true, \"cacheable\": false, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"T2\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_name\"], \"attached_condition\": \"(`test_db_case_11_1748591779`.`T2`.`student_name` <= `test_db_case_11_1748591779`.`T1`.`student_name`)\"}}}]}}}}\n\n## Original SQL:\nSELECT T1.student_name, T1.date_of_birth FROM students AS T1 WHERE (SELECT COUNT(*) FROM students AS T2 WHERE T2.student_name <= T1.student_name) <= 3 AND (SELECT COUNT(*) FROM students AS T3 WHERE T3.date_of_birth <= T1.date_of_birth) <= 2 ORDER BY T1.student_name, T1.date_of_birth;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_name, date_of_birth FROM (SELECT student_name, date_of_birth, COUNT(*) OVER (ORDER BY student_name RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as name_count, COUNT(*) OVER (ORDER BY date_of_birth RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as dob_count FROM students) t WHERE name_count <= 3 AND dob_count <= 2 ORDER BY student_name, date_of_birth;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "12",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"12\", \"db_type\": \"mysql\", \"description\": \"一个包含UNION的SELECT语句，其中WHERE子句包含LIKE前缀匹配，可以改写为范围查询。\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), major VARCHAR(100) );\"], \"sql\": \"SELECT * FROM students WHERE student_name LIKE 'John%' UNION SELECT * FROM students WHERE student_name LIKE 'Jane%';\", \"explain\": \"{\\\"query_block\\\": {\\\"union_result\\\": {\\\"using_temporary_table\\\": true, \\\"table_name\\\": \\\"<union1,2>\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"query_specifications\\\": [{\\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"208\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\", \\\"major\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_12_1748591779`.`students`.`student_name` like 'John%')\\\"}}}, {\\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"208\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\", \\\"major\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_12_1748591779`.`students`.`student_name` like 'Jane%')\\\"}}}]}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"1\", \"rationale\": \"LIKE前缀查询优化：`WHERE student_name LIKE 'John%'` 和 `WHERE student_name LIKE 'Jane%'` 都是 `LIKE 'prefix%'` 形式的前缀匹配。`student_name` 字段是字符串类型，且LIKE右侧为常量前缀。可以将其改写为 `student_name >= 'John' AND student_name < 'Joko'` 和 `student_name >= 'Jane' AND student_name < 'Janf'`（这里假设下一个字典序值为'Joko'和'Janf'），利用索引的有序性，避免全表扫描，提升查询性能。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), major VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": {\"union_result\": {\"using_temporary_table\": true, \"table_name\": \"<union1,2>\", \"access_type\": \"ALL\", \"query_specifications\": [{\"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"208\"}, \"used_columns\": [\"student_id\", \"student_name\", \"major\"], \"attached_condition\": \"(`test_db_case_12_1748591779`.`students`.`student_name` like 'John%')\"}}}, {\"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"208\"}, \"used_columns\": [\"student_id\", \"student_name\", \"major\"], \"attached_condition\": \"(`test_db_case_12_1748591779`.`students`.`student_name` like 'Jane%')\"}}}]}}}\n\n## Original SQL:\nSELECT * FROM students WHERE student_name LIKE 'John%' UNION SELECT * FROM students WHERE student_name LIKE 'Jane%';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM students WHERE student_name LIKE 'John%' OR student_name LIKE 'Jane%';"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "13",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"13\", \"db_type\": \"mysql\", \"description\": \"一个包含UNION的SELECT语句，外部查询包含LIMIT子句，可以下推到UNION的各个分支中。\", \"create_table_statements\": [\"CREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(100), reg_date DATE );\", \"CREATE TABLE articles ( id INT PRIMARY KEY, title VARCHAR(255), publish_time DATETIME );\"], \"sql\": \"SELECT * FROM (  (SELECT name FROM users ORDER BY reg_date DESC)  UNION  (SELECT title FROM articles ORDER BY publish_time DESC) ) AS mixed  ORDER BY name LIMIT 5;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"15.00\\\"}, \\\"ordering_operation\\\": {\\\"using_filesort\\\": true, \\\"cost_info\\\": {\\\"sort_cost\\\": \\\"4.00\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"mixed\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 4, \\\"rows_produced_per_join\\\": 4, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"10.20\\\", \\\"eval_cost\\\": \\\"0.80\\\", \\\"prefix_cost\\\": \\\"11.00\\\", \\\"data_read_per_join\\\": \\\"1K\\\"}, \\\"used_columns\\\": [\\\"name\\\"], \\\"materialized_from_subquery\\\": {\\\"using_temporary_table\\\": true, \\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"union_result\\\": {\\\"using_temporary_table\\\": true, \\\"table_name\\\": \\\"<union2,3>\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"query_specifications\\\": [{\\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"users\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"name\\\", \\\"reg_date\\\"]}}}, {\\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 3, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"articles\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"272\\\"}, \\\"used_columns\\\": [\\\"title\\\", \\\"publish_time\\\"]}}}]}}}}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"LIMIT下推至UNION分支：外部查询有一个`LIMIT 5`子句，没有`GROUP BY`，`FROM`只有一个子查询 (`mixed`)，没有其他条件。子查询是`UNION`连接的多个查询。这符合LIMIT下推的条件。可以将外部的`LIMIT`下推到`UNION`的各个分支中，减少中间结果集的大小，提高查询性能。需要注意的是，下推时要考虑`ORDER BY`，并且可能需要调整下推的`LIMIT`值以确保结果正确。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(100), reg_date DATE );\nCREATE TABLE articles ( id INT PRIMARY KEY, title VARCHAR(255), publish_time DATETIME );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"15.00\"}, \"ordering_operation\": {\"using_filesort\": true, \"cost_info\": {\"sort_cost\": \"4.00\"}, \"table\": {\"table_name\": \"mixed\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 4, \"rows_produced_per_join\": 4, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"10.20\", \"eval_cost\": \"0.80\", \"prefix_cost\": \"11.00\", \"data_read_per_join\": \"1K\"}, \"used_columns\": [\"name\"], \"materialized_from_subquery\": {\"using_temporary_table\": true, \"dependent\": false, \"cacheable\": true, \"query_block\": {\"union_result\": {\"using_temporary_table\": true, \"table_name\": \"<union2,3>\", \"access_type\": \"ALL\", \"query_specifications\": [{\"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"users\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"name\", \"reg_date\"]}}}, {\"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 3, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"articles\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"272\"}, \"used_columns\": [\"title\", \"publish_time\"]}}}]}}}}}}\n\n## Original SQL:\nSELECT * FROM (  (SELECT name FROM users ORDER BY reg_date DESC)  UNION  (SELECT title FROM articles ORDER BY publish_time DESC) ) AS mixed  ORDER BY name LIMIT 5;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM ((SELECT name FROM users) UNION (SELECT title FROM articles)) AS mixed ORDER BY name LIMIT 5;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "14",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"14\", \"db_type\": \"mysql\", \"description\": \"一个包含IN子查询的SELECT语句，子查询明确只返回一行，因此可以转换为标量子查询。\", \"create_table_statements\": [\"CREATE TABLE students ( id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), score INT );\"], \"sql\": \"SELECT * FROM students WHERE id IN ( SELECT MAX(id) FROM students );\", \"explain\": \"{\\\"query_block\\\": { \\\"select_id\\\": 1, \\\"cost_info\\\": { \\\"query_cost\\\": \\\"1.20\\\" }, \\\"table\\\": { \\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\" }, \\\"used_columns\\\": [ \\\"id\\\", \\\"student_name\\\", \\\"score\\\" ], \\\"attached_condition\\\": \\\"<in_optimizer>(`test_db_case_14_1749536504`.`students`.`id`,<exists>(/* select#2 */ select max(`test_db_case_14_1749536504`.`students`.`id`) from `test_db_case_14_1749536504`.`students` having (<cache>(`test_db_case_14_1749536504`.`students`.`id`) = <ref_null_helper>(max(`test_db_case_14_1749536504`.`students`.`id`)))))\\\", \\\"attached_subqueries\\\": [ { \\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": { \\\"select_id\\\": 2, \\\"message\\\": \\\"No matching min/max row\\\" } } ] } } }\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"IN/ANY 子查询转标量子查询：子查询 `SELECT MAX(id) FROM students` 明确只返回一个聚合结果（最大ID），即最多返回一行。同时，该子查询不引用外部查询的列。因此，可以将 `IN` 子查询转换为 `=` 比较的标量子查询形式，以利用子查询物化，减少重复计算，提升查询性能。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), score INT );\n\n## Explain Output in JSON:\n{\"query_block\": { \"select_id\": 1, \"cost_info\": { \"query_cost\": \"1.20\" }, \"table\": { \"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\" }, \"used_columns\": [ \"id\", \"student_name\", \"score\" ], \"attached_condition\": \"<in_optimizer>(`test_db_case_14_1749536504`.`students`.`id`,<exists>(/* select#2 */ select max(`test_db_case_14_1749536504`.`students`.`id`) from `test_db_case_14_1749536504`.`students` having (<cache>(`test_db_case_14_1749536504`.`students`.`id`) = <ref_null_helper>(max(`test_db_case_14_1749536504`.`students`.`id`)))))\", \"attached_subqueries\": [ { \"dependent\": true, \"cacheable\": false, \"query_block\": { \"select_id\": 2, \"message\": \"No matching min/max row\" } } ] } } }\n\n## Original SQL:\nSELECT * FROM students WHERE id IN ( SELECT MAX(id) FROM students );\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM students ORDER BY id DESC LIMIT 1;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "15",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"15\", \"db_type\": \"mysql\", \"description\": \"一个包含嵌套子查询的COUNT语句，其中外部的WHERE子句条件可以下推到内层的子查询中，并且子查询中存在可以投影下推的冗余列。\", \"create_table_statements\": [\"CREATE TABLE enrollments ( student_id INT PRIMARY KEY, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT COUNT(*) FROM ( SELECT student_id, enrollment_date FROM enrollments WHERE student_id < 1000 ) AS dt WHERE enrollment_date >= '2023-01-01';\", \"explain\": \"{\\\"query_block\\\": { \\\"select_id\\\": 1, \\\"cost_info\\\": { \\\"query_cost\\\": \\\"1.41\\\" }, \\\"table\\\": { \\\"table_name\\\": \\\"enrollments\\\", \\\"access_type\\\": \\\"range\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"student_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.21\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.41\\\", \\\"data_read_per_join\\\": \\\"16\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"enrollment_date\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_15_1749719333`.`enrollments`.`enrollment_date` >= '2023-01-01') and (`test_db_case_15_1749719333`.`enrollments`.`student_id` < 1000))\\\" } } }\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"谓词下推：外部查询的 `WHERE enrollment_date >= '2023-01-01'` 条件可以下推到子查询 `SELECT student_id, enrollment_date FROM enrollments` 的 `enrollments` 表中，从而在数据源处尽早过滤不必要的数据，减少处理量。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"投影下推：子查询 `SELECT student_id, enrollment_date FROM enrollments WHERE student_id < 1000` 中的 `student_id` 列在外层 `SELECT COUNT(*)` 中没有被直接使用，但由于 `COUNT(*)` 仅关心行数，因此 `student_id` 列可以从投影中移除，替换为 `SELECT 1` 或仅保留必要的列，以减少IO和网络代价。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"2\", \"rationale\": \"子查询折叠：外部查询的运算级别不高于子查询，且没有别名冲突及其他限制，故可将子查询折叠以减少中间结果\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE enrollments ( student_id INT PRIMARY KEY, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": { \"select_id\": 1, \"cost_info\": { \"query_cost\": \"1.41\" }, \"table\": { \"table_name\": \"enrollments\", \"access_type\": \"range\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"student_id\" ], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.21\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.41\", \"data_read_per_join\": \"16\" }, \"used_columns\": [ \"student_id\", \"enrollment_date\" ], \"attached_condition\": \"((`test_db_case_15_1749719333`.`enrollments`.`enrollment_date` >= '2023-01-01') and (`test_db_case_15_1749719333`.`enrollments`.`student_id` < 1000))\" } } }\n\n## Original SQL:\nSELECT COUNT(*) FROM ( SELECT student_id, enrollment_date FROM enrollments WHERE student_id < 1000 ) AS dt WHERE enrollment_date >= '2023-01-01';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT COUNT(*) FROM enrollments WHERE student_id < 1000 AND enrollment_date >= '2023-01-01';"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "15",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"15\", \"db_type\": \"mysql\", \"description\": \"一个包含嵌套子查询的COUNT语句，其中外部的WHERE子句条件可以下推到内层的子查询中，并且子查询中存在可以投影下推的冗余列。\", \"create_table_statements\": [\"CREATE TABLE enrollments ( student_id INT PRIMARY KEY, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT COUNT(*) FROM ( SELECT student_id, enrollment_date FROM enrollments WHERE student_id < 1000 ) AS dt WHERE enrollment_date >= '2023-01-01';\", \"explain\": \"{\\\"query_block\\\": { \\\"select_id\\\": 1, \\\"cost_info\\\": { \\\"query_cost\\\": \\\"1.41\\\" }, \\\"table\\\": { \\\"table_name\\\": \\\"enrollments\\\", \\\"access_type\\\": \\\"range\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"student_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.21\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.41\\\", \\\"data_read_per_join\\\": \\\"16\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"enrollment_date\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_15_1749719333`.`enrollments`.`enrollment_date` >= '2023-01-01') and (`test_db_case_15_1749719333`.`enrollments`.`student_id` < 1000))\\\" } } }\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"谓词下推：外部查询的 `WHERE enrollment_date >= '2023-01-01'` 条件可以下推到子查询 `SELECT student_id, enrollment_date FROM enrollments` 的 `enrollments` 表中，从而在数据源处尽早过滤不必要的数据，减少处理量。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"投影下推：子查询 `SELECT student_id, enrollment_date FROM enrollments WHERE student_id < 1000` 中的 `student_id` 列在外层 `SELECT COUNT(*)` 中没有被直接使用，但由于 `COUNT(*)` 仅关心行数，因此 `student_id` 列可以从投影中移除，替换为 `SELECT 1` 或仅保留必要的列，以减少IO和网络代价。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"2\", \"rationale\": \"子查询折叠：外部查询的运算级别不高于子查询，且没有别名冲突及其他限制，故可将子查询折叠以减少中间结果\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE enrollments ( student_id INT PRIMARY KEY, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": { \"select_id\": 1, \"cost_info\": { \"query_cost\": \"1.41\" }, \"table\": { \"table_name\": \"enrollments\", \"access_type\": \"range\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"student_id\" ], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.21\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.41\", \"data_read_per_join\": \"16\" }, \"used_columns\": [ \"student_id\", \"enrollment_date\" ], \"attached_condition\": \"((`test_db_case_15_1749719333`.`enrollments`.`enrollment_date` >= '2023-01-01') and (`test_db_case_15_1749719333`.`enrollments`.`student_id` < 1000))\" } } }\n\n## Original SQL:\nSELECT COUNT(*) FROM ( SELECT student_id, enrollment_date FROM enrollments WHERE student_id < 1000 ) AS dt WHERE enrollment_date >= '2023-01-01';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT COUNT(*) FROM enrollments WHERE student_id < 1000 AND enrollment_date >= '2023-01-01';"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "15",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"15\", \"db_type\": \"mysql\", \"description\": \"一个包含嵌套子查询的COUNT语句，其中外部的WHERE子句条件可以下推到内层的子查询中，并且子查询中存在可以投影下推的冗余列。\", \"create_table_statements\": [\"CREATE TABLE enrollments ( student_id INT PRIMARY KEY, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT COUNT(*) FROM ( SELECT student_id, enrollment_date FROM enrollments WHERE student_id < 1000 ) AS dt WHERE enrollment_date >= '2023-01-01';\", \"explain\": \"{\\\"query_block\\\": { \\\"select_id\\\": 1, \\\"cost_info\\\": { \\\"query_cost\\\": \\\"1.41\\\" }, \\\"table\\\": { \\\"table_name\\\": \\\"enrollments\\\", \\\"access_type\\\": \\\"range\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"student_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.21\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.41\\\", \\\"data_read_per_join\\\": \\\"16\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"enrollment_date\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_15_1749719333`.`enrollments`.`enrollment_date` >= '2023-01-01') and (`test_db_case_15_1749719333`.`enrollments`.`student_id` < 1000))\\\" } } }\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"谓词下推：外部查询的 `WHERE enrollment_date >= '2023-01-01'` 条件可以下推到子查询 `SELECT student_id, enrollment_date FROM enrollments` 的 `enrollments` 表中，从而在数据源处尽早过滤不必要的数据，减少处理量。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"1\", \"rationale\": \"投影下推：子查询 `SELECT student_id, enrollment_date FROM enrollments WHERE student_id < 1000` 中的 `student_id` 列在外层 `SELECT COUNT(*)` 中没有被直接使用，但由于 `COUNT(*)` 仅关心行数，因此 `student_id` 列可以从投影中移除，替换为 `SELECT 1` 或仅保留必要的列，以减少IO和网络代价。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"2\", \"rationale\": \"子查询折叠：外部查询的运算级别不高于子查询，且没有别名冲突及其他限制，故可将子查询折叠以减少中间结果\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE enrollments ( student_id INT PRIMARY KEY, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": { \"select_id\": 1, \"cost_info\": { \"query_cost\": \"1.41\" }, \"table\": { \"table_name\": \"enrollments\", \"access_type\": \"range\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"student_id\" ], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.21\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.41\", \"data_read_per_join\": \"16\" }, \"used_columns\": [ \"student_id\", \"enrollment_date\" ], \"attached_condition\": \"((`test_db_case_15_1749719333`.`enrollments`.`enrollment_date` >= '2023-01-01') and (`test_db_case_15_1749719333`.`enrollments`.`student_id` < 1000))\" } } }\n\n## Original SQL:\nSELECT COUNT(*) FROM ( SELECT student_id, enrollment_date FROM enrollments WHERE student_id < 1000 ) AS dt WHERE enrollment_date >= '2023-01-01';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT COUNT(*) FROM enrollments WHERE student_id < 1000 AND enrollment_date >= '2023-01-01';"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "16",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"16\", \"db_type\": \"mysql\", \"description\": \"一个简单的LEFT JOIN查询，明确引用了主表中的列，可能存在可消除的外连接。\", \"create_table_statements\": [\"CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;\"], \"sql\": \"SELECT o.o_custkey FROM orders o LEFT JOIN customer ON c_custkey=o_custkey\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"},\\\"table\\\": {\\\"table_name\\\": \\\"o\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"O_CUSTKEY\\\",\\\"O_ORDERKEY\\\",\\\"O_ORDERSTATUS\\\",\\\"O_TOTALPRICE\\\",\\\"O_ORDERDATE\\\",\\\"O_ORDERPRIORITY\\\",\\\"O_CLERK\\\",\\\"O_SHIPPRIORITY\\\",\\\"O_COMMENT\\\"]}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"外连接表消除：`LEFT JOIN customer` 是一个外连接。由于 `customer` 表的任何列没有在 `SELECT` 列表、`WHERE`、`GROUP BY`、`ORDER BY` 或 `HAVING` 子句中被引用（即被关联表没有被引用）。假设其为等值连接且未加锁，并且 `C_CUSTKEY` 是主键，满足“连表语句不会导致数据重复”的条件，因此这个 `LEFT JOIN` 可以被消除，只保留 `orders` 表。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"1.20\"},\"table\": {\"table_name\": \"o\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"O_CUSTKEY\",\"O_ORDERKEY\",\"O_ORDERSTATUS\",\"O_TOTALPRICE\",\"O_ORDERDATE\",\"O_ORDERPRIORITY\",\"O_CLERK\",\"O_SHIPPRIORITY\",\"O_COMMENT\"]}}}\n\n## Original SQL:\nSELECT o.o_custkey FROM orders o LEFT JOIN customer ON c_custkey=o_custkey\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT o.o_custkey FROM orders o"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "17",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"17\", \"db_type\": \"mysql\", \"description\": \"一个包含LEFT JOIN的SELECT语句，连接条件为不等值连接，难以进行外连接消除。\", \"create_table_statements\": [\"CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\"], \"sql\": \"SELECT c.* FROM customer c LEFT JOIN orders o ON c.c_custkey > o.o_custkey\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"},\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"c\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"C_CUSTKEY\\\",\\\"C_NAME\\\",\\\"C_ADDRESS\\\",\\\"C_NATIONKEY\\\",\\\"C_PHONE\\\",\\\"C_ACCTBAL\\\",\\\"C_MKTSEGMENT\\\",\\\"C_COMMENT\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"o\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"O_CUSTKEY\\\",\\\"O_ORDERKEY\\\",\\\"O_ORDERSTATUS\\\",\\\"O_TOTALPRICE\\\",\\\"O_ORDERDATE\\\",\\\"O_ORDERPRIORITY\\\",\\\"O_CLERK\\\",\\\"O_SHIPPRIORITY\\\",\\\"O_COMMENT\\\"],\\\"attached_condition\\\": \\\"(`c`.`C_CUSTKEY` > `o`.`O_CUSTKEY`)\\\"}}]}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"外连接表消除：该语句是 `LEFT JOIN`，但连接条件 `c.c_custkey > o.o_custkey` 是一个不等值连接。根据规则，外连接消除通常只适用于等值连接（即 `ON` 条件中不能存在其他 `OR` 条件，且主要通过字段进行等值判断）。因此，这种不等值连接不满足 `rule0003` 中两表是等值连接的条件，不能直接进行外连接消除。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"1.20\"},\"nested_loop\": [{\"table\": {\"table_name\": \"c\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"C_CUSTKEY\",\"C_NAME\",\"C_ADDRESS\",\"C_NATIONKEY\",\"C_PHONE\",\"C_ACCTBAL\",\"C_MKTSEGMENT\",\"C_COMMENT\"]}},{\"table\": {\"table_name\": \"o\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"O_CUSTKEY\",\"O_ORDERKEY\",\"O_ORDERSTATUS\",\"O_TOTALPRICE\",\"O_ORDERDATE\",\"O_ORDERPRIORITY\",\"O_CLERK\",\"O_SHIPPRIORITY\",\"O_COMMENT\"],\"attached_condition\": \"(`c`.`C_CUSTKEY` > `o`.`O_CUSTKEY`)\"}}]}}}\n\n## Original SQL:\nSELECT c.* FROM customer c LEFT JOIN orders o ON c.c_custkey > o.o_custkey\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT c.* FROM customer c LEFT JOIN orders o ON c.C_CUSTKEY = o.O_CUSTKEY"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "18",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"18\", \"db_type\": \"mysql\", \"description\": \"一个包含LEFT JOIN的SELECT语句，连接条件为不等值连接，难以进行外连接消除，且使用了表别名。\", \"create_table_statements\": [\"CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\"], \"sql\": \"SELECT c.* FROM customer AS c LEFT JOIN orders AS o ON c.c_custkey > o.o_custkey\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"},\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"c\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"C_CUSTKEY\\\",\\\"C_NAME\\\",\\\"C_ADDRESS\\\",\\\"C_NATIONKEY\\\",\\\"C_PHONE\\\",\\\"C_ACCTBAL\\\",\\\"C_MKTSEGMENT\\\",\\\"C_COMMENT\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"o\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"O_CUSTKEY\\\",\\\"O_ORDERKEY\\\",\\\"O_ORDERSTATUS\\\",\\\"O_TOTALPRICE\\\",\\\"O_ORDERDATE\\\",\\\"O_ORDERPRIORITY\\\",\\\"O_CLERK\\\",\\\"O_SHIPPRIORITY\\\",\\\"O_COMMENT\\\"],\\\"attached_condition\\\": \\\"(`c`.`C_CUSTKEY` > `o`.`O_CUSTKEY`)\\\"}}]}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"外连接表消除：该语句是 `LEFT JOIN`，但连接条件 `c.c_custkey > o.o_custkey` 是一个不等值连接。根据规则，外连接消除通常只适用于等值连接。因此，这种不等值连接不满足 `rule0003` 中两表是等值连接的条件，不能直接进行外连接消除。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"1.20\"},\"nested_loop\": [{\"table\": {\"table_name\": \"c\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"C_CUSTKEY\",\"C_NAME\",\"C_ADDRESS\",\"C_NATIONKEY\",\"C_PHONE\",\"C_ACCTBAL\",\"C_MKTSEGMENT\",\"C_COMMENT\"]}},{\"table\": {\"table_name\": \"o\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"O_CUSTKEY\",\"O_ORDERKEY\",\"O_ORDERSTATUS\",\"O_TOTALPRICE\",\"O_ORDERDATE\",\"O_ORDERPRIORITY\",\"O_CLERK\",\"O_SHIPPRIORITY\",\"O_COMMENT\"],\"attached_condition\": \"(`c`.`C_CUSTKEY` > `o`.`O_CUSTKEY`)\"}}]}}}\n\n## Original SQL:\nSELECT c.* FROM customer AS c LEFT JOIN orders AS o ON c.c_custkey > o.o_custkey\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT c.* FROM customer AS c LEFT JOIN orders AS o ON c.c_custkey = o.o_custkey"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "19",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"19\", \"db_type\": \"mysql\", \"description\": \"一个包含INNER JOIN和DISTINCT的SELECT语句，可能存在不必要的DISTINCT，且包含排序操作。\", \"create_table_statements\": [\"CREATE TABLE PatientRecords (PatientID INT PRIMARY KEY,Name VARCHAR(255),Age INT);CREATE TABLE DoctorSchedules (DoctorID INT PRIMARY KEY,ScheduleDate DATE,PatientID INT);CREATE TABLE MedicalDevices (DeviceID INT PRIMARY KEY,DeviceName VARCHAR(255),PatientID INT);CREATE TABLE TreatmentHistory (TreatmentID INT PRIMARY KEY,PatientID INT,TreatmentDate DATE);\"], \"sql\": \"SELECT DISTINCT PatientRecords.PatientID, PatientRecords.Name, TreatmentHistory.TreatmentDate FROM PatientRecords INNER JOIN TreatmentHistory ON PatientRecords.PatientID = TreatmentHistory.PatientID ORDER BY TreatmentHistory.TreatmentDate DESC\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"},\\\"duplicates_removal\\\": {\\\"using_temporary_table\\\": true,\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"PatientRecords\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"PatientID\\\",\\\"Name\\\",\\\"Age\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"TreatmentHistory\\\",\\\"access_type\\\": \\\"ref\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"TreatmentID\\\",\\\"PatientID\\\",\\\"TreatmentDate\\\"],\\\"attached_condition\\\": \\\"(`PatientRecords`.`PatientID` = `TreatmentHistory`.`PatientID`)\\\"}}]}}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"外连接表消除：本用例为 `INNER JOIN`，而非 `LEFT JOIN` 或 `RIGHT JOIN`。`外连接表消除`规则 (rule0003) 明确适用于 `LEFT JOIN` 或 `RIGHT JOIN`，其目的是在满足特定条件时将外连接转换为内连接或直接消除。对于原始就是 `INNER JOIN` 的情况，该规则不直接适用，因为其连接语义已经是最严格的。因此，此SQL不符合 `rule0003` 的应用条件。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE PatientRecords (PatientID INT PRIMARY KEY,Name VARCHAR(255),Age INT);CREATE TABLE DoctorSchedules (DoctorID INT PRIMARY KEY,ScheduleDate DATE,PatientID INT);CREATE TABLE MedicalDevices (DeviceID INT PRIMARY KEY,DeviceName VARCHAR(255),PatientID INT);CREATE TABLE TreatmentHistory (TreatmentID INT PRIMARY KEY,PatientID INT,TreatmentDate DATE);\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"1.20\"},\"duplicates_removal\": {\"using_temporary_table\": true,\"nested_loop\": [{\"table\": {\"table_name\": \"PatientRecords\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"PatientID\",\"Name\",\"Age\"]}},{\"table\": {\"table_name\": \"TreatmentHistory\",\"access_type\": \"ref\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"TreatmentID\",\"PatientID\",\"TreatmentDate\"],\"attached_condition\": \"(`PatientRecords`.`PatientID` = `TreatmentHistory`.`PatientID`)\"}}]}}}\n\n## Original SQL:\nSELECT DISTINCT PatientRecords.PatientID, PatientRecords.Name, TreatmentHistory.TreatmentDate FROM PatientRecords INNER JOIN TreatmentHistory ON PatientRecords.PatientID = TreatmentHistory.PatientID ORDER BY TreatmentHistory.TreatmentDate DESC\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT PatientRecords.PatientID, PatientRecords.Name, TreatmentHistory.TreatmentDate FROM PatientRecords INNER JOIN TreatmentHistory ON PatientRecords.PatientID = TreatmentHistory.PatientID ORDER BY TreatmentHistory.TreatmentDate DESC"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "20",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"20\", \"db_type\": \"mysql\", \"description\": \"一个简单的LEFT JOIN查询，可能存在可消除的外连接，且未引用被连接表中的任何列。\", \"create_table_statements\": [\"CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\"], \"sql\": \"SELECT o_custkey FROM orders LEFT JOIN customer ON c_custkey=o_custkey\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"0.70\\\"}, \\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"orders\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"0.25\\\", \\\"eval_cost\\\": \\\"0.10\\\", \\\"prefix_cost\\\": \\\"0.35\\\", \\\"data_read_per_join\\\": \\\"472\\\"}, \\\"used_columns\\\": [\\\"O_CUSTKEY\\\"]}}, {\\\"table\\\": {\\\"table_name\\\": \\\"customer\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"C_CUSTKEY\\\"], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [\\\"test_db_case_10_1749728367.orders.O_CUSTKEY\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"using_index\\\": true, \\\"cost_info\\\": {\\\"read_cost\\\": \\\"0.25\\\", \\\"eval_cost\\\": \\\"0.10\\\", \\\"prefix_cost\\\": \\\"0.70\\\", \\\"data_read_per_join\\\": \\\"848\\\"}, \\\"used_columns\\\": [\\\"C_CUSTKEY\\\"]}}]}}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"2\", \"rationale\": \"外连接表消除：与Case 5类似，`LEFT JOIN customer` 是一个外连接。由于 `customer` 表的任何列没有在 `SELECT` 列表、`WHERE`、`GROUP BY`、`ORDER BY` 或 `HAVING` 子句中被引用（即被关联表没有被引用）。假设其为等值连接且未加锁，并且 `C_CUSTKEY` 是主键，满足“连表语句不会导致数据重复”的条件，因此这个 `LEFT JOIN` 可以被消除，只保留 `orders` 表。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"0.70\"}, \"nested_loop\": [{\"table\": {\"table_name\": \"orders\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"0.25\", \"eval_cost\": \"0.10\", \"prefix_cost\": \"0.35\", \"data_read_per_join\": \"472\"}, \"used_columns\": [\"O_CUSTKEY\"]}}, {\"table\": {\"table_name\": \"customer\", \"access_type\": \"eq_ref\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"C_CUSTKEY\"], \"key_length\": \"4\", \"ref\": [\"test_db_case_10_1749728367.orders.O_CUSTKEY\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"using_index\": true, \"cost_info\": {\"read_cost\": \"0.25\", \"eval_cost\": \"0.10\", \"prefix_cost\": \"0.70\", \"data_read_per_join\": \"848\"}, \"used_columns\": [\"C_CUSTKEY\"]}}]}}\n\n## Original SQL:\nSELECT o_custkey FROM orders LEFT JOIN customer ON c_custkey=o_custkey\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT o_custkey FROM orders"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "21",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"21\", \"db_type\": \"oracle\", \"description\": \"本次改写的核心技术是将score_model_factor表的JOIN转换为EXISTS子查询。原SQL中,虽然JOIN了score_model_factor表,但SELECT子句中并未使用该表的任何列(仅用于过滤),这正是JOIN转EXISTS优化的典型场景。改写后,通过EXISTS(SELECT 1 FROM score_model_factor f WHERE f.model_factor_id = t.model_factor_id)实现了相同的语义:只有当SCORE_RATING_RECORD_DETAIL.model_factor_id在score_model_factor表中存在时,该行才被保留。EXISTS的优势在于:(1)利用主键索引快速验证;(2)找到第一条匹配记录即返回TRUE,无需扫描所有匹配行;(3)不需要传递score_model_factor的列数据,减少内存和网络开销。\", \"create_table_statements\": [\"CREATE SEQUENCE score_rating_record_seq; CREATE TABLE SCORE_RATING_RECORD (score_rating_record_id NUMBER PRIMARY KEY, rpt_dt DATE NOT NULL); CREATE OR REPLACE TRIGGER score_rating_record_bi BEFORE INSERT ON SCORE_RATING_RECORD FOR EACH ROW BEGIN IF :NEW.score_rating_record_id IS NULL THEN SELECT score_rating_record_seq.NEXTVAL INTO :NEW.score_rating_record_id FROM DUAL; END IF; END;\", \"CREATE SEQUENCE score_rating_region_record_seq; CREATE TABLE score_rating_region_record (score_rating_region_record_id NUMBER PRIMARY KEY, score_rating_record_id NUMBER NOT NULL, region_cd VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER score_rating_region_record_bi BEFORE INSERT ON score_rating_region_record FOR EACH ROW BEGIN IF :NEW.score_rating_region_record_id IS NULL THEN SELECT score_rating_region_record_seq.NEXTVAL INTO :NEW.score_rating_region_record_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_srr_score_rating_record_id ON score_rating_region_record(score_rating_record_id);\", \"CREATE INDEX idx_srr_region_cd ON score_rating_region_record(region_cd);\", \"CREATE SEQUENCE score_rating_record_detail_seq; CREATE TABLE SCORE_RATING_RECORD_DETAIL (score_rating_record_detail_id NUMBER PRIMARY KEY, score_rating_region_record_id NUMBER NOT NULL, model_factor_id NUMBER NOT NULL, factor_cd VARCHAR2(50) NOT NULL, factor_value NUMBER(18,4), option_init VARCHAR2(100)); CREATE OR REPLACE TRIGGER score_rating_record_detail_bi BEFORE INSERT ON SCORE_RATING_RECORD_DETAIL FOR EACH ROW BEGIN IF :NEW.score_rating_record_detail_id IS NULL THEN SELECT score_rating_record_detail_seq.NEXTVAL INTO :NEW.score_rating_record_detail_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_srrd_region_record_id ON SCORE_RATING_RECORD_DETAIL(score_rating_region_record_id);\", \"CREATE INDEX idx_srrd_model_factor_id ON SCORE_RATING_RECORD_DETAIL(model_factor_id);\", \"CREATE INDEX idx_srrd_factor_cd ON SCORE_RATING_RECORD_DETAIL(factor_cd);\", \"CREATE SEQUENCE score_model_factor_seq; CREATE TABLE score_model_factor (model_factor_id NUMBER PRIMARY KEY, factor_name VARCHAR2(100), factor_desc VARCHAR2(500)); CREATE OR REPLACE TRIGGER score_model_factor_bi BEFORE INSERT ON score_model_factor FOR EACH ROW BEGIN IF :NEW.model_factor_id IS NULL THEN SELECT score_model_factor_seq.NEXTVAL INTO :NEW.model_factor_id FROM DUAL; END IF; END;\"], \"sql\": \"select a.rpt_dt,s.region_cd , t.factor_cd,t.factor_value,t.option_init from SCORE_RATING_RECORD a\\njoin score_rating_region_record s on a.score_rating_record_id =s.score_rating_record_id\\njoin SCORE_RATING_RECORD_DETAIL t on s.score_rating_region_record_id =t.score_rating_region_record_id\\njoin score_model_factor f on f.model_factor_id =t.model_factor_id\\nwhere a.score_rating_record_id =1951215209649586177\\norder by s.region_cd , t.factor_cd;\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t109\\t50\\t2650\\t37698709\\t108\\n1\\t  SORT ORDER BY \\t109\\t50\\t2650\\t37698709\\t108\\n2\\t  HASH JOIN  \\t108\\t50\\t2650\\t817426\\t108\\n3\\t   NESTED LOOPS  \\t108\\t50\\t2650\\t817426\\t108\\n4\\t  NESTED LOOPS  \\t108\\t100\\t2650\\t817426\\t108\\n5\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n6\\t   NESTED LOOPS  \\t6\\t1\\t34\\t45189\\t6\\n7\\t  TABLE ACCESS BY INDEX ROWID SCORE_RATING_RECORD\\t3\\t1\\t18\\t22584\\t3\\n8\\t  INDEX UNIQUE SCAN SYS_C008302\\t2\\t1\\t\\t15293\\t2\\n9\\t  TABLE ACCESS BY INDEX ROWID BATCHED SCORE_RATING_REGION_RECORD\\t3\\t1\\t16\\t22604\\t3\\n10\\t  INDEX RANGE SCAN IDX_SRR_SCORE_RATING_RECORD_ID\\t2\\t1\\t\\t15293\\t2\\n11\\t  INDEX RANGE SCAN IDX_SRRD_REGION_RECORD_ID\\t2\\t100\\t\\t35093\\t2\\n12\\t  TABLE ACCESS BY INDEX ROWID SCORE_RATING_RECORD_DETAIL\\t102\\t100\\t1900\\t772237\\t102\\n13\\t   TABLE ACCESS FULL SCORE_RATING_RECORD_DETAIL\\t102\\t100\\t1900\\t772237\\t102\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,将因子表（score_model_factor）的无输出INNER JOIN改写为EXISTS子查询，避免实际连接操作，减少数据处理量，提升查询效率。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE score_rating_record_seq; CREATE TABLE SCORE_RATING_RECORD (score_rating_record_id NUMBER PRIMARY KEY, rpt_dt DATE NOT NULL); CREATE OR REPLACE TRIGGER score_rating_record_bi BEFORE INSERT ON SCORE_RATING_RECORD FOR EACH ROW BEGIN IF :NEW.score_rating_record_id IS NULL THEN SELECT score_rating_record_seq.NEXTVAL INTO :NEW.score_rating_record_id FROM DUAL; END IF; END;\nCREATE SEQUENCE score_rating_region_record_seq; CREATE TABLE score_rating_region_record (score_rating_region_record_id NUMBER PRIMARY KEY, score_rating_record_id NUMBER NOT NULL, region_cd VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER score_rating_region_record_bi BEFORE INSERT ON score_rating_region_record FOR EACH ROW BEGIN IF :NEW.score_rating_region_record_id IS NULL THEN SELECT score_rating_region_record_seq.NEXTVAL INTO :NEW.score_rating_region_record_id FROM DUAL; END IF; END;\nCREATE INDEX idx_srr_score_rating_record_id ON score_rating_region_record(score_rating_record_id);\nCREATE INDEX idx_srr_region_cd ON score_rating_region_record(region_cd);\nCREATE SEQUENCE score_rating_record_detail_seq; CREATE TABLE SCORE_RATING_RECORD_DETAIL (score_rating_record_detail_id NUMBER PRIMARY KEY, score_rating_region_record_id NUMBER NOT NULL, model_factor_id NUMBER NOT NULL, factor_cd VARCHAR2(50) NOT NULL, factor_value NUMBER(18,4), option_init VARCHAR2(100)); CREATE OR REPLACE TRIGGER score_rating_record_detail_bi BEFORE INSERT ON SCORE_RATING_RECORD_DETAIL FOR EACH ROW BEGIN IF :NEW.score_rating_record_detail_id IS NULL THEN SELECT score_rating_record_detail_seq.NEXTVAL INTO :NEW.score_rating_record_detail_id FROM DUAL; END IF; END;\nCREATE INDEX idx_srrd_region_record_id ON SCORE_RATING_RECORD_DETAIL(score_rating_region_record_id);\nCREATE INDEX idx_srrd_model_factor_id ON SCORE_RATING_RECORD_DETAIL(model_factor_id);\nCREATE INDEX idx_srrd_factor_cd ON SCORE_RATING_RECORD_DETAIL(factor_cd);\nCREATE SEQUENCE score_model_factor_seq; CREATE TABLE score_model_factor (model_factor_id NUMBER PRIMARY KEY, factor_name VARCHAR2(100), factor_desc VARCHAR2(500)); CREATE OR REPLACE TRIGGER score_model_factor_bi BEFORE INSERT ON score_model_factor FOR EACH ROW BEGIN IF :NEW.model_factor_id IS NULL THEN SELECT score_model_factor_seq.NEXTVAL INTO :NEW.model_factor_id FROM DUAL; END IF; END;\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t109\t50\t2650\t37698709\t108\n1\t  SORT ORDER BY \t109\t50\t2650\t37698709\t108\n2\t  HASH JOIN  \t108\t50\t2650\t817426\t108\n3\t   NESTED LOOPS  \t108\t50\t2650\t817426\t108\n4\t  NESTED LOOPS  \t108\t100\t2650\t817426\t108\n5\t  STATISTICS COLLECTOR  \t\t\t\t\t\n6\t   NESTED LOOPS  \t6\t1\t34\t45189\t6\n7\t  TABLE ACCESS BY INDEX ROWID SCORE_RATING_RECORD\t3\t1\t18\t22584\t3\n8\t  INDEX UNIQUE SCAN SYS_C008302\t2\t1\t\t15293\t2\n9\t  TABLE ACCESS BY INDEX ROWID BATCHED SCORE_RATING_REGION_RECORD\t3\t1\t16\t22604\t3\n10\t  INDEX RANGE SCAN IDX_SRR_SCORE_RATING_RECORD_ID\t2\t1\t\t15293\t2\n11\t  INDEX RANGE SCAN IDX_SRRD_REGION_RECORD_ID\t2\t100\t\t35093\t2\n12\t  TABLE ACCESS BY INDEX ROWID SCORE_RATING_RECORD_DETAIL\t102\t100\t1900\t772237\t102\n13\t   TABLE ACCESS FULL SCORE_RATING_RECORD_DETAIL\t102\t100\t1900\t772237\t102\n\n## Original SQL:\nselect a.rpt_dt,s.region_cd , t.factor_cd,t.factor_value,t.option_init from SCORE_RATING_RECORD a\njoin score_rating_region_record s on a.score_rating_record_id =s.score_rating_record_id\njoin SCORE_RATING_RECORD_DETAIL t on s.score_rating_region_record_id =t.score_rating_region_record_id\njoin score_model_factor f on f.model_factor_id =t.model_factor_id\nwhere a.score_rating_record_id =1951215209649586177\norder by s.region_cd , t.factor_cd;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select a.rpt_dt,s.region_cd,t.factor_cd,t.factor_value,t.option_init from SCORE_RATING_RECORD a join score_rating_region_record s on a.score_rating_record_id=s.score_rating_record_id join SCORE_RATING_RECORD_DETAIL t on s.score_rating_region_record_id=t.score_rating_region_record_id where a.score_rating_record_id=1951215209649586177 order by s.region_cd,t.factor_cd"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "22",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"22\", \"db_type\": \"oracle\", \"description\": \"此次改写主要采用了谓词下推技术，试图通过提前过滤减少数据量。同时移除了内层不必要的ORDER BY操作（因为最外层使用ROWNUM限制结果集），理论上可以节省排序成本。还优化了日期比较条件，使其更加精确。然而，由于过滤条件位置调整不当，导致了SQL语义发生变化。\", \"create_table_statements\": [\"CREATE SEQUENCE SYS_READ_HIS_LOG_SEQ; CREATE TABLE SYS_READ_HIS_LOG (PKID NUMBER PRIMARY KEY, FD_MODEL_ID NUMBER, FD_MODEL_NAME VARCHAR2(200), FD_READ_TIME TIMESTAMP); CREATE OR REPLACE TRIGGER SYS_READ_HIS_LOG_BI BEFORE INSERT ON SYS_READ_HIS_LOG FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT SYS_READ_HIS_LOG_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_sys_read_model_name ON SYS_READ_HIS_LOG(FD_MODEL_NAME);\", \"CREATE INDEX idx_sys_read_model_id ON SYS_READ_HIS_LOG(FD_MODEL_ID);\", \"CREATE INDEX idx_sys_read_time ON SYS_READ_HIS_LOG(FD_READ_TIME);\", \"CREATE SEQUENCE MANUAL_FILE_SEQ; CREATE TABLE MANUAL_FILE (FD_ID NUMBER PRIMARY KEY, FD_FILE_ID NUMBER); CREATE OR REPLACE TRIGGER MANUAL_FILE_BI BEFORE INSERT ON MANUAL_FILE FOR EACH ROW BEGIN IF :NEW.FD_ID IS NULL THEN SELECT MANUAL_FILE_SEQ.NEXTVAL INTO :NEW.FD_ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_manual_file_id ON MANUAL_FILE(FD_FILE_ID);\", \"CREATE SEQUENCE MANUAL_FILE_BASIC_INFO_SEQ; CREATE TABLE MANUAL_FILE_BASIC_INFO (PKID NUMBER PRIMARY KEY, FD_FILE_NAME VARCHAR2(200), FD_NO VARCHAR2(100), MANUAL_ID NUMBER, IS_DELETED VARCHAR2(1) DEFAULT '0'); CREATE OR REPLACE TRIGGER MANUAL_FILE_BASIC_INFO_BI BEFORE INSERT ON MANUAL_FILE_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT MANUAL_FILE_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mfbi_manual_id ON MANUAL_FILE_BASIC_INFO(MANUAL_ID);\", \"CREATE INDEX idx_mfbi_is_deleted ON MANUAL_FILE_BASIC_INFO(IS_DELETED);\", \"CREATE SEQUENCE XMAIR_MANUAL_BASIC_INFO_SEQ; CREATE TABLE XMAIR_MANUAL_BASIC_INFO (PKID NUMBER PRIMARY KEY, TYPE_ID NUMBER); CREATE OR REPLACE TRIGGER XMAIR_MANUAL_BASIC_INFO_BI BEFORE INSERT ON XMAIR_MANUAL_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT XMAIR_MANUAL_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_xmbi_type_id ON XMAIR_MANUAL_BASIC_INFO(TYPE_ID);\"], \"sql\": \"SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (\\n  SELECT  max(FD_MODEL_ID) FD_MODEL_ID,sum(countNumber) sumNumber ,max(FD_FILE_ID) FD_FILE_ID FROM (\\n  SELECT FD_MODEL_ID,count(1) countNumber from\\n  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL\\n  <if test=\\\"startDate != null and startDate != ''\\\">\\n   and FD_READ_TIME >= to_date(#{startDate},'yyyy-mm-dd')\\n  </if>\\n  <if test=\\\"endDate != null and endDate != ''\\\">\\n   and FD_READ_TIME &lt;= to_date(#{endDate},'yyyy-mm-dd')\\n  </if>\\n  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID\\n  GROUP BY FD_FILE_ID order by  sumNumber desc ) w\\n  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi\\n  ON mfbi.PKID = w.FD_FILE_ID\\n  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID\\n  <where>\\n   mfbi.IS_DELETED = '0'\\n   <if test=\\\" typeIdsByMfId != null  and typeIdsByMfId.size>0\\\">\\n  and  xmbi.TYPE_ID in\\n  <foreach collection=\\\"typeIdsByMfId\\\" item=\\\"typeId\\\" open=\\\"(\\\" separator=\\\",\\\" close=\\\")\\\">\\n  #{typeId}\\n  </foreach>\\n   </if>\\n   and rownum <![CDATA[ <= ]]> 10\\n  </where>\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t101\\t10\\t670\\t32701838\\t100\\n1\\t  COUNT STOPKEY \\t\\t\\t\\t\\t\\n2\\t  NESTED LOOPS  \\t101\\t10\\t670\\t32701838\\t100\\n3\\t   NESTED LOOPS  \\t101\\t20\\t670\\t32701838\\t100\\n4\\t  VIEW  \\t61\\t1000\\t26000\\t32373380\\t60\\n5\\t  SORT ORDER BY \\t3030\\t1000\\t29000\\t1618668956\\t2986\\n6\\t   HASH GROUP BY \\t3030\\t1000\\t29000\\t1618668956\\t2986\\n7\\t  VIEW  \\t3028\\t1000\\t29000\\t1544033810\\t2986\\n8\\t  HASH JOIN OUTER \\t3028\\t1000\\t33000\\t1544033810\\t2986\\n9\\t   NESTED LOOPS OUTER \\t3028\\t1000\\t33000\\t1544033810\\t2986\\n10\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n11\\t  VIEW  VW_GBF_8\\t2497\\t1000\\t26000\\t1259582159\\t2463\\n12\\t   HASH GROUP BY \\t2497\\t1000\\t46000\\t1259582159\\t2463\\n13\\t  TABLE ACCESS FULL SYS_READ_HIS_LOG\\t2472\\t1000000\\t46000000\\t324705404\\t2463\\n14\\t  TABLE ACCESS BY INDEX ROWID MANUAL_FILE\\t528\\t1\\t7\\t183701651\\t523\\n15\\t  INDEX UNIQUE SCAN SYS_C008302\\t\\t\\t\\t\\t\\n16\\t   TABLE ACCESS FULL MANUAL_FILE\\t528\\t1000000\\t7000000\\t183701651\\t523\\n17\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n18\\t   TABLE ACCESS BY INDEX ROWID MANUAL_FILE_BASIC_INFO\\t2\\t1\\t41\\t16423\\t2\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推优化，移除了子查询w中未被外部使用的列FD_MODEL_ID。该列在聚合后未传递到外层查询，属于冗余投影。消除该列可减少约30%-50%的临时表内存占用和I/O开销，尤其当数据量大（如10万行以上）时，性能提升更显著。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将外层WHERE条件中的mfbi.IS_DELETED='0'下推至子查询，提前过滤MANUAL_FILE_BASIC_INFO表。同时将xmbi.TYPE_ID条件移动到左连接ON子句中，以在连接时过滤XMAIR_MANUAL_BASIC_INFO表；并为保持语义，在typeIdsByMfId条件存在时添加`xmbi.PKID IS NOT NULL`条件（替代原xmbi.TYPE_ID过滤效果）。这减少了参与连接的数据量，提升了查询效率。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"没有LIMIT的子查询排序消除,消除子查询w中无用的ORDER BY排序（order by sumNumber desc），因为：1) 子查询作为LEFT JOIN源表且无LIMIT；2) JOIN操作会重新组织数据，使子查询排序失效；3) 移除冗余排序可提升执行效率\"}, {\"rule_id\": \"4\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,优化了时间筛选条件中的隐式转换风险：1) 将简化的日期格式改为完整时间戳格式 2) 调整起始时间的比较运算符 3) 消除了Oracle需要补全时间部分的隐式转换开销\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE SYS_READ_HIS_LOG_SEQ; CREATE TABLE SYS_READ_HIS_LOG (PKID NUMBER PRIMARY KEY, FD_MODEL_ID NUMBER, FD_MODEL_NAME VARCHAR2(200), FD_READ_TIME TIMESTAMP); CREATE OR REPLACE TRIGGER SYS_READ_HIS_LOG_BI BEFORE INSERT ON SYS_READ_HIS_LOG FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT SYS_READ_HIS_LOG_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_sys_read_model_name ON SYS_READ_HIS_LOG(FD_MODEL_NAME);\nCREATE INDEX idx_sys_read_model_id ON SYS_READ_HIS_LOG(FD_MODEL_ID);\nCREATE INDEX idx_sys_read_time ON SYS_READ_HIS_LOG(FD_READ_TIME);\nCREATE SEQUENCE MANUAL_FILE_SEQ; CREATE TABLE MANUAL_FILE (FD_ID NUMBER PRIMARY KEY, FD_FILE_ID NUMBER); CREATE OR REPLACE TRIGGER MANUAL_FILE_BI BEFORE INSERT ON MANUAL_FILE FOR EACH ROW BEGIN IF :NEW.FD_ID IS NULL THEN SELECT MANUAL_FILE_SEQ.NEXTVAL INTO :NEW.FD_ID FROM DUAL; END IF; END;\nCREATE INDEX idx_manual_file_id ON MANUAL_FILE(FD_FILE_ID);\nCREATE SEQUENCE MANUAL_FILE_BASIC_INFO_SEQ; CREATE TABLE MANUAL_FILE_BASIC_INFO (PKID NUMBER PRIMARY KEY, FD_FILE_NAME VARCHAR2(200), FD_NO VARCHAR2(100), MANUAL_ID NUMBER, IS_DELETED VARCHAR2(1) DEFAULT '0'); CREATE OR REPLACE TRIGGER MANUAL_FILE_BASIC_INFO_BI BEFORE INSERT ON MANUAL_FILE_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT MANUAL_FILE_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_mfbi_manual_id ON MANUAL_FILE_BASIC_INFO(MANUAL_ID);\nCREATE INDEX idx_mfbi_is_deleted ON MANUAL_FILE_BASIC_INFO(IS_DELETED);\nCREATE SEQUENCE XMAIR_MANUAL_BASIC_INFO_SEQ; CREATE TABLE XMAIR_MANUAL_BASIC_INFO (PKID NUMBER PRIMARY KEY, TYPE_ID NUMBER); CREATE OR REPLACE TRIGGER XMAIR_MANUAL_BASIC_INFO_BI BEFORE INSERT ON XMAIR_MANUAL_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT XMAIR_MANUAL_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_xmbi_type_id ON XMAIR_MANUAL_BASIC_INFO(TYPE_ID);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t101\t10\t670\t32701838\t100\n1\t  COUNT STOPKEY \t\t\t\t\t\n2\t  NESTED LOOPS  \t101\t10\t670\t32701838\t100\n3\t   NESTED LOOPS  \t101\t20\t670\t32701838\t100\n4\t  VIEW  \t61\t1000\t26000\t32373380\t60\n5\t  SORT ORDER BY \t3030\t1000\t29000\t1618668956\t2986\n6\t   HASH GROUP BY \t3030\t1000\t29000\t1618668956\t2986\n7\t  VIEW  \t3028\t1000\t29000\t1544033810\t2986\n8\t  HASH JOIN OUTER \t3028\t1000\t33000\t1544033810\t2986\n9\t   NESTED LOOPS OUTER \t3028\t1000\t33000\t1544033810\t2986\n10\t  STATISTICS COLLECTOR  \t\t\t\t\t\n11\t  VIEW  VW_GBF_8\t2497\t1000\t26000\t1259582159\t2463\n12\t   HASH GROUP BY \t2497\t1000\t46000\t1259582159\t2463\n13\t  TABLE ACCESS FULL SYS_READ_HIS_LOG\t2472\t1000000\t46000000\t324705404\t2463\n14\t  TABLE ACCESS BY INDEX ROWID MANUAL_FILE\t528\t1\t7\t183701651\t523\n15\t  INDEX UNIQUE SCAN SYS_C008302\t\t\t\t\t\n16\t   TABLE ACCESS FULL MANUAL_FILE\t528\t1000000\t7000000\t183701651\t523\n17\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n18\t   TABLE ACCESS BY INDEX ROWID MANUAL_FILE_BASIC_INFO\t2\t1\t41\t16423\t2\n\n## Original SQL:\nSELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (\n  SELECT  max(FD_MODEL_ID) FD_MODEL_ID,sum(countNumber) sumNumber ,max(FD_FILE_ID) FD_FILE_ID FROM (\n  SELECT FD_MODEL_ID,count(1) countNumber from\n  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL\n  <if test=\"startDate != null and startDate != ''\">\n   and FD_READ_TIME >= to_date(#{startDate},'yyyy-mm-dd')\n  </if>\n  <if test=\"endDate != null and endDate != ''\">\n   and FD_READ_TIME &lt;= to_date(#{endDate},'yyyy-mm-dd')\n  </if>\n  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID\n  GROUP BY FD_FILE_ID order by  sumNumber desc ) w\n  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi\n  ON mfbi.PKID = w.FD_FILE_ID\n  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID\n  <where>\n   mfbi.IS_DELETED = '0'\n   <if test=\" typeIdsByMfId != null  and typeIdsByMfId.size>0\">\n  and  xmbi.TYPE_ID in\n  <foreach collection=\"typeIdsByMfId\" item=\"typeId\" open=\"(\" separator=\",\" close=\")\">\n  #{typeId}\n  </foreach>\n   </if>\n   and rownum <![CDATA[ <= ]]> 10\n  </where>\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO,w.sumNumber countNumber FROM (SELECT FD_FILE_ID,sumNumber FROM (SELECT mf.FD_FILE_ID,SUM(cnt) sumNumber FROM (SELECT FD_MODEL_ID,COUNT(*) cnt FROM SYS_READ_HIS_LOG WHERE FD_MODEL_NAME='com.xmair.core.entity.DO.XmairManualFileNew' AND FD_MODEL_ID IS NOT NULL GROUP BY FD_MODEL_ID) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID=t.FD_MODEL_ID GROUP BY mf.FD_FILE_ID ORDER BY sumNumber DESC) WHERE ROWNUM<=10) w LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi ON mfbi.PKID=w.FD_FILE_ID LEFT JOIN XMAIR_MANUAL_BASIC_INFO xmbi ON xmbi.PKID=mfbi.MANUAL_ID WHERE mfbi.IS_DELETED='0'"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "22",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"22\", \"db_type\": \"oracle\", \"description\": \"此次改写主要采用了谓词下推技术，试图通过提前过滤减少数据量。同时移除了内层不必要的ORDER BY操作（因为最外层使用ROWNUM限制结果集），理论上可以节省排序成本。还优化了日期比较条件，使其更加精确。然而，由于过滤条件位置调整不当，导致了SQL语义发生变化。\", \"create_table_statements\": [\"CREATE SEQUENCE SYS_READ_HIS_LOG_SEQ; CREATE TABLE SYS_READ_HIS_LOG (PKID NUMBER PRIMARY KEY, FD_MODEL_ID NUMBER, FD_MODEL_NAME VARCHAR2(200), FD_READ_TIME TIMESTAMP); CREATE OR REPLACE TRIGGER SYS_READ_HIS_LOG_BI BEFORE INSERT ON SYS_READ_HIS_LOG FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT SYS_READ_HIS_LOG_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_sys_read_model_name ON SYS_READ_HIS_LOG(FD_MODEL_NAME);\", \"CREATE INDEX idx_sys_read_model_id ON SYS_READ_HIS_LOG(FD_MODEL_ID);\", \"CREATE INDEX idx_sys_read_time ON SYS_READ_HIS_LOG(FD_READ_TIME);\", \"CREATE SEQUENCE MANUAL_FILE_SEQ; CREATE TABLE MANUAL_FILE (FD_ID NUMBER PRIMARY KEY, FD_FILE_ID NUMBER); CREATE OR REPLACE TRIGGER MANUAL_FILE_BI BEFORE INSERT ON MANUAL_FILE FOR EACH ROW BEGIN IF :NEW.FD_ID IS NULL THEN SELECT MANUAL_FILE_SEQ.NEXTVAL INTO :NEW.FD_ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_manual_file_id ON MANUAL_FILE(FD_FILE_ID);\", \"CREATE SEQUENCE MANUAL_FILE_BASIC_INFO_SEQ; CREATE TABLE MANUAL_FILE_BASIC_INFO (PKID NUMBER PRIMARY KEY, FD_FILE_NAME VARCHAR2(200), FD_NO VARCHAR2(100), MANUAL_ID NUMBER, IS_DELETED VARCHAR2(1) DEFAULT '0'); CREATE OR REPLACE TRIGGER MANUAL_FILE_BASIC_INFO_BI BEFORE INSERT ON MANUAL_FILE_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT MANUAL_FILE_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mfbi_manual_id ON MANUAL_FILE_BASIC_INFO(MANUAL_ID);\", \"CREATE INDEX idx_mfbi_is_deleted ON MANUAL_FILE_BASIC_INFO(IS_DELETED);\", \"CREATE SEQUENCE XMAIR_MANUAL_BASIC_INFO_SEQ; CREATE TABLE XMAIR_MANUAL_BASIC_INFO (PKID NUMBER PRIMARY KEY, TYPE_ID NUMBER); CREATE OR REPLACE TRIGGER XMAIR_MANUAL_BASIC_INFO_BI BEFORE INSERT ON XMAIR_MANUAL_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT XMAIR_MANUAL_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_xmbi_type_id ON XMAIR_MANUAL_BASIC_INFO(TYPE_ID);\"], \"sql\": \"SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (\\n  SELECT  max(FD_MODEL_ID) FD_MODEL_ID,sum(countNumber) sumNumber ,max(FD_FILE_ID) FD_FILE_ID FROM (\\n  SELECT FD_MODEL_ID,count(1) countNumber from\\n  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL\\n  <if test=\\\"startDate != null and startDate != ''\\\">\\n   and FD_READ_TIME >= to_date(#{startDate},'yyyy-mm-dd')\\n  </if>\\n  <if test=\\\"endDate != null and endDate != ''\\\">\\n   and FD_READ_TIME &lt;= to_date(#{endDate},'yyyy-mm-dd')\\n  </if>\\n  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID\\n  GROUP BY FD_FILE_ID order by  sumNumber desc ) w\\n  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi\\n  ON mfbi.PKID = w.FD_FILE_ID\\n  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID\\n  <where>\\n   mfbi.IS_DELETED = '0'\\n   <if test=\\\" typeIdsByMfId != null  and typeIdsByMfId.size>0\\\">\\n  and  xmbi.TYPE_ID in\\n  <foreach collection=\\\"typeIdsByMfId\\\" item=\\\"typeId\\\" open=\\\"(\\\" separator=\\\",\\\" close=\\\")\\\">\\n  #{typeId}\\n  </foreach>\\n   </if>\\n   and rownum <![CDATA[ <= ]]> 10\\n  </where>\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t101\\t10\\t670\\t32701838\\t100\\n1\\t  COUNT STOPKEY \\t\\t\\t\\t\\t\\n2\\t  NESTED LOOPS  \\t101\\t10\\t670\\t32701838\\t100\\n3\\t   NESTED LOOPS  \\t101\\t20\\t670\\t32701838\\t100\\n4\\t  VIEW  \\t61\\t1000\\t26000\\t32373380\\t60\\n5\\t  SORT ORDER BY \\t3030\\t1000\\t29000\\t1618668956\\t2986\\n6\\t   HASH GROUP BY \\t3030\\t1000\\t29000\\t1618668956\\t2986\\n7\\t  VIEW  \\t3028\\t1000\\t29000\\t1544033810\\t2986\\n8\\t  HASH JOIN OUTER \\t3028\\t1000\\t33000\\t1544033810\\t2986\\n9\\t   NESTED LOOPS OUTER \\t3028\\t1000\\t33000\\t1544033810\\t2986\\n10\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n11\\t  VIEW  VW_GBF_8\\t2497\\t1000\\t26000\\t1259582159\\t2463\\n12\\t   HASH GROUP BY \\t2497\\t1000\\t46000\\t1259582159\\t2463\\n13\\t  TABLE ACCESS FULL SYS_READ_HIS_LOG\\t2472\\t1000000\\t46000000\\t324705404\\t2463\\n14\\t  TABLE ACCESS BY INDEX ROWID MANUAL_FILE\\t528\\t1\\t7\\t183701651\\t523\\n15\\t  INDEX UNIQUE SCAN SYS_C008302\\t\\t\\t\\t\\t\\n16\\t   TABLE ACCESS FULL MANUAL_FILE\\t528\\t1000000\\t7000000\\t183701651\\t523\\n17\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n18\\t   TABLE ACCESS BY INDEX ROWID MANUAL_FILE_BASIC_INFO\\t2\\t1\\t41\\t16423\\t2\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推优化，移除了子查询w中未被外部使用的列FD_MODEL_ID。该列在聚合后未传递到外层查询，属于冗余投影。消除该列可减少约30%-50%的临时表内存占用和I/O开销，尤其当数据量大（如10万行以上）时，性能提升更显著。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将外层WHERE条件中的mfbi.IS_DELETED='0'下推至子查询，提前过滤MANUAL_FILE_BASIC_INFO表。同时将xmbi.TYPE_ID条件移动到左连接ON子句中，以在连接时过滤XMAIR_MANUAL_BASIC_INFO表；并为保持语义，在typeIdsByMfId条件存在时添加`xmbi.PKID IS NOT NULL`条件（替代原xmbi.TYPE_ID过滤效果）。这减少了参与连接的数据量，提升了查询效率。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"没有LIMIT的子查询排序消除,消除子查询w中无用的ORDER BY排序（order by sumNumber desc），因为：1) 子查询作为LEFT JOIN源表且无LIMIT；2) JOIN操作会重新组织数据，使子查询排序失效；3) 移除冗余排序可提升执行效率\"}, {\"rule_id\": \"4\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,优化了时间筛选条件中的隐式转换风险：1) 将简化的日期格式改为完整时间戳格式 2) 调整起始时间的比较运算符 3) 消除了Oracle需要补全时间部分的隐式转换开销\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE SYS_READ_HIS_LOG_SEQ; CREATE TABLE SYS_READ_HIS_LOG (PKID NUMBER PRIMARY KEY, FD_MODEL_ID NUMBER, FD_MODEL_NAME VARCHAR2(200), FD_READ_TIME TIMESTAMP); CREATE OR REPLACE TRIGGER SYS_READ_HIS_LOG_BI BEFORE INSERT ON SYS_READ_HIS_LOG FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT SYS_READ_HIS_LOG_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_sys_read_model_name ON SYS_READ_HIS_LOG(FD_MODEL_NAME);\nCREATE INDEX idx_sys_read_model_id ON SYS_READ_HIS_LOG(FD_MODEL_ID);\nCREATE INDEX idx_sys_read_time ON SYS_READ_HIS_LOG(FD_READ_TIME);\nCREATE SEQUENCE MANUAL_FILE_SEQ; CREATE TABLE MANUAL_FILE (FD_ID NUMBER PRIMARY KEY, FD_FILE_ID NUMBER); CREATE OR REPLACE TRIGGER MANUAL_FILE_BI BEFORE INSERT ON MANUAL_FILE FOR EACH ROW BEGIN IF :NEW.FD_ID IS NULL THEN SELECT MANUAL_FILE_SEQ.NEXTVAL INTO :NEW.FD_ID FROM DUAL; END IF; END;\nCREATE INDEX idx_manual_file_id ON MANUAL_FILE(FD_FILE_ID);\nCREATE SEQUENCE MANUAL_FILE_BASIC_INFO_SEQ; CREATE TABLE MANUAL_FILE_BASIC_INFO (PKID NUMBER PRIMARY KEY, FD_FILE_NAME VARCHAR2(200), FD_NO VARCHAR2(100), MANUAL_ID NUMBER, IS_DELETED VARCHAR2(1) DEFAULT '0'); CREATE OR REPLACE TRIGGER MANUAL_FILE_BASIC_INFO_BI BEFORE INSERT ON MANUAL_FILE_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT MANUAL_FILE_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_mfbi_manual_id ON MANUAL_FILE_BASIC_INFO(MANUAL_ID);\nCREATE INDEX idx_mfbi_is_deleted ON MANUAL_FILE_BASIC_INFO(IS_DELETED);\nCREATE SEQUENCE XMAIR_MANUAL_BASIC_INFO_SEQ; CREATE TABLE XMAIR_MANUAL_BASIC_INFO (PKID NUMBER PRIMARY KEY, TYPE_ID NUMBER); CREATE OR REPLACE TRIGGER XMAIR_MANUAL_BASIC_INFO_BI BEFORE INSERT ON XMAIR_MANUAL_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT XMAIR_MANUAL_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_xmbi_type_id ON XMAIR_MANUAL_BASIC_INFO(TYPE_ID);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t101\t10\t670\t32701838\t100\n1\t  COUNT STOPKEY \t\t\t\t\t\n2\t  NESTED LOOPS  \t101\t10\t670\t32701838\t100\n3\t   NESTED LOOPS  \t101\t20\t670\t32701838\t100\n4\t  VIEW  \t61\t1000\t26000\t32373380\t60\n5\t  SORT ORDER BY \t3030\t1000\t29000\t1618668956\t2986\n6\t   HASH GROUP BY \t3030\t1000\t29000\t1618668956\t2986\n7\t  VIEW  \t3028\t1000\t29000\t1544033810\t2986\n8\t  HASH JOIN OUTER \t3028\t1000\t33000\t1544033810\t2986\n9\t   NESTED LOOPS OUTER \t3028\t1000\t33000\t1544033810\t2986\n10\t  STATISTICS COLLECTOR  \t\t\t\t\t\n11\t  VIEW  VW_GBF_8\t2497\t1000\t26000\t1259582159\t2463\n12\t   HASH GROUP BY \t2497\t1000\t46000\t1259582159\t2463\n13\t  TABLE ACCESS FULL SYS_READ_HIS_LOG\t2472\t1000000\t46000000\t324705404\t2463\n14\t  TABLE ACCESS BY INDEX ROWID MANUAL_FILE\t528\t1\t7\t183701651\t523\n15\t  INDEX UNIQUE SCAN SYS_C008302\t\t\t\t\t\n16\t   TABLE ACCESS FULL MANUAL_FILE\t528\t1000000\t7000000\t183701651\t523\n17\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n18\t   TABLE ACCESS BY INDEX ROWID MANUAL_FILE_BASIC_INFO\t2\t1\t41\t16423\t2\n\n## Original SQL:\nSELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (\n  SELECT  max(FD_MODEL_ID) FD_MODEL_ID,sum(countNumber) sumNumber ,max(FD_FILE_ID) FD_FILE_ID FROM (\n  SELECT FD_MODEL_ID,count(1) countNumber from\n  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL\n  <if test=\"startDate != null and startDate != ''\">\n   and FD_READ_TIME >= to_date(#{startDate},'yyyy-mm-dd')\n  </if>\n  <if test=\"endDate != null and endDate != ''\">\n   and FD_READ_TIME &lt;= to_date(#{endDate},'yyyy-mm-dd')\n  </if>\n  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID\n  GROUP BY FD_FILE_ID order by  sumNumber desc ) w\n  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi\n  ON mfbi.PKID = w.FD_FILE_ID\n  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID\n  <where>\n   mfbi.IS_DELETED = '0'\n   <if test=\" typeIdsByMfId != null  and typeIdsByMfId.size>0\">\n  and  xmbi.TYPE_ID in\n  <foreach collection=\"typeIdsByMfId\" item=\"typeId\" open=\"(\" separator=\",\" close=\")\">\n  #{typeId}\n  </foreach>\n   </if>\n   and rownum <![CDATA[ <= ]]> 10\n  </where>\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO,w.sumNumber countNumber FROM (SELECT FD_FILE_ID,sumNumber FROM (SELECT mf.FD_FILE_ID,SUM(cnt) sumNumber FROM (SELECT FD_MODEL_ID,COUNT(*) cnt FROM SYS_READ_HIS_LOG WHERE FD_MODEL_NAME='com.xmair.core.entity.DO.XmairManualFileNew' AND FD_MODEL_ID IS NOT NULL GROUP BY FD_MODEL_ID) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID=t.FD_MODEL_ID GROUP BY mf.FD_FILE_ID ORDER BY sumNumber DESC) WHERE ROWNUM<=10) w LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi ON mfbi.PKID=w.FD_FILE_ID LEFT JOIN XMAIR_MANUAL_BASIC_INFO xmbi ON xmbi.PKID=mfbi.MANUAL_ID WHERE mfbi.IS_DELETED='0'"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "22",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"22\", \"db_type\": \"oracle\", \"description\": \"此次改写主要采用了谓词下推技术，试图通过提前过滤减少数据量。同时移除了内层不必要的ORDER BY操作（因为最外层使用ROWNUM限制结果集），理论上可以节省排序成本。还优化了日期比较条件，使其更加精确。然而，由于过滤条件位置调整不当，导致了SQL语义发生变化。\", \"create_table_statements\": [\"CREATE SEQUENCE SYS_READ_HIS_LOG_SEQ; CREATE TABLE SYS_READ_HIS_LOG (PKID NUMBER PRIMARY KEY, FD_MODEL_ID NUMBER, FD_MODEL_NAME VARCHAR2(200), FD_READ_TIME TIMESTAMP); CREATE OR REPLACE TRIGGER SYS_READ_HIS_LOG_BI BEFORE INSERT ON SYS_READ_HIS_LOG FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT SYS_READ_HIS_LOG_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_sys_read_model_name ON SYS_READ_HIS_LOG(FD_MODEL_NAME);\", \"CREATE INDEX idx_sys_read_model_id ON SYS_READ_HIS_LOG(FD_MODEL_ID);\", \"CREATE INDEX idx_sys_read_time ON SYS_READ_HIS_LOG(FD_READ_TIME);\", \"CREATE SEQUENCE MANUAL_FILE_SEQ; CREATE TABLE MANUAL_FILE (FD_ID NUMBER PRIMARY KEY, FD_FILE_ID NUMBER); CREATE OR REPLACE TRIGGER MANUAL_FILE_BI BEFORE INSERT ON MANUAL_FILE FOR EACH ROW BEGIN IF :NEW.FD_ID IS NULL THEN SELECT MANUAL_FILE_SEQ.NEXTVAL INTO :NEW.FD_ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_manual_file_id ON MANUAL_FILE(FD_FILE_ID);\", \"CREATE SEQUENCE MANUAL_FILE_BASIC_INFO_SEQ; CREATE TABLE MANUAL_FILE_BASIC_INFO (PKID NUMBER PRIMARY KEY, FD_FILE_NAME VARCHAR2(200), FD_NO VARCHAR2(100), MANUAL_ID NUMBER, IS_DELETED VARCHAR2(1) DEFAULT '0'); CREATE OR REPLACE TRIGGER MANUAL_FILE_BASIC_INFO_BI BEFORE INSERT ON MANUAL_FILE_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT MANUAL_FILE_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mfbi_manual_id ON MANUAL_FILE_BASIC_INFO(MANUAL_ID);\", \"CREATE INDEX idx_mfbi_is_deleted ON MANUAL_FILE_BASIC_INFO(IS_DELETED);\", \"CREATE SEQUENCE XMAIR_MANUAL_BASIC_INFO_SEQ; CREATE TABLE XMAIR_MANUAL_BASIC_INFO (PKID NUMBER PRIMARY KEY, TYPE_ID NUMBER); CREATE OR REPLACE TRIGGER XMAIR_MANUAL_BASIC_INFO_BI BEFORE INSERT ON XMAIR_MANUAL_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT XMAIR_MANUAL_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_xmbi_type_id ON XMAIR_MANUAL_BASIC_INFO(TYPE_ID);\"], \"sql\": \"SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (\\n  SELECT  max(FD_MODEL_ID) FD_MODEL_ID,sum(countNumber) sumNumber ,max(FD_FILE_ID) FD_FILE_ID FROM (\\n  SELECT FD_MODEL_ID,count(1) countNumber from\\n  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL\\n  <if test=\\\"startDate != null and startDate != ''\\\">\\n   and FD_READ_TIME >= to_date(#{startDate},'yyyy-mm-dd')\\n  </if>\\n  <if test=\\\"endDate != null and endDate != ''\\\">\\n   and FD_READ_TIME &lt;= to_date(#{endDate},'yyyy-mm-dd')\\n  </if>\\n  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID\\n  GROUP BY FD_FILE_ID order by  sumNumber desc ) w\\n  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi\\n  ON mfbi.PKID = w.FD_FILE_ID\\n  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID\\n  <where>\\n   mfbi.IS_DELETED = '0'\\n   <if test=\\\" typeIdsByMfId != null  and typeIdsByMfId.size>0\\\">\\n  and  xmbi.TYPE_ID in\\n  <foreach collection=\\\"typeIdsByMfId\\\" item=\\\"typeId\\\" open=\\\"(\\\" separator=\\\",\\\" close=\\\")\\\">\\n  #{typeId}\\n  </foreach>\\n   </if>\\n   and rownum <![CDATA[ <= ]]> 10\\n  </where>\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t101\\t10\\t670\\t32701838\\t100\\n1\\t  COUNT STOPKEY \\t\\t\\t\\t\\t\\n2\\t  NESTED LOOPS  \\t101\\t10\\t670\\t32701838\\t100\\n3\\t   NESTED LOOPS  \\t101\\t20\\t670\\t32701838\\t100\\n4\\t  VIEW  \\t61\\t1000\\t26000\\t32373380\\t60\\n5\\t  SORT ORDER BY \\t3030\\t1000\\t29000\\t1618668956\\t2986\\n6\\t   HASH GROUP BY \\t3030\\t1000\\t29000\\t1618668956\\t2986\\n7\\t  VIEW  \\t3028\\t1000\\t29000\\t1544033810\\t2986\\n8\\t  HASH JOIN OUTER \\t3028\\t1000\\t33000\\t1544033810\\t2986\\n9\\t   NESTED LOOPS OUTER \\t3028\\t1000\\t33000\\t1544033810\\t2986\\n10\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n11\\t  VIEW  VW_GBF_8\\t2497\\t1000\\t26000\\t1259582159\\t2463\\n12\\t   HASH GROUP BY \\t2497\\t1000\\t46000\\t1259582159\\t2463\\n13\\t  TABLE ACCESS FULL SYS_READ_HIS_LOG\\t2472\\t1000000\\t46000000\\t324705404\\t2463\\n14\\t  TABLE ACCESS BY INDEX ROWID MANUAL_FILE\\t528\\t1\\t7\\t183701651\\t523\\n15\\t  INDEX UNIQUE SCAN SYS_C008302\\t\\t\\t\\t\\t\\n16\\t   TABLE ACCESS FULL MANUAL_FILE\\t528\\t1000000\\t7000000\\t183701651\\t523\\n17\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n18\\t   TABLE ACCESS BY INDEX ROWID MANUAL_FILE_BASIC_INFO\\t2\\t1\\t41\\t16423\\t2\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推优化，移除了子查询w中未被外部使用的列FD_MODEL_ID。该列在聚合后未传递到外层查询，属于冗余投影。消除该列可减少约30%-50%的临时表内存占用和I/O开销，尤其当数据量大（如10万行以上）时，性能提升更显著。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将外层WHERE条件中的mfbi.IS_DELETED='0'下推至子查询，提前过滤MANUAL_FILE_BASIC_INFO表。同时将xmbi.TYPE_ID条件移动到左连接ON子句中，以在连接时过滤XMAIR_MANUAL_BASIC_INFO表；并为保持语义，在typeIdsByMfId条件存在时添加`xmbi.PKID IS NOT NULL`条件（替代原xmbi.TYPE_ID过滤效果）。这减少了参与连接的数据量，提升了查询效率。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"没有LIMIT的子查询排序消除,消除子查询w中无用的ORDER BY排序（order by sumNumber desc），因为：1) 子查询作为LEFT JOIN源表且无LIMIT；2) JOIN操作会重新组织数据，使子查询排序失效；3) 移除冗余排序可提升执行效率\"}, {\"rule_id\": \"4\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,优化了时间筛选条件中的隐式转换风险：1) 将简化的日期格式改为完整时间戳格式 2) 调整起始时间的比较运算符 3) 消除了Oracle需要补全时间部分的隐式转换开销\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE SYS_READ_HIS_LOG_SEQ; CREATE TABLE SYS_READ_HIS_LOG (PKID NUMBER PRIMARY KEY, FD_MODEL_ID NUMBER, FD_MODEL_NAME VARCHAR2(200), FD_READ_TIME TIMESTAMP); CREATE OR REPLACE TRIGGER SYS_READ_HIS_LOG_BI BEFORE INSERT ON SYS_READ_HIS_LOG FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT SYS_READ_HIS_LOG_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_sys_read_model_name ON SYS_READ_HIS_LOG(FD_MODEL_NAME);\nCREATE INDEX idx_sys_read_model_id ON SYS_READ_HIS_LOG(FD_MODEL_ID);\nCREATE INDEX idx_sys_read_time ON SYS_READ_HIS_LOG(FD_READ_TIME);\nCREATE SEQUENCE MANUAL_FILE_SEQ; CREATE TABLE MANUAL_FILE (FD_ID NUMBER PRIMARY KEY, FD_FILE_ID NUMBER); CREATE OR REPLACE TRIGGER MANUAL_FILE_BI BEFORE INSERT ON MANUAL_FILE FOR EACH ROW BEGIN IF :NEW.FD_ID IS NULL THEN SELECT MANUAL_FILE_SEQ.NEXTVAL INTO :NEW.FD_ID FROM DUAL; END IF; END;\nCREATE INDEX idx_manual_file_id ON MANUAL_FILE(FD_FILE_ID);\nCREATE SEQUENCE MANUAL_FILE_BASIC_INFO_SEQ; CREATE TABLE MANUAL_FILE_BASIC_INFO (PKID NUMBER PRIMARY KEY, FD_FILE_NAME VARCHAR2(200), FD_NO VARCHAR2(100), MANUAL_ID NUMBER, IS_DELETED VARCHAR2(1) DEFAULT '0'); CREATE OR REPLACE TRIGGER MANUAL_FILE_BASIC_INFO_BI BEFORE INSERT ON MANUAL_FILE_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT MANUAL_FILE_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_mfbi_manual_id ON MANUAL_FILE_BASIC_INFO(MANUAL_ID);\nCREATE INDEX idx_mfbi_is_deleted ON MANUAL_FILE_BASIC_INFO(IS_DELETED);\nCREATE SEQUENCE XMAIR_MANUAL_BASIC_INFO_SEQ; CREATE TABLE XMAIR_MANUAL_BASIC_INFO (PKID NUMBER PRIMARY KEY, TYPE_ID NUMBER); CREATE OR REPLACE TRIGGER XMAIR_MANUAL_BASIC_INFO_BI BEFORE INSERT ON XMAIR_MANUAL_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT XMAIR_MANUAL_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_xmbi_type_id ON XMAIR_MANUAL_BASIC_INFO(TYPE_ID);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t101\t10\t670\t32701838\t100\n1\t  COUNT STOPKEY \t\t\t\t\t\n2\t  NESTED LOOPS  \t101\t10\t670\t32701838\t100\n3\t   NESTED LOOPS  \t101\t20\t670\t32701838\t100\n4\t  VIEW  \t61\t1000\t26000\t32373380\t60\n5\t  SORT ORDER BY \t3030\t1000\t29000\t1618668956\t2986\n6\t   HASH GROUP BY \t3030\t1000\t29000\t1618668956\t2986\n7\t  VIEW  \t3028\t1000\t29000\t1544033810\t2986\n8\t  HASH JOIN OUTER \t3028\t1000\t33000\t1544033810\t2986\n9\t   NESTED LOOPS OUTER \t3028\t1000\t33000\t1544033810\t2986\n10\t  STATISTICS COLLECTOR  \t\t\t\t\t\n11\t  VIEW  VW_GBF_8\t2497\t1000\t26000\t1259582159\t2463\n12\t   HASH GROUP BY \t2497\t1000\t46000\t1259582159\t2463\n13\t  TABLE ACCESS FULL SYS_READ_HIS_LOG\t2472\t1000000\t46000000\t324705404\t2463\n14\t  TABLE ACCESS BY INDEX ROWID MANUAL_FILE\t528\t1\t7\t183701651\t523\n15\t  INDEX UNIQUE SCAN SYS_C008302\t\t\t\t\t\n16\t   TABLE ACCESS FULL MANUAL_FILE\t528\t1000000\t7000000\t183701651\t523\n17\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n18\t   TABLE ACCESS BY INDEX ROWID MANUAL_FILE_BASIC_INFO\t2\t1\t41\t16423\t2\n\n## Original SQL:\nSELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (\n  SELECT  max(FD_MODEL_ID) FD_MODEL_ID,sum(countNumber) sumNumber ,max(FD_FILE_ID) FD_FILE_ID FROM (\n  SELECT FD_MODEL_ID,count(1) countNumber from\n  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL\n  <if test=\"startDate != null and startDate != ''\">\n   and FD_READ_TIME >= to_date(#{startDate},'yyyy-mm-dd')\n  </if>\n  <if test=\"endDate != null and endDate != ''\">\n   and FD_READ_TIME &lt;= to_date(#{endDate},'yyyy-mm-dd')\n  </if>\n  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID\n  GROUP BY FD_FILE_ID order by  sumNumber desc ) w\n  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi\n  ON mfbi.PKID = w.FD_FILE_ID\n  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID\n  <where>\n   mfbi.IS_DELETED = '0'\n   <if test=\" typeIdsByMfId != null  and typeIdsByMfId.size>0\">\n  and  xmbi.TYPE_ID in\n  <foreach collection=\"typeIdsByMfId\" item=\"typeId\" open=\"(\" separator=\",\" close=\")\">\n  #{typeId}\n  </foreach>\n   </if>\n   and rownum <![CDATA[ <= ]]> 10\n  </where>\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO,w.sumNumber countNumber FROM (SELECT FD_FILE_ID,sumNumber FROM (SELECT mf.FD_FILE_ID,SUM(cnt) sumNumber FROM (SELECT FD_MODEL_ID,COUNT(*) cnt FROM SYS_READ_HIS_LOG WHERE FD_MODEL_NAME='com.xmair.core.entity.DO.XmairManualFileNew' AND FD_MODEL_ID IS NOT NULL GROUP BY FD_MODEL_ID) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID=t.FD_MODEL_ID GROUP BY mf.FD_FILE_ID ORDER BY sumNumber DESC) WHERE ROWNUM<=10) w LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi ON mfbi.PKID=w.FD_FILE_ID LEFT JOIN XMAIR_MANUAL_BASIC_INFO xmbi ON xmbi.PKID=mfbi.MANUAL_ID WHERE mfbi.IS_DELETED='0'"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "22",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"22\", \"db_type\": \"oracle\", \"description\": \"此次改写主要采用了谓词下推技术，试图通过提前过滤减少数据量。同时移除了内层不必要的ORDER BY操作（因为最外层使用ROWNUM限制结果集），理论上可以节省排序成本。还优化了日期比较条件，使其更加精确。然而，由于过滤条件位置调整不当，导致了SQL语义发生变化。\", \"create_table_statements\": [\"CREATE SEQUENCE SYS_READ_HIS_LOG_SEQ; CREATE TABLE SYS_READ_HIS_LOG (PKID NUMBER PRIMARY KEY, FD_MODEL_ID NUMBER, FD_MODEL_NAME VARCHAR2(200), FD_READ_TIME TIMESTAMP); CREATE OR REPLACE TRIGGER SYS_READ_HIS_LOG_BI BEFORE INSERT ON SYS_READ_HIS_LOG FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT SYS_READ_HIS_LOG_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_sys_read_model_name ON SYS_READ_HIS_LOG(FD_MODEL_NAME);\", \"CREATE INDEX idx_sys_read_model_id ON SYS_READ_HIS_LOG(FD_MODEL_ID);\", \"CREATE INDEX idx_sys_read_time ON SYS_READ_HIS_LOG(FD_READ_TIME);\", \"CREATE SEQUENCE MANUAL_FILE_SEQ; CREATE TABLE MANUAL_FILE (FD_ID NUMBER PRIMARY KEY, FD_FILE_ID NUMBER); CREATE OR REPLACE TRIGGER MANUAL_FILE_BI BEFORE INSERT ON MANUAL_FILE FOR EACH ROW BEGIN IF :NEW.FD_ID IS NULL THEN SELECT MANUAL_FILE_SEQ.NEXTVAL INTO :NEW.FD_ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_manual_file_id ON MANUAL_FILE(FD_FILE_ID);\", \"CREATE SEQUENCE MANUAL_FILE_BASIC_INFO_SEQ; CREATE TABLE MANUAL_FILE_BASIC_INFO (PKID NUMBER PRIMARY KEY, FD_FILE_NAME VARCHAR2(200), FD_NO VARCHAR2(100), MANUAL_ID NUMBER, IS_DELETED VARCHAR2(1) DEFAULT '0'); CREATE OR REPLACE TRIGGER MANUAL_FILE_BASIC_INFO_BI BEFORE INSERT ON MANUAL_FILE_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT MANUAL_FILE_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mfbi_manual_id ON MANUAL_FILE_BASIC_INFO(MANUAL_ID);\", \"CREATE INDEX idx_mfbi_is_deleted ON MANUAL_FILE_BASIC_INFO(IS_DELETED);\", \"CREATE SEQUENCE XMAIR_MANUAL_BASIC_INFO_SEQ; CREATE TABLE XMAIR_MANUAL_BASIC_INFO (PKID NUMBER PRIMARY KEY, TYPE_ID NUMBER); CREATE OR REPLACE TRIGGER XMAIR_MANUAL_BASIC_INFO_BI BEFORE INSERT ON XMAIR_MANUAL_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT XMAIR_MANUAL_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_xmbi_type_id ON XMAIR_MANUAL_BASIC_INFO(TYPE_ID);\"], \"sql\": \"SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (\\n  SELECT  max(FD_MODEL_ID) FD_MODEL_ID,sum(countNumber) sumNumber ,max(FD_FILE_ID) FD_FILE_ID FROM (\\n  SELECT FD_MODEL_ID,count(1) countNumber from\\n  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL\\n  <if test=\\\"startDate != null and startDate != ''\\\">\\n   and FD_READ_TIME >= to_date(#{startDate},'yyyy-mm-dd')\\n  </if>\\n  <if test=\\\"endDate != null and endDate != ''\\\">\\n   and FD_READ_TIME &lt;= to_date(#{endDate},'yyyy-mm-dd')\\n  </if>\\n  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID\\n  GROUP BY FD_FILE_ID order by  sumNumber desc ) w\\n  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi\\n  ON mfbi.PKID = w.FD_FILE_ID\\n  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID\\n  <where>\\n   mfbi.IS_DELETED = '0'\\n   <if test=\\\" typeIdsByMfId != null  and typeIdsByMfId.size>0\\\">\\n  and  xmbi.TYPE_ID in\\n  <foreach collection=\\\"typeIdsByMfId\\\" item=\\\"typeId\\\" open=\\\"(\\\" separator=\\\",\\\" close=\\\")\\\">\\n  #{typeId}\\n  </foreach>\\n   </if>\\n   and rownum <![CDATA[ <= ]]> 10\\n  </where>\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t101\\t10\\t670\\t32701838\\t100\\n1\\t  COUNT STOPKEY \\t\\t\\t\\t\\t\\n2\\t  NESTED LOOPS  \\t101\\t10\\t670\\t32701838\\t100\\n3\\t   NESTED LOOPS  \\t101\\t20\\t670\\t32701838\\t100\\n4\\t  VIEW  \\t61\\t1000\\t26000\\t32373380\\t60\\n5\\t  SORT ORDER BY \\t3030\\t1000\\t29000\\t1618668956\\t2986\\n6\\t   HASH GROUP BY \\t3030\\t1000\\t29000\\t1618668956\\t2986\\n7\\t  VIEW  \\t3028\\t1000\\t29000\\t1544033810\\t2986\\n8\\t  HASH JOIN OUTER \\t3028\\t1000\\t33000\\t1544033810\\t2986\\n9\\t   NESTED LOOPS OUTER \\t3028\\t1000\\t33000\\t1544033810\\t2986\\n10\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n11\\t  VIEW  VW_GBF_8\\t2497\\t1000\\t26000\\t1259582159\\t2463\\n12\\t   HASH GROUP BY \\t2497\\t1000\\t46000\\t1259582159\\t2463\\n13\\t  TABLE ACCESS FULL SYS_READ_HIS_LOG\\t2472\\t1000000\\t46000000\\t324705404\\t2463\\n14\\t  TABLE ACCESS BY INDEX ROWID MANUAL_FILE\\t528\\t1\\t7\\t183701651\\t523\\n15\\t  INDEX UNIQUE SCAN SYS_C008302\\t\\t\\t\\t\\t\\n16\\t   TABLE ACCESS FULL MANUAL_FILE\\t528\\t1000000\\t7000000\\t183701651\\t523\\n17\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n18\\t   TABLE ACCESS BY INDEX ROWID MANUAL_FILE_BASIC_INFO\\t2\\t1\\t41\\t16423\\t2\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推优化，移除了子查询w中未被外部使用的列FD_MODEL_ID。该列在聚合后未传递到外层查询，属于冗余投影。消除该列可减少约30%-50%的临时表内存占用和I/O开销，尤其当数据量大（如10万行以上）时，性能提升更显著。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将外层WHERE条件中的mfbi.IS_DELETED='0'下推至子查询，提前过滤MANUAL_FILE_BASIC_INFO表。同时将xmbi.TYPE_ID条件移动到左连接ON子句中，以在连接时过滤XMAIR_MANUAL_BASIC_INFO表；并为保持语义，在typeIdsByMfId条件存在时添加`xmbi.PKID IS NOT NULL`条件（替代原xmbi.TYPE_ID过滤效果）。这减少了参与连接的数据量，提升了查询效率。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"没有LIMIT的子查询排序消除,消除子查询w中无用的ORDER BY排序（order by sumNumber desc），因为：1) 子查询作为LEFT JOIN源表且无LIMIT；2) JOIN操作会重新组织数据，使子查询排序失效；3) 移除冗余排序可提升执行效率\"}, {\"rule_id\": \"4\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,优化了时间筛选条件中的隐式转换风险：1) 将简化的日期格式改为完整时间戳格式 2) 调整起始时间的比较运算符 3) 消除了Oracle需要补全时间部分的隐式转换开销\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE SYS_READ_HIS_LOG_SEQ; CREATE TABLE SYS_READ_HIS_LOG (PKID NUMBER PRIMARY KEY, FD_MODEL_ID NUMBER, FD_MODEL_NAME VARCHAR2(200), FD_READ_TIME TIMESTAMP); CREATE OR REPLACE TRIGGER SYS_READ_HIS_LOG_BI BEFORE INSERT ON SYS_READ_HIS_LOG FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT SYS_READ_HIS_LOG_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_sys_read_model_name ON SYS_READ_HIS_LOG(FD_MODEL_NAME);\nCREATE INDEX idx_sys_read_model_id ON SYS_READ_HIS_LOG(FD_MODEL_ID);\nCREATE INDEX idx_sys_read_time ON SYS_READ_HIS_LOG(FD_READ_TIME);\nCREATE SEQUENCE MANUAL_FILE_SEQ; CREATE TABLE MANUAL_FILE (FD_ID NUMBER PRIMARY KEY, FD_FILE_ID NUMBER); CREATE OR REPLACE TRIGGER MANUAL_FILE_BI BEFORE INSERT ON MANUAL_FILE FOR EACH ROW BEGIN IF :NEW.FD_ID IS NULL THEN SELECT MANUAL_FILE_SEQ.NEXTVAL INTO :NEW.FD_ID FROM DUAL; END IF; END;\nCREATE INDEX idx_manual_file_id ON MANUAL_FILE(FD_FILE_ID);\nCREATE SEQUENCE MANUAL_FILE_BASIC_INFO_SEQ; CREATE TABLE MANUAL_FILE_BASIC_INFO (PKID NUMBER PRIMARY KEY, FD_FILE_NAME VARCHAR2(200), FD_NO VARCHAR2(100), MANUAL_ID NUMBER, IS_DELETED VARCHAR2(1) DEFAULT '0'); CREATE OR REPLACE TRIGGER MANUAL_FILE_BASIC_INFO_BI BEFORE INSERT ON MANUAL_FILE_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT MANUAL_FILE_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_mfbi_manual_id ON MANUAL_FILE_BASIC_INFO(MANUAL_ID);\nCREATE INDEX idx_mfbi_is_deleted ON MANUAL_FILE_BASIC_INFO(IS_DELETED);\nCREATE SEQUENCE XMAIR_MANUAL_BASIC_INFO_SEQ; CREATE TABLE XMAIR_MANUAL_BASIC_INFO (PKID NUMBER PRIMARY KEY, TYPE_ID NUMBER); CREATE OR REPLACE TRIGGER XMAIR_MANUAL_BASIC_INFO_BI BEFORE INSERT ON XMAIR_MANUAL_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT XMAIR_MANUAL_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_xmbi_type_id ON XMAIR_MANUAL_BASIC_INFO(TYPE_ID);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t101\t10\t670\t32701838\t100\n1\t  COUNT STOPKEY \t\t\t\t\t\n2\t  NESTED LOOPS  \t101\t10\t670\t32701838\t100\n3\t   NESTED LOOPS  \t101\t20\t670\t32701838\t100\n4\t  VIEW  \t61\t1000\t26000\t32373380\t60\n5\t  SORT ORDER BY \t3030\t1000\t29000\t1618668956\t2986\n6\t   HASH GROUP BY \t3030\t1000\t29000\t1618668956\t2986\n7\t  VIEW  \t3028\t1000\t29000\t1544033810\t2986\n8\t  HASH JOIN OUTER \t3028\t1000\t33000\t1544033810\t2986\n9\t   NESTED LOOPS OUTER \t3028\t1000\t33000\t1544033810\t2986\n10\t  STATISTICS COLLECTOR  \t\t\t\t\t\n11\t  VIEW  VW_GBF_8\t2497\t1000\t26000\t1259582159\t2463\n12\t   HASH GROUP BY \t2497\t1000\t46000\t1259582159\t2463\n13\t  TABLE ACCESS FULL SYS_READ_HIS_LOG\t2472\t1000000\t46000000\t324705404\t2463\n14\t  TABLE ACCESS BY INDEX ROWID MANUAL_FILE\t528\t1\t7\t183701651\t523\n15\t  INDEX UNIQUE SCAN SYS_C008302\t\t\t\t\t\n16\t   TABLE ACCESS FULL MANUAL_FILE\t528\t1000000\t7000000\t183701651\t523\n17\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n18\t   TABLE ACCESS BY INDEX ROWID MANUAL_FILE_BASIC_INFO\t2\t1\t41\t16423\t2\n\n## Original SQL:\nSELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (\n  SELECT  max(FD_MODEL_ID) FD_MODEL_ID,sum(countNumber) sumNumber ,max(FD_FILE_ID) FD_FILE_ID FROM (\n  SELECT FD_MODEL_ID,count(1) countNumber from\n  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL\n  <if test=\"startDate != null and startDate != ''\">\n   and FD_READ_TIME >= to_date(#{startDate},'yyyy-mm-dd')\n  </if>\n  <if test=\"endDate != null and endDate != ''\">\n   and FD_READ_TIME &lt;= to_date(#{endDate},'yyyy-mm-dd')\n  </if>\n  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID\n  GROUP BY FD_FILE_ID order by  sumNumber desc ) w\n  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi\n  ON mfbi.PKID = w.FD_FILE_ID\n  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID\n  <where>\n   mfbi.IS_DELETED = '0'\n   <if test=\" typeIdsByMfId != null  and typeIdsByMfId.size>0\">\n  and  xmbi.TYPE_ID in\n  <foreach collection=\"typeIdsByMfId\" item=\"typeId\" open=\"(\" separator=\",\" close=\")\">\n  #{typeId}\n  </foreach>\n   </if>\n   and rownum <![CDATA[ <= ]]> 10\n  </where>\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO,w.sumNumber countNumber FROM (SELECT FD_FILE_ID,sumNumber FROM (SELECT mf.FD_FILE_ID,SUM(cnt) sumNumber FROM (SELECT FD_MODEL_ID,COUNT(*) cnt FROM SYS_READ_HIS_LOG WHERE FD_MODEL_NAME='com.xmair.core.entity.DO.XmairManualFileNew' AND FD_MODEL_ID IS NOT NULL GROUP BY FD_MODEL_ID) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID=t.FD_MODEL_ID GROUP BY mf.FD_FILE_ID ORDER BY sumNumber DESC) WHERE ROWNUM<=10) w LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi ON mfbi.PKID=w.FD_FILE_ID LEFT JOIN XMAIR_MANUAL_BASIC_INFO xmbi ON xmbi.PKID=mfbi.MANUAL_ID WHERE mfbi.IS_DELETED='0'"
                    }
                ],
                "rule_id": "4"
            },
            {
                "case_id": "23",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"23\", \"db_type\": \"oracle\", \"description\": \"此次改写将子查询内部的'LEFT JOIN mrtrecordinfo B ON A.ID = B.ID'改为'INNER JOIN'。改写的理论基础是：由于外层查询使用了WHERE A.ID IN (SELECT bid FROM ...)条件，而bid来源于B.ID，这意味着只有B.ID存在的记录才会被选中。因此LEFT JOIN产生的NULL行在后续过滤中会被完全排除，使用INNER JOIN语义上等价且理论上可减少NULL处理开销。然而实际测试显示，Oracle优化器在处理原始LEFT JOIN时已经识别出这种模式并进行了等价优化，导致手动改写未产生实质性能提升。\", \"create_table_statements\": [\"CREATE SEQUENCE mrtopration_seq; CREATE TABLE mrtopration (ID NUMBER PRIMARY KEY, PRAMARYID NUMBER, OPERCODE VARCHAR2(50), OPERNAME VARCHAR2(100), OPERDEPT VARCHAR2(100), OPERDATE DATE NOT NULL, MARK VARCHAR2(500), MARK2 VARCHAR2(500), MARK3 VARCHAR2(500), MARK4 VARCHAR2(500), OPERTYPE VARCHAR2(50), NEXTOPERTYPE VARCHAR2(50), PREOPERTYPE VARCHAR2(50), VALID NUMBER(1), CONFIRMUSER VARCHAR2(100), CONFIRMDEPT VARCHAR2(100), VERSIONNUMBER NUMBER); CREATE OR REPLACE TRIGGER mrtopration_bi BEFORE INSERT ON mrtopration FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtopration_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mrtopration_operdate ON mrtopration(OPERDATE);\", \"CREATE INDEX idx_mrtopration_opercode ON mrtopration(OPERCODE);\", \"CREATE SEQUENCE mrtrecordinfo_seq; CREATE TABLE mrtrecordinfo (ID NUMBER PRIMARY KEY, IN_TIMES NUMBER, NAME VARCHAR2(100), IN_DATE DATE, OUT_DATE DATE, OUT_DEPT VARCHAR2(100), RECORD_STATE VARCHAR2(50)); CREATE OR REPLACE TRIGGER mrtrecordinfo_bi BEFORE INSERT ON mrtrecordinfo FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtrecordinfo_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mrtrecordinfo_indate ON mrtrecordinfo(IN_DATE);\", \"CREATE TABLE mrtrecordregresses (RECODE_NO NUMBER NOT NULL, OPER_DATE DATE NOT NULL, OPERID VARCHAR2(50) NOT NULL, BACKREASON VARCHAR2(500), CONSTRAINT pk_mrtrecordregresses PRIMARY KEY (RECODE_NO, OPER_DATE, OPERID));\"], \"sql\": \"SELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID WHERE A.ID IN (SELECT bid FROM (SELECT B.ID AS bid, B.IN_DATE AS inDate, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID WHERE B.ID LIKE :\\\"SYS_B_0\\\" || :1 || :\\\" SYS_B_1\\\" GROUP BY B.ID, B.IN_DATE) WHERE rn BETWEEN :2 + :\\\"SYS_B_2\\\" AND :3 + :4 ) ORDER BY A.OPERDATE DESC\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t3725\\t10\\t1950\\t907708019\\t3700\\n1\\t  SORT ORDER BY \\t3725\\t10\\t1950\\t907708019\\t3700\\n2\\t  HASH JOIN OUTER \\t3724\\t10\\t1950\\t870837954\\t3700\\n3\\t   NESTED LOOPS OUTER \\t3724\\t10\\t1950\\t870837954\\t3700\\n4\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n5\\t  HASH JOIN OUTER \\t3714\\t10\\t1560\\t870747739\\t3690\\n6\\t   NESTED LOOPS OUTER \\t3714\\t10\\t1560\\t870747739\\t3690\\n7\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n8\\t  HASH JOIN  \\t3694\\t10\\t1110\\t870583611\\t3670\\n9\\t   NESTED LOOPS  \\t3694\\t10\\t1110\\t870583611\\t3670\\n10\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n11\\t  VIEW  VW_NSO_1\\t3673\\t10\\t40\\t833547416\\t3650\\n12\\t   HASH UNIQUE \\t\\t10\\t150\\t\\t\\n13\\t  VIEW  \\t3673\\t10\\t150\\t833547416\\t3650\\n14\\t  WINDOW NOSORT STOPKEY \\t3673\\t50000\\t750000\\t833547416\\t3650\\n15\\t   SORT GROUP BY \\t3673\\t50000\\t750000\\t833547416\\t3650\\n16\\t  HASH JOIN SEMI \\t3413\\t50000\\t750000\\t757426652\\t3392\\n17\\t  TABLE ACCESS FULL MRTRECORDINFO\\t2081\\t50000\\t550000\\t407379316\\t2070\\n18\\t  INDEX FAST FULL SCAN SYS_C008302\\t514\\t1000000\\t4000000\\t133352700\\t510\\n19\\t  TABLE ACCESS BY INDEX ROWID MRTOPRATION\\t2\\t1\\t107\\t16613\\t2\\n20\\t  INDEX UNIQUE SCAN SYS_C008302\\t1\\t1\\t\\t9021\\t1\\n21\\t   TABLE ACCESS FULL MRTOPRATION\\t2\\t1\\t107\\t16613\\t2\\n22\\t  TABLE ACCESS BY INDEX ROWID MRTRECORDINFO\\t2\\t1\\t45\\t16413\\t2\\n23\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n24\\t   TABLE ACCESS FULL MRTRECORDINFO\\t2\\t1\\t45\\t16413\\t2\\n25\\t  TABLE ACCESS BY INDEX ROWID MRTRECORDREGRESSES\\t1\\t1\\t39\\t9021\\t1\\n26\\t  INDEX UNIQUE SCAN PK_MRTRECORDREGRESSES\\t1\\t1\\t\\t9021\\t1\\n27\\t   TABLE ACCESS FULL MRTRECORDREGRESSES\\t1\\t1\\t39\\t9021\\t1\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,在IN子查询内部应用投影下推，移除未使用的inDate列。窗口函数仍使用该列排序但不再物化结果，减少派生表17%的数据体积\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,将子查询中的LEFT JOIN改为INNER JOIN，因为B.ID的LIKE过滤和分组已排除NULL记录。主查询保留LEFT JOIN因输出需要C表列且无强过滤条件\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE mrtopration_seq; CREATE TABLE mrtopration (ID NUMBER PRIMARY KEY, PRAMARYID NUMBER, OPERCODE VARCHAR2(50), OPERNAME VARCHAR2(100), OPERDEPT VARCHAR2(100), OPERDATE DATE NOT NULL, MARK VARCHAR2(500), MARK2 VARCHAR2(500), MARK3 VARCHAR2(500), MARK4 VARCHAR2(500), OPERTYPE VARCHAR2(50), NEXTOPERTYPE VARCHAR2(50), PREOPERTYPE VARCHAR2(50), VALID NUMBER(1), CONFIRMUSER VARCHAR2(100), CONFIRMDEPT VARCHAR2(100), VERSIONNUMBER NUMBER); CREATE OR REPLACE TRIGGER mrtopration_bi BEFORE INSERT ON mrtopration FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtopration_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\nCREATE INDEX idx_mrtopration_operdate ON mrtopration(OPERDATE);\nCREATE INDEX idx_mrtopration_opercode ON mrtopration(OPERCODE);\nCREATE SEQUENCE mrtrecordinfo_seq; CREATE TABLE mrtrecordinfo (ID NUMBER PRIMARY KEY, IN_TIMES NUMBER, NAME VARCHAR2(100), IN_DATE DATE, OUT_DATE DATE, OUT_DEPT VARCHAR2(100), RECORD_STATE VARCHAR2(50)); CREATE OR REPLACE TRIGGER mrtrecordinfo_bi BEFORE INSERT ON mrtrecordinfo FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtrecordinfo_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\nCREATE INDEX idx_mrtrecordinfo_indate ON mrtrecordinfo(IN_DATE);\nCREATE TABLE mrtrecordregresses (RECODE_NO NUMBER NOT NULL, OPER_DATE DATE NOT NULL, OPERID VARCHAR2(50) NOT NULL, BACKREASON VARCHAR2(500), CONSTRAINT pk_mrtrecordregresses PRIMARY KEY (RECODE_NO, OPER_DATE, OPERID));\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t3725\t10\t1950\t907708019\t3700\n1\t  SORT ORDER BY \t3725\t10\t1950\t907708019\t3700\n2\t  HASH JOIN OUTER \t3724\t10\t1950\t870837954\t3700\n3\t   NESTED LOOPS OUTER \t3724\t10\t1950\t870837954\t3700\n4\t  STATISTICS COLLECTOR  \t\t\t\t\t\n5\t  HASH JOIN OUTER \t3714\t10\t1560\t870747739\t3690\n6\t   NESTED LOOPS OUTER \t3714\t10\t1560\t870747739\t3690\n7\t  STATISTICS COLLECTOR  \t\t\t\t\t\n8\t  HASH JOIN  \t3694\t10\t1110\t870583611\t3670\n9\t   NESTED LOOPS  \t3694\t10\t1110\t870583611\t3670\n10\t  STATISTICS COLLECTOR  \t\t\t\t\t\n11\t  VIEW  VW_NSO_1\t3673\t10\t40\t833547416\t3650\n12\t   HASH UNIQUE \t\t10\t150\t\t\n13\t  VIEW  \t3673\t10\t150\t833547416\t3650\n14\t  WINDOW NOSORT STOPKEY \t3673\t50000\t750000\t833547416\t3650\n15\t   SORT GROUP BY \t3673\t50000\t750000\t833547416\t3650\n16\t  HASH JOIN SEMI \t3413\t50000\t750000\t757426652\t3392\n17\t  TABLE ACCESS FULL MRTRECORDINFO\t2081\t50000\t550000\t407379316\t2070\n18\t  INDEX FAST FULL SCAN SYS_C008302\t514\t1000000\t4000000\t133352700\t510\n19\t  TABLE ACCESS BY INDEX ROWID MRTOPRATION\t2\t1\t107\t16613\t2\n20\t  INDEX UNIQUE SCAN SYS_C008302\t1\t1\t\t9021\t1\n21\t   TABLE ACCESS FULL MRTOPRATION\t2\t1\t107\t16613\t2\n22\t  TABLE ACCESS BY INDEX ROWID MRTRECORDINFO\t2\t1\t45\t16413\t2\n23\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n24\t   TABLE ACCESS FULL MRTRECORDINFO\t2\t1\t45\t16413\t2\n25\t  TABLE ACCESS BY INDEX ROWID MRTRECORDREGRESSES\t1\t1\t39\t9021\t1\n26\t  INDEX UNIQUE SCAN PK_MRTRECORDREGRESSES\t1\t1\t\t9021\t1\n27\t   TABLE ACCESS FULL MRTRECORDREGRESSES\t1\t1\t39\t9021\t1\n\n## Original SQL:\nSELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID WHERE A.ID IN (SELECT bid FROM (SELECT B.ID AS bid, B.IN_DATE AS inDate, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID WHERE B.ID LIKE :\"SYS_B_0\" || :1 || :\" SYS_B_1\" GROUP BY B.ID, B.IN_DATE) WHERE rn BETWEEN :2 + :\"SYS_B_2\" AND :3 + :4 ) ORDER BY A.OPERDATE DESC\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID WHERE A.ID IN (SELECT B.ID FROM (SELECT B.ID, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn FROM mrtrecordinfo B WHERE B.ID LIKE :\"SYS_B_0\" || :1 || :\" SYS_B_1\") WHERE rn BETWEEN :2 + :\"SYS_B_2\" AND :3 + :4) ORDER BY A.OPERDATE DESC"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "23",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"23\", \"db_type\": \"oracle\", \"description\": \"此次改写将子查询内部的'LEFT JOIN mrtrecordinfo B ON A.ID = B.ID'改为'INNER JOIN'。改写的理论基础是：由于外层查询使用了WHERE A.ID IN (SELECT bid FROM ...)条件，而bid来源于B.ID，这意味着只有B.ID存在的记录才会被选中。因此LEFT JOIN产生的NULL行在后续过滤中会被完全排除，使用INNER JOIN语义上等价且理论上可减少NULL处理开销。然而实际测试显示，Oracle优化器在处理原始LEFT JOIN时已经识别出这种模式并进行了等价优化，导致手动改写未产生实质性能提升。\", \"create_table_statements\": [\"CREATE SEQUENCE mrtopration_seq; CREATE TABLE mrtopration (ID NUMBER PRIMARY KEY, PRAMARYID NUMBER, OPERCODE VARCHAR2(50), OPERNAME VARCHAR2(100), OPERDEPT VARCHAR2(100), OPERDATE DATE NOT NULL, MARK VARCHAR2(500), MARK2 VARCHAR2(500), MARK3 VARCHAR2(500), MARK4 VARCHAR2(500), OPERTYPE VARCHAR2(50), NEXTOPERTYPE VARCHAR2(50), PREOPERTYPE VARCHAR2(50), VALID NUMBER(1), CONFIRMUSER VARCHAR2(100), CONFIRMDEPT VARCHAR2(100), VERSIONNUMBER NUMBER); CREATE OR REPLACE TRIGGER mrtopration_bi BEFORE INSERT ON mrtopration FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtopration_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mrtopration_operdate ON mrtopration(OPERDATE);\", \"CREATE INDEX idx_mrtopration_opercode ON mrtopration(OPERCODE);\", \"CREATE SEQUENCE mrtrecordinfo_seq; CREATE TABLE mrtrecordinfo (ID NUMBER PRIMARY KEY, IN_TIMES NUMBER, NAME VARCHAR2(100), IN_DATE DATE, OUT_DATE DATE, OUT_DEPT VARCHAR2(100), RECORD_STATE VARCHAR2(50)); CREATE OR REPLACE TRIGGER mrtrecordinfo_bi BEFORE INSERT ON mrtrecordinfo FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtrecordinfo_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mrtrecordinfo_indate ON mrtrecordinfo(IN_DATE);\", \"CREATE TABLE mrtrecordregresses (RECODE_NO NUMBER NOT NULL, OPER_DATE DATE NOT NULL, OPERID VARCHAR2(50) NOT NULL, BACKREASON VARCHAR2(500), CONSTRAINT pk_mrtrecordregresses PRIMARY KEY (RECODE_NO, OPER_DATE, OPERID));\"], \"sql\": \"SELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID WHERE A.ID IN (SELECT bid FROM (SELECT B.ID AS bid, B.IN_DATE AS inDate, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID WHERE B.ID LIKE :\\\"SYS_B_0\\\" || :1 || :\\\" SYS_B_1\\\" GROUP BY B.ID, B.IN_DATE) WHERE rn BETWEEN :2 + :\\\"SYS_B_2\\\" AND :3 + :4 ) ORDER BY A.OPERDATE DESC\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t3725\\t10\\t1950\\t907708019\\t3700\\n1\\t  SORT ORDER BY \\t3725\\t10\\t1950\\t907708019\\t3700\\n2\\t  HASH JOIN OUTER \\t3724\\t10\\t1950\\t870837954\\t3700\\n3\\t   NESTED LOOPS OUTER \\t3724\\t10\\t1950\\t870837954\\t3700\\n4\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n5\\t  HASH JOIN OUTER \\t3714\\t10\\t1560\\t870747739\\t3690\\n6\\t   NESTED LOOPS OUTER \\t3714\\t10\\t1560\\t870747739\\t3690\\n7\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n8\\t  HASH JOIN  \\t3694\\t10\\t1110\\t870583611\\t3670\\n9\\t   NESTED LOOPS  \\t3694\\t10\\t1110\\t870583611\\t3670\\n10\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n11\\t  VIEW  VW_NSO_1\\t3673\\t10\\t40\\t833547416\\t3650\\n12\\t   HASH UNIQUE \\t\\t10\\t150\\t\\t\\n13\\t  VIEW  \\t3673\\t10\\t150\\t833547416\\t3650\\n14\\t  WINDOW NOSORT STOPKEY \\t3673\\t50000\\t750000\\t833547416\\t3650\\n15\\t   SORT GROUP BY \\t3673\\t50000\\t750000\\t833547416\\t3650\\n16\\t  HASH JOIN SEMI \\t3413\\t50000\\t750000\\t757426652\\t3392\\n17\\t  TABLE ACCESS FULL MRTRECORDINFO\\t2081\\t50000\\t550000\\t407379316\\t2070\\n18\\t  INDEX FAST FULL SCAN SYS_C008302\\t514\\t1000000\\t4000000\\t133352700\\t510\\n19\\t  TABLE ACCESS BY INDEX ROWID MRTOPRATION\\t2\\t1\\t107\\t16613\\t2\\n20\\t  INDEX UNIQUE SCAN SYS_C008302\\t1\\t1\\t\\t9021\\t1\\n21\\t   TABLE ACCESS FULL MRTOPRATION\\t2\\t1\\t107\\t16613\\t2\\n22\\t  TABLE ACCESS BY INDEX ROWID MRTRECORDINFO\\t2\\t1\\t45\\t16413\\t2\\n23\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n24\\t   TABLE ACCESS FULL MRTRECORDINFO\\t2\\t1\\t45\\t16413\\t2\\n25\\t  TABLE ACCESS BY INDEX ROWID MRTRECORDREGRESSES\\t1\\t1\\t39\\t9021\\t1\\n26\\t  INDEX UNIQUE SCAN PK_MRTRECORDREGRESSES\\t1\\t1\\t\\t9021\\t1\\n27\\t   TABLE ACCESS FULL MRTRECORDREGRESSES\\t1\\t1\\t39\\t9021\\t1\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,在IN子查询内部应用投影下推，移除未使用的inDate列。窗口函数仍使用该列排序但不再物化结果，减少派生表17%的数据体积\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,将子查询中的LEFT JOIN改为INNER JOIN，因为B.ID的LIKE过滤和分组已排除NULL记录。主查询保留LEFT JOIN因输出需要C表列且无强过滤条件\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE mrtopration_seq; CREATE TABLE mrtopration (ID NUMBER PRIMARY KEY, PRAMARYID NUMBER, OPERCODE VARCHAR2(50), OPERNAME VARCHAR2(100), OPERDEPT VARCHAR2(100), OPERDATE DATE NOT NULL, MARK VARCHAR2(500), MARK2 VARCHAR2(500), MARK3 VARCHAR2(500), MARK4 VARCHAR2(500), OPERTYPE VARCHAR2(50), NEXTOPERTYPE VARCHAR2(50), PREOPERTYPE VARCHAR2(50), VALID NUMBER(1), CONFIRMUSER VARCHAR2(100), CONFIRMDEPT VARCHAR2(100), VERSIONNUMBER NUMBER); CREATE OR REPLACE TRIGGER mrtopration_bi BEFORE INSERT ON mrtopration FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtopration_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\nCREATE INDEX idx_mrtopration_operdate ON mrtopration(OPERDATE);\nCREATE INDEX idx_mrtopration_opercode ON mrtopration(OPERCODE);\nCREATE SEQUENCE mrtrecordinfo_seq; CREATE TABLE mrtrecordinfo (ID NUMBER PRIMARY KEY, IN_TIMES NUMBER, NAME VARCHAR2(100), IN_DATE DATE, OUT_DATE DATE, OUT_DEPT VARCHAR2(100), RECORD_STATE VARCHAR2(50)); CREATE OR REPLACE TRIGGER mrtrecordinfo_bi BEFORE INSERT ON mrtrecordinfo FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtrecordinfo_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\nCREATE INDEX idx_mrtrecordinfo_indate ON mrtrecordinfo(IN_DATE);\nCREATE TABLE mrtrecordregresses (RECODE_NO NUMBER NOT NULL, OPER_DATE DATE NOT NULL, OPERID VARCHAR2(50) NOT NULL, BACKREASON VARCHAR2(500), CONSTRAINT pk_mrtrecordregresses PRIMARY KEY (RECODE_NO, OPER_DATE, OPERID));\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t3725\t10\t1950\t907708019\t3700\n1\t  SORT ORDER BY \t3725\t10\t1950\t907708019\t3700\n2\t  HASH JOIN OUTER \t3724\t10\t1950\t870837954\t3700\n3\t   NESTED LOOPS OUTER \t3724\t10\t1950\t870837954\t3700\n4\t  STATISTICS COLLECTOR  \t\t\t\t\t\n5\t  HASH JOIN OUTER \t3714\t10\t1560\t870747739\t3690\n6\t   NESTED LOOPS OUTER \t3714\t10\t1560\t870747739\t3690\n7\t  STATISTICS COLLECTOR  \t\t\t\t\t\n8\t  HASH JOIN  \t3694\t10\t1110\t870583611\t3670\n9\t   NESTED LOOPS  \t3694\t10\t1110\t870583611\t3670\n10\t  STATISTICS COLLECTOR  \t\t\t\t\t\n11\t  VIEW  VW_NSO_1\t3673\t10\t40\t833547416\t3650\n12\t   HASH UNIQUE \t\t10\t150\t\t\n13\t  VIEW  \t3673\t10\t150\t833547416\t3650\n14\t  WINDOW NOSORT STOPKEY \t3673\t50000\t750000\t833547416\t3650\n15\t   SORT GROUP BY \t3673\t50000\t750000\t833547416\t3650\n16\t  HASH JOIN SEMI \t3413\t50000\t750000\t757426652\t3392\n17\t  TABLE ACCESS FULL MRTRECORDINFO\t2081\t50000\t550000\t407379316\t2070\n18\t  INDEX FAST FULL SCAN SYS_C008302\t514\t1000000\t4000000\t133352700\t510\n19\t  TABLE ACCESS BY INDEX ROWID MRTOPRATION\t2\t1\t107\t16613\t2\n20\t  INDEX UNIQUE SCAN SYS_C008302\t1\t1\t\t9021\t1\n21\t   TABLE ACCESS FULL MRTOPRATION\t2\t1\t107\t16613\t2\n22\t  TABLE ACCESS BY INDEX ROWID MRTRECORDINFO\t2\t1\t45\t16413\t2\n23\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n24\t   TABLE ACCESS FULL MRTRECORDINFO\t2\t1\t45\t16413\t2\n25\t  TABLE ACCESS BY INDEX ROWID MRTRECORDREGRESSES\t1\t1\t39\t9021\t1\n26\t  INDEX UNIQUE SCAN PK_MRTRECORDREGRESSES\t1\t1\t\t9021\t1\n27\t   TABLE ACCESS FULL MRTRECORDREGRESSES\t1\t1\t39\t9021\t1\n\n## Original SQL:\nSELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID WHERE A.ID IN (SELECT bid FROM (SELECT B.ID AS bid, B.IN_DATE AS inDate, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID WHERE B.ID LIKE :\"SYS_B_0\" || :1 || :\" SYS_B_1\" GROUP BY B.ID, B.IN_DATE) WHERE rn BETWEEN :2 + :\"SYS_B_2\" AND :3 + :4 ) ORDER BY A.OPERDATE DESC\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID WHERE A.ID IN (SELECT B.ID FROM (SELECT B.ID, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn FROM mrtrecordinfo B WHERE B.ID LIKE :\"SYS_B_0\" || :1 || :\" SYS_B_1\") WHERE rn BETWEEN :2 + :\"SYS_B_2\" AND :3 + :4) ORDER BY A.OPERDATE DESC"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "24",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"24\", \"db_type\": \"oracle\", \"description\": \"这是一种经典的UNION ALL消除优化技术。当UNION ALL的多个分支查询相同的表，且仅在SELECT列表的计算逻辑或WHERE条件的常量值上有差异时，可以通过CASE表达式将不同的计算逻辑统一到一个SELECT语句中。改写的核心是将'metric_name IN (集合1) 返回round(VALUE,2)'和'metric_name IN (集合2) 返回round(VALUE*10,2)'两个分支，合并为'metric_name IN (集合1+集合2) 返回CASE WHEN...END'。这样WHERE条件从两次分别过滤变为一次过滤更大的集合，SELECT列表使用CASE根据metric_name动态选择计算方式。这种改写在保证逻辑等价的前提下，显著减少了I/O操作。\", \"create_table_statements\": [\"CREATE SEQUENCE gv_session_seq; CREATE TABLE gv$session (session_id NUMBER PRIMARY KEY, inst_id NUMBER NOT NULL, TYPE VARCHAR2(20) NOT NULL, status VARCHAR2(20)); CREATE OR REPLACE TRIGGER gv_session_bi BEFORE INSERT ON gv$session FOR EACH ROW BEGIN IF :NEW.session_id IS NULL THEN SELECT gv_session_seq.NEXTVAL INTO :NEW.session_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_gv_session_inst_id ON gv$session(inst_id);\", \"CREATE INDEX idx_gv_session_type_status ON gv$session(TYPE, status);\", \"CREATE SEQUENCE gv_sysmetric_seq; CREATE TABLE gv$sysmetric (metric_id NUMBER PRIMARY KEY, inst_id NUMBER NOT NULL, end_time TIMESTAMP NOT NULL, metric_name VARCHAR2(100) NOT NULL, VALUE NUMBER(20,2), intsize_csec NUMBER); CREATE OR REPLACE TRIGGER gv_sysmetric_bi BEFORE INSERT ON gv$sysmetric FOR EACH ROW BEGIN IF :NEW.metric_id IS NULL THEN SELECT gv_sysmetric_seq.NEXTVAL INTO :NEW.metric_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_gv_sysmetric_inst_id ON gv$sysmetric(inst_id);\", \"CREATE INDEX idx_gv_sysmetric_intsize ON gv$sysmetric(intsize_csec);\", \"CREATE INDEX idx_gv_sysmetric_metric_name ON gv$sysmetric(metric_name);\"], \"sql\": \"SELECT\\n  c.inst_id,\\n  m.end_time AS checktime,\\n  c.conn,\\n  c.activeconn,\\n  m.sqlthroughput,\\n  m.sqlavgtime,\\n  m.user_commits,\\n  m.user_rollbacks,\\n  m.user_commits + m.user_rollbacks AS transactioncount,\\n  m.transactionavgtime\\nFROM\\n  (\\n  WITH\\n   t1 AS (\\n  SELECT\\n  inst_id,\\n  COUNT(*) conn\\n  FROM\\n  gv$session\\n  WHERE\\n  TYPE = 'USER'\\n  GROUP BY\\n  inst_id\\n   ),\\n   t2 AS (\\n  SELECT\\n  inst_id,\\n  COUNT(*) activeconn\\n  FROM\\n  gv$session\\n  WHERE\\n  TYPE = 'USER'\\n  AND status = 'ACTIVE'\\n  GROUP BY\\n  inst_id\\n   )\\n  SELECT\\n   t1.inst_id,\\n   t1.conn,\\n   t2.activeconn\\n  FROM\\n   t1,\\n   t2\\n  WHERE\\n   t1.inst_id = t2.inst_id\\n  ) c,\\n  (\\n  SELECT\\n   *\\n  FROM\\n   (\\n  SELECT\\n  inst_id,\\n  end_time,\\n  metric_name,\\n  round(VALUE, 2) VALUE\\n  FROM\\n  gv$sysmetric\\n  WHERE\\n  round(intsize_csec / 100, 0) = 60\\n  AND metric_name IN (\\n   'Executions Per Sec',\\n   'User Commits Per Sec',\\n   'User Rollbacks Per Sec'\\n  )\\n  UNION ALL\\n  SELECT\\n  inst_id,\\n  end_time,\\n  metric_name,\\n  round(VALUE * 10, 2) VALUE\\n  FROM\\n  gv$sysmetric\\n  WHERE\\n  round(intsize_csec / 100, 0) = 60\\n  AND metric_name IN (\\n   'SQL Service Response Time',\\n   'Response Time Per Txn'\\n  )\\n   ) PIVOT (\\n  AVG(VALUE) FOR metric_name IN (\\n  'Executions Per Sec' sqlthroughput,\\n  'SQL Service Response Time' sqlavgtime,\\n  'User Commits Per Sec' user_commits,\\n  'User Rollbacks Per Sec' user_rollbacks,\\n  'Response Time Per Txn' transactionavgtime\\n  )\\n   )\\n  ) m\\nWHERE\\n  c.inst_id = m.inst_id\\nORDER BY\\n  inst_id\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t6390\\t10000\\t1100000\\t2369214804\\t6326\\n1\\t  MERGE JOIN  \\t6390\\t10000\\t1100000\\t2369214804\\t6326\\n2\\t  MERGE JOIN  \\t5337\\t10000\\t950000\\t1861270817\\t5287\\n3\\t   SORT JOIN \\t4278\\t10000\\t800000\\t1093774272\\t4248\\n4\\t  VIEW  \\t4278\\t10000\\t800000\\t1093774272\\t4248\\n5\\t  HASH GROUP BY PIVOT \\t4278\\t10000\\t780000\\t1093774272\\t4248\\n6\\t   VIEW  \\t4092\\t10000\\t780000\\t1048013114\\t4064\\n7\\t  UNION-ALL  \\t\\t\\t\\t\\t\\n8\\t  TABLE ACCESS FULL GV$SYSMETRIC\\t2047\\t6000\\t246000\\t554616557\\t2032\\n9\\t  TABLE ACCESS FULL GV$SYSMETRIC\\t2045\\t4000\\t164000\\t493396557\\t2032\\n10\\t   SORT JOIN \\t1060\\t4\\t60\\t767496545\\t1039\\n11\\t  VIEW  \\t1059\\t4\\t60\\t730627615\\t1039\\n12\\t  HASH GROUP BY \\t1059\\t4\\t32\\t730627615\\t1039\\n13\\t   TABLE ACCESS FULL GV$SESSION\\t1046\\t500000\\t4000000\\t267282237\\t1039\\n14\\t  SORT JOIN \\t1053\\t4\\t60\\t507943987\\t1039\\n15\\t   VIEW  \\t1052\\t4\\t60\\t471075058\\t1039\\n16\\t  HASH GROUP BY \\t1052\\t4\\t60\\t471075058\\t1039\\n17\\t  TABLE ACCESS FULL GV$SESSION\\t1047\\t166667\\t2500005\\t303948903\\t1039\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"UNION消除优化,成功应用UNION消除优化规则，将两个访问gv$sysmetric表的UNION ALL分支合并为单次扫描。通过在SELECT列表中使用CASE表达式处理不同的数值计算逻辑，并合并metric_name过滤条件，避免重复表扫描和临时表操作。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE gv_session_seq; CREATE TABLE gv$session (session_id NUMBER PRIMARY KEY, inst_id NUMBER NOT NULL, TYPE VARCHAR2(20) NOT NULL, status VARCHAR2(20)); CREATE OR REPLACE TRIGGER gv_session_bi BEFORE INSERT ON gv$session FOR EACH ROW BEGIN IF :NEW.session_id IS NULL THEN SELECT gv_session_seq.NEXTVAL INTO :NEW.session_id FROM DUAL; END IF; END;\nCREATE INDEX idx_gv_session_inst_id ON gv$session(inst_id);\nCREATE INDEX idx_gv_session_type_status ON gv$session(TYPE, status);\nCREATE SEQUENCE gv_sysmetric_seq; CREATE TABLE gv$sysmetric (metric_id NUMBER PRIMARY KEY, inst_id NUMBER NOT NULL, end_time TIMESTAMP NOT NULL, metric_name VARCHAR2(100) NOT NULL, VALUE NUMBER(20,2), intsize_csec NUMBER); CREATE OR REPLACE TRIGGER gv_sysmetric_bi BEFORE INSERT ON gv$sysmetric FOR EACH ROW BEGIN IF :NEW.metric_id IS NULL THEN SELECT gv_sysmetric_seq.NEXTVAL INTO :NEW.metric_id FROM DUAL; END IF; END;\nCREATE INDEX idx_gv_sysmetric_inst_id ON gv$sysmetric(inst_id);\nCREATE INDEX idx_gv_sysmetric_intsize ON gv$sysmetric(intsize_csec);\nCREATE INDEX idx_gv_sysmetric_metric_name ON gv$sysmetric(metric_name);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t6390\t10000\t1100000\t2369214804\t6326\n1\t  MERGE JOIN  \t6390\t10000\t1100000\t2369214804\t6326\n2\t  MERGE JOIN  \t5337\t10000\t950000\t1861270817\t5287\n3\t   SORT JOIN \t4278\t10000\t800000\t1093774272\t4248\n4\t  VIEW  \t4278\t10000\t800000\t1093774272\t4248\n5\t  HASH GROUP BY PIVOT \t4278\t10000\t780000\t1093774272\t4248\n6\t   VIEW  \t4092\t10000\t780000\t1048013114\t4064\n7\t  UNION-ALL  \t\t\t\t\t\n8\t  TABLE ACCESS FULL GV$SYSMETRIC\t2047\t6000\t246000\t554616557\t2032\n9\t  TABLE ACCESS FULL GV$SYSMETRIC\t2045\t4000\t164000\t493396557\t2032\n10\t   SORT JOIN \t1060\t4\t60\t767496545\t1039\n11\t  VIEW  \t1059\t4\t60\t730627615\t1039\n12\t  HASH GROUP BY \t1059\t4\t32\t730627615\t1039\n13\t   TABLE ACCESS FULL GV$SESSION\t1046\t500000\t4000000\t267282237\t1039\n14\t  SORT JOIN \t1053\t4\t60\t507943987\t1039\n15\t   VIEW  \t1052\t4\t60\t471075058\t1039\n16\t  HASH GROUP BY \t1052\t4\t60\t471075058\t1039\n17\t  TABLE ACCESS FULL GV$SESSION\t1047\t166667\t2500005\t303948903\t1039\n\n## Original SQL:\nSELECT\n  c.inst_id,\n  m.end_time AS checktime,\n  c.conn,\n  c.activeconn,\n  m.sqlthroughput,\n  m.sqlavgtime,\n  m.user_commits,\n  m.user_rollbacks,\n  m.user_commits + m.user_rollbacks AS transactioncount,\n  m.transactionavgtime\nFROM\n  (\n  WITH\n   t1 AS (\n  SELECT\n  inst_id,\n  COUNT(*) conn\n  FROM\n  gv$session\n  WHERE\n  TYPE = 'USER'\n  GROUP BY\n  inst_id\n   ),\n   t2 AS (\n  SELECT\n  inst_id,\n  COUNT(*) activeconn\n  FROM\n  gv$session\n  WHERE\n  TYPE = 'USER'\n  AND status = 'ACTIVE'\n  GROUP BY\n  inst_id\n   )\n  SELECT\n   t1.inst_id,\n   t1.conn,\n   t2.activeconn\n  FROM\n   t1,\n   t2\n  WHERE\n   t1.inst_id = t2.inst_id\n  ) c,\n  (\n  SELECT\n   *\n  FROM\n   (\n  SELECT\n  inst_id,\n  end_time,\n  metric_name,\n  round(VALUE, 2) VALUE\n  FROM\n  gv$sysmetric\n  WHERE\n  round(intsize_csec / 100, 0) = 60\n  AND metric_name IN (\n   'Executions Per Sec',\n   'User Commits Per Sec',\n   'User Rollbacks Per Sec'\n  )\n  UNION ALL\n  SELECT\n  inst_id,\n  end_time,\n  metric_name,\n  round(VALUE * 10, 2) VALUE\n  FROM\n  gv$sysmetric\n  WHERE\n  round(intsize_csec / 100, 0) = 60\n  AND metric_name IN (\n   'SQL Service Response Time',\n   'Response Time Per Txn'\n  )\n   ) PIVOT (\n  AVG(VALUE) FOR metric_name IN (\n  'Executions Per Sec' sqlthroughput,\n  'SQL Service Response Time' sqlavgtime,\n  'User Commits Per Sec' user_commits,\n  'User Rollbacks Per Sec' user_rollbacks,\n  'Response Time Per Txn' transactionavgtime\n  )\n   )\n  ) m\nWHERE\n  c.inst_id = m.inst_id\nORDER BY\n  inst_id\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT c.inst_id, m.end_time AS checktime, c.conn, c.activeconn, m.sqlthroughput, m.sqlavgtime, m.user_commits, m.user_rollbacks, m.user_commits + m.user_rollbacks AS transactioncount, m.transactionavgtime FROM (SELECT inst_id, SUM(CASE WHEN TYPE = 'USER' THEN 1 ELSE 0 END) conn, SUM(CASE WHEN TYPE = 'USER' AND status = 'ACTIVE' THEN 1 ELSE 0 END) activeconn FROM gv$session WHERE TYPE = 'USER' GROUP BY inst_id) c INNER JOIN (SELECT * FROM (SELECT inst_id, end_time, metric_name, CASE WHEN metric_name IN ('Executions Per Sec', 'User Commits Per Sec', 'User Rollbacks Per Sec') THEN round(VALUE, 2) ELSE round(VALUE * 10, 2) END VALUE FROM gv$sysmetric WHERE intsize_csec >= 5950 AND intsize_csec <= 6049 AND metric_name IN ('Executions Per Sec', 'User Commits Per Sec', 'User Rollbacks Per Sec', 'SQL Service Response Time', 'Response Time Per Txn')) PIVOT (AVG(VALUE) FOR metric_name IN ('Executions Per Sec' sqlthroughput, 'SQL Service Response Time' sqlavgtime, 'User Commits Per Sec' user_commits, 'User Rollbacks Per Sec' user_rollbacks, 'Response Time Per Txn' transactionavgtime))) m ON c.inst_id = m.inst_id ORDER BY inst_id"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "25",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"25\", \"db_type\": \"mysql\", \"description\": \"在LEFT JOIN场景中，当WHERE子句包含对右表（被LEFT JOIN的表）的条件时，这些条件实际上会将LEFT JOIN转化为INNER JOIN的效果（因为NULL行会被WHERE过滤掉）。但如果将这些条件移到ON子句中，就能：1）保持真正的LEFT JOIN语义；2）在连接阶段就减少需要处理的数据；3）让优化器有更多优化空间。本次改写正是基于这一原理，将对表B的tenant_id和bo_name过滤从WHERE移到ON子句。同时清理了冗余的'A.tenant_id = 1065587309019136'重复条件（改写前WHERE子句中出现了多次）\", \"create_table_statements\": [\"CREATE TABLE acctg_trans_detail (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, gl_account_id BIGINT NOT NULL, master_voucher_id BIGINT, base_posted_dr DECIMAL(20,2) DEFAULT 0, base_posted_cr DECIMAL(20,2) DEFAULT 0, voucher_status_enum VARCHAR(50), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_tenant_id ON acctg_trans_detail(tenant_id);\", \"CREATE INDEX idx_master_voucher_id ON acctg_trans_detail(master_voucher_id);\", \"CREATE INDEX idx_tenant_gl_account ON acctg_trans_detail(tenant_id, gl_account_id);\", \"CREATE INDEX idx_voucher_status ON acctg_trans_detail(voucher_status_enum);\", \"CREATE TABLE acctg_trans (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, acctg_period VARCHAR(20), bo_name VARCHAR(100), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_tenant_id ON acctg_trans(tenant_id);\", \"CREATE INDEX idx_tenant_id_acctg_period ON acctg_trans(tenant_id, id, acctg_period);\", \"CREATE INDEX idx_bo_name ON acctg_trans(bo_name);\", \"CREATE TABLE gl_account_balance (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, gl_account_id BIGINT NOT NULL, acctg_period VARCHAR(20) NOT NULL, base_posted_dr DECIMAL(20,2) DEFAULT 0, base_posted_cr DECIMAL(20,2) DEFAULT 0, created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_tenant_id ON gl_account_balance(tenant_id);\", \"CREATE INDEX idx_gl_account_period ON gl_account_balance(gl_account_id, acctg_period, tenant_id);\", \"CREATE INDEX idx_acctg_period ON gl_account_balance(acctg_period);\", \"CREATE TABLE gl_account (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, code VARCHAR(50) NOT NULL, name VARCHAR(200), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_tenant_id ON gl_account(tenant_id);\", \"CREATE INDEX idx_tenant_code ON gl_account(tenant_id, code);\"], \"sql\": \"SELECT acctg.tenant_id, acctg.gl_account_id, ac.code, acctg.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg LEFT JOIN gl_account_balance A ON (A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id) AND A.tenant_id = 1065587309019136 LEFT JOIN gl_account ac ON (ac.id = acctg.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (acctg.base_posted_dr1 != ifnull(A.base_posted_dr, 0) OR acctg.base_posted_cr1 != ifnull(A.base_posted_cr, 0)) UNION SELECT A.tenant_id, A.gl_account_id, ac.code, A.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM gl_account_balance A LEFT JOIN (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id LEFT JOIN gl_account ac ON (ac.id = A.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND A.acctg_period NOT LIKE '%00' AND (A.base_posted_dr != ifnull(acctg.base_posted_dr1, 0) OR A.base_posted_cr != ifnull(acctg.base_posted_cr1, 0))) AND A.tenant_id = 1065587309019136 LIMIT 50001;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t13821\\t100.0\\t\\n1\\tPRIMARY\\tA\\t\\tref\\tidx_tenant_id,idx_gl_account_period,idx_acctg_period\\tidx_gl_account_period\\t98\\tacctg.gl_account_id,acctg.acctg_period,const\\t70\\t100.0\\tUsing where\\n1\\tPRIMARY\\tac\\t\\teq_ref\\tPRIMARY,idx_tenant_id,idx_tenant_code\\tPRIMARY\\t8\\tacctg.gl_account_id\\t1\\t100.0\\tUsing where\\n2\\tDERIVED\\tA\\t\\tref\\tidx_tenant_id,idx_tenant_gl_account,idx_voucher_status\\tidx_tenant_id\\t8\\tconst\\t497420\\t55.57\\tUsing where; Using temporary\\n2\\tDERIVED\\tB\\t\\teq_ref\\tPRIMARY,idx_tenant_id,idx_tenant_id_acctg_period\\tPRIMARY\\t8\\ttest_db.A.master_voucher_id\\t1\\t5.0\\tUsing where\\n3\\tUNION\\tA\\t\\tref\\tidx_tenant_id\\tidx_tenant_id\\t8\\tconst\\t497472\\t88.89\\tUsing where\\n3\\tUNION\\t<derived4>\\t\\tref\\t<auto_key0>\\t<auto_key0>\\t99\\tconst,test_db.A.gl_account_id,test_db.A.acctg_period\\t10\\t100.0\\tUsing where\\n3\\tUNION\\tac\\t\\teq_ref\\tPRIMARY,idx_tenant_id,idx_tenant_code\\tPRIMARY\\t8\\ttest_db.A.gl_account_id\\t1\\t100.0\\tUsing where\\n4\\tDERIVED\\tA\\t\\tref\\tidx_tenant_id,idx_tenant_gl_account,idx_voucher_status\\tidx_tenant_id\\t8\\tconst\\t497420\\t55.57\\tUsing where; Using temporary\\n4\\tDERIVED\\tB\\t\\teq_ref\\tPRIMARY,idx_tenant_id,idx_tenant_id_acctg_period\\tPRIMARY\\t8\\ttest_db.A.master_voucher_id\\t1\\t5.0\\tUsing where\\n5\\tUNION RESULT\\t<union1,3>\\t\\tALL\\t\\t\\t\\t\\t\\t\\tUsing temporary\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"union_result\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"select_id\\\": 5,\\n   \\\"table_name\\\": \\\"<union1,3>\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"query_specifications\\\": [\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n   \\\"select_id\\\": 1,\\n   \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"869134.39\\\"\\n   },\\n   \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"acctg\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"rows_examined_per_scan\\\": 13821,\\n   \\\"rows_produced_per_join\\\": 13821,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"175.26\\\",\\n  \\\"eval_cost\\\": \\\"1382.10\\\",\\n  \\\"prefix_cost\\\": \\\"1557.36\\\",\\n  \\\"data_read_per_join\\\": \\\"1M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"base_posted_dr1\\\",\\n  \\\"base_posted_cr1\\\"\\n   ],\\n   \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"364233.56\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"using_filesort\\\": false,\\n   \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"A\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_gl_account\\\",\\n  \\\"idx_voucher_status\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_tenant_id\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"tenant_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 497420,\\n   \\\"rows_produced_per_join\\\": 276421,\\n   \\\"filtered\\\": \\\"55.57\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"12601.85\\\",\\n  \\\"eval_cost\\\": \\\"27642.10\\\",\\n  \\\"prefix_cost\\\": \\\"62343.85\\\",\\n  \\\"data_read_per_join\\\": \\\"69M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"master_voucher_id\\\",\\n  \\\"base_posted_dr\\\",\\n  \\\"base_posted_cr\\\",\\n  \\\"voucher_status_enum\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`A`.`voucher_status_enum` is null) or (`test_db`.`A`.`voucher_status_enum` <> 'CANCELLED'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"B\\\",\\n   \\\"access_type\\\": \\\"eq_ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_id_acctg_period\\\"\\n   ],\\n   \\\"key\\\": \\\"PRIMARY\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"test_db.A.master_voucher_id\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 1,\\n   \\\"rows_produced_per_join\\\": 13821,\\n   \\\"filtered\\\": \\\"5.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"274247.61\\\",\\n  \\\"eval_cost\\\": \\\"1382.11\\\",\\n  \\\"prefix_cost\\\": \\\"364233.56\\\",\\n  \\\"data_read_per_join\\\": \\\"6M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"bo_name\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(<if>(found_match(B), ((`test_db`.`B`.`bo_name` is null) or (`test_db`.`B`.`bo_name` <> 'DraftAcctgTrans')), true) and <if>(is_not_null_compl(B), (`test_db`.`B`.`tenant_id` = 1065587309019136), true))\\\"\\n  }\\n  }\\n   ]\\n  }\\n  }\\n   }\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"A\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_gl_account_period\\\",\\n  \\\"idx_acctg_period\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_gl_account_period\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"tenant_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"98\\\",\\n   \\\"ref\\\": [\\n  \\\"acctg.gl_account_id\\\",\\n  \\\"acctg.acctg_period\\\",\\n  \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 70,\\n   \\\"rows_produced_per_join\\\": 980681,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"658345.61\\\",\\n  \\\"eval_cost\\\": \\\"98068.18\\\",\\n  \\\"prefix_cost\\\": \\\"757971.16\\\",\\n  \\\"data_read_per_join\\\": \\\"127M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"base_posted_dr\\\",\\n  \\\"base_posted_cr\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(<if>(found_match(A), ((`acctg`.`base_posted_dr1` <> ifnull(`test_db`.`A`.`base_posted_dr`,0)) or (`acctg`.`base_posted_cr1` <> ifnull(`test_db`.`A`.`base_posted_cr`,0))), true) and <if>(is_not_null_compl(A), (`acctg`.`tenant_id` = 1065587309019136), true))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"ac\\\",\\n   \\\"access_type\\\": \\\"eq_ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_code\\\"\\n   ],\\n   \\\"key\\\": \\\"PRIMARY\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"acctg.gl_account_id\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 1,\\n   \\\"rows_produced_per_join\\\": 980681,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"13095.05\\\",\\n  \\\"eval_cost\\\": \\\"98068.18\\\",\\n  \\\"prefix_cost\\\": \\\"869134.39\\\",\\n  \\\"data_read_per_join\\\": \\\"965M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"code\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"<if>(is_not_null_compl(ac), (`test_db`.`ac`.`tenant_id` = 1065587309019136), true)\\\"\\n  }\\n  }\\n   ]\\n  }\\n  },\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n   \\\"select_id\\\": 3,\\n   \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"2469300.89\\\"\\n   },\\n   \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"A\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"idx_tenant_id\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_tenant_id\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"tenant_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 497472,\\n   \\\"rows_produced_per_join\\\": 442202,\\n   \\\"filtered\\\": \\\"88.89\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"10520.84\\\",\\n  \\\"eval_cost\\\": \\\"44220.29\\\",\\n  \\\"prefix_cost\\\": \\\"60268.04\\\",\\n  \\\"data_read_per_join\\\": \\\"57M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"base_posted_dr\\\",\\n  \\\"base_posted_cr\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(not((`test_db`.`A`.`acctg_period` like '%00')))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"acctg\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"<auto_key0>\\\"\\n   ],\\n   \\\"key\\\": \\\"<auto_key0>\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\"\\n   ],\\n   \\\"key_length\\\": \\\"99\\\",\\n   \\\"ref\\\": [\\n  \\\"const\\\",\\n  \\\"test_db.A.gl_account_id\\\",\\n  \\\"test_db.A.acctg_period\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 10,\\n   \\\"rows_produced_per_join\\\": 4422348,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1105587.12\\\",\\n  \\\"eval_cost\\\": \\\"442234.85\\\",\\n  \\\"prefix_cost\\\": \\\"1608090.01\\\",\\n  \\\"data_read_per_join\\\": \\\"607M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"base_posted_dr1\\\",\\n  \\\"base_posted_cr1\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"<if>(found_match(acctg), ((`test_db`.`A`.`base_posted_dr` <> ifnull(`acctg`.`base_posted_dr1`,0)) or (`test_db`.`A`.`base_posted_cr` <> ifnull(`acctg`.`base_posted_cr1`,0))), true)\\\",\\n   \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 4,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"364233.56\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"using_filesort\\\": false,\\n   \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"A\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_gl_account\\\",\\n  \\\"idx_voucher_status\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_tenant_id\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"tenant_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 497420,\\n   \\\"rows_produced_per_join\\\": 276421,\\n   \\\"filtered\\\": \\\"55.57\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"12601.85\\\",\\n  \\\"eval_cost\\\": \\\"27642.10\\\",\\n  \\\"prefix_cost\\\": \\\"62343.85\\\",\\n  \\\"data_read_per_join\\\": \\\"69M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"master_voucher_id\\\",\\n  \\\"base_posted_dr\\\",\\n  \\\"base_posted_cr\\\",\\n  \\\"voucher_status_enum\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`A`.`voucher_status_enum` is null) or (`test_db`.`A`.`voucher_status_enum` <> 'CANCELLED'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"B\\\",\\n   \\\"access_type\\\": \\\"eq_ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_id_acctg_period\\\"\\n   ],\\n   \\\"key\\\": \\\"PRIMARY\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"test_db.A.master_voucher_id\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 1,\\n   \\\"rows_produced_per_join\\\": 13821,\\n   \\\"filtered\\\": \\\"5.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"274247.61\\\",\\n  \\\"eval_cost\\\": \\\"1382.11\\\",\\n  \\\"prefix_cost\\\": \\\"364233.56\\\",\\n  \\\"data_read_per_join\\\": \\\"6M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"bo_name\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(<if>(found_match(B), ((`test_db`.`B`.`bo_name` is null) or (`test_db`.`B`.`bo_name` <> 'DraftAcctgTrans')), true) and <if>(is_not_null_compl(B), (`test_db`.`B`.`tenant_id` = 1065587309019136), true))\\\"\\n  }\\n  }\\n   ]\\n  }\\n  }\\n   }\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"ac\\\",\\n   \\\"access_type\\\": \\\"eq_ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_code\\\"\\n   ],\\n   \\\"key\\\": \\\"PRIMARY\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"test_db.A.gl_account_id\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 1,\\n   \\\"rows_produced_per_join\\\": 4422348,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"418976.04\\\",\\n  \\\"eval_cost\\\": \\\"442234.85\\\",\\n  \\\"prefix_cost\\\": \\\"2469300.89\\\",\\n  \\\"data_read_per_join\\\": \\\"4G\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"code\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"<if>(is_not_null_compl(ac), (`test_db`.`ac`.`tenant_id` = 1065587309019136), true)\\\"\\n  }\\n  }\\n   ]\\n  }\\n  }\\n   ]\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,优化了子查询中重复的tenant_id过滤条件，并将B表(acctg_trans)的bo_name过滤条件从WHERE子句移到LEFT JOIN的ON子句中，提前过滤右表数据，减少连接过程中的数据量。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE acctg_trans_detail (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, gl_account_id BIGINT NOT NULL, master_voucher_id BIGINT, base_posted_dr DECIMAL(20,2) DEFAULT 0, base_posted_cr DECIMAL(20,2) DEFAULT 0, voucher_status_enum VARCHAR(50), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_tenant_id ON acctg_trans_detail(tenant_id);\nCREATE INDEX idx_master_voucher_id ON acctg_trans_detail(master_voucher_id);\nCREATE INDEX idx_tenant_gl_account ON acctg_trans_detail(tenant_id, gl_account_id);\nCREATE INDEX idx_voucher_status ON acctg_trans_detail(voucher_status_enum);\nCREATE TABLE acctg_trans (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, acctg_period VARCHAR(20), bo_name VARCHAR(100), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_tenant_id ON acctg_trans(tenant_id);\nCREATE INDEX idx_tenant_id_acctg_period ON acctg_trans(tenant_id, id, acctg_period);\nCREATE INDEX idx_bo_name ON acctg_trans(bo_name);\nCREATE TABLE gl_account_balance (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, gl_account_id BIGINT NOT NULL, acctg_period VARCHAR(20) NOT NULL, base_posted_dr DECIMAL(20,2) DEFAULT 0, base_posted_cr DECIMAL(20,2) DEFAULT 0, created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_tenant_id ON gl_account_balance(tenant_id);\nCREATE INDEX idx_gl_account_period ON gl_account_balance(gl_account_id, acctg_period, tenant_id);\nCREATE INDEX idx_acctg_period ON gl_account_balance(acctg_period);\nCREATE TABLE gl_account (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, code VARCHAR(50) NOT NULL, name VARCHAR(200), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_tenant_id ON gl_account(tenant_id);\nCREATE INDEX idx_tenant_code ON gl_account(tenant_id, code);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t13821\t100.0\t\n1\tPRIMARY\tA\t\tref\tidx_tenant_id,idx_gl_account_period,idx_acctg_period\tidx_gl_account_period\t98\tacctg.gl_account_id,acctg.acctg_period,const\t70\t100.0\tUsing where\n1\tPRIMARY\tac\t\teq_ref\tPRIMARY,idx_tenant_id,idx_tenant_code\tPRIMARY\t8\tacctg.gl_account_id\t1\t100.0\tUsing where\n2\tDERIVED\tA\t\tref\tidx_tenant_id,idx_tenant_gl_account,idx_voucher_status\tidx_tenant_id\t8\tconst\t497420\t55.57\tUsing where; Using temporary\n2\tDERIVED\tB\t\teq_ref\tPRIMARY,idx_tenant_id,idx_tenant_id_acctg_period\tPRIMARY\t8\ttest_db.A.master_voucher_id\t1\t5.0\tUsing where\n3\tUNION\tA\t\tref\tidx_tenant_id\tidx_tenant_id\t8\tconst\t497472\t88.89\tUsing where\n3\tUNION\t<derived4>\t\tref\t<auto_key0>\t<auto_key0>\t99\tconst,test_db.A.gl_account_id,test_db.A.acctg_period\t10\t100.0\tUsing where\n3\tUNION\tac\t\teq_ref\tPRIMARY,idx_tenant_id,idx_tenant_code\tPRIMARY\t8\ttest_db.A.gl_account_id\t1\t100.0\tUsing where\n4\tDERIVED\tA\t\tref\tidx_tenant_id,idx_tenant_gl_account,idx_voucher_status\tidx_tenant_id\t8\tconst\t497420\t55.57\tUsing where; Using temporary\n4\tDERIVED\tB\t\teq_ref\tPRIMARY,idx_tenant_id,idx_tenant_id_acctg_period\tPRIMARY\t8\ttest_db.A.master_voucher_id\t1\t5.0\tUsing where\n5\tUNION RESULT\t<union1,3>\t\tALL\t\t\t\t\t\t\tUsing temporary\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"union_result\": {\n   \"using_temporary_table\": true,\n   \"select_id\": 5,\n   \"table_name\": \"<union1,3>\",\n   \"access_type\": \"ALL\",\n   \"query_specifications\": [\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n   \"select_id\": 1,\n   \"cost_info\": {\n  \"query_cost\": \"869134.39\"\n   },\n   \"nested_loop\": [\n  {\n  \"table\": {\n   \"table_name\": \"acctg\",\n   \"access_type\": \"ALL\",\n   \"rows_examined_per_scan\": 13821,\n   \"rows_produced_per_join\": 13821,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"175.26\",\n  \"eval_cost\": \"1382.10\",\n  \"prefix_cost\": \"1557.36\",\n  \"data_read_per_join\": \"1M\"\n   },\n   \"used_columns\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"base_posted_dr1\",\n  \"base_posted_cr1\"\n   ],\n   \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n   \"query_cost\": \"364233.56\"\n  },\n  \"grouping_operation\": {\n   \"using_temporary_table\": true,\n   \"using_filesort\": false,\n   \"nested_loop\": [\n  {\n  \"table\": {\n   \"table_name\": \"A\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"idx_tenant_id\",\n  \"idx_tenant_gl_account\",\n  \"idx_voucher_status\"\n   ],\n   \"key\": \"idx_tenant_id\",\n   \"used_key_parts\": [\n  \"tenant_id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"const\"\n   ],\n   \"rows_examined_per_scan\": 497420,\n   \"rows_produced_per_join\": 276421,\n   \"filtered\": \"55.57\",\n   \"cost_info\": {\n  \"read_cost\": \"12601.85\",\n  \"eval_cost\": \"27642.10\",\n  \"prefix_cost\": \"62343.85\",\n  \"data_read_per_join\": \"69M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"master_voucher_id\",\n  \"base_posted_dr\",\n  \"base_posted_cr\",\n  \"voucher_status_enum\"\n   ],\n   \"attached_condition\": \"((`test_db`.`A`.`voucher_status_enum` is null) or (`test_db`.`A`.`voucher_status_enum` <> 'CANCELLED'))\"\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"B\",\n   \"access_type\": \"eq_ref\",\n   \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_tenant_id\",\n  \"idx_tenant_id_acctg_period\"\n   ],\n   \"key\": \"PRIMARY\",\n   \"used_key_parts\": [\n  \"id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"test_db.A.master_voucher_id\"\n   ],\n   \"rows_examined_per_scan\": 1,\n   \"rows_produced_per_join\": 13821,\n   \"filtered\": \"5.00\",\n   \"cost_info\": {\n  \"read_cost\": \"274247.61\",\n  \"eval_cost\": \"1382.11\",\n  \"prefix_cost\": \"364233.56\",\n  \"data_read_per_join\": \"6M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"acctg_period\",\n  \"bo_name\"\n   ],\n   \"attached_condition\": \"(<if>(found_match(B), ((`test_db`.`B`.`bo_name` is null) or (`test_db`.`B`.`bo_name` <> 'DraftAcctgTrans')), true) and <if>(is_not_null_compl(B), (`test_db`.`B`.`tenant_id` = 1065587309019136), true))\"\n  }\n  }\n   ]\n  }\n  }\n   }\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"A\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"idx_tenant_id\",\n  \"idx_gl_account_period\",\n  \"idx_acctg_period\"\n   ],\n   \"key\": \"idx_gl_account_period\",\n   \"used_key_parts\": [\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"tenant_id\"\n   ],\n   \"key_length\": \"98\",\n   \"ref\": [\n  \"acctg.gl_account_id\",\n  \"acctg.acctg_period\",\n  \"const\"\n   ],\n   \"rows_examined_per_scan\": 70,\n   \"rows_produced_per_join\": 980681,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"658345.61\",\n  \"eval_cost\": \"98068.18\",\n  \"prefix_cost\": \"757971.16\",\n  \"data_read_per_join\": \"127M\"\n   },\n   \"used_columns\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"base_posted_dr\",\n  \"base_posted_cr\"\n   ],\n   \"attached_condition\": \"(<if>(found_match(A), ((`acctg`.`base_posted_dr1` <> ifnull(`test_db`.`A`.`base_posted_dr`,0)) or (`acctg`.`base_posted_cr1` <> ifnull(`test_db`.`A`.`base_posted_cr`,0))), true) and <if>(is_not_null_compl(A), (`acctg`.`tenant_id` = 1065587309019136), true))\"\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"ac\",\n   \"access_type\": \"eq_ref\",\n   \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_tenant_id\",\n  \"idx_tenant_code\"\n   ],\n   \"key\": \"PRIMARY\",\n   \"used_key_parts\": [\n  \"id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"acctg.gl_account_id\"\n   ],\n   \"rows_examined_per_scan\": 1,\n   \"rows_produced_per_join\": 980681,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"13095.05\",\n  \"eval_cost\": \"98068.18\",\n  \"prefix_cost\": \"869134.39\",\n  \"data_read_per_join\": \"965M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"code\"\n   ],\n   \"attached_condition\": \"<if>(is_not_null_compl(ac), (`test_db`.`ac`.`tenant_id` = 1065587309019136), true)\"\n  }\n  }\n   ]\n  }\n  },\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n   \"select_id\": 3,\n   \"cost_info\": {\n  \"query_cost\": \"2469300.89\"\n   },\n   \"nested_loop\": [\n  {\n  \"table\": {\n   \"table_name\": \"A\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"idx_tenant_id\"\n   ],\n   \"key\": \"idx_tenant_id\",\n   \"used_key_parts\": [\n  \"tenant_id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"const\"\n   ],\n   \"rows_examined_per_scan\": 497472,\n   \"rows_produced_per_join\": 442202,\n   \"filtered\": \"88.89\",\n   \"cost_info\": {\n  \"read_cost\": \"10520.84\",\n  \"eval_cost\": \"44220.29\",\n  \"prefix_cost\": \"60268.04\",\n  \"data_read_per_join\": \"57M\"\n   },\n   \"used_columns\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"base_posted_dr\",\n  \"base_posted_cr\"\n   ],\n   \"attached_condition\": \"(not((`test_db`.`A`.`acctg_period` like '%00')))\"\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"acctg\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"<auto_key0>\"\n   ],\n   \"key\": \"<auto_key0>\",\n   \"used_key_parts\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\"\n   ],\n   \"key_length\": \"99\",\n   \"ref\": [\n  \"const\",\n  \"test_db.A.gl_account_id\",\n  \"test_db.A.acctg_period\"\n   ],\n   \"rows_examined_per_scan\": 10,\n   \"rows_produced_per_join\": 4422348,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"1105587.12\",\n  \"eval_cost\": \"442234.85\",\n  \"prefix_cost\": \"1608090.01\",\n  \"data_read_per_join\": \"607M\"\n   },\n   \"used_columns\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"base_posted_dr1\",\n  \"base_posted_cr1\"\n   ],\n   \"attached_condition\": \"<if>(found_match(acctg), ((`test_db`.`A`.`base_posted_dr` <> ifnull(`acctg`.`base_posted_dr1`,0)) or (`test_db`.`A`.`base_posted_cr` <> ifnull(`acctg`.`base_posted_cr1`,0))), true)\",\n   \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 4,\n  \"cost_info\": {\n   \"query_cost\": \"364233.56\"\n  },\n  \"grouping_operation\": {\n   \"using_temporary_table\": true,\n   \"using_filesort\": false,\n   \"nested_loop\": [\n  {\n  \"table\": {\n   \"table_name\": \"A\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"idx_tenant_id\",\n  \"idx_tenant_gl_account\",\n  \"idx_voucher_status\"\n   ],\n   \"key\": \"idx_tenant_id\",\n   \"used_key_parts\": [\n  \"tenant_id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"const\"\n   ],\n   \"rows_examined_per_scan\": 497420,\n   \"rows_produced_per_join\": 276421,\n   \"filtered\": \"55.57\",\n   \"cost_info\": {\n  \"read_cost\": \"12601.85\",\n  \"eval_cost\": \"27642.10\",\n  \"prefix_cost\": \"62343.85\",\n  \"data_read_per_join\": \"69M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"master_voucher_id\",\n  \"base_posted_dr\",\n  \"base_posted_cr\",\n  \"voucher_status_enum\"\n   ],\n   \"attached_condition\": \"((`test_db`.`A`.`voucher_status_enum` is null) or (`test_db`.`A`.`voucher_status_enum` <> 'CANCELLED'))\"\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"B\",\n   \"access_type\": \"eq_ref\",\n   \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_tenant_id\",\n  \"idx_tenant_id_acctg_period\"\n   ],\n   \"key\": \"PRIMARY\",\n   \"used_key_parts\": [\n  \"id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"test_db.A.master_voucher_id\"\n   ],\n   \"rows_examined_per_scan\": 1,\n   \"rows_produced_per_join\": 13821,\n   \"filtered\": \"5.00\",\n   \"cost_info\": {\n  \"read_cost\": \"274247.61\",\n  \"eval_cost\": \"1382.11\",\n  \"prefix_cost\": \"364233.56\",\n  \"data_read_per_join\": \"6M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"acctg_period\",\n  \"bo_name\"\n   ],\n   \"attached_condition\": \"(<if>(found_match(B), ((`test_db`.`B`.`bo_name` is null) or (`test_db`.`B`.`bo_name` <> 'DraftAcctgTrans')), true) and <if>(is_not_null_compl(B), (`test_db`.`B`.`tenant_id` = 1065587309019136), true))\"\n  }\n  }\n   ]\n  }\n  }\n   }\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"ac\",\n   \"access_type\": \"eq_ref\",\n   \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_tenant_id\",\n  \"idx_tenant_code\"\n   ],\n   \"key\": \"PRIMARY\",\n   \"used_key_parts\": [\n  \"id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"test_db.A.gl_account_id\"\n   ],\n   \"rows_examined_per_scan\": 1,\n   \"rows_produced_per_join\": 4422348,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"418976.04\",\n  \"eval_cost\": \"442234.85\",\n  \"prefix_cost\": \"2469300.89\",\n  \"data_read_per_join\": \"4G\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"code\"\n   ],\n   \"attached_condition\": \"<if>(is_not_null_compl(ac), (`test_db`.`ac`.`tenant_id` = 1065587309019136), true)\"\n  }\n  }\n   ]\n  }\n  }\n   ]\n  }\n  }\n}\n\n## Original SQL:\nSELECT acctg.tenant_id, acctg.gl_account_id, ac.code, acctg.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg LEFT JOIN gl_account_balance A ON (A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id) AND A.tenant_id = 1065587309019136 LEFT JOIN gl_account ac ON (ac.id = acctg.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (acctg.base_posted_dr1 != ifnull(A.base_posted_dr, 0) OR acctg.base_posted_cr1 != ifnull(A.base_posted_cr, 0)) UNION SELECT A.tenant_id, A.gl_account_id, ac.code, A.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM gl_account_balance A LEFT JOIN (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id LEFT JOIN gl_account ac ON (ac.id = A.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND A.acctg_period NOT LIKE '%00' AND (A.base_posted_dr != ifnull(acctg.base_posted_dr1, 0) OR A.base_posted_cr != ifnull(acctg.base_posted_cr1, 0))) AND A.tenant_id = 1065587309019136 LIMIT 50001;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH trans_summary AS (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, SUM(A.base_posted_dr) AS base_posted_dr1, SUM(A.base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id WHERE A.tenant_id = 1065587309019136 AND (A.voucher_status_enum IS NULL OR A.voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans') GROUP BY A.tenant_id, A.gl_account_id, B.acctg_period) SELECT acctg.tenant_id, acctg.gl_account_id, ac.code, acctg.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM trans_summary acctg LEFT JOIN gl_account_balance A ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = 1065587309019136 LEFT JOIN gl_account ac ON ac.id = acctg.gl_account_id AND ac.tenant_id = 1065587309019136 WHERE acctg.base_posted_dr1 != IFNULL(A.base_posted_dr, 0) OR acctg.base_posted_cr1 != IFNULL(A.base_posted_cr, 0) UNION ALL SELECT A.tenant_id, A.gl_account_id, ac.code, A.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM gl_account_balance A LEFT JOIN trans_summary acctg ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id LEFT JOIN gl_account ac ON ac.id = A.gl_account_id AND ac.tenant_id = 1065587309019136 WHERE A.tenant_id = 1065587309019136 AND A.acctg_period NOT LIKE '%00' AND (A.base_posted_dr != IFNULL(acctg.base_posted_dr1, 0) OR A.base_posted_cr != IFNULL(acctg.base_posted_cr1, 0)) LIMIT 50001"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "26",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"26\", \"db_type\": \"postgresql\", \"description\": \"本次改写采用了CTE常量提取模式，将时间计算逻辑（fun_addmonth、to_char等）从连接条件中提取到CTE中，理论上可以避免在循环中重复计算这些函数。同时将COALESCE改写为显式OR条件，希望优化器能更好地理解谓词逻辑。然而，这种改写忽略了LIMIT 1对执行计划的影响：在只需要返回1行的场景下，原SQL的\\\"惰性计算\\\"策略更优，因为常量函数只会被调用极少次数。CTE的物化成本和额外的扫描开销在这种场景下无法被节省的计算成本所抵消。\", \"create_table_statements\": [\"CREATE TABLE dwd_csi_ac02 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aae140 VARCHAR(10), aac008 VARCHAR(5), aac031 VARCHAR(5), aac030 NUMERIC(8,0), aae041 NUMERIC(6,0), aae042 NUMERIC(6,0));\", \"CREATE INDEX idx_dwd_csi_ac02_aac001 ON dwd_csi_ac02(aac001);\", \"CREATE INDEX idx_dwd_csi_ac02_composite ON dwd_csi_ac02(aae140, aac008, aac031, aac030, aae041, aae042);\", \"CREATE TABLE dwd_hrss_ac99 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aac147 VARCHAR(100));\", \"CREATE INDEX idx_dwd_hrss_ac99_aac001 ON dwd_hrss_ac99(aac001);\", \"CREATE INDEX idx_dwd_hrss_ac99_aac147 ON dwd_hrss_ac99(aac147);\"], \"sql\": \"select\\n\\t'lxzdqdwjf5nys',\\n\\t'连续在当前单位参保5年以上',\\n\\tc.aac147,\\n\\t'是',\\n\\t'连续在当前单位参保5年以上'\\nfrom\\n\\tdwd_csi_ac02 a,\\n\\t(\\n\\tselect\\n\\t\\t(fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)|| '31')::numeric aac030,\\n\\t\\t fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)::numeric aae041,\\n\\t\\tto_char(current_timestamp, 'yyyymm')::numeric aae042) b,\\n\\tdwd_hrss_ac99 c\\nwhere a.aac001::varchar = c.aac001::varchar\\n\\tand a.aae140 = '110'\\n\\tand a.aac008 = '1'\\n\\tand a.aac031 = '1'\\n\\tand a.aac030 <= b.aac030\\n\\tand a.aae041 <= b.aae041\\n\\tand coalesce(a.aae042, 999912) >= b.aae042\\n\\tand c.aac147 is not null limit 1\", \"explain\": \"QUERY PLAN\\nLimit  (cost=0.42..3.47 rows=1 width=166)\\n  ->  Nested Loop  (cost=0.42..45289.49 rows=14886 width=166)\\n  ->  Nested Loop  (cost=0.00..35441.33 rows=16590 width=19)\\n  Join Filter: ((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\\n  ->  Result  (cost=0.00..0.54 rows=1 width=96)\\n  ->  Seq Scan on dwd_csi_ac02 a  (cost=0.00..27602.00 rows=447931 width=40)\\n  Filter: (((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\\n  ->  Index Scan using idx_dwd_hrss_ac99_aac001 on dwd_hrss_ac99 c  (cost=0.42..0.58 rows=1 width=57)\\n  Index Cond: ((aac001)::text = (a.aac001)::text)\\n  Filter: (aac147 IS NOT NULL)\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Limit', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 3.47, 'Plan Rows': 1, 'Plan Width': 166, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.42, 'Total Cost': 45289.49, 'Plan Rows': 14886, 'Plan Width': 166, 'Inner Unique': False, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.0, 'Total Cost': 35441.33, 'Plan Rows': 16590, 'Plan Width': 19, 'Inner Unique': False, 'Join Filter': \\\"((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\\\", 'Plans': [{'Node Type': 'Result', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.0, 'Total Cost': 0.54, 'Plan Rows': 1, 'Plan Width': 96}, {'Node Type': 'Seq Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'dwd_csi_ac02', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 27602.0, 'Plan Rows': 447931, 'Plan Width': 40, 'Filter': \\\"(((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\\\"}]}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_dwd_hrss_ac99_aac001', 'Relation Name': 'dwd_hrss_ac99', 'Alias': 'c', 'Startup Cost': 0.42, 'Total Cost': 0.58, 'Plan Rows': 1, 'Plan Width': 57, 'Index Cond': '((aac001)::text = (a.aac001)::text)', 'Filter': '(aac147 IS NOT NULL)'}]}]}}]\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推规则优化：1) 将a表的独立过滤条件(aae140/aac008/aac031)下推到内联子查询；2) 将c表的aac147非空检查下推到子查询；3) 保持b视图计算逻辑不变。改写后显著减少JOIN前的中间数据量，保持业务逻辑不变。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,通过将COALESCE函数替换为等效的OR条件，消除字段上的函数操作，使数据库能利用aae042字段的索引。改写前后逻辑完全等价\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"用静态可搜索参数替换动态条件,优化消除动态函数包装、多重类型转换和非SARGable模式：1) 移除3层类型转换链(DATE→CHAR→NUMERIC) 2) 消除JOIN条件冗余类型转换 3) 提取动态函数到CTE避免重复计算 4) 保持NULL处理逻辑优化 5) 移除仅生成常量的CROSS JOIN。预期性能提升5%-15%(高并发场景累积效应显著)，扫描行数减少约30%\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE dwd_csi_ac02 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aae140 VARCHAR(10), aac008 VARCHAR(5), aac031 VARCHAR(5), aac030 NUMERIC(8,0), aae041 NUMERIC(6,0), aae042 NUMERIC(6,0));\nCREATE INDEX idx_dwd_csi_ac02_aac001 ON dwd_csi_ac02(aac001);\nCREATE INDEX idx_dwd_csi_ac02_composite ON dwd_csi_ac02(aae140, aac008, aac031, aac030, aae041, aae042);\nCREATE TABLE dwd_hrss_ac99 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aac147 VARCHAR(100));\nCREATE INDEX idx_dwd_hrss_ac99_aac001 ON dwd_hrss_ac99(aac001);\nCREATE INDEX idx_dwd_hrss_ac99_aac147 ON dwd_hrss_ac99(aac147);\n\n## Explain Output in JSON:\nQUERY PLAN\nLimit  (cost=0.42..3.47 rows=1 width=166)\n  ->  Nested Loop  (cost=0.42..45289.49 rows=14886 width=166)\n  ->  Nested Loop  (cost=0.00..35441.33 rows=16590 width=19)\n  Join Filter: ((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\n  ->  Result  (cost=0.00..0.54 rows=1 width=96)\n  ->  Seq Scan on dwd_csi_ac02 a  (cost=0.00..27602.00 rows=447931 width=40)\n  Filter: (((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\n  ->  Index Scan using idx_dwd_hrss_ac99_aac001 on dwd_hrss_ac99 c  (cost=0.42..0.58 rows=1 width=57)\n  Index Cond: ((aac001)::text = (a.aac001)::text)\n  Filter: (aac147 IS NOT NULL)\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Limit', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 3.47, 'Plan Rows': 1, 'Plan Width': 166, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.42, 'Total Cost': 45289.49, 'Plan Rows': 14886, 'Plan Width': 166, 'Inner Unique': False, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.0, 'Total Cost': 35441.33, 'Plan Rows': 16590, 'Plan Width': 19, 'Inner Unique': False, 'Join Filter': \"((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\", 'Plans': [{'Node Type': 'Result', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.0, 'Total Cost': 0.54, 'Plan Rows': 1, 'Plan Width': 96}, {'Node Type': 'Seq Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'dwd_csi_ac02', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 27602.0, 'Plan Rows': 447931, 'Plan Width': 40, 'Filter': \"(((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\"}]}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_dwd_hrss_ac99_aac001', 'Relation Name': 'dwd_hrss_ac99', 'Alias': 'c', 'Startup Cost': 0.42, 'Total Cost': 0.58, 'Plan Rows': 1, 'Plan Width': 57, 'Index Cond': '((aac001)::text = (a.aac001)::text)', 'Filter': '(aac147 IS NOT NULL)'}]}]}}]\n\n## Original SQL:\nselect\n\t'lxzdqdwjf5nys',\n\t'连续在当前单位参保5年以上',\n\tc.aac147,\n\t'是',\n\t'连续在当前单位参保5年以上'\nfrom\n\tdwd_csi_ac02 a,\n\t(\n\tselect\n\t\t(fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)|| '31')::numeric aac030,\n\t\t fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)::numeric aae041,\n\t\tto_char(current_timestamp, 'yyyymm')::numeric aae042) b,\n\tdwd_hrss_ac99 c\nwhere a.aac001::varchar = c.aac001::varchar\n\tand a.aae140 = '110'\n\tand a.aac008 = '1'\n\tand a.aac031 = '1'\n\tand a.aac030 <= b.aac030\n\tand a.aae041 <= b.aae041\n\tand coalesce(a.aae042, 999912) >= b.aae042\n\tand c.aac147 is not null limit 1\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select 'lxzdqdwjf5nys','连续在当前单位参保5年以上',c.aac147,'是','连续在当前单位参保5年以上' from dwd_csi_ac02 a inner join dwd_hrss_ac99 c on a.aac001=c.aac001 where a.aae140='110' and a.aac008='1' and a.aac031='1' and a.aac030<=(fun_addmonth(to_char(current_timestamp,'yyyymm')::varchar,-61)||'31')::numeric and a.aae041<=fun_addmonth(to_char(current_timestamp,'yyyymm')::varchar,-61)::numeric and coalesce(a.aae042,999912)>=to_char(current_timestamp,'yyyymm')::numeric and c.aac147 is not null limit 1"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "26",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"26\", \"db_type\": \"postgresql\", \"description\": \"本次改写采用了CTE常量提取模式，将时间计算逻辑（fun_addmonth、to_char等）从连接条件中提取到CTE中，理论上可以避免在循环中重复计算这些函数。同时将COALESCE改写为显式OR条件，希望优化器能更好地理解谓词逻辑。然而，这种改写忽略了LIMIT 1对执行计划的影响：在只需要返回1行的场景下，原SQL的\\\"惰性计算\\\"策略更优，因为常量函数只会被调用极少次数。CTE的物化成本和额外的扫描开销在这种场景下无法被节省的计算成本所抵消。\", \"create_table_statements\": [\"CREATE TABLE dwd_csi_ac02 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aae140 VARCHAR(10), aac008 VARCHAR(5), aac031 VARCHAR(5), aac030 NUMERIC(8,0), aae041 NUMERIC(6,0), aae042 NUMERIC(6,0));\", \"CREATE INDEX idx_dwd_csi_ac02_aac001 ON dwd_csi_ac02(aac001);\", \"CREATE INDEX idx_dwd_csi_ac02_composite ON dwd_csi_ac02(aae140, aac008, aac031, aac030, aae041, aae042);\", \"CREATE TABLE dwd_hrss_ac99 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aac147 VARCHAR(100));\", \"CREATE INDEX idx_dwd_hrss_ac99_aac001 ON dwd_hrss_ac99(aac001);\", \"CREATE INDEX idx_dwd_hrss_ac99_aac147 ON dwd_hrss_ac99(aac147);\"], \"sql\": \"select\\n\\t'lxzdqdwjf5nys',\\n\\t'连续在当前单位参保5年以上',\\n\\tc.aac147,\\n\\t'是',\\n\\t'连续在当前单位参保5年以上'\\nfrom\\n\\tdwd_csi_ac02 a,\\n\\t(\\n\\tselect\\n\\t\\t(fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)|| '31')::numeric aac030,\\n\\t\\t fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)::numeric aae041,\\n\\t\\tto_char(current_timestamp, 'yyyymm')::numeric aae042) b,\\n\\tdwd_hrss_ac99 c\\nwhere a.aac001::varchar = c.aac001::varchar\\n\\tand a.aae140 = '110'\\n\\tand a.aac008 = '1'\\n\\tand a.aac031 = '1'\\n\\tand a.aac030 <= b.aac030\\n\\tand a.aae041 <= b.aae041\\n\\tand coalesce(a.aae042, 999912) >= b.aae042\\n\\tand c.aac147 is not null limit 1\", \"explain\": \"QUERY PLAN\\nLimit  (cost=0.42..3.47 rows=1 width=166)\\n  ->  Nested Loop  (cost=0.42..45289.49 rows=14886 width=166)\\n  ->  Nested Loop  (cost=0.00..35441.33 rows=16590 width=19)\\n  Join Filter: ((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\\n  ->  Result  (cost=0.00..0.54 rows=1 width=96)\\n  ->  Seq Scan on dwd_csi_ac02 a  (cost=0.00..27602.00 rows=447931 width=40)\\n  Filter: (((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\\n  ->  Index Scan using idx_dwd_hrss_ac99_aac001 on dwd_hrss_ac99 c  (cost=0.42..0.58 rows=1 width=57)\\n  Index Cond: ((aac001)::text = (a.aac001)::text)\\n  Filter: (aac147 IS NOT NULL)\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Limit', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 3.47, 'Plan Rows': 1, 'Plan Width': 166, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.42, 'Total Cost': 45289.49, 'Plan Rows': 14886, 'Plan Width': 166, 'Inner Unique': False, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.0, 'Total Cost': 35441.33, 'Plan Rows': 16590, 'Plan Width': 19, 'Inner Unique': False, 'Join Filter': \\\"((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\\\", 'Plans': [{'Node Type': 'Result', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.0, 'Total Cost': 0.54, 'Plan Rows': 1, 'Plan Width': 96}, {'Node Type': 'Seq Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'dwd_csi_ac02', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 27602.0, 'Plan Rows': 447931, 'Plan Width': 40, 'Filter': \\\"(((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\\\"}]}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_dwd_hrss_ac99_aac001', 'Relation Name': 'dwd_hrss_ac99', 'Alias': 'c', 'Startup Cost': 0.42, 'Total Cost': 0.58, 'Plan Rows': 1, 'Plan Width': 57, 'Index Cond': '((aac001)::text = (a.aac001)::text)', 'Filter': '(aac147 IS NOT NULL)'}]}]}}]\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推规则优化：1) 将a表的独立过滤条件(aae140/aac008/aac031)下推到内联子查询；2) 将c表的aac147非空检查下推到子查询；3) 保持b视图计算逻辑不变。改写后显著减少JOIN前的中间数据量，保持业务逻辑不变。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,通过将COALESCE函数替换为等效的OR条件，消除字段上的函数操作，使数据库能利用aae042字段的索引。改写前后逻辑完全等价\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"用静态可搜索参数替换动态条件,优化消除动态函数包装、多重类型转换和非SARGable模式：1) 移除3层类型转换链(DATE→CHAR→NUMERIC) 2) 消除JOIN条件冗余类型转换 3) 提取动态函数到CTE避免重复计算 4) 保持NULL处理逻辑优化 5) 移除仅生成常量的CROSS JOIN。预期性能提升5%-15%(高并发场景累积效应显著)，扫描行数减少约30%\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE dwd_csi_ac02 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aae140 VARCHAR(10), aac008 VARCHAR(5), aac031 VARCHAR(5), aac030 NUMERIC(8,0), aae041 NUMERIC(6,0), aae042 NUMERIC(6,0));\nCREATE INDEX idx_dwd_csi_ac02_aac001 ON dwd_csi_ac02(aac001);\nCREATE INDEX idx_dwd_csi_ac02_composite ON dwd_csi_ac02(aae140, aac008, aac031, aac030, aae041, aae042);\nCREATE TABLE dwd_hrss_ac99 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aac147 VARCHAR(100));\nCREATE INDEX idx_dwd_hrss_ac99_aac001 ON dwd_hrss_ac99(aac001);\nCREATE INDEX idx_dwd_hrss_ac99_aac147 ON dwd_hrss_ac99(aac147);\n\n## Explain Output in JSON:\nQUERY PLAN\nLimit  (cost=0.42..3.47 rows=1 width=166)\n  ->  Nested Loop  (cost=0.42..45289.49 rows=14886 width=166)\n  ->  Nested Loop  (cost=0.00..35441.33 rows=16590 width=19)\n  Join Filter: ((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\n  ->  Result  (cost=0.00..0.54 rows=1 width=96)\n  ->  Seq Scan on dwd_csi_ac02 a  (cost=0.00..27602.00 rows=447931 width=40)\n  Filter: (((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\n  ->  Index Scan using idx_dwd_hrss_ac99_aac001 on dwd_hrss_ac99 c  (cost=0.42..0.58 rows=1 width=57)\n  Index Cond: ((aac001)::text = (a.aac001)::text)\n  Filter: (aac147 IS NOT NULL)\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Limit', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 3.47, 'Plan Rows': 1, 'Plan Width': 166, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.42, 'Total Cost': 45289.49, 'Plan Rows': 14886, 'Plan Width': 166, 'Inner Unique': False, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.0, 'Total Cost': 35441.33, 'Plan Rows': 16590, 'Plan Width': 19, 'Inner Unique': False, 'Join Filter': \"((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\", 'Plans': [{'Node Type': 'Result', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.0, 'Total Cost': 0.54, 'Plan Rows': 1, 'Plan Width': 96}, {'Node Type': 'Seq Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'dwd_csi_ac02', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 27602.0, 'Plan Rows': 447931, 'Plan Width': 40, 'Filter': \"(((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\"}]}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_dwd_hrss_ac99_aac001', 'Relation Name': 'dwd_hrss_ac99', 'Alias': 'c', 'Startup Cost': 0.42, 'Total Cost': 0.58, 'Plan Rows': 1, 'Plan Width': 57, 'Index Cond': '((aac001)::text = (a.aac001)::text)', 'Filter': '(aac147 IS NOT NULL)'}]}]}}]\n\n## Original SQL:\nselect\n\t'lxzdqdwjf5nys',\n\t'连续在当前单位参保5年以上',\n\tc.aac147,\n\t'是',\n\t'连续在当前单位参保5年以上'\nfrom\n\tdwd_csi_ac02 a,\n\t(\n\tselect\n\t\t(fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)|| '31')::numeric aac030,\n\t\t fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)::numeric aae041,\n\t\tto_char(current_timestamp, 'yyyymm')::numeric aae042) b,\n\tdwd_hrss_ac99 c\nwhere a.aac001::varchar = c.aac001::varchar\n\tand a.aae140 = '110'\n\tand a.aac008 = '1'\n\tand a.aac031 = '1'\n\tand a.aac030 <= b.aac030\n\tand a.aae041 <= b.aae041\n\tand coalesce(a.aae042, 999912) >= b.aae042\n\tand c.aac147 is not null limit 1\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select 'lxzdqdwjf5nys','连续在当前单位参保5年以上',c.aac147,'是','连续在当前单位参保5年以上' from dwd_csi_ac02 a inner join dwd_hrss_ac99 c on a.aac001=c.aac001 where a.aae140='110' and a.aac008='1' and a.aac031='1' and a.aac030<=(fun_addmonth(to_char(current_timestamp,'yyyymm')::varchar,-61)||'31')::numeric and a.aae041<=fun_addmonth(to_char(current_timestamp,'yyyymm')::varchar,-61)::numeric and coalesce(a.aae042,999912)>=to_char(current_timestamp,'yyyymm')::numeric and c.aac147 is not null limit 1"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "26",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"26\", \"db_type\": \"postgresql\", \"description\": \"本次改写采用了CTE常量提取模式，将时间计算逻辑（fun_addmonth、to_char等）从连接条件中提取到CTE中，理论上可以避免在循环中重复计算这些函数。同时将COALESCE改写为显式OR条件，希望优化器能更好地理解谓词逻辑。然而，这种改写忽略了LIMIT 1对执行计划的影响：在只需要返回1行的场景下，原SQL的\\\"惰性计算\\\"策略更优，因为常量函数只会被调用极少次数。CTE的物化成本和额外的扫描开销在这种场景下无法被节省的计算成本所抵消。\", \"create_table_statements\": [\"CREATE TABLE dwd_csi_ac02 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aae140 VARCHAR(10), aac008 VARCHAR(5), aac031 VARCHAR(5), aac030 NUMERIC(8,0), aae041 NUMERIC(6,0), aae042 NUMERIC(6,0));\", \"CREATE INDEX idx_dwd_csi_ac02_aac001 ON dwd_csi_ac02(aac001);\", \"CREATE INDEX idx_dwd_csi_ac02_composite ON dwd_csi_ac02(aae140, aac008, aac031, aac030, aae041, aae042);\", \"CREATE TABLE dwd_hrss_ac99 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aac147 VARCHAR(100));\", \"CREATE INDEX idx_dwd_hrss_ac99_aac001 ON dwd_hrss_ac99(aac001);\", \"CREATE INDEX idx_dwd_hrss_ac99_aac147 ON dwd_hrss_ac99(aac147);\"], \"sql\": \"select\\n\\t'lxzdqdwjf5nys',\\n\\t'连续在当前单位参保5年以上',\\n\\tc.aac147,\\n\\t'是',\\n\\t'连续在当前单位参保5年以上'\\nfrom\\n\\tdwd_csi_ac02 a,\\n\\t(\\n\\tselect\\n\\t\\t(fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)|| '31')::numeric aac030,\\n\\t\\t fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)::numeric aae041,\\n\\t\\tto_char(current_timestamp, 'yyyymm')::numeric aae042) b,\\n\\tdwd_hrss_ac99 c\\nwhere a.aac001::varchar = c.aac001::varchar\\n\\tand a.aae140 = '110'\\n\\tand a.aac008 = '1'\\n\\tand a.aac031 = '1'\\n\\tand a.aac030 <= b.aac030\\n\\tand a.aae041 <= b.aae041\\n\\tand coalesce(a.aae042, 999912) >= b.aae042\\n\\tand c.aac147 is not null limit 1\", \"explain\": \"QUERY PLAN\\nLimit  (cost=0.42..3.47 rows=1 width=166)\\n  ->  Nested Loop  (cost=0.42..45289.49 rows=14886 width=166)\\n  ->  Nested Loop  (cost=0.00..35441.33 rows=16590 width=19)\\n  Join Filter: ((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\\n  ->  Result  (cost=0.00..0.54 rows=1 width=96)\\n  ->  Seq Scan on dwd_csi_ac02 a  (cost=0.00..27602.00 rows=447931 width=40)\\n  Filter: (((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\\n  ->  Index Scan using idx_dwd_hrss_ac99_aac001 on dwd_hrss_ac99 c  (cost=0.42..0.58 rows=1 width=57)\\n  Index Cond: ((aac001)::text = (a.aac001)::text)\\n  Filter: (aac147 IS NOT NULL)\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Limit', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 3.47, 'Plan Rows': 1, 'Plan Width': 166, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.42, 'Total Cost': 45289.49, 'Plan Rows': 14886, 'Plan Width': 166, 'Inner Unique': False, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.0, 'Total Cost': 35441.33, 'Plan Rows': 16590, 'Plan Width': 19, 'Inner Unique': False, 'Join Filter': \\\"((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\\\", 'Plans': [{'Node Type': 'Result', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.0, 'Total Cost': 0.54, 'Plan Rows': 1, 'Plan Width': 96}, {'Node Type': 'Seq Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'dwd_csi_ac02', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 27602.0, 'Plan Rows': 447931, 'Plan Width': 40, 'Filter': \\\"(((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\\\"}]}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_dwd_hrss_ac99_aac001', 'Relation Name': 'dwd_hrss_ac99', 'Alias': 'c', 'Startup Cost': 0.42, 'Total Cost': 0.58, 'Plan Rows': 1, 'Plan Width': 57, 'Index Cond': '((aac001)::text = (a.aac001)::text)', 'Filter': '(aac147 IS NOT NULL)'}]}]}}]\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推规则优化：1) 将a表的独立过滤条件(aae140/aac008/aac031)下推到内联子查询；2) 将c表的aac147非空检查下推到子查询；3) 保持b视图计算逻辑不变。改写后显著减少JOIN前的中间数据量，保持业务逻辑不变。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,通过将COALESCE函数替换为等效的OR条件，消除字段上的函数操作，使数据库能利用aae042字段的索引。改写前后逻辑完全等价\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"用静态可搜索参数替换动态条件,优化消除动态函数包装、多重类型转换和非SARGable模式：1) 移除3层类型转换链(DATE→CHAR→NUMERIC) 2) 消除JOIN条件冗余类型转换 3) 提取动态函数到CTE避免重复计算 4) 保持NULL处理逻辑优化 5) 移除仅生成常量的CROSS JOIN。预期性能提升5%-15%(高并发场景累积效应显著)，扫描行数减少约30%\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE dwd_csi_ac02 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aae140 VARCHAR(10), aac008 VARCHAR(5), aac031 VARCHAR(5), aac030 NUMERIC(8,0), aae041 NUMERIC(6,0), aae042 NUMERIC(6,0));\nCREATE INDEX idx_dwd_csi_ac02_aac001 ON dwd_csi_ac02(aac001);\nCREATE INDEX idx_dwd_csi_ac02_composite ON dwd_csi_ac02(aae140, aac008, aac031, aac030, aae041, aae042);\nCREATE TABLE dwd_hrss_ac99 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aac147 VARCHAR(100));\nCREATE INDEX idx_dwd_hrss_ac99_aac001 ON dwd_hrss_ac99(aac001);\nCREATE INDEX idx_dwd_hrss_ac99_aac147 ON dwd_hrss_ac99(aac147);\n\n## Explain Output in JSON:\nQUERY PLAN\nLimit  (cost=0.42..3.47 rows=1 width=166)\n  ->  Nested Loop  (cost=0.42..45289.49 rows=14886 width=166)\n  ->  Nested Loop  (cost=0.00..35441.33 rows=16590 width=19)\n  Join Filter: ((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\n  ->  Result  (cost=0.00..0.54 rows=1 width=96)\n  ->  Seq Scan on dwd_csi_ac02 a  (cost=0.00..27602.00 rows=447931 width=40)\n  Filter: (((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\n  ->  Index Scan using idx_dwd_hrss_ac99_aac001 on dwd_hrss_ac99 c  (cost=0.42..0.58 rows=1 width=57)\n  Index Cond: ((aac001)::text = (a.aac001)::text)\n  Filter: (aac147 IS NOT NULL)\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Limit', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 3.47, 'Plan Rows': 1, 'Plan Width': 166, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.42, 'Total Cost': 45289.49, 'Plan Rows': 14886, 'Plan Width': 166, 'Inner Unique': False, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.0, 'Total Cost': 35441.33, 'Plan Rows': 16590, 'Plan Width': 19, 'Inner Unique': False, 'Join Filter': \"((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\", 'Plans': [{'Node Type': 'Result', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.0, 'Total Cost': 0.54, 'Plan Rows': 1, 'Plan Width': 96}, {'Node Type': 'Seq Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'dwd_csi_ac02', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 27602.0, 'Plan Rows': 447931, 'Plan Width': 40, 'Filter': \"(((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\"}]}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_dwd_hrss_ac99_aac001', 'Relation Name': 'dwd_hrss_ac99', 'Alias': 'c', 'Startup Cost': 0.42, 'Total Cost': 0.58, 'Plan Rows': 1, 'Plan Width': 57, 'Index Cond': '((aac001)::text = (a.aac001)::text)', 'Filter': '(aac147 IS NOT NULL)'}]}]}}]\n\n## Original SQL:\nselect\n\t'lxzdqdwjf5nys',\n\t'连续在当前单位参保5年以上',\n\tc.aac147,\n\t'是',\n\t'连续在当前单位参保5年以上'\nfrom\n\tdwd_csi_ac02 a,\n\t(\n\tselect\n\t\t(fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)|| '31')::numeric aac030,\n\t\t fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)::numeric aae041,\n\t\tto_char(current_timestamp, 'yyyymm')::numeric aae042) b,\n\tdwd_hrss_ac99 c\nwhere a.aac001::varchar = c.aac001::varchar\n\tand a.aae140 = '110'\n\tand a.aac008 = '1'\n\tand a.aac031 = '1'\n\tand a.aac030 <= b.aac030\n\tand a.aae041 <= b.aae041\n\tand coalesce(a.aae042, 999912) >= b.aae042\n\tand c.aac147 is not null limit 1\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select 'lxzdqdwjf5nys','连续在当前单位参保5年以上',c.aac147,'是','连续在当前单位参保5年以上' from dwd_csi_ac02 a inner join dwd_hrss_ac99 c on a.aac001=c.aac001 where a.aae140='110' and a.aac008='1' and a.aac031='1' and a.aac030<=(fun_addmonth(to_char(current_timestamp,'yyyymm')::varchar,-61)||'31')::numeric and a.aae041<=fun_addmonth(to_char(current_timestamp,'yyyymm')::varchar,-61)::numeric and coalesce(a.aae042,999912)>=to_char(current_timestamp,'yyyymm')::numeric and c.aac147 is not null limit 1"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "27",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"27\", \"db_type\": \"postgresql\", \"description\": \"该改写试图用经典的'MAX+自连接'模式替代窗口函数来获取每个分组的最新记录。理论上，当窗口函数需要处理大量数据时，GROUP BY聚合可能更高效。然而，本次改写犯了两个严重错误：1) 在CTE定义和子查询中使用了SELECT指定列而非SELECT *，导致结果集缺少字段；2) 没有充分验证结果集的完整性。正确的改写应该保持与原SQL完全相同的输出列，只改变获取数据的方法。\", \"create_table_statements\": [\"CREATE TABLE cash_transaction (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL, balance DECIMAL(15,2) NOT NULL DEFAULT 0, created_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, cash_type INTEGER NOT NULL);\", \"CREATE INDEX idx_cash_transaction_member_num ON cash_transaction(member_num);\", \"CREATE INDEX idx_cash_transaction_cash_type ON cash_transaction(cash_type);\", \"CREATE INDEX idx_cash_transaction_composite ON cash_transaction(member_num, cash_type, id DESC);\", \"CREATE TABLE cash (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL UNIQUE, credit_available DECIMAL(15,2) NOT NULL DEFAULT 0);\", \"CREATE INDEX idx_cash_member_num ON cash(member_num);\"], \"sql\": \"with temp as(\\n select * from (\\n select ROW_NUMBER() OVER (PARTITION BY member_num ORDER BY id desc)a,\\n member_num,balance,created_on\\n from cash_transaction where cash_type=2 )a\\n where a=1 and balance<>0)\\n select * from temp a \\n full outer join\\n ( select * from  cash where  credit_available<>0)b\\n on a.member_num=b.member_num\\n where a.balance<>b.credit_available\\n or a.member_num is null\\n or b.member_num is null\", \"explain\": \"QUERY PLAN\\nHash Full Join  (cost=100581.31..137547.65 rows=835137 width=58)\\n  Hash Cond: ((cash.member_num)::text = (a.member_num)::text)\\n  Filter: ((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))\\n  ->  Seq Scan on cash  (cost=0.00..19747.00 rows=859467 width=26)\\n  Filter: (credit_available <> '0'::numeric)\\n  ->  Hash  (cost=100546.39..100546.39 rows=2793 width=32)\\n  ->  Subquery Scan on a  (cost=0.42..100546.39 rows=2793 width=32)\\n  Filter: ((a.balance <> '0'::numeric) AND (a.a = 1))\\n  ->  WindowAgg  (cost=0.42..90052.89 rows=699567 width=40)\\n  Run Condition: (row_number() OVER (?) <= 1)\\n  ->  Index Scan using idx_cash_transaction_composite on cash_transaction  (cost=0.42..77810.47 rows=699567 width=32)\\n  Index Cond: (cash_type = 2)\\nJIT:\\n  Functions: 25\\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Hash Join', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Full', 'Startup Cost': 100581.31, 'Total Cost': 137547.65, 'Plan Rows': 835137, 'Plan Width': 58, 'Inner Unique': False, 'Hash Cond': '((cash.member_num)::text = (a.member_num)::text)', 'Filter': '((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'cash', 'Alias': 'cash', 'Startup Cost': 0.0, 'Total Cost': 19747.0, 'Plan Rows': 859467, 'Plan Width': 26, 'Filter': \\\"(credit_available <> '0'::numeric)\\\"}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 100546.39, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'a', 'Startup Cost': 0.42, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Filter': \\\"((a.balance <> '0'::numeric) AND (a.a = 1))\\\", 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 90052.89, 'Plan Rows': 699567, 'Plan Width': 40, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_cash_transaction_composite', 'Relation Name': 'cash_transaction', 'Alias': 'cash_transaction', 'Startup Cost': 0.42, 'Total Cost': 77810.47, 'Plan Rows': 699567, 'Plan Width': 32, 'Index Cond': '(cash_type = 2)'}]}]}]}]}, 'JIT': {'Functions': 25, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推优化：消除子查询中未使用的列。移除CTE内部子查询的created_on列和子查询b的多余列，减少临时表内存占用（估计减少30%+）和I/O开销。优化后temp仅输出member_num和balance，子查询b仅输出credit_available和member_num。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"窗口函数推导TopN,通过TopN算子优化窗口函数计算：添加预排序CTE使窗口函数流式处理，避免全量排序。需确保(member_num, id)索引存在以实现最佳性能，预估提升10-30%。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"窗口函数转聚合,通过将窗口函数改写为GROUP BY聚合配合JOIN，避免全量排序。利用索引松散扫描直接定位每组的最大值，性能提升显著。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE cash_transaction (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL, balance DECIMAL(15,2) NOT NULL DEFAULT 0, created_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, cash_type INTEGER NOT NULL);\nCREATE INDEX idx_cash_transaction_member_num ON cash_transaction(member_num);\nCREATE INDEX idx_cash_transaction_cash_type ON cash_transaction(cash_type);\nCREATE INDEX idx_cash_transaction_composite ON cash_transaction(member_num, cash_type, id DESC);\nCREATE TABLE cash (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL UNIQUE, credit_available DECIMAL(15,2) NOT NULL DEFAULT 0);\nCREATE INDEX idx_cash_member_num ON cash(member_num);\n\n## Explain Output in JSON:\nQUERY PLAN\nHash Full Join  (cost=100581.31..137547.65 rows=835137 width=58)\n  Hash Cond: ((cash.member_num)::text = (a.member_num)::text)\n  Filter: ((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))\n  ->  Seq Scan on cash  (cost=0.00..19747.00 rows=859467 width=26)\n  Filter: (credit_available <> '0'::numeric)\n  ->  Hash  (cost=100546.39..100546.39 rows=2793 width=32)\n  ->  Subquery Scan on a  (cost=0.42..100546.39 rows=2793 width=32)\n  Filter: ((a.balance <> '0'::numeric) AND (a.a = 1))\n  ->  WindowAgg  (cost=0.42..90052.89 rows=699567 width=40)\n  Run Condition: (row_number() OVER (?) <= 1)\n  ->  Index Scan using idx_cash_transaction_composite on cash_transaction  (cost=0.42..77810.47 rows=699567 width=32)\n  Index Cond: (cash_type = 2)\nJIT:\n  Functions: 25\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Hash Join', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Full', 'Startup Cost': 100581.31, 'Total Cost': 137547.65, 'Plan Rows': 835137, 'Plan Width': 58, 'Inner Unique': False, 'Hash Cond': '((cash.member_num)::text = (a.member_num)::text)', 'Filter': '((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'cash', 'Alias': 'cash', 'Startup Cost': 0.0, 'Total Cost': 19747.0, 'Plan Rows': 859467, 'Plan Width': 26, 'Filter': \"(credit_available <> '0'::numeric)\"}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 100546.39, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'a', 'Startup Cost': 0.42, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Filter': \"((a.balance <> '0'::numeric) AND (a.a = 1))\", 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 90052.89, 'Plan Rows': 699567, 'Plan Width': 40, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_cash_transaction_composite', 'Relation Name': 'cash_transaction', 'Alias': 'cash_transaction', 'Startup Cost': 0.42, 'Total Cost': 77810.47, 'Plan Rows': 699567, 'Plan Width': 32, 'Index Cond': '(cash_type = 2)'}]}]}]}]}, 'JIT': {'Functions': 25, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\n\n## Original SQL:\nwith temp as(\n select * from (\n select ROW_NUMBER() OVER (PARTITION BY member_num ORDER BY id desc)a,\n member_num,balance,created_on\n from cash_transaction where cash_type=2 )a\n where a=1 and balance<>0)\n select * from temp a \n full outer join\n ( select * from  cash where  credit_available<>0)b\n on a.member_num=b.member_num\n where a.balance<>b.credit_available\n or a.member_num is null\n or b.member_num is null\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select * from (select distinct on (member_num) member_num,balance,created_on from cash_transaction where cash_type=2 and balance<>0 order by member_num,id desc) a full outer join (select * from cash where credit_available<>0) b on a.member_num=b.member_num where a.balance is distinct from b.credit_available or a.member_num is null or b.member_num is null"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "27",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"27\", \"db_type\": \"postgresql\", \"description\": \"该改写试图用经典的'MAX+自连接'模式替代窗口函数来获取每个分组的最新记录。理论上，当窗口函数需要处理大量数据时，GROUP BY聚合可能更高效。然而，本次改写犯了两个严重错误：1) 在CTE定义和子查询中使用了SELECT指定列而非SELECT *，导致结果集缺少字段；2) 没有充分验证结果集的完整性。正确的改写应该保持与原SQL完全相同的输出列，只改变获取数据的方法。\", \"create_table_statements\": [\"CREATE TABLE cash_transaction (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL, balance DECIMAL(15,2) NOT NULL DEFAULT 0, created_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, cash_type INTEGER NOT NULL);\", \"CREATE INDEX idx_cash_transaction_member_num ON cash_transaction(member_num);\", \"CREATE INDEX idx_cash_transaction_cash_type ON cash_transaction(cash_type);\", \"CREATE INDEX idx_cash_transaction_composite ON cash_transaction(member_num, cash_type, id DESC);\", \"CREATE TABLE cash (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL UNIQUE, credit_available DECIMAL(15,2) NOT NULL DEFAULT 0);\", \"CREATE INDEX idx_cash_member_num ON cash(member_num);\"], \"sql\": \"with temp as(\\n select * from (\\n select ROW_NUMBER() OVER (PARTITION BY member_num ORDER BY id desc)a,\\n member_num,balance,created_on\\n from cash_transaction where cash_type=2 )a\\n where a=1 and balance<>0)\\n select * from temp a \\n full outer join\\n ( select * from  cash where  credit_available<>0)b\\n on a.member_num=b.member_num\\n where a.balance<>b.credit_available\\n or a.member_num is null\\n or b.member_num is null\", \"explain\": \"QUERY PLAN\\nHash Full Join  (cost=100581.31..137547.65 rows=835137 width=58)\\n  Hash Cond: ((cash.member_num)::text = (a.member_num)::text)\\n  Filter: ((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))\\n  ->  Seq Scan on cash  (cost=0.00..19747.00 rows=859467 width=26)\\n  Filter: (credit_available <> '0'::numeric)\\n  ->  Hash  (cost=100546.39..100546.39 rows=2793 width=32)\\n  ->  Subquery Scan on a  (cost=0.42..100546.39 rows=2793 width=32)\\n  Filter: ((a.balance <> '0'::numeric) AND (a.a = 1))\\n  ->  WindowAgg  (cost=0.42..90052.89 rows=699567 width=40)\\n  Run Condition: (row_number() OVER (?) <= 1)\\n  ->  Index Scan using idx_cash_transaction_composite on cash_transaction  (cost=0.42..77810.47 rows=699567 width=32)\\n  Index Cond: (cash_type = 2)\\nJIT:\\n  Functions: 25\\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Hash Join', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Full', 'Startup Cost': 100581.31, 'Total Cost': 137547.65, 'Plan Rows': 835137, 'Plan Width': 58, 'Inner Unique': False, 'Hash Cond': '((cash.member_num)::text = (a.member_num)::text)', 'Filter': '((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'cash', 'Alias': 'cash', 'Startup Cost': 0.0, 'Total Cost': 19747.0, 'Plan Rows': 859467, 'Plan Width': 26, 'Filter': \\\"(credit_available <> '0'::numeric)\\\"}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 100546.39, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'a', 'Startup Cost': 0.42, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Filter': \\\"((a.balance <> '0'::numeric) AND (a.a = 1))\\\", 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 90052.89, 'Plan Rows': 699567, 'Plan Width': 40, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_cash_transaction_composite', 'Relation Name': 'cash_transaction', 'Alias': 'cash_transaction', 'Startup Cost': 0.42, 'Total Cost': 77810.47, 'Plan Rows': 699567, 'Plan Width': 32, 'Index Cond': '(cash_type = 2)'}]}]}]}]}, 'JIT': {'Functions': 25, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推优化：消除子查询中未使用的列。移除CTE内部子查询的created_on列和子查询b的多余列，减少临时表内存占用（估计减少30%+）和I/O开销。优化后temp仅输出member_num和balance，子查询b仅输出credit_available和member_num。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"窗口函数推导TopN,通过TopN算子优化窗口函数计算：添加预排序CTE使窗口函数流式处理，避免全量排序。需确保(member_num, id)索引存在以实现最佳性能，预估提升10-30%。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"窗口函数转聚合,通过将窗口函数改写为GROUP BY聚合配合JOIN，避免全量排序。利用索引松散扫描直接定位每组的最大值，性能提升显著。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE cash_transaction (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL, balance DECIMAL(15,2) NOT NULL DEFAULT 0, created_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, cash_type INTEGER NOT NULL);\nCREATE INDEX idx_cash_transaction_member_num ON cash_transaction(member_num);\nCREATE INDEX idx_cash_transaction_cash_type ON cash_transaction(cash_type);\nCREATE INDEX idx_cash_transaction_composite ON cash_transaction(member_num, cash_type, id DESC);\nCREATE TABLE cash (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL UNIQUE, credit_available DECIMAL(15,2) NOT NULL DEFAULT 0);\nCREATE INDEX idx_cash_member_num ON cash(member_num);\n\n## Explain Output in JSON:\nQUERY PLAN\nHash Full Join  (cost=100581.31..137547.65 rows=835137 width=58)\n  Hash Cond: ((cash.member_num)::text = (a.member_num)::text)\n  Filter: ((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))\n  ->  Seq Scan on cash  (cost=0.00..19747.00 rows=859467 width=26)\n  Filter: (credit_available <> '0'::numeric)\n  ->  Hash  (cost=100546.39..100546.39 rows=2793 width=32)\n  ->  Subquery Scan on a  (cost=0.42..100546.39 rows=2793 width=32)\n  Filter: ((a.balance <> '0'::numeric) AND (a.a = 1))\n  ->  WindowAgg  (cost=0.42..90052.89 rows=699567 width=40)\n  Run Condition: (row_number() OVER (?) <= 1)\n  ->  Index Scan using idx_cash_transaction_composite on cash_transaction  (cost=0.42..77810.47 rows=699567 width=32)\n  Index Cond: (cash_type = 2)\nJIT:\n  Functions: 25\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Hash Join', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Full', 'Startup Cost': 100581.31, 'Total Cost': 137547.65, 'Plan Rows': 835137, 'Plan Width': 58, 'Inner Unique': False, 'Hash Cond': '((cash.member_num)::text = (a.member_num)::text)', 'Filter': '((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'cash', 'Alias': 'cash', 'Startup Cost': 0.0, 'Total Cost': 19747.0, 'Plan Rows': 859467, 'Plan Width': 26, 'Filter': \"(credit_available <> '0'::numeric)\"}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 100546.39, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'a', 'Startup Cost': 0.42, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Filter': \"((a.balance <> '0'::numeric) AND (a.a = 1))\", 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 90052.89, 'Plan Rows': 699567, 'Plan Width': 40, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_cash_transaction_composite', 'Relation Name': 'cash_transaction', 'Alias': 'cash_transaction', 'Startup Cost': 0.42, 'Total Cost': 77810.47, 'Plan Rows': 699567, 'Plan Width': 32, 'Index Cond': '(cash_type = 2)'}]}]}]}]}, 'JIT': {'Functions': 25, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\n\n## Original SQL:\nwith temp as(\n select * from (\n select ROW_NUMBER() OVER (PARTITION BY member_num ORDER BY id desc)a,\n member_num,balance,created_on\n from cash_transaction where cash_type=2 )a\n where a=1 and balance<>0)\n select * from temp a \n full outer join\n ( select * from  cash where  credit_available<>0)b\n on a.member_num=b.member_num\n where a.balance<>b.credit_available\n or a.member_num is null\n or b.member_num is null\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select * from (select distinct on (member_num) member_num,balance,created_on from cash_transaction where cash_type=2 and balance<>0 order by member_num,id desc) a full outer join (select * from cash where credit_available<>0) b on a.member_num=b.member_num where a.balance is distinct from b.credit_available or a.member_num is null or b.member_num is null"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "27",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"27\", \"db_type\": \"postgresql\", \"description\": \"该改写试图用经典的'MAX+自连接'模式替代窗口函数来获取每个分组的最新记录。理论上，当窗口函数需要处理大量数据时，GROUP BY聚合可能更高效。然而，本次改写犯了两个严重错误：1) 在CTE定义和子查询中使用了SELECT指定列而非SELECT *，导致结果集缺少字段；2) 没有充分验证结果集的完整性。正确的改写应该保持与原SQL完全相同的输出列，只改变获取数据的方法。\", \"create_table_statements\": [\"CREATE TABLE cash_transaction (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL, balance DECIMAL(15,2) NOT NULL DEFAULT 0, created_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, cash_type INTEGER NOT NULL);\", \"CREATE INDEX idx_cash_transaction_member_num ON cash_transaction(member_num);\", \"CREATE INDEX idx_cash_transaction_cash_type ON cash_transaction(cash_type);\", \"CREATE INDEX idx_cash_transaction_composite ON cash_transaction(member_num, cash_type, id DESC);\", \"CREATE TABLE cash (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL UNIQUE, credit_available DECIMAL(15,2) NOT NULL DEFAULT 0);\", \"CREATE INDEX idx_cash_member_num ON cash(member_num);\"], \"sql\": \"with temp as(\\n select * from (\\n select ROW_NUMBER() OVER (PARTITION BY member_num ORDER BY id desc)a,\\n member_num,balance,created_on\\n from cash_transaction where cash_type=2 )a\\n where a=1 and balance<>0)\\n select * from temp a \\n full outer join\\n ( select * from  cash where  credit_available<>0)b\\n on a.member_num=b.member_num\\n where a.balance<>b.credit_available\\n or a.member_num is null\\n or b.member_num is null\", \"explain\": \"QUERY PLAN\\nHash Full Join  (cost=100581.31..137547.65 rows=835137 width=58)\\n  Hash Cond: ((cash.member_num)::text = (a.member_num)::text)\\n  Filter: ((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))\\n  ->  Seq Scan on cash  (cost=0.00..19747.00 rows=859467 width=26)\\n  Filter: (credit_available <> '0'::numeric)\\n  ->  Hash  (cost=100546.39..100546.39 rows=2793 width=32)\\n  ->  Subquery Scan on a  (cost=0.42..100546.39 rows=2793 width=32)\\n  Filter: ((a.balance <> '0'::numeric) AND (a.a = 1))\\n  ->  WindowAgg  (cost=0.42..90052.89 rows=699567 width=40)\\n  Run Condition: (row_number() OVER (?) <= 1)\\n  ->  Index Scan using idx_cash_transaction_composite on cash_transaction  (cost=0.42..77810.47 rows=699567 width=32)\\n  Index Cond: (cash_type = 2)\\nJIT:\\n  Functions: 25\\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Hash Join', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Full', 'Startup Cost': 100581.31, 'Total Cost': 137547.65, 'Plan Rows': 835137, 'Plan Width': 58, 'Inner Unique': False, 'Hash Cond': '((cash.member_num)::text = (a.member_num)::text)', 'Filter': '((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'cash', 'Alias': 'cash', 'Startup Cost': 0.0, 'Total Cost': 19747.0, 'Plan Rows': 859467, 'Plan Width': 26, 'Filter': \\\"(credit_available <> '0'::numeric)\\\"}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 100546.39, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'a', 'Startup Cost': 0.42, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Filter': \\\"((a.balance <> '0'::numeric) AND (a.a = 1))\\\", 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 90052.89, 'Plan Rows': 699567, 'Plan Width': 40, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_cash_transaction_composite', 'Relation Name': 'cash_transaction', 'Alias': 'cash_transaction', 'Startup Cost': 0.42, 'Total Cost': 77810.47, 'Plan Rows': 699567, 'Plan Width': 32, 'Index Cond': '(cash_type = 2)'}]}]}]}]}, 'JIT': {'Functions': 25, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推优化：消除子查询中未使用的列。移除CTE内部子查询的created_on列和子查询b的多余列，减少临时表内存占用（估计减少30%+）和I/O开销。优化后temp仅输出member_num和balance，子查询b仅输出credit_available和member_num。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"窗口函数推导TopN,通过TopN算子优化窗口函数计算：添加预排序CTE使窗口函数流式处理，避免全量排序。需确保(member_num, id)索引存在以实现最佳性能，预估提升10-30%。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"窗口函数转聚合,通过将窗口函数改写为GROUP BY聚合配合JOIN，避免全量排序。利用索引松散扫描直接定位每组的最大值，性能提升显著。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE cash_transaction (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL, balance DECIMAL(15,2) NOT NULL DEFAULT 0, created_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, cash_type INTEGER NOT NULL);\nCREATE INDEX idx_cash_transaction_member_num ON cash_transaction(member_num);\nCREATE INDEX idx_cash_transaction_cash_type ON cash_transaction(cash_type);\nCREATE INDEX idx_cash_transaction_composite ON cash_transaction(member_num, cash_type, id DESC);\nCREATE TABLE cash (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL UNIQUE, credit_available DECIMAL(15,2) NOT NULL DEFAULT 0);\nCREATE INDEX idx_cash_member_num ON cash(member_num);\n\n## Explain Output in JSON:\nQUERY PLAN\nHash Full Join  (cost=100581.31..137547.65 rows=835137 width=58)\n  Hash Cond: ((cash.member_num)::text = (a.member_num)::text)\n  Filter: ((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))\n  ->  Seq Scan on cash  (cost=0.00..19747.00 rows=859467 width=26)\n  Filter: (credit_available <> '0'::numeric)\n  ->  Hash  (cost=100546.39..100546.39 rows=2793 width=32)\n  ->  Subquery Scan on a  (cost=0.42..100546.39 rows=2793 width=32)\n  Filter: ((a.balance <> '0'::numeric) AND (a.a = 1))\n  ->  WindowAgg  (cost=0.42..90052.89 rows=699567 width=40)\n  Run Condition: (row_number() OVER (?) <= 1)\n  ->  Index Scan using idx_cash_transaction_composite on cash_transaction  (cost=0.42..77810.47 rows=699567 width=32)\n  Index Cond: (cash_type = 2)\nJIT:\n  Functions: 25\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Hash Join', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Full', 'Startup Cost': 100581.31, 'Total Cost': 137547.65, 'Plan Rows': 835137, 'Plan Width': 58, 'Inner Unique': False, 'Hash Cond': '((cash.member_num)::text = (a.member_num)::text)', 'Filter': '((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'cash', 'Alias': 'cash', 'Startup Cost': 0.0, 'Total Cost': 19747.0, 'Plan Rows': 859467, 'Plan Width': 26, 'Filter': \"(credit_available <> '0'::numeric)\"}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 100546.39, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'a', 'Startup Cost': 0.42, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Filter': \"((a.balance <> '0'::numeric) AND (a.a = 1))\", 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 90052.89, 'Plan Rows': 699567, 'Plan Width': 40, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_cash_transaction_composite', 'Relation Name': 'cash_transaction', 'Alias': 'cash_transaction', 'Startup Cost': 0.42, 'Total Cost': 77810.47, 'Plan Rows': 699567, 'Plan Width': 32, 'Index Cond': '(cash_type = 2)'}]}]}]}]}, 'JIT': {'Functions': 25, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\n\n## Original SQL:\nwith temp as(\n select * from (\n select ROW_NUMBER() OVER (PARTITION BY member_num ORDER BY id desc)a,\n member_num,balance,created_on\n from cash_transaction where cash_type=2 )a\n where a=1 and balance<>0)\n select * from temp a \n full outer join\n ( select * from  cash where  credit_available<>0)b\n on a.member_num=b.member_num\n where a.balance<>b.credit_available\n or a.member_num is null\n or b.member_num is null\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select * from (select distinct on (member_num) member_num,balance,created_on from cash_transaction where cash_type=2 and balance<>0 order by member_num,id desc) a full outer join (select * from cash where credit_available<>0) b on a.member_num=b.member_num where a.balance is distinct from b.credit_available or a.member_num is null or b.member_num is null"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "28",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"28\", \"db_type\": \"oracle\", \"description\": \"本次改写主要做了两方面优化：1) 消除了子查询中计算但从未使用的first_tran_date字段，减少了一次min()聚合操作；2) 将onhold_accounts这个内联视图展开，直接在主查询中JOIN audit_header和audit_detail表，并将过滤条件移到WHERE子句中。这种改写理论上可以给优化器更多的优化空间，但由于原SQL结构已经较为优化，实际收益有限。\", \"create_table_statements\": [\"CREATE SEQUENCE accounts_seq; CREATE TABLE accounts (acc_account_no VARCHAR2(50), acc_subacc_no VARCHAR2(50), acc_incep_date DATE NOT NULL, acc_act_code VARCHAR2(20), acc_gact_type VARCHAR2(10), PRIMARY KEY (acc_account_no, acc_subacc_no)); CREATE OR REPLACE TRIGGER accounts_bi BEFORE INSERT ON accounts FOR EACH ROW BEGIN NULL; END;\", \"CREATE INDEX idx_accounts_act_code ON accounts(acc_act_code);\", \"CREATE INDEX idx_accounts_gact_type ON accounts(acc_gact_type);\", \"CREATE INDEX idx_accounts_incep_date ON accounts(acc_incep_date);\", \"CREATE SEQUENCE account_headers_seq; CREATE TABLE account_headers (acch_account_no VARCHAR2(50) PRIMARY KEY, acch_title VARCHAR2(200), acch_brn_code VARCHAR2(20)); CREATE OR REPLACE TRIGGER account_headers_bi BEFORE INSERT ON account_headers FOR EACH ROW BEGIN NULL; END;\", \"CREATE INDEX idx_acch_account_no ON account_headers(acch_account_no);\", \"CREATE SEQUENCE account_types_seq; CREATE TABLE account_types (act_code VARCHAR2(20) PRIMARY KEY, act_long_name VARCHAR2(100)); CREATE OR REPLACE TRIGGER account_types_bi BEFORE INSERT ON account_types FOR EACH ROW BEGIN NULL; END;\", \"CREATE SEQUENCE transactions_seq; CREATE TABLE transactions (tran_seqno NUMBER PRIMARY KEY, tran_account_no VARCHAR2(50) NOT NULL, tran_subacc_no VARCHAR2(50) NOT NULL, tran_date DATE NOT NULL, tran_amount_cr NUMBER(18,2), tran_trans_code VARCHAR2(20), tran_pay_method VARCHAR2(10), tran_create_by VARCHAR2(50)); CREATE OR REPLACE TRIGGER transactions_bi BEFORE INSERT ON transactions FOR EACH ROW BEGIN IF :NEW.tran_seqno IS NULL THEN SELECT transactions_seq.NEXTVAL INTO :NEW.tran_seqno FROM DUAL; END IF; END;\", \"CREATE INDEX idx_trans_account_subacc ON transactions(tran_account_no, tran_subacc_no);\", \"CREATE INDEX idx_trans_date ON transactions(tran_date);\", \"CREATE INDEX idx_trans_trans_code ON transactions(tran_trans_code);\", \"CREATE INDEX idx_trans_pay_method ON transactions(tran_pay_method);\", \"CREATE SEQUENCE audit_header_seq; CREATE TABLE audit_header (audh_seqno NUMBER PRIMARY KEY, audh_key1 VARCHAR2(50), audh_key2 VARCHAR2(50), audh_date DATE, audh_table_prefix VARCHAR2(20), audh_change_type VARCHAR2(10)); CREATE OR REPLACE TRIGGER audit_header_bi BEFORE INSERT ON audit_header FOR EACH ROW BEGIN IF :NEW.audh_seqno IS NULL THEN SELECT audit_header_seq.NEXTVAL INTO :NEW.audh_seqno FROM DUAL; END IF; END;\", \"CREATE INDEX idx_audh_keys ON audit_header(audh_key1, audh_key2);\", \"CREATE INDEX idx_audh_table_prefix ON audit_header(audh_table_prefix);\", \"CREATE INDEX idx_audh_change_type ON audit_header(audh_change_type);\", \"CREATE SEQUENCE audit_detail_seq; CREATE TABLE audit_detail (audd_id NUMBER PRIMARY KEY, audd_audh_seqno NUMBER NOT NULL, audd_col_sufix VARCHAR2(50), audd_old_value VARCHAR2(200), audd_new_value VARCHAR2(200)); CREATE OR REPLACE TRIGGER audit_detail_bi BEFORE INSERT ON audit_detail FOR EACH ROW BEGIN IF :NEW.audd_id IS NULL THEN SELECT audit_detail_seq.NEXTVAL INTO :NEW.audd_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_audd_audh_seqno ON audit_detail(audd_audh_seqno);\", \"CREATE INDEX idx_audd_col_sufix ON audit_detail(audd_col_sufix);\", \"CREATE SEQUENCE account_links_seq; CREATE TABLE ACCOUNT_LINKS (accl_id NUMBER PRIMARY KEY, accl_account_no VARCHAR2(50) NOT NULL, accl_subacc_no VARCHAR2(50) NOT NULL, accl_holder_pos NUMBER, accl_cust_seqno NUMBER); CREATE OR REPLACE TRIGGER account_links_bi BEFORE INSERT ON ACCOUNT_LINKS FOR EACH ROW BEGIN IF :NEW.accl_id IS NULL THEN SELECT account_links_seq.NEXTVAL INTO :NEW.accl_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_accl_account_subacc ON ACCOUNT_LINKS(accl_account_no, accl_subacc_no);\", \"CREATE INDEX idx_accl_holder_pos ON ACCOUNT_LINKS(accl_holder_pos);\", \"CREATE SEQUENCE account_holding_tax_seq; CREATE TABLE SUMMIT.ACCOUNT_HOLDING_TAX (acctax_id NUMBER PRIMARY KEY, ACCTAX_ACCOUNT_NO VARCHAR2(50) NOT NULL, ACCTAX_SUBACC_NO VARCHAR2(50) NOT NULL, ACCTAX_CUST_SEQNO NUMBER, ACCTAX_EFF_DATE_FROM DATE); CREATE OR REPLACE TRIGGER account_holding_tax_bi BEFORE INSERT ON SUMMIT.ACCOUNT_HOLDING_TAX FOR EACH ROW BEGIN IF :NEW.acctax_id IS NULL THEN SELECT account_holding_tax_seq.NEXTVAL INTO :NEW.acctax_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_acctax_composite ON SUMMIT.ACCOUNT_HOLDING_TAX(ACCTAX_ACCOUNT_NO, ACCTAX_SUBACC_NO, ACCTAX_CUST_SEQNO);\"], \"sql\": \"SELECT DISTINCT acc_account_no, \\n  acc_subacc_no, \\n  acch_title,\\n  to_char(acc_incep_date,'DD/MM/YYYY') acc_incep_date,\\n  htax.ACCTAX_EFF_DATE_FROM,\\n  to_char(onhold_accounts.audh_date, 'DD-MON-YYYY') approved_date,\\n  act_long_name, \\n  tran_amount_cr,\\n  tran_create_by,\\n  CASE WHEN (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) < 0 THEN 0 ELSE\\n   (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) END time_on_approved,\\n  acch_brn_code\\n  FROM\\n  (\\n   (\\n  SELECT accounts.acc_account_no,\\n   acch_title, \\n   accounts.acc_subacc_no,\\n   acc_incep_date,\\n   act_long_name,\\n   tran_amount_cr,\\n   transactions.tran_create_by,\\n   first_tran_date,\\n   acch_brn_code\\n  FROM accounts \\n  JOIN account_headers ON account_headers.acch_account_no = accounts.acc_account_no\\n  JOIN account_types ON acc_act_code = act_code\\n  JOIN \\n   (\\n  SELECT tran_account_no, tran_subacc_no, min(tran_seqno) first_tran_seq, min(tran_date) first_tran_date\\n  FROM transactions\\n  WHERE tran_amount_cr IS NOT NULL\\n  AND tran_trans_code IN ('RIC','RSAV')\\n  AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE\\n  AND tran_pay_method not in ('C','CQ')   --Exclude cash and cheque receipts as those accounts will already have the passbook.\\n  GROUP BY tran_account_no, tran_subacc_no\\n   ) first_trans\\n   ON tran_account_no = acc_account_no AND tran_subacc_no = acc_subacc_no\\n  JOIN transactions ON tran_seqno = first_trans.first_tran_seq\\n  WHERE acc_gact_type IN ('S', 'IC') \\n   AND acc_incep_date BETWEEN IN_INCEP_FROM_DATE and IN_INCEP_TO_DATE\\n   ) opened_accounts\\n   JOIN\\n   (\\n  SELECT audh_key1, audh_key2, audh_date, audd_old_value, audd_new_value\\n  FROM audit_header\\n  JOIN audit_detail\\n   ON audh_seqno = audd_audh_seqno\\n  WHERE audh_table_prefix = 'ACC'\\n   AND audd_col_sufix = 'PROCESS_STATUS'\\n   AND audh_change_type  = 'I'\\n   AND audd_old_value IS NULL \\n   AND audd_new_value = 1\\n   ) onhold_accounts\\n  ON opened_accounts.acc_account_no = onhold_accounts.audh_key1\\n   AND opened_accounts.acc_subacc_no = onhold_accounts.audh_key2\\n   JOIN ACCOUNT_LINKS al ON al.accl_account_no = opened_accounts.ACC_ACCOUNT_NO and al.accl_subacc_no = opened_accounts.ACC_SUBACC_NO and al.accl_holder_pos = 1\\n   JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax \\n  ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO\\n   AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO\\n   AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO\\n  )\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t1320\\t1\\t264\\t333735386\\t1311\\n1\\t  HASH UNIQUE \\t1320\\t1\\t264\\t333735386\\t1311\\n2\\t  HASH JOIN  \\t1319\\t1\\t264\\t296866817\\t1311\\n3\\t   NESTED LOOPS  \\t1319\\t1\\t264\\t296866817\\t1311\\n4\\t  NESTED LOOPS  \\t1319\\t1\\t264\\t296866817\\t1311\\n5\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n6\\t   NESTED LOOPS  \\t1317\\t1\\t249\\t296850384\\t1309\\n7\\t  HASH JOIN  \\t1294\\t1\\t236\\t296676455\\t1286\\n8\\t  NESTED LOOPS  \\t1294\\t1\\t236\\t296676455\\t1286\\n9\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n10\\t  HASH JOIN  \\t1291\\t1\\t206\\t296653810\\t1283\\n11\\t  NESTED LOOPS  \\t1291\\t1\\t206\\t296653810\\t1283\\n12\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n13\\t  HASH JOIN  \\t1289\\t1\\t180\\t296638517\\t1281\\n14\\t  NESTED LOOPS  \\t1289\\t1\\t180\\t296638517\\t1281\\n15\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n16\\t  HASH JOIN  \\t1287\\t1\\t132\\t296622185\\t1279\\n17\\t  NESTED LOOPS  \\t1287\\t1\\t132\\t296622185\\t1279\\n18\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n19\\t  NESTED LOOPS  \\t1283\\t4\\t328\\t296586099\\t1275\\n20\\t  HASH JOIN  \\t1278\\t4\\t208\\t296542487\\t1270\\n21\\t   NESTED LOOPS  \\t1278\\t4\\t208\\t296542487\\t1270\\n22\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n23\\t  TABLE ACCESS FULL AUDIT_DETAIL\\t1270\\t4\\t84\\t296476515\\t1262\\n24\\t  TABLE ACCESS BY INDEX ROWID AUDIT_HEADER\\t2\\t1\\t31\\t16493\\t2\\n25\\t  INDEX UNIQUE SCAN SYS_C008309\\t1\\t1\\t\\t9021\\t1\\n26\\t   TABLE ACCESS FULL AUDIT_HEADER\\t2\\t1\\t31\\t16493\\t2\\n27\\t  TABLE ACCESS BY INDEX ROWID ACCOUNTS\\t2\\t1\\t30\\t16548\\t2\\n28\\t   INDEX UNIQUE SCAN SYS_C008302\\t1\\t1\\t\\t9021\\t1\\n29\\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_TYPES\\t1\\t1\\t50\\t9021\\t1\\n30\\t  INDEX UNIQUE SCAN SYS_C008304\\t1\\t1\\t\\t9021\\t1\\n31\\t  TABLE ACCESS FULL ACCOUNT_TYPES\\t1\\t1\\t50\\t9021\\t1\\n32\\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_HEADERS\\t2\\t1\\t48\\t16333\\t2\\n33\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n34\\t  TABLE ACCESS FULL ACCOUNT_HEADERS\\t2\\t1\\t48\\t16333\\t2\\n35\\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_LINKS\\t2\\t1\\t26\\t15293\\t2\\n36\\t  INDEX RANGE SCAN IDX_ACCL_ACCOUNT_SUBACC\\t2\\t10\\t\\t15293\\t2\\n37\\t  TABLE ACCESS FULL ACCOUNT_LINKS\\t2\\t1\\t26\\t15293\\t2\\n38\\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_HOLDING_TAX\\t3\\t1\\t30\\t22644\\t3\\n39\\t  INDEX RANGE SCAN IDX_ACCTAX_COMPOSITE\\t2\\t1\\t\\t15293\\t2\\n40\\t  TABLE ACCESS FULL ACCOUNT_HOLDING_TAX\\t3\\t1\\t30\\t22644\\t3\\n41\\t  VIEW PUSHED PREDICATE  \\t23\\t1\\t13\\t173930\\t23\\n42\\t  FILTER  \\t\\t\\t\\t\\t\\n43\\t   SORT AGGREGATE \\t\\t1\\t40\\t\\t\\n44\\t  TABLE ACCESS BY INDEX ROWID BATCHED TRANSACTIONS\\t23\\t1\\t40\\t173930\\t23\\n45\\t  INDEX RANGE SCAN IDX_TRANS_ACCOUNT_SUBACC\\t3\\t20\\t\\t25364\\t3\\n46\\t  INDEX UNIQUE SCAN SYS_C008308\\t1\\t1\\t\\t9021\\t1\\n47\\t  TABLE ACCESS BY INDEX ROWID TRANSACTIONS\\t2\\t1\\t15\\t16433\\t2\\n48\\t   TABLE ACCESS FULL TRANSACTIONS\\t2\\t1\\t15\\t16433\\t2\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推规则，移除了子查询中未被外层引用的冗余列(min(tran_date)、audd_old_value和audd_new_value)，减少了数据读取量30%以上。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将accounts表的过滤条件下推至子查询内部，在JOIN前完成数据过滤。优化后数据库先过滤accounts表，减少中间结果集大小和后续JOIN开销，尤其当过滤条件选择性高时效果显著。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"子查询折叠,对符合条件的accounts和onhold_accounts子查询进行折叠优化，减少中间结果物化开销。通过消除冗余子查询包装，降低查询复杂度并减少临时表创建成本。优化后保留first_trans子查询的聚合逻辑，确保语义不变。性能预估提升10-15%，特别在MySQL 5.7环境下效果显著。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE accounts_seq; CREATE TABLE accounts (acc_account_no VARCHAR2(50), acc_subacc_no VARCHAR2(50), acc_incep_date DATE NOT NULL, acc_act_code VARCHAR2(20), acc_gact_type VARCHAR2(10), PRIMARY KEY (acc_account_no, acc_subacc_no)); CREATE OR REPLACE TRIGGER accounts_bi BEFORE INSERT ON accounts FOR EACH ROW BEGIN NULL; END;\nCREATE INDEX idx_accounts_act_code ON accounts(acc_act_code);\nCREATE INDEX idx_accounts_gact_type ON accounts(acc_gact_type);\nCREATE INDEX idx_accounts_incep_date ON accounts(acc_incep_date);\nCREATE SEQUENCE account_headers_seq; CREATE TABLE account_headers (acch_account_no VARCHAR2(50) PRIMARY KEY, acch_title VARCHAR2(200), acch_brn_code VARCHAR2(20)); CREATE OR REPLACE TRIGGER account_headers_bi BEFORE INSERT ON account_headers FOR EACH ROW BEGIN NULL; END;\nCREATE INDEX idx_acch_account_no ON account_headers(acch_account_no);\nCREATE SEQUENCE account_types_seq; CREATE TABLE account_types (act_code VARCHAR2(20) PRIMARY KEY, act_long_name VARCHAR2(100)); CREATE OR REPLACE TRIGGER account_types_bi BEFORE INSERT ON account_types FOR EACH ROW BEGIN NULL; END;\nCREATE SEQUENCE transactions_seq; CREATE TABLE transactions (tran_seqno NUMBER PRIMARY KEY, tran_account_no VARCHAR2(50) NOT NULL, tran_subacc_no VARCHAR2(50) NOT NULL, tran_date DATE NOT NULL, tran_amount_cr NUMBER(18,2), tran_trans_code VARCHAR2(20), tran_pay_method VARCHAR2(10), tran_create_by VARCHAR2(50)); CREATE OR REPLACE TRIGGER transactions_bi BEFORE INSERT ON transactions FOR EACH ROW BEGIN IF :NEW.tran_seqno IS NULL THEN SELECT transactions_seq.NEXTVAL INTO :NEW.tran_seqno FROM DUAL; END IF; END;\nCREATE INDEX idx_trans_account_subacc ON transactions(tran_account_no, tran_subacc_no);\nCREATE INDEX idx_trans_date ON transactions(tran_date);\nCREATE INDEX idx_trans_trans_code ON transactions(tran_trans_code);\nCREATE INDEX idx_trans_pay_method ON transactions(tran_pay_method);\nCREATE SEQUENCE audit_header_seq; CREATE TABLE audit_header (audh_seqno NUMBER PRIMARY KEY, audh_key1 VARCHAR2(50), audh_key2 VARCHAR2(50), audh_date DATE, audh_table_prefix VARCHAR2(20), audh_change_type VARCHAR2(10)); CREATE OR REPLACE TRIGGER audit_header_bi BEFORE INSERT ON audit_header FOR EACH ROW BEGIN IF :NEW.audh_seqno IS NULL THEN SELECT audit_header_seq.NEXTVAL INTO :NEW.audh_seqno FROM DUAL; END IF; END;\nCREATE INDEX idx_audh_keys ON audit_header(audh_key1, audh_key2);\nCREATE INDEX idx_audh_table_prefix ON audit_header(audh_table_prefix);\nCREATE INDEX idx_audh_change_type ON audit_header(audh_change_type);\nCREATE SEQUENCE audit_detail_seq; CREATE TABLE audit_detail (audd_id NUMBER PRIMARY KEY, audd_audh_seqno NUMBER NOT NULL, audd_col_sufix VARCHAR2(50), audd_old_value VARCHAR2(200), audd_new_value VARCHAR2(200)); CREATE OR REPLACE TRIGGER audit_detail_bi BEFORE INSERT ON audit_detail FOR EACH ROW BEGIN IF :NEW.audd_id IS NULL THEN SELECT audit_detail_seq.NEXTVAL INTO :NEW.audd_id FROM DUAL; END IF; END;\nCREATE INDEX idx_audd_audh_seqno ON audit_detail(audd_audh_seqno);\nCREATE INDEX idx_audd_col_sufix ON audit_detail(audd_col_sufix);\nCREATE SEQUENCE account_links_seq; CREATE TABLE ACCOUNT_LINKS (accl_id NUMBER PRIMARY KEY, accl_account_no VARCHAR2(50) NOT NULL, accl_subacc_no VARCHAR2(50) NOT NULL, accl_holder_pos NUMBER, accl_cust_seqno NUMBER); CREATE OR REPLACE TRIGGER account_links_bi BEFORE INSERT ON ACCOUNT_LINKS FOR EACH ROW BEGIN IF :NEW.accl_id IS NULL THEN SELECT account_links_seq.NEXTVAL INTO :NEW.accl_id FROM DUAL; END IF; END;\nCREATE INDEX idx_accl_account_subacc ON ACCOUNT_LINKS(accl_account_no, accl_subacc_no);\nCREATE INDEX idx_accl_holder_pos ON ACCOUNT_LINKS(accl_holder_pos);\nCREATE SEQUENCE account_holding_tax_seq; CREATE TABLE SUMMIT.ACCOUNT_HOLDING_TAX (acctax_id NUMBER PRIMARY KEY, ACCTAX_ACCOUNT_NO VARCHAR2(50) NOT NULL, ACCTAX_SUBACC_NO VARCHAR2(50) NOT NULL, ACCTAX_CUST_SEQNO NUMBER, ACCTAX_EFF_DATE_FROM DATE); CREATE OR REPLACE TRIGGER account_holding_tax_bi BEFORE INSERT ON SUMMIT.ACCOUNT_HOLDING_TAX FOR EACH ROW BEGIN IF :NEW.acctax_id IS NULL THEN SELECT account_holding_tax_seq.NEXTVAL INTO :NEW.acctax_id FROM DUAL; END IF; END;\nCREATE INDEX idx_acctax_composite ON SUMMIT.ACCOUNT_HOLDING_TAX(ACCTAX_ACCOUNT_NO, ACCTAX_SUBACC_NO, ACCTAX_CUST_SEQNO);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t1320\t1\t264\t333735386\t1311\n1\t  HASH UNIQUE \t1320\t1\t264\t333735386\t1311\n2\t  HASH JOIN  \t1319\t1\t264\t296866817\t1311\n3\t   NESTED LOOPS  \t1319\t1\t264\t296866817\t1311\n4\t  NESTED LOOPS  \t1319\t1\t264\t296866817\t1311\n5\t  STATISTICS COLLECTOR  \t\t\t\t\t\n6\t   NESTED LOOPS  \t1317\t1\t249\t296850384\t1309\n7\t  HASH JOIN  \t1294\t1\t236\t296676455\t1286\n8\t  NESTED LOOPS  \t1294\t1\t236\t296676455\t1286\n9\t   STATISTICS COLLECTOR  \t\t\t\t\t\n10\t  HASH JOIN  \t1291\t1\t206\t296653810\t1283\n11\t  NESTED LOOPS  \t1291\t1\t206\t296653810\t1283\n12\t   STATISTICS COLLECTOR  \t\t\t\t\t\n13\t  HASH JOIN  \t1289\t1\t180\t296638517\t1281\n14\t  NESTED LOOPS  \t1289\t1\t180\t296638517\t1281\n15\t   STATISTICS COLLECTOR  \t\t\t\t\t\n16\t  HASH JOIN  \t1287\t1\t132\t296622185\t1279\n17\t  NESTED LOOPS  \t1287\t1\t132\t296622185\t1279\n18\t   STATISTICS COLLECTOR  \t\t\t\t\t\n19\t  NESTED LOOPS  \t1283\t4\t328\t296586099\t1275\n20\t  HASH JOIN  \t1278\t4\t208\t296542487\t1270\n21\t   NESTED LOOPS  \t1278\t4\t208\t296542487\t1270\n22\t  STATISTICS COLLECTOR  \t\t\t\t\t\n23\t  TABLE ACCESS FULL AUDIT_DETAIL\t1270\t4\t84\t296476515\t1262\n24\t  TABLE ACCESS BY INDEX ROWID AUDIT_HEADER\t2\t1\t31\t16493\t2\n25\t  INDEX UNIQUE SCAN SYS_C008309\t1\t1\t\t9021\t1\n26\t   TABLE ACCESS FULL AUDIT_HEADER\t2\t1\t31\t16493\t2\n27\t  TABLE ACCESS BY INDEX ROWID ACCOUNTS\t2\t1\t30\t16548\t2\n28\t   INDEX UNIQUE SCAN SYS_C008302\t1\t1\t\t9021\t1\n29\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_TYPES\t1\t1\t50\t9021\t1\n30\t  INDEX UNIQUE SCAN SYS_C008304\t1\t1\t\t9021\t1\n31\t  TABLE ACCESS FULL ACCOUNT_TYPES\t1\t1\t50\t9021\t1\n32\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_HEADERS\t2\t1\t48\t16333\t2\n33\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n34\t  TABLE ACCESS FULL ACCOUNT_HEADERS\t2\t1\t48\t16333\t2\n35\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_LINKS\t2\t1\t26\t15293\t2\n36\t  INDEX RANGE SCAN IDX_ACCL_ACCOUNT_SUBACC\t2\t10\t\t15293\t2\n37\t  TABLE ACCESS FULL ACCOUNT_LINKS\t2\t1\t26\t15293\t2\n38\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_HOLDING_TAX\t3\t1\t30\t22644\t3\n39\t  INDEX RANGE SCAN IDX_ACCTAX_COMPOSITE\t2\t1\t\t15293\t2\n40\t  TABLE ACCESS FULL ACCOUNT_HOLDING_TAX\t3\t1\t30\t22644\t3\n41\t  VIEW PUSHED PREDICATE  \t23\t1\t13\t173930\t23\n42\t  FILTER  \t\t\t\t\t\n43\t   SORT AGGREGATE \t\t1\t40\t\t\n44\t  TABLE ACCESS BY INDEX ROWID BATCHED TRANSACTIONS\t23\t1\t40\t173930\t23\n45\t  INDEX RANGE SCAN IDX_TRANS_ACCOUNT_SUBACC\t3\t20\t\t25364\t3\n46\t  INDEX UNIQUE SCAN SYS_C008308\t1\t1\t\t9021\t1\n47\t  TABLE ACCESS BY INDEX ROWID TRANSACTIONS\t2\t1\t15\t16433\t2\n48\t   TABLE ACCESS FULL TRANSACTIONS\t2\t1\t15\t16433\t2\n\n## Original SQL:\nSELECT DISTINCT acc_account_no, \n  acc_subacc_no, \n  acch_title,\n  to_char(acc_incep_date,'DD/MM/YYYY') acc_incep_date,\n  htax.ACCTAX_EFF_DATE_FROM,\n  to_char(onhold_accounts.audh_date, 'DD-MON-YYYY') approved_date,\n  act_long_name, \n  tran_amount_cr,\n  tran_create_by,\n  CASE WHEN (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) < 0 THEN 0 ELSE\n   (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) END time_on_approved,\n  acch_brn_code\n  FROM\n  (\n   (\n  SELECT accounts.acc_account_no,\n   acch_title, \n   accounts.acc_subacc_no,\n   acc_incep_date,\n   act_long_name,\n   tran_amount_cr,\n   transactions.tran_create_by,\n   first_tran_date,\n   acch_brn_code\n  FROM accounts \n  JOIN account_headers ON account_headers.acch_account_no = accounts.acc_account_no\n  JOIN account_types ON acc_act_code = act_code\n  JOIN \n   (\n  SELECT tran_account_no, tran_subacc_no, min(tran_seqno) first_tran_seq, min(tran_date) first_tran_date\n  FROM transactions\n  WHERE tran_amount_cr IS NOT NULL\n  AND tran_trans_code IN ('RIC','RSAV')\n  AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE\n  AND tran_pay_method not in ('C','CQ')   --Exclude cash and cheque receipts as those accounts will already have the passbook.\n  GROUP BY tran_account_no, tran_subacc_no\n   ) first_trans\n   ON tran_account_no = acc_account_no AND tran_subacc_no = acc_subacc_no\n  JOIN transactions ON tran_seqno = first_trans.first_tran_seq\n  WHERE acc_gact_type IN ('S', 'IC') \n   AND acc_incep_date BETWEEN IN_INCEP_FROM_DATE and IN_INCEP_TO_DATE\n   ) opened_accounts\n   JOIN\n   (\n  SELECT audh_key1, audh_key2, audh_date, audd_old_value, audd_new_value\n  FROM audit_header\n  JOIN audit_detail\n   ON audh_seqno = audd_audh_seqno\n  WHERE audh_table_prefix = 'ACC'\n   AND audd_col_sufix = 'PROCESS_STATUS'\n   AND audh_change_type  = 'I'\n   AND audd_old_value IS NULL \n   AND audd_new_value = 1\n   ) onhold_accounts\n  ON opened_accounts.acc_account_no = onhold_accounts.audh_key1\n   AND opened_accounts.acc_subacc_no = onhold_accounts.audh_key2\n   JOIN ACCOUNT_LINKS al ON al.accl_account_no = opened_accounts.ACC_ACCOUNT_NO and al.accl_subacc_no = opened_accounts.ACC_SUBACC_NO and al.accl_holder_pos = 1\n   JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax \n  ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO\n   AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO\n   AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO\n  )\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT DISTINCT a.acc_account_no, a.acc_subacc_no, ah.acch_title, TO_CHAR(a.acc_incep_date,'DD/MM/YYYY') acc_incep_date, htax.ACCTAX_EFF_DATE_FROM, TO_CHAR(ad.audh_date, 'DD-MON-YYYY') approved_date, at.act_long_name, t.tran_amount_cr, t.tran_create_by, CASE WHEN (TRUNC(a.acc_incep_date) - TRUNC(ad.audh_date)) < 0 THEN 0 ELSE (TRUNC(a.acc_incep_date) - TRUNC(ad.audh_date)) END time_on_approved, ah.acch_brn_code FROM accounts a INNER JOIN account_headers ah ON ah.acch_account_no = a.acc_account_no INNER JOIN account_types at ON a.acc_act_code = at.act_code INNER JOIN (SELECT tran_account_no, tran_subacc_no, MIN(tran_seqno) first_tran_seq FROM transactions WHERE tran_amount_cr IS NOT NULL AND tran_trans_code IN ('RIC','RSAV') AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE AND tran_pay_method NOT IN ('C','CQ') GROUP BY tran_account_no, tran_subacc_no) ft ON ft.tran_account_no = a.acc_account_no AND ft.tran_subacc_no = a.acc_subacc_no INNER JOIN transactions t ON t.tran_seqno = ft.first_tran_seq INNER JOIN audit_header ad ON ad.audh_key1 = a.acc_account_no AND ad.audh_key2 = a.acc_subacc_no AND ad.audh_table_prefix = 'ACC' AND ad.audh_change_type = 'I' INNER JOIN audit_detail audd ON ad.audh_seqno = audd.audd_audh_seqno AND audd.audd_col_sufix = 'PROCESS_STATUS' AND audd.audd_old_value IS NULL AND audd.audd_new_value = 1 INNER JOIN ACCOUNT_LINKS al ON al.accl_account_no = a.acc_account_no AND al.accl_subacc_no = a.acc_subacc_no AND al.accl_holder_pos = 1 INNER JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO WHERE a.acc_gact_type IN ('S', 'IC') AND a.acc_incep_date BETWEEN IN_INCEP_FROM_DATE AND IN_INCEP_TO_DATE;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "28",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"28\", \"db_type\": \"oracle\", \"description\": \"本次改写主要做了两方面优化：1) 消除了子查询中计算但从未使用的first_tran_date字段，减少了一次min()聚合操作；2) 将onhold_accounts这个内联视图展开，直接在主查询中JOIN audit_header和audit_detail表，并将过滤条件移到WHERE子句中。这种改写理论上可以给优化器更多的优化空间，但由于原SQL结构已经较为优化，实际收益有限。\", \"create_table_statements\": [\"CREATE SEQUENCE accounts_seq; CREATE TABLE accounts (acc_account_no VARCHAR2(50), acc_subacc_no VARCHAR2(50), acc_incep_date DATE NOT NULL, acc_act_code VARCHAR2(20), acc_gact_type VARCHAR2(10), PRIMARY KEY (acc_account_no, acc_subacc_no)); CREATE OR REPLACE TRIGGER accounts_bi BEFORE INSERT ON accounts FOR EACH ROW BEGIN NULL; END;\", \"CREATE INDEX idx_accounts_act_code ON accounts(acc_act_code);\", \"CREATE INDEX idx_accounts_gact_type ON accounts(acc_gact_type);\", \"CREATE INDEX idx_accounts_incep_date ON accounts(acc_incep_date);\", \"CREATE SEQUENCE account_headers_seq; CREATE TABLE account_headers (acch_account_no VARCHAR2(50) PRIMARY KEY, acch_title VARCHAR2(200), acch_brn_code VARCHAR2(20)); CREATE OR REPLACE TRIGGER account_headers_bi BEFORE INSERT ON account_headers FOR EACH ROW BEGIN NULL; END;\", \"CREATE INDEX idx_acch_account_no ON account_headers(acch_account_no);\", \"CREATE SEQUENCE account_types_seq; CREATE TABLE account_types (act_code VARCHAR2(20) PRIMARY KEY, act_long_name VARCHAR2(100)); CREATE OR REPLACE TRIGGER account_types_bi BEFORE INSERT ON account_types FOR EACH ROW BEGIN NULL; END;\", \"CREATE SEQUENCE transactions_seq; CREATE TABLE transactions (tran_seqno NUMBER PRIMARY KEY, tran_account_no VARCHAR2(50) NOT NULL, tran_subacc_no VARCHAR2(50) NOT NULL, tran_date DATE NOT NULL, tran_amount_cr NUMBER(18,2), tran_trans_code VARCHAR2(20), tran_pay_method VARCHAR2(10), tran_create_by VARCHAR2(50)); CREATE OR REPLACE TRIGGER transactions_bi BEFORE INSERT ON transactions FOR EACH ROW BEGIN IF :NEW.tran_seqno IS NULL THEN SELECT transactions_seq.NEXTVAL INTO :NEW.tran_seqno FROM DUAL; END IF; END;\", \"CREATE INDEX idx_trans_account_subacc ON transactions(tran_account_no, tran_subacc_no);\", \"CREATE INDEX idx_trans_date ON transactions(tran_date);\", \"CREATE INDEX idx_trans_trans_code ON transactions(tran_trans_code);\", \"CREATE INDEX idx_trans_pay_method ON transactions(tran_pay_method);\", \"CREATE SEQUENCE audit_header_seq; CREATE TABLE audit_header (audh_seqno NUMBER PRIMARY KEY, audh_key1 VARCHAR2(50), audh_key2 VARCHAR2(50), audh_date DATE, audh_table_prefix VARCHAR2(20), audh_change_type VARCHAR2(10)); CREATE OR REPLACE TRIGGER audit_header_bi BEFORE INSERT ON audit_header FOR EACH ROW BEGIN IF :NEW.audh_seqno IS NULL THEN SELECT audit_header_seq.NEXTVAL INTO :NEW.audh_seqno FROM DUAL; END IF; END;\", \"CREATE INDEX idx_audh_keys ON audit_header(audh_key1, audh_key2);\", \"CREATE INDEX idx_audh_table_prefix ON audit_header(audh_table_prefix);\", \"CREATE INDEX idx_audh_change_type ON audit_header(audh_change_type);\", \"CREATE SEQUENCE audit_detail_seq; CREATE TABLE audit_detail (audd_id NUMBER PRIMARY KEY, audd_audh_seqno NUMBER NOT NULL, audd_col_sufix VARCHAR2(50), audd_old_value VARCHAR2(200), audd_new_value VARCHAR2(200)); CREATE OR REPLACE TRIGGER audit_detail_bi BEFORE INSERT ON audit_detail FOR EACH ROW BEGIN IF :NEW.audd_id IS NULL THEN SELECT audit_detail_seq.NEXTVAL INTO :NEW.audd_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_audd_audh_seqno ON audit_detail(audd_audh_seqno);\", \"CREATE INDEX idx_audd_col_sufix ON audit_detail(audd_col_sufix);\", \"CREATE SEQUENCE account_links_seq; CREATE TABLE ACCOUNT_LINKS (accl_id NUMBER PRIMARY KEY, accl_account_no VARCHAR2(50) NOT NULL, accl_subacc_no VARCHAR2(50) NOT NULL, accl_holder_pos NUMBER, accl_cust_seqno NUMBER); CREATE OR REPLACE TRIGGER account_links_bi BEFORE INSERT ON ACCOUNT_LINKS FOR EACH ROW BEGIN IF :NEW.accl_id IS NULL THEN SELECT account_links_seq.NEXTVAL INTO :NEW.accl_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_accl_account_subacc ON ACCOUNT_LINKS(accl_account_no, accl_subacc_no);\", \"CREATE INDEX idx_accl_holder_pos ON ACCOUNT_LINKS(accl_holder_pos);\", \"CREATE SEQUENCE account_holding_tax_seq; CREATE TABLE SUMMIT.ACCOUNT_HOLDING_TAX (acctax_id NUMBER PRIMARY KEY, ACCTAX_ACCOUNT_NO VARCHAR2(50) NOT NULL, ACCTAX_SUBACC_NO VARCHAR2(50) NOT NULL, ACCTAX_CUST_SEQNO NUMBER, ACCTAX_EFF_DATE_FROM DATE); CREATE OR REPLACE TRIGGER account_holding_tax_bi BEFORE INSERT ON SUMMIT.ACCOUNT_HOLDING_TAX FOR EACH ROW BEGIN IF :NEW.acctax_id IS NULL THEN SELECT account_holding_tax_seq.NEXTVAL INTO :NEW.acctax_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_acctax_composite ON SUMMIT.ACCOUNT_HOLDING_TAX(ACCTAX_ACCOUNT_NO, ACCTAX_SUBACC_NO, ACCTAX_CUST_SEQNO);\"], \"sql\": \"SELECT DISTINCT acc_account_no, \\n  acc_subacc_no, \\n  acch_title,\\n  to_char(acc_incep_date,'DD/MM/YYYY') acc_incep_date,\\n  htax.ACCTAX_EFF_DATE_FROM,\\n  to_char(onhold_accounts.audh_date, 'DD-MON-YYYY') approved_date,\\n  act_long_name, \\n  tran_amount_cr,\\n  tran_create_by,\\n  CASE WHEN (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) < 0 THEN 0 ELSE\\n   (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) END time_on_approved,\\n  acch_brn_code\\n  FROM\\n  (\\n   (\\n  SELECT accounts.acc_account_no,\\n   acch_title, \\n   accounts.acc_subacc_no,\\n   acc_incep_date,\\n   act_long_name,\\n   tran_amount_cr,\\n   transactions.tran_create_by,\\n   first_tran_date,\\n   acch_brn_code\\n  FROM accounts \\n  JOIN account_headers ON account_headers.acch_account_no = accounts.acc_account_no\\n  JOIN account_types ON acc_act_code = act_code\\n  JOIN \\n   (\\n  SELECT tran_account_no, tran_subacc_no, min(tran_seqno) first_tran_seq, min(tran_date) first_tran_date\\n  FROM transactions\\n  WHERE tran_amount_cr IS NOT NULL\\n  AND tran_trans_code IN ('RIC','RSAV')\\n  AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE\\n  AND tran_pay_method not in ('C','CQ')   --Exclude cash and cheque receipts as those accounts will already have the passbook.\\n  GROUP BY tran_account_no, tran_subacc_no\\n   ) first_trans\\n   ON tran_account_no = acc_account_no AND tran_subacc_no = acc_subacc_no\\n  JOIN transactions ON tran_seqno = first_trans.first_tran_seq\\n  WHERE acc_gact_type IN ('S', 'IC') \\n   AND acc_incep_date BETWEEN IN_INCEP_FROM_DATE and IN_INCEP_TO_DATE\\n   ) opened_accounts\\n   JOIN\\n   (\\n  SELECT audh_key1, audh_key2, audh_date, audd_old_value, audd_new_value\\n  FROM audit_header\\n  JOIN audit_detail\\n   ON audh_seqno = audd_audh_seqno\\n  WHERE audh_table_prefix = 'ACC'\\n   AND audd_col_sufix = 'PROCESS_STATUS'\\n   AND audh_change_type  = 'I'\\n   AND audd_old_value IS NULL \\n   AND audd_new_value = 1\\n   ) onhold_accounts\\n  ON opened_accounts.acc_account_no = onhold_accounts.audh_key1\\n   AND opened_accounts.acc_subacc_no = onhold_accounts.audh_key2\\n   JOIN ACCOUNT_LINKS al ON al.accl_account_no = opened_accounts.ACC_ACCOUNT_NO and al.accl_subacc_no = opened_accounts.ACC_SUBACC_NO and al.accl_holder_pos = 1\\n   JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax \\n  ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO\\n   AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO\\n   AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO\\n  )\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t1320\\t1\\t264\\t333735386\\t1311\\n1\\t  HASH UNIQUE \\t1320\\t1\\t264\\t333735386\\t1311\\n2\\t  HASH JOIN  \\t1319\\t1\\t264\\t296866817\\t1311\\n3\\t   NESTED LOOPS  \\t1319\\t1\\t264\\t296866817\\t1311\\n4\\t  NESTED LOOPS  \\t1319\\t1\\t264\\t296866817\\t1311\\n5\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n6\\t   NESTED LOOPS  \\t1317\\t1\\t249\\t296850384\\t1309\\n7\\t  HASH JOIN  \\t1294\\t1\\t236\\t296676455\\t1286\\n8\\t  NESTED LOOPS  \\t1294\\t1\\t236\\t296676455\\t1286\\n9\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n10\\t  HASH JOIN  \\t1291\\t1\\t206\\t296653810\\t1283\\n11\\t  NESTED LOOPS  \\t1291\\t1\\t206\\t296653810\\t1283\\n12\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n13\\t  HASH JOIN  \\t1289\\t1\\t180\\t296638517\\t1281\\n14\\t  NESTED LOOPS  \\t1289\\t1\\t180\\t296638517\\t1281\\n15\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n16\\t  HASH JOIN  \\t1287\\t1\\t132\\t296622185\\t1279\\n17\\t  NESTED LOOPS  \\t1287\\t1\\t132\\t296622185\\t1279\\n18\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n19\\t  NESTED LOOPS  \\t1283\\t4\\t328\\t296586099\\t1275\\n20\\t  HASH JOIN  \\t1278\\t4\\t208\\t296542487\\t1270\\n21\\t   NESTED LOOPS  \\t1278\\t4\\t208\\t296542487\\t1270\\n22\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n23\\t  TABLE ACCESS FULL AUDIT_DETAIL\\t1270\\t4\\t84\\t296476515\\t1262\\n24\\t  TABLE ACCESS BY INDEX ROWID AUDIT_HEADER\\t2\\t1\\t31\\t16493\\t2\\n25\\t  INDEX UNIQUE SCAN SYS_C008309\\t1\\t1\\t\\t9021\\t1\\n26\\t   TABLE ACCESS FULL AUDIT_HEADER\\t2\\t1\\t31\\t16493\\t2\\n27\\t  TABLE ACCESS BY INDEX ROWID ACCOUNTS\\t2\\t1\\t30\\t16548\\t2\\n28\\t   INDEX UNIQUE SCAN SYS_C008302\\t1\\t1\\t\\t9021\\t1\\n29\\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_TYPES\\t1\\t1\\t50\\t9021\\t1\\n30\\t  INDEX UNIQUE SCAN SYS_C008304\\t1\\t1\\t\\t9021\\t1\\n31\\t  TABLE ACCESS FULL ACCOUNT_TYPES\\t1\\t1\\t50\\t9021\\t1\\n32\\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_HEADERS\\t2\\t1\\t48\\t16333\\t2\\n33\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n34\\t  TABLE ACCESS FULL ACCOUNT_HEADERS\\t2\\t1\\t48\\t16333\\t2\\n35\\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_LINKS\\t2\\t1\\t26\\t15293\\t2\\n36\\t  INDEX RANGE SCAN IDX_ACCL_ACCOUNT_SUBACC\\t2\\t10\\t\\t15293\\t2\\n37\\t  TABLE ACCESS FULL ACCOUNT_LINKS\\t2\\t1\\t26\\t15293\\t2\\n38\\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_HOLDING_TAX\\t3\\t1\\t30\\t22644\\t3\\n39\\t  INDEX RANGE SCAN IDX_ACCTAX_COMPOSITE\\t2\\t1\\t\\t15293\\t2\\n40\\t  TABLE ACCESS FULL ACCOUNT_HOLDING_TAX\\t3\\t1\\t30\\t22644\\t3\\n41\\t  VIEW PUSHED PREDICATE  \\t23\\t1\\t13\\t173930\\t23\\n42\\t  FILTER  \\t\\t\\t\\t\\t\\n43\\t   SORT AGGREGATE \\t\\t1\\t40\\t\\t\\n44\\t  TABLE ACCESS BY INDEX ROWID BATCHED TRANSACTIONS\\t23\\t1\\t40\\t173930\\t23\\n45\\t  INDEX RANGE SCAN IDX_TRANS_ACCOUNT_SUBACC\\t3\\t20\\t\\t25364\\t3\\n46\\t  INDEX UNIQUE SCAN SYS_C008308\\t1\\t1\\t\\t9021\\t1\\n47\\t  TABLE ACCESS BY INDEX ROWID TRANSACTIONS\\t2\\t1\\t15\\t16433\\t2\\n48\\t   TABLE ACCESS FULL TRANSACTIONS\\t2\\t1\\t15\\t16433\\t2\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推规则，移除了子查询中未被外层引用的冗余列(min(tran_date)、audd_old_value和audd_new_value)，减少了数据读取量30%以上。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将accounts表的过滤条件下推至子查询内部，在JOIN前完成数据过滤。优化后数据库先过滤accounts表，减少中间结果集大小和后续JOIN开销，尤其当过滤条件选择性高时效果显著。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"子查询折叠,对符合条件的accounts和onhold_accounts子查询进行折叠优化，减少中间结果物化开销。通过消除冗余子查询包装，降低查询复杂度并减少临时表创建成本。优化后保留first_trans子查询的聚合逻辑，确保语义不变。性能预估提升10-15%，特别在MySQL 5.7环境下效果显著。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE accounts_seq; CREATE TABLE accounts (acc_account_no VARCHAR2(50), acc_subacc_no VARCHAR2(50), acc_incep_date DATE NOT NULL, acc_act_code VARCHAR2(20), acc_gact_type VARCHAR2(10), PRIMARY KEY (acc_account_no, acc_subacc_no)); CREATE OR REPLACE TRIGGER accounts_bi BEFORE INSERT ON accounts FOR EACH ROW BEGIN NULL; END;\nCREATE INDEX idx_accounts_act_code ON accounts(acc_act_code);\nCREATE INDEX idx_accounts_gact_type ON accounts(acc_gact_type);\nCREATE INDEX idx_accounts_incep_date ON accounts(acc_incep_date);\nCREATE SEQUENCE account_headers_seq; CREATE TABLE account_headers (acch_account_no VARCHAR2(50) PRIMARY KEY, acch_title VARCHAR2(200), acch_brn_code VARCHAR2(20)); CREATE OR REPLACE TRIGGER account_headers_bi BEFORE INSERT ON account_headers FOR EACH ROW BEGIN NULL; END;\nCREATE INDEX idx_acch_account_no ON account_headers(acch_account_no);\nCREATE SEQUENCE account_types_seq; CREATE TABLE account_types (act_code VARCHAR2(20) PRIMARY KEY, act_long_name VARCHAR2(100)); CREATE OR REPLACE TRIGGER account_types_bi BEFORE INSERT ON account_types FOR EACH ROW BEGIN NULL; END;\nCREATE SEQUENCE transactions_seq; CREATE TABLE transactions (tran_seqno NUMBER PRIMARY KEY, tran_account_no VARCHAR2(50) NOT NULL, tran_subacc_no VARCHAR2(50) NOT NULL, tran_date DATE NOT NULL, tran_amount_cr NUMBER(18,2), tran_trans_code VARCHAR2(20), tran_pay_method VARCHAR2(10), tran_create_by VARCHAR2(50)); CREATE OR REPLACE TRIGGER transactions_bi BEFORE INSERT ON transactions FOR EACH ROW BEGIN IF :NEW.tran_seqno IS NULL THEN SELECT transactions_seq.NEXTVAL INTO :NEW.tran_seqno FROM DUAL; END IF; END;\nCREATE INDEX idx_trans_account_subacc ON transactions(tran_account_no, tran_subacc_no);\nCREATE INDEX idx_trans_date ON transactions(tran_date);\nCREATE INDEX idx_trans_trans_code ON transactions(tran_trans_code);\nCREATE INDEX idx_trans_pay_method ON transactions(tran_pay_method);\nCREATE SEQUENCE audit_header_seq; CREATE TABLE audit_header (audh_seqno NUMBER PRIMARY KEY, audh_key1 VARCHAR2(50), audh_key2 VARCHAR2(50), audh_date DATE, audh_table_prefix VARCHAR2(20), audh_change_type VARCHAR2(10)); CREATE OR REPLACE TRIGGER audit_header_bi BEFORE INSERT ON audit_header FOR EACH ROW BEGIN IF :NEW.audh_seqno IS NULL THEN SELECT audit_header_seq.NEXTVAL INTO :NEW.audh_seqno FROM DUAL; END IF; END;\nCREATE INDEX idx_audh_keys ON audit_header(audh_key1, audh_key2);\nCREATE INDEX idx_audh_table_prefix ON audit_header(audh_table_prefix);\nCREATE INDEX idx_audh_change_type ON audit_header(audh_change_type);\nCREATE SEQUENCE audit_detail_seq; CREATE TABLE audit_detail (audd_id NUMBER PRIMARY KEY, audd_audh_seqno NUMBER NOT NULL, audd_col_sufix VARCHAR2(50), audd_old_value VARCHAR2(200), audd_new_value VARCHAR2(200)); CREATE OR REPLACE TRIGGER audit_detail_bi BEFORE INSERT ON audit_detail FOR EACH ROW BEGIN IF :NEW.audd_id IS NULL THEN SELECT audit_detail_seq.NEXTVAL INTO :NEW.audd_id FROM DUAL; END IF; END;\nCREATE INDEX idx_audd_audh_seqno ON audit_detail(audd_audh_seqno);\nCREATE INDEX idx_audd_col_sufix ON audit_detail(audd_col_sufix);\nCREATE SEQUENCE account_links_seq; CREATE TABLE ACCOUNT_LINKS (accl_id NUMBER PRIMARY KEY, accl_account_no VARCHAR2(50) NOT NULL, accl_subacc_no VARCHAR2(50) NOT NULL, accl_holder_pos NUMBER, accl_cust_seqno NUMBER); CREATE OR REPLACE TRIGGER account_links_bi BEFORE INSERT ON ACCOUNT_LINKS FOR EACH ROW BEGIN IF :NEW.accl_id IS NULL THEN SELECT account_links_seq.NEXTVAL INTO :NEW.accl_id FROM DUAL; END IF; END;\nCREATE INDEX idx_accl_account_subacc ON ACCOUNT_LINKS(accl_account_no, accl_subacc_no);\nCREATE INDEX idx_accl_holder_pos ON ACCOUNT_LINKS(accl_holder_pos);\nCREATE SEQUENCE account_holding_tax_seq; CREATE TABLE SUMMIT.ACCOUNT_HOLDING_TAX (acctax_id NUMBER PRIMARY KEY, ACCTAX_ACCOUNT_NO VARCHAR2(50) NOT NULL, ACCTAX_SUBACC_NO VARCHAR2(50) NOT NULL, ACCTAX_CUST_SEQNO NUMBER, ACCTAX_EFF_DATE_FROM DATE); CREATE OR REPLACE TRIGGER account_holding_tax_bi BEFORE INSERT ON SUMMIT.ACCOUNT_HOLDING_TAX FOR EACH ROW BEGIN IF :NEW.acctax_id IS NULL THEN SELECT account_holding_tax_seq.NEXTVAL INTO :NEW.acctax_id FROM DUAL; END IF; END;\nCREATE INDEX idx_acctax_composite ON SUMMIT.ACCOUNT_HOLDING_TAX(ACCTAX_ACCOUNT_NO, ACCTAX_SUBACC_NO, ACCTAX_CUST_SEQNO);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t1320\t1\t264\t333735386\t1311\n1\t  HASH UNIQUE \t1320\t1\t264\t333735386\t1311\n2\t  HASH JOIN  \t1319\t1\t264\t296866817\t1311\n3\t   NESTED LOOPS  \t1319\t1\t264\t296866817\t1311\n4\t  NESTED LOOPS  \t1319\t1\t264\t296866817\t1311\n5\t  STATISTICS COLLECTOR  \t\t\t\t\t\n6\t   NESTED LOOPS  \t1317\t1\t249\t296850384\t1309\n7\t  HASH JOIN  \t1294\t1\t236\t296676455\t1286\n8\t  NESTED LOOPS  \t1294\t1\t236\t296676455\t1286\n9\t   STATISTICS COLLECTOR  \t\t\t\t\t\n10\t  HASH JOIN  \t1291\t1\t206\t296653810\t1283\n11\t  NESTED LOOPS  \t1291\t1\t206\t296653810\t1283\n12\t   STATISTICS COLLECTOR  \t\t\t\t\t\n13\t  HASH JOIN  \t1289\t1\t180\t296638517\t1281\n14\t  NESTED LOOPS  \t1289\t1\t180\t296638517\t1281\n15\t   STATISTICS COLLECTOR  \t\t\t\t\t\n16\t  HASH JOIN  \t1287\t1\t132\t296622185\t1279\n17\t  NESTED LOOPS  \t1287\t1\t132\t296622185\t1279\n18\t   STATISTICS COLLECTOR  \t\t\t\t\t\n19\t  NESTED LOOPS  \t1283\t4\t328\t296586099\t1275\n20\t  HASH JOIN  \t1278\t4\t208\t296542487\t1270\n21\t   NESTED LOOPS  \t1278\t4\t208\t296542487\t1270\n22\t  STATISTICS COLLECTOR  \t\t\t\t\t\n23\t  TABLE ACCESS FULL AUDIT_DETAIL\t1270\t4\t84\t296476515\t1262\n24\t  TABLE ACCESS BY INDEX ROWID AUDIT_HEADER\t2\t1\t31\t16493\t2\n25\t  INDEX UNIQUE SCAN SYS_C008309\t1\t1\t\t9021\t1\n26\t   TABLE ACCESS FULL AUDIT_HEADER\t2\t1\t31\t16493\t2\n27\t  TABLE ACCESS BY INDEX ROWID ACCOUNTS\t2\t1\t30\t16548\t2\n28\t   INDEX UNIQUE SCAN SYS_C008302\t1\t1\t\t9021\t1\n29\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_TYPES\t1\t1\t50\t9021\t1\n30\t  INDEX UNIQUE SCAN SYS_C008304\t1\t1\t\t9021\t1\n31\t  TABLE ACCESS FULL ACCOUNT_TYPES\t1\t1\t50\t9021\t1\n32\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_HEADERS\t2\t1\t48\t16333\t2\n33\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n34\t  TABLE ACCESS FULL ACCOUNT_HEADERS\t2\t1\t48\t16333\t2\n35\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_LINKS\t2\t1\t26\t15293\t2\n36\t  INDEX RANGE SCAN IDX_ACCL_ACCOUNT_SUBACC\t2\t10\t\t15293\t2\n37\t  TABLE ACCESS FULL ACCOUNT_LINKS\t2\t1\t26\t15293\t2\n38\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_HOLDING_TAX\t3\t1\t30\t22644\t3\n39\t  INDEX RANGE SCAN IDX_ACCTAX_COMPOSITE\t2\t1\t\t15293\t2\n40\t  TABLE ACCESS FULL ACCOUNT_HOLDING_TAX\t3\t1\t30\t22644\t3\n41\t  VIEW PUSHED PREDICATE  \t23\t1\t13\t173930\t23\n42\t  FILTER  \t\t\t\t\t\n43\t   SORT AGGREGATE \t\t1\t40\t\t\n44\t  TABLE ACCESS BY INDEX ROWID BATCHED TRANSACTIONS\t23\t1\t40\t173930\t23\n45\t  INDEX RANGE SCAN IDX_TRANS_ACCOUNT_SUBACC\t3\t20\t\t25364\t3\n46\t  INDEX UNIQUE SCAN SYS_C008308\t1\t1\t\t9021\t1\n47\t  TABLE ACCESS BY INDEX ROWID TRANSACTIONS\t2\t1\t15\t16433\t2\n48\t   TABLE ACCESS FULL TRANSACTIONS\t2\t1\t15\t16433\t2\n\n## Original SQL:\nSELECT DISTINCT acc_account_no, \n  acc_subacc_no, \n  acch_title,\n  to_char(acc_incep_date,'DD/MM/YYYY') acc_incep_date,\n  htax.ACCTAX_EFF_DATE_FROM,\n  to_char(onhold_accounts.audh_date, 'DD-MON-YYYY') approved_date,\n  act_long_name, \n  tran_amount_cr,\n  tran_create_by,\n  CASE WHEN (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) < 0 THEN 0 ELSE\n   (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) END time_on_approved,\n  acch_brn_code\n  FROM\n  (\n   (\n  SELECT accounts.acc_account_no,\n   acch_title, \n   accounts.acc_subacc_no,\n   acc_incep_date,\n   act_long_name,\n   tran_amount_cr,\n   transactions.tran_create_by,\n   first_tran_date,\n   acch_brn_code\n  FROM accounts \n  JOIN account_headers ON account_headers.acch_account_no = accounts.acc_account_no\n  JOIN account_types ON acc_act_code = act_code\n  JOIN \n   (\n  SELECT tran_account_no, tran_subacc_no, min(tran_seqno) first_tran_seq, min(tran_date) first_tran_date\n  FROM transactions\n  WHERE tran_amount_cr IS NOT NULL\n  AND tran_trans_code IN ('RIC','RSAV')\n  AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE\n  AND tran_pay_method not in ('C','CQ')   --Exclude cash and cheque receipts as those accounts will already have the passbook.\n  GROUP BY tran_account_no, tran_subacc_no\n   ) first_trans\n   ON tran_account_no = acc_account_no AND tran_subacc_no = acc_subacc_no\n  JOIN transactions ON tran_seqno = first_trans.first_tran_seq\n  WHERE acc_gact_type IN ('S', 'IC') \n   AND acc_incep_date BETWEEN IN_INCEP_FROM_DATE and IN_INCEP_TO_DATE\n   ) opened_accounts\n   JOIN\n   (\n  SELECT audh_key1, audh_key2, audh_date, audd_old_value, audd_new_value\n  FROM audit_header\n  JOIN audit_detail\n   ON audh_seqno = audd_audh_seqno\n  WHERE audh_table_prefix = 'ACC'\n   AND audd_col_sufix = 'PROCESS_STATUS'\n   AND audh_change_type  = 'I'\n   AND audd_old_value IS NULL \n   AND audd_new_value = 1\n   ) onhold_accounts\n  ON opened_accounts.acc_account_no = onhold_accounts.audh_key1\n   AND opened_accounts.acc_subacc_no = onhold_accounts.audh_key2\n   JOIN ACCOUNT_LINKS al ON al.accl_account_no = opened_accounts.ACC_ACCOUNT_NO and al.accl_subacc_no = opened_accounts.ACC_SUBACC_NO and al.accl_holder_pos = 1\n   JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax \n  ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO\n   AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO\n   AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO\n  )\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT DISTINCT a.acc_account_no, a.acc_subacc_no, ah.acch_title, TO_CHAR(a.acc_incep_date,'DD/MM/YYYY') acc_incep_date, htax.ACCTAX_EFF_DATE_FROM, TO_CHAR(ad.audh_date, 'DD-MON-YYYY') approved_date, at.act_long_name, t.tran_amount_cr, t.tran_create_by, CASE WHEN (TRUNC(a.acc_incep_date) - TRUNC(ad.audh_date)) < 0 THEN 0 ELSE (TRUNC(a.acc_incep_date) - TRUNC(ad.audh_date)) END time_on_approved, ah.acch_brn_code FROM accounts a INNER JOIN account_headers ah ON ah.acch_account_no = a.acc_account_no INNER JOIN account_types at ON a.acc_act_code = at.act_code INNER JOIN (SELECT tran_account_no, tran_subacc_no, MIN(tran_seqno) first_tran_seq FROM transactions WHERE tran_amount_cr IS NOT NULL AND tran_trans_code IN ('RIC','RSAV') AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE AND tran_pay_method NOT IN ('C','CQ') GROUP BY tran_account_no, tran_subacc_no) ft ON ft.tran_account_no = a.acc_account_no AND ft.tran_subacc_no = a.acc_subacc_no INNER JOIN transactions t ON t.tran_seqno = ft.first_tran_seq INNER JOIN audit_header ad ON ad.audh_key1 = a.acc_account_no AND ad.audh_key2 = a.acc_subacc_no AND ad.audh_table_prefix = 'ACC' AND ad.audh_change_type = 'I' INNER JOIN audit_detail audd ON ad.audh_seqno = audd.audd_audh_seqno AND audd.audd_col_sufix = 'PROCESS_STATUS' AND audd.audd_old_value IS NULL AND audd.audd_new_value = 1 INNER JOIN ACCOUNT_LINKS al ON al.accl_account_no = a.acc_account_no AND al.accl_subacc_no = a.acc_subacc_no AND al.accl_holder_pos = 1 INNER JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO WHERE a.acc_gact_type IN ('S', 'IC') AND a.acc_incep_date BETWEEN IN_INCEP_FROM_DATE AND IN_INCEP_TO_DATE;"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "28",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"28\", \"db_type\": \"oracle\", \"description\": \"本次改写主要做了两方面优化：1) 消除了子查询中计算但从未使用的first_tran_date字段，减少了一次min()聚合操作；2) 将onhold_accounts这个内联视图展开，直接在主查询中JOIN audit_header和audit_detail表，并将过滤条件移到WHERE子句中。这种改写理论上可以给优化器更多的优化空间，但由于原SQL结构已经较为优化，实际收益有限。\", \"create_table_statements\": [\"CREATE SEQUENCE accounts_seq; CREATE TABLE accounts (acc_account_no VARCHAR2(50), acc_subacc_no VARCHAR2(50), acc_incep_date DATE NOT NULL, acc_act_code VARCHAR2(20), acc_gact_type VARCHAR2(10), PRIMARY KEY (acc_account_no, acc_subacc_no)); CREATE OR REPLACE TRIGGER accounts_bi BEFORE INSERT ON accounts FOR EACH ROW BEGIN NULL; END;\", \"CREATE INDEX idx_accounts_act_code ON accounts(acc_act_code);\", \"CREATE INDEX idx_accounts_gact_type ON accounts(acc_gact_type);\", \"CREATE INDEX idx_accounts_incep_date ON accounts(acc_incep_date);\", \"CREATE SEQUENCE account_headers_seq; CREATE TABLE account_headers (acch_account_no VARCHAR2(50) PRIMARY KEY, acch_title VARCHAR2(200), acch_brn_code VARCHAR2(20)); CREATE OR REPLACE TRIGGER account_headers_bi BEFORE INSERT ON account_headers FOR EACH ROW BEGIN NULL; END;\", \"CREATE INDEX idx_acch_account_no ON account_headers(acch_account_no);\", \"CREATE SEQUENCE account_types_seq; CREATE TABLE account_types (act_code VARCHAR2(20) PRIMARY KEY, act_long_name VARCHAR2(100)); CREATE OR REPLACE TRIGGER account_types_bi BEFORE INSERT ON account_types FOR EACH ROW BEGIN NULL; END;\", \"CREATE SEQUENCE transactions_seq; CREATE TABLE transactions (tran_seqno NUMBER PRIMARY KEY, tran_account_no VARCHAR2(50) NOT NULL, tran_subacc_no VARCHAR2(50) NOT NULL, tran_date DATE NOT NULL, tran_amount_cr NUMBER(18,2), tran_trans_code VARCHAR2(20), tran_pay_method VARCHAR2(10), tran_create_by VARCHAR2(50)); CREATE OR REPLACE TRIGGER transactions_bi BEFORE INSERT ON transactions FOR EACH ROW BEGIN IF :NEW.tran_seqno IS NULL THEN SELECT transactions_seq.NEXTVAL INTO :NEW.tran_seqno FROM DUAL; END IF; END;\", \"CREATE INDEX idx_trans_account_subacc ON transactions(tran_account_no, tran_subacc_no);\", \"CREATE INDEX idx_trans_date ON transactions(tran_date);\", \"CREATE INDEX idx_trans_trans_code ON transactions(tran_trans_code);\", \"CREATE INDEX idx_trans_pay_method ON transactions(tran_pay_method);\", \"CREATE SEQUENCE audit_header_seq; CREATE TABLE audit_header (audh_seqno NUMBER PRIMARY KEY, audh_key1 VARCHAR2(50), audh_key2 VARCHAR2(50), audh_date DATE, audh_table_prefix VARCHAR2(20), audh_change_type VARCHAR2(10)); CREATE OR REPLACE TRIGGER audit_header_bi BEFORE INSERT ON audit_header FOR EACH ROW BEGIN IF :NEW.audh_seqno IS NULL THEN SELECT audit_header_seq.NEXTVAL INTO :NEW.audh_seqno FROM DUAL; END IF; END;\", \"CREATE INDEX idx_audh_keys ON audit_header(audh_key1, audh_key2);\", \"CREATE INDEX idx_audh_table_prefix ON audit_header(audh_table_prefix);\", \"CREATE INDEX idx_audh_change_type ON audit_header(audh_change_type);\", \"CREATE SEQUENCE audit_detail_seq; CREATE TABLE audit_detail (audd_id NUMBER PRIMARY KEY, audd_audh_seqno NUMBER NOT NULL, audd_col_sufix VARCHAR2(50), audd_old_value VARCHAR2(200), audd_new_value VARCHAR2(200)); CREATE OR REPLACE TRIGGER audit_detail_bi BEFORE INSERT ON audit_detail FOR EACH ROW BEGIN IF :NEW.audd_id IS NULL THEN SELECT audit_detail_seq.NEXTVAL INTO :NEW.audd_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_audd_audh_seqno ON audit_detail(audd_audh_seqno);\", \"CREATE INDEX idx_audd_col_sufix ON audit_detail(audd_col_sufix);\", \"CREATE SEQUENCE account_links_seq; CREATE TABLE ACCOUNT_LINKS (accl_id NUMBER PRIMARY KEY, accl_account_no VARCHAR2(50) NOT NULL, accl_subacc_no VARCHAR2(50) NOT NULL, accl_holder_pos NUMBER, accl_cust_seqno NUMBER); CREATE OR REPLACE TRIGGER account_links_bi BEFORE INSERT ON ACCOUNT_LINKS FOR EACH ROW BEGIN IF :NEW.accl_id IS NULL THEN SELECT account_links_seq.NEXTVAL INTO :NEW.accl_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_accl_account_subacc ON ACCOUNT_LINKS(accl_account_no, accl_subacc_no);\", \"CREATE INDEX idx_accl_holder_pos ON ACCOUNT_LINKS(accl_holder_pos);\", \"CREATE SEQUENCE account_holding_tax_seq; CREATE TABLE SUMMIT.ACCOUNT_HOLDING_TAX (acctax_id NUMBER PRIMARY KEY, ACCTAX_ACCOUNT_NO VARCHAR2(50) NOT NULL, ACCTAX_SUBACC_NO VARCHAR2(50) NOT NULL, ACCTAX_CUST_SEQNO NUMBER, ACCTAX_EFF_DATE_FROM DATE); CREATE OR REPLACE TRIGGER account_holding_tax_bi BEFORE INSERT ON SUMMIT.ACCOUNT_HOLDING_TAX FOR EACH ROW BEGIN IF :NEW.acctax_id IS NULL THEN SELECT account_holding_tax_seq.NEXTVAL INTO :NEW.acctax_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_acctax_composite ON SUMMIT.ACCOUNT_HOLDING_TAX(ACCTAX_ACCOUNT_NO, ACCTAX_SUBACC_NO, ACCTAX_CUST_SEQNO);\"], \"sql\": \"SELECT DISTINCT acc_account_no, \\n  acc_subacc_no, \\n  acch_title,\\n  to_char(acc_incep_date,'DD/MM/YYYY') acc_incep_date,\\n  htax.ACCTAX_EFF_DATE_FROM,\\n  to_char(onhold_accounts.audh_date, 'DD-MON-YYYY') approved_date,\\n  act_long_name, \\n  tran_amount_cr,\\n  tran_create_by,\\n  CASE WHEN (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) < 0 THEN 0 ELSE\\n   (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) END time_on_approved,\\n  acch_brn_code\\n  FROM\\n  (\\n   (\\n  SELECT accounts.acc_account_no,\\n   acch_title, \\n   accounts.acc_subacc_no,\\n   acc_incep_date,\\n   act_long_name,\\n   tran_amount_cr,\\n   transactions.tran_create_by,\\n   first_tran_date,\\n   acch_brn_code\\n  FROM accounts \\n  JOIN account_headers ON account_headers.acch_account_no = accounts.acc_account_no\\n  JOIN account_types ON acc_act_code = act_code\\n  JOIN \\n   (\\n  SELECT tran_account_no, tran_subacc_no, min(tran_seqno) first_tran_seq, min(tran_date) first_tran_date\\n  FROM transactions\\n  WHERE tran_amount_cr IS NOT NULL\\n  AND tran_trans_code IN ('RIC','RSAV')\\n  AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE\\n  AND tran_pay_method not in ('C','CQ')   --Exclude cash and cheque receipts as those accounts will already have the passbook.\\n  GROUP BY tran_account_no, tran_subacc_no\\n   ) first_trans\\n   ON tran_account_no = acc_account_no AND tran_subacc_no = acc_subacc_no\\n  JOIN transactions ON tran_seqno = first_trans.first_tran_seq\\n  WHERE acc_gact_type IN ('S', 'IC') \\n   AND acc_incep_date BETWEEN IN_INCEP_FROM_DATE and IN_INCEP_TO_DATE\\n   ) opened_accounts\\n   JOIN\\n   (\\n  SELECT audh_key1, audh_key2, audh_date, audd_old_value, audd_new_value\\n  FROM audit_header\\n  JOIN audit_detail\\n   ON audh_seqno = audd_audh_seqno\\n  WHERE audh_table_prefix = 'ACC'\\n   AND audd_col_sufix = 'PROCESS_STATUS'\\n   AND audh_change_type  = 'I'\\n   AND audd_old_value IS NULL \\n   AND audd_new_value = 1\\n   ) onhold_accounts\\n  ON opened_accounts.acc_account_no = onhold_accounts.audh_key1\\n   AND opened_accounts.acc_subacc_no = onhold_accounts.audh_key2\\n   JOIN ACCOUNT_LINKS al ON al.accl_account_no = opened_accounts.ACC_ACCOUNT_NO and al.accl_subacc_no = opened_accounts.ACC_SUBACC_NO and al.accl_holder_pos = 1\\n   JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax \\n  ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO\\n   AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO\\n   AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO\\n  )\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t1320\\t1\\t264\\t333735386\\t1311\\n1\\t  HASH UNIQUE \\t1320\\t1\\t264\\t333735386\\t1311\\n2\\t  HASH JOIN  \\t1319\\t1\\t264\\t296866817\\t1311\\n3\\t   NESTED LOOPS  \\t1319\\t1\\t264\\t296866817\\t1311\\n4\\t  NESTED LOOPS  \\t1319\\t1\\t264\\t296866817\\t1311\\n5\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n6\\t   NESTED LOOPS  \\t1317\\t1\\t249\\t296850384\\t1309\\n7\\t  HASH JOIN  \\t1294\\t1\\t236\\t296676455\\t1286\\n8\\t  NESTED LOOPS  \\t1294\\t1\\t236\\t296676455\\t1286\\n9\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n10\\t  HASH JOIN  \\t1291\\t1\\t206\\t296653810\\t1283\\n11\\t  NESTED LOOPS  \\t1291\\t1\\t206\\t296653810\\t1283\\n12\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n13\\t  HASH JOIN  \\t1289\\t1\\t180\\t296638517\\t1281\\n14\\t  NESTED LOOPS  \\t1289\\t1\\t180\\t296638517\\t1281\\n15\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n16\\t  HASH JOIN  \\t1287\\t1\\t132\\t296622185\\t1279\\n17\\t  NESTED LOOPS  \\t1287\\t1\\t132\\t296622185\\t1279\\n18\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n19\\t  NESTED LOOPS  \\t1283\\t4\\t328\\t296586099\\t1275\\n20\\t  HASH JOIN  \\t1278\\t4\\t208\\t296542487\\t1270\\n21\\t   NESTED LOOPS  \\t1278\\t4\\t208\\t296542487\\t1270\\n22\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n23\\t  TABLE ACCESS FULL AUDIT_DETAIL\\t1270\\t4\\t84\\t296476515\\t1262\\n24\\t  TABLE ACCESS BY INDEX ROWID AUDIT_HEADER\\t2\\t1\\t31\\t16493\\t2\\n25\\t  INDEX UNIQUE SCAN SYS_C008309\\t1\\t1\\t\\t9021\\t1\\n26\\t   TABLE ACCESS FULL AUDIT_HEADER\\t2\\t1\\t31\\t16493\\t2\\n27\\t  TABLE ACCESS BY INDEX ROWID ACCOUNTS\\t2\\t1\\t30\\t16548\\t2\\n28\\t   INDEX UNIQUE SCAN SYS_C008302\\t1\\t1\\t\\t9021\\t1\\n29\\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_TYPES\\t1\\t1\\t50\\t9021\\t1\\n30\\t  INDEX UNIQUE SCAN SYS_C008304\\t1\\t1\\t\\t9021\\t1\\n31\\t  TABLE ACCESS FULL ACCOUNT_TYPES\\t1\\t1\\t50\\t9021\\t1\\n32\\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_HEADERS\\t2\\t1\\t48\\t16333\\t2\\n33\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n34\\t  TABLE ACCESS FULL ACCOUNT_HEADERS\\t2\\t1\\t48\\t16333\\t2\\n35\\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_LINKS\\t2\\t1\\t26\\t15293\\t2\\n36\\t  INDEX RANGE SCAN IDX_ACCL_ACCOUNT_SUBACC\\t2\\t10\\t\\t15293\\t2\\n37\\t  TABLE ACCESS FULL ACCOUNT_LINKS\\t2\\t1\\t26\\t15293\\t2\\n38\\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_HOLDING_TAX\\t3\\t1\\t30\\t22644\\t3\\n39\\t  INDEX RANGE SCAN IDX_ACCTAX_COMPOSITE\\t2\\t1\\t\\t15293\\t2\\n40\\t  TABLE ACCESS FULL ACCOUNT_HOLDING_TAX\\t3\\t1\\t30\\t22644\\t3\\n41\\t  VIEW PUSHED PREDICATE  \\t23\\t1\\t13\\t173930\\t23\\n42\\t  FILTER  \\t\\t\\t\\t\\t\\n43\\t   SORT AGGREGATE \\t\\t1\\t40\\t\\t\\n44\\t  TABLE ACCESS BY INDEX ROWID BATCHED TRANSACTIONS\\t23\\t1\\t40\\t173930\\t23\\n45\\t  INDEX RANGE SCAN IDX_TRANS_ACCOUNT_SUBACC\\t3\\t20\\t\\t25364\\t3\\n46\\t  INDEX UNIQUE SCAN SYS_C008308\\t1\\t1\\t\\t9021\\t1\\n47\\t  TABLE ACCESS BY INDEX ROWID TRANSACTIONS\\t2\\t1\\t15\\t16433\\t2\\n48\\t   TABLE ACCESS FULL TRANSACTIONS\\t2\\t1\\t15\\t16433\\t2\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推规则，移除了子查询中未被外层引用的冗余列(min(tran_date)、audd_old_value和audd_new_value)，减少了数据读取量30%以上。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将accounts表的过滤条件下推至子查询内部，在JOIN前完成数据过滤。优化后数据库先过滤accounts表，减少中间结果集大小和后续JOIN开销，尤其当过滤条件选择性高时效果显著。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"子查询折叠,对符合条件的accounts和onhold_accounts子查询进行折叠优化，减少中间结果物化开销。通过消除冗余子查询包装，降低查询复杂度并减少临时表创建成本。优化后保留first_trans子查询的聚合逻辑，确保语义不变。性能预估提升10-15%，特别在MySQL 5.7环境下效果显著。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE accounts_seq; CREATE TABLE accounts (acc_account_no VARCHAR2(50), acc_subacc_no VARCHAR2(50), acc_incep_date DATE NOT NULL, acc_act_code VARCHAR2(20), acc_gact_type VARCHAR2(10), PRIMARY KEY (acc_account_no, acc_subacc_no)); CREATE OR REPLACE TRIGGER accounts_bi BEFORE INSERT ON accounts FOR EACH ROW BEGIN NULL; END;\nCREATE INDEX idx_accounts_act_code ON accounts(acc_act_code);\nCREATE INDEX idx_accounts_gact_type ON accounts(acc_gact_type);\nCREATE INDEX idx_accounts_incep_date ON accounts(acc_incep_date);\nCREATE SEQUENCE account_headers_seq; CREATE TABLE account_headers (acch_account_no VARCHAR2(50) PRIMARY KEY, acch_title VARCHAR2(200), acch_brn_code VARCHAR2(20)); CREATE OR REPLACE TRIGGER account_headers_bi BEFORE INSERT ON account_headers FOR EACH ROW BEGIN NULL; END;\nCREATE INDEX idx_acch_account_no ON account_headers(acch_account_no);\nCREATE SEQUENCE account_types_seq; CREATE TABLE account_types (act_code VARCHAR2(20) PRIMARY KEY, act_long_name VARCHAR2(100)); CREATE OR REPLACE TRIGGER account_types_bi BEFORE INSERT ON account_types FOR EACH ROW BEGIN NULL; END;\nCREATE SEQUENCE transactions_seq; CREATE TABLE transactions (tran_seqno NUMBER PRIMARY KEY, tran_account_no VARCHAR2(50) NOT NULL, tran_subacc_no VARCHAR2(50) NOT NULL, tran_date DATE NOT NULL, tran_amount_cr NUMBER(18,2), tran_trans_code VARCHAR2(20), tran_pay_method VARCHAR2(10), tran_create_by VARCHAR2(50)); CREATE OR REPLACE TRIGGER transactions_bi BEFORE INSERT ON transactions FOR EACH ROW BEGIN IF :NEW.tran_seqno IS NULL THEN SELECT transactions_seq.NEXTVAL INTO :NEW.tran_seqno FROM DUAL; END IF; END;\nCREATE INDEX idx_trans_account_subacc ON transactions(tran_account_no, tran_subacc_no);\nCREATE INDEX idx_trans_date ON transactions(tran_date);\nCREATE INDEX idx_trans_trans_code ON transactions(tran_trans_code);\nCREATE INDEX idx_trans_pay_method ON transactions(tran_pay_method);\nCREATE SEQUENCE audit_header_seq; CREATE TABLE audit_header (audh_seqno NUMBER PRIMARY KEY, audh_key1 VARCHAR2(50), audh_key2 VARCHAR2(50), audh_date DATE, audh_table_prefix VARCHAR2(20), audh_change_type VARCHAR2(10)); CREATE OR REPLACE TRIGGER audit_header_bi BEFORE INSERT ON audit_header FOR EACH ROW BEGIN IF :NEW.audh_seqno IS NULL THEN SELECT audit_header_seq.NEXTVAL INTO :NEW.audh_seqno FROM DUAL; END IF; END;\nCREATE INDEX idx_audh_keys ON audit_header(audh_key1, audh_key2);\nCREATE INDEX idx_audh_table_prefix ON audit_header(audh_table_prefix);\nCREATE INDEX idx_audh_change_type ON audit_header(audh_change_type);\nCREATE SEQUENCE audit_detail_seq; CREATE TABLE audit_detail (audd_id NUMBER PRIMARY KEY, audd_audh_seqno NUMBER NOT NULL, audd_col_sufix VARCHAR2(50), audd_old_value VARCHAR2(200), audd_new_value VARCHAR2(200)); CREATE OR REPLACE TRIGGER audit_detail_bi BEFORE INSERT ON audit_detail FOR EACH ROW BEGIN IF :NEW.audd_id IS NULL THEN SELECT audit_detail_seq.NEXTVAL INTO :NEW.audd_id FROM DUAL; END IF; END;\nCREATE INDEX idx_audd_audh_seqno ON audit_detail(audd_audh_seqno);\nCREATE INDEX idx_audd_col_sufix ON audit_detail(audd_col_sufix);\nCREATE SEQUENCE account_links_seq; CREATE TABLE ACCOUNT_LINKS (accl_id NUMBER PRIMARY KEY, accl_account_no VARCHAR2(50) NOT NULL, accl_subacc_no VARCHAR2(50) NOT NULL, accl_holder_pos NUMBER, accl_cust_seqno NUMBER); CREATE OR REPLACE TRIGGER account_links_bi BEFORE INSERT ON ACCOUNT_LINKS FOR EACH ROW BEGIN IF :NEW.accl_id IS NULL THEN SELECT account_links_seq.NEXTVAL INTO :NEW.accl_id FROM DUAL; END IF; END;\nCREATE INDEX idx_accl_account_subacc ON ACCOUNT_LINKS(accl_account_no, accl_subacc_no);\nCREATE INDEX idx_accl_holder_pos ON ACCOUNT_LINKS(accl_holder_pos);\nCREATE SEQUENCE account_holding_tax_seq; CREATE TABLE SUMMIT.ACCOUNT_HOLDING_TAX (acctax_id NUMBER PRIMARY KEY, ACCTAX_ACCOUNT_NO VARCHAR2(50) NOT NULL, ACCTAX_SUBACC_NO VARCHAR2(50) NOT NULL, ACCTAX_CUST_SEQNO NUMBER, ACCTAX_EFF_DATE_FROM DATE); CREATE OR REPLACE TRIGGER account_holding_tax_bi BEFORE INSERT ON SUMMIT.ACCOUNT_HOLDING_TAX FOR EACH ROW BEGIN IF :NEW.acctax_id IS NULL THEN SELECT account_holding_tax_seq.NEXTVAL INTO :NEW.acctax_id FROM DUAL; END IF; END;\nCREATE INDEX idx_acctax_composite ON SUMMIT.ACCOUNT_HOLDING_TAX(ACCTAX_ACCOUNT_NO, ACCTAX_SUBACC_NO, ACCTAX_CUST_SEQNO);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t1320\t1\t264\t333735386\t1311\n1\t  HASH UNIQUE \t1320\t1\t264\t333735386\t1311\n2\t  HASH JOIN  \t1319\t1\t264\t296866817\t1311\n3\t   NESTED LOOPS  \t1319\t1\t264\t296866817\t1311\n4\t  NESTED LOOPS  \t1319\t1\t264\t296866817\t1311\n5\t  STATISTICS COLLECTOR  \t\t\t\t\t\n6\t   NESTED LOOPS  \t1317\t1\t249\t296850384\t1309\n7\t  HASH JOIN  \t1294\t1\t236\t296676455\t1286\n8\t  NESTED LOOPS  \t1294\t1\t236\t296676455\t1286\n9\t   STATISTICS COLLECTOR  \t\t\t\t\t\n10\t  HASH JOIN  \t1291\t1\t206\t296653810\t1283\n11\t  NESTED LOOPS  \t1291\t1\t206\t296653810\t1283\n12\t   STATISTICS COLLECTOR  \t\t\t\t\t\n13\t  HASH JOIN  \t1289\t1\t180\t296638517\t1281\n14\t  NESTED LOOPS  \t1289\t1\t180\t296638517\t1281\n15\t   STATISTICS COLLECTOR  \t\t\t\t\t\n16\t  HASH JOIN  \t1287\t1\t132\t296622185\t1279\n17\t  NESTED LOOPS  \t1287\t1\t132\t296622185\t1279\n18\t   STATISTICS COLLECTOR  \t\t\t\t\t\n19\t  NESTED LOOPS  \t1283\t4\t328\t296586099\t1275\n20\t  HASH JOIN  \t1278\t4\t208\t296542487\t1270\n21\t   NESTED LOOPS  \t1278\t4\t208\t296542487\t1270\n22\t  STATISTICS COLLECTOR  \t\t\t\t\t\n23\t  TABLE ACCESS FULL AUDIT_DETAIL\t1270\t4\t84\t296476515\t1262\n24\t  TABLE ACCESS BY INDEX ROWID AUDIT_HEADER\t2\t1\t31\t16493\t2\n25\t  INDEX UNIQUE SCAN SYS_C008309\t1\t1\t\t9021\t1\n26\t   TABLE ACCESS FULL AUDIT_HEADER\t2\t1\t31\t16493\t2\n27\t  TABLE ACCESS BY INDEX ROWID ACCOUNTS\t2\t1\t30\t16548\t2\n28\t   INDEX UNIQUE SCAN SYS_C008302\t1\t1\t\t9021\t1\n29\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_TYPES\t1\t1\t50\t9021\t1\n30\t  INDEX UNIQUE SCAN SYS_C008304\t1\t1\t\t9021\t1\n31\t  TABLE ACCESS FULL ACCOUNT_TYPES\t1\t1\t50\t9021\t1\n32\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_HEADERS\t2\t1\t48\t16333\t2\n33\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n34\t  TABLE ACCESS FULL ACCOUNT_HEADERS\t2\t1\t48\t16333\t2\n35\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_LINKS\t2\t1\t26\t15293\t2\n36\t  INDEX RANGE SCAN IDX_ACCL_ACCOUNT_SUBACC\t2\t10\t\t15293\t2\n37\t  TABLE ACCESS FULL ACCOUNT_LINKS\t2\t1\t26\t15293\t2\n38\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_HOLDING_TAX\t3\t1\t30\t22644\t3\n39\t  INDEX RANGE SCAN IDX_ACCTAX_COMPOSITE\t2\t1\t\t15293\t2\n40\t  TABLE ACCESS FULL ACCOUNT_HOLDING_TAX\t3\t1\t30\t22644\t3\n41\t  VIEW PUSHED PREDICATE  \t23\t1\t13\t173930\t23\n42\t  FILTER  \t\t\t\t\t\n43\t   SORT AGGREGATE \t\t1\t40\t\t\n44\t  TABLE ACCESS BY INDEX ROWID BATCHED TRANSACTIONS\t23\t1\t40\t173930\t23\n45\t  INDEX RANGE SCAN IDX_TRANS_ACCOUNT_SUBACC\t3\t20\t\t25364\t3\n46\t  INDEX UNIQUE SCAN SYS_C008308\t1\t1\t\t9021\t1\n47\t  TABLE ACCESS BY INDEX ROWID TRANSACTIONS\t2\t1\t15\t16433\t2\n48\t   TABLE ACCESS FULL TRANSACTIONS\t2\t1\t15\t16433\t2\n\n## Original SQL:\nSELECT DISTINCT acc_account_no, \n  acc_subacc_no, \n  acch_title,\n  to_char(acc_incep_date,'DD/MM/YYYY') acc_incep_date,\n  htax.ACCTAX_EFF_DATE_FROM,\n  to_char(onhold_accounts.audh_date, 'DD-MON-YYYY') approved_date,\n  act_long_name, \n  tran_amount_cr,\n  tran_create_by,\n  CASE WHEN (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) < 0 THEN 0 ELSE\n   (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) END time_on_approved,\n  acch_brn_code\n  FROM\n  (\n   (\n  SELECT accounts.acc_account_no,\n   acch_title, \n   accounts.acc_subacc_no,\n   acc_incep_date,\n   act_long_name,\n   tran_amount_cr,\n   transactions.tran_create_by,\n   first_tran_date,\n   acch_brn_code\n  FROM accounts \n  JOIN account_headers ON account_headers.acch_account_no = accounts.acc_account_no\n  JOIN account_types ON acc_act_code = act_code\n  JOIN \n   (\n  SELECT tran_account_no, tran_subacc_no, min(tran_seqno) first_tran_seq, min(tran_date) first_tran_date\n  FROM transactions\n  WHERE tran_amount_cr IS NOT NULL\n  AND tran_trans_code IN ('RIC','RSAV')\n  AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE\n  AND tran_pay_method not in ('C','CQ')   --Exclude cash and cheque receipts as those accounts will already have the passbook.\n  GROUP BY tran_account_no, tran_subacc_no\n   ) first_trans\n   ON tran_account_no = acc_account_no AND tran_subacc_no = acc_subacc_no\n  JOIN transactions ON tran_seqno = first_trans.first_tran_seq\n  WHERE acc_gact_type IN ('S', 'IC') \n   AND acc_incep_date BETWEEN IN_INCEP_FROM_DATE and IN_INCEP_TO_DATE\n   ) opened_accounts\n   JOIN\n   (\n  SELECT audh_key1, audh_key2, audh_date, audd_old_value, audd_new_value\n  FROM audit_header\n  JOIN audit_detail\n   ON audh_seqno = audd_audh_seqno\n  WHERE audh_table_prefix = 'ACC'\n   AND audd_col_sufix = 'PROCESS_STATUS'\n   AND audh_change_type  = 'I'\n   AND audd_old_value IS NULL \n   AND audd_new_value = 1\n   ) onhold_accounts\n  ON opened_accounts.acc_account_no = onhold_accounts.audh_key1\n   AND opened_accounts.acc_subacc_no = onhold_accounts.audh_key2\n   JOIN ACCOUNT_LINKS al ON al.accl_account_no = opened_accounts.ACC_ACCOUNT_NO and al.accl_subacc_no = opened_accounts.ACC_SUBACC_NO and al.accl_holder_pos = 1\n   JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax \n  ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO\n   AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO\n   AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO\n  )\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT DISTINCT a.acc_account_no, a.acc_subacc_no, ah.acch_title, TO_CHAR(a.acc_incep_date,'DD/MM/YYYY') acc_incep_date, htax.ACCTAX_EFF_DATE_FROM, TO_CHAR(ad.audh_date, 'DD-MON-YYYY') approved_date, at.act_long_name, t.tran_amount_cr, t.tran_create_by, CASE WHEN (TRUNC(a.acc_incep_date) - TRUNC(ad.audh_date)) < 0 THEN 0 ELSE (TRUNC(a.acc_incep_date) - TRUNC(ad.audh_date)) END time_on_approved, ah.acch_brn_code FROM accounts a INNER JOIN account_headers ah ON ah.acch_account_no = a.acc_account_no INNER JOIN account_types at ON a.acc_act_code = at.act_code INNER JOIN (SELECT tran_account_no, tran_subacc_no, MIN(tran_seqno) first_tran_seq FROM transactions WHERE tran_amount_cr IS NOT NULL AND tran_trans_code IN ('RIC','RSAV') AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE AND tran_pay_method NOT IN ('C','CQ') GROUP BY tran_account_no, tran_subacc_no) ft ON ft.tran_account_no = a.acc_account_no AND ft.tran_subacc_no = a.acc_subacc_no INNER JOIN transactions t ON t.tran_seqno = ft.first_tran_seq INNER JOIN audit_header ad ON ad.audh_key1 = a.acc_account_no AND ad.audh_key2 = a.acc_subacc_no AND ad.audh_table_prefix = 'ACC' AND ad.audh_change_type = 'I' INNER JOIN audit_detail audd ON ad.audh_seqno = audd.audd_audh_seqno AND audd.audd_col_sufix = 'PROCESS_STATUS' AND audd.audd_old_value IS NULL AND audd.audd_new_value = 1 INNER JOIN ACCOUNT_LINKS al ON al.accl_account_no = a.acc_account_no AND al.accl_subacc_no = a.acc_subacc_no AND al.accl_holder_pos = 1 INNER JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO WHERE a.acc_gact_type IN ('S', 'IC') AND a.acc_incep_date BETWEEN IN_INCEP_FROM_DATE AND IN_INCEP_TO_DATE;"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "29",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"29\", \"db_type\": \"oracle\", \"description\": \"改写试图通过三个方向优化：1）谓词优化：将SUBSTR函数改为LIKE谓词以便索引扫描；将HAVING COUNT(DECODE())改为简单的WHERE过滤；2）投影裁剪：对于COUNT(*)查询，将SELECT所有列改为SELECT 1，减少数据传输；3）数据预过滤：在连接前通过内联视图过滤数据。理论上这些都是常见的优化技术，但在本案例中，HAVING到WHERE的转换导致优化器基数估算失准，反而产生了更差的执行计划。\", \"create_table_statements\": [\"CREATE SEQUENCE jobinfo_his_seq; CREATE TABLE jobinfo_his (id NUMBER PRIMARY KEY, jobid VARCHAR2(50) NOT NULL, tellercode VARCHAR2(50), jobname VARCHAR2(100), jobstatus VARCHAR2(10), jobstartpersname VARCHAR2(100), jobpriorpersname VARCHAR2(100), jobtype VARCHAR2(50), createtime DATE NOT NULL, tranname VARCHAR2(100), issucc VARCHAR2(1), tranprop VARCHAR2(100), trandata VARCHAR2(4000), jbjg VARCHAR2(100), jbgy VARCHAR2(100), ldlcid VARCHAR2(50)); CREATE OR REPLACE TRIGGER jobinfo_his_bi BEFORE INSERT ON jobinfo_his FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT jobinfo_his_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_jobinfo_his_jobid ON jobinfo_his(jobid);\", \"CREATE INDEX idx_jobinfo_his_status ON jobinfo_his(jobstatus);\", \"CREATE INDEX idx_jobinfo_his_createtime ON jobinfo_his(createtime);\", \"CREATE INDEX idx_jobinfo_his_composite ON jobinfo_his(jobid, jobstatus, createtime);\", \"CREATE SEQUENCE businodeinst_seq; CREATE TABLE businodeinst (id NUMBER PRIMARY KEY, nodeinstid VARCHAR2(50) NOT NULL, flowinstid VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER businodeinst_bi BEFORE INSERT ON businodeinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT businodeinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_businodeinst_nodeinstid ON businodeinst(nodeinstid);\", \"CREATE INDEX idx_businodeinst_flowinstid ON businodeinst(flowinstid);\", \"CREATE SEQUENCE busiflowinst_seq; CREATE TABLE busiflowinst (id NUMBER PRIMARY KEY, flowinstid VARCHAR2(50) NOT NULL, status VARCHAR2(10)); CREATE OR REPLACE TRIGGER busiflowinst_bi BEFORE INSERT ON busiflowinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT busiflowinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_busiflowinst_flowinstid ON busiflowinst(flowinstid);\", \"CREATE INDEX idx_busiflowinst_composite ON busiflowinst(flowinstid, status);\"], \"sql\": \"select\\n  count(*)\\nfrom\\n  (\\n  select\\n   tt.jobid,\\n   tt.tellercode,\\n   tt.jobname,\\n   tt.jobstatus,\\n   tt.jobstartpersname,\\n   tt.jobpriorpersname,\\n   tt.jobtype,\\n   tt.createtime,\\n   tt.tranname,\\n   tt.issucc,\\n   tt.tranprop,\\n   tt.trandata,\\n   tt.jbjg,\\n   tt.jbgy,\\n   tt.ldlcid\\n  from\\n   (\\n  select\\n  t3.jobid,\\n  t3.tellercode,\\n  t3.jobname,\\n  t3.jobstatus,\\n  t3.jobstartpersname,\\n  t3.jobpriorpersname,\\n  t3.jobtype,\\n  t3.createtime,\\n  t3.tranname,\\n  t3.issucc,\\n  t3.tranprop,\\n  t3.trandata,\\n  t3.jbjg,\\n  t3.jbgy,\\n  t3.ldlcid,\\n  row_number() over (\\n   partition by\\n  t3.jobid\\n   order by\\n  t3.createtime desc\\n  ) as rn\\n  from\\n  jobinfo_his t3\\n  where\\n  exists (\\n   select\\n  t2.jobid\\n   from\\n  jobinfo_his t2\\n   where\\n  t2.jobid = t3.jobid\\n  and exists (\\n  select\\n   t1.jobid\\n  from\\n   jobinfo_his t1\\n  where\\n   t1.jobid = t2.jobid\\n   and t1.jobstatus = 'O'\\n   and substr(jobid, 0, 1) = 'A'\\n  )\\n   group by\\n  t2.jobid\\n   having\\n  count(decode(t2.jobstatus, 'N', 1, null)) = 0\\n  )\\n   ) tt\\n  where\\n   tt.rn = 1\\n  union all\\n  select\\n   t.jobid,\\n   t.tellercode,\\n   t.jobname,\\n   t.jobstatus,\\n   t.jobstartpersname,\\n   t.jobpriorpersname,\\n   t.jobtype,\\n   t.createtime,\\n   t.tranname,\\n   t.issucc,\\n   t.tranprop,\\n   t.trandata,\\n   t.jbjg,\\n   t.jbgy,\\n   t.ldlcid\\n  from\\n   jobinfo_his t,\\n   businodeinst t1,\\n   busiflowinst t2\\n  where\\n   t.jobid = t1.nodeinstid\\n   and t1.flowinstid = t2.flowinstid\\n   and t2.status = '1'\\n   and t.jobstatus = 'O'\\n  )\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t11679\\t1\\t\\t1903461107\\t11627\\n1\\t  SORT AGGREGATE \\t\\t1\\t\\t\\t\\n2\\t  VIEW  \\t11679\\t343333\\t\\t1903461107\\t11627\\n3\\t   UNION-ALL  \\t\\t\\t\\t\\t\\n4\\t  VIEW  \\t4181\\t10000\\t130000\\t837889750\\t4158\\n5\\t  WINDOW SORT PUSHED RANK \\t4181\\t10000\\t290000\\t837889750\\t4158\\n6\\t   NESTED LOOPS  \\t4180\\t10000\\t290000\\t795034459\\t4158\\n7\\t  VIEW  VW_NSO_1\\t3611\\t500\\t5500\\t785488019\\t3590\\n8\\t  HASH GROUP BY \\t3611\\t500\\t12000\\t785488019\\t3590\\n9\\t   HASH JOIN RIGHT SEMI \\t3609\\t64600\\t1550400\\t702111454\\t3590\\n10\\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1807\\t3333\\t39996\\t433839085\\t1795\\n11\\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1800\\t1000000\\t12000000\\t167172419\\t1795\\n12\\t  INDEX RANGE SCAN IDX_JOBINFO_HIS_COMPOSITE\\t2\\t20\\t360\\t19093\\t2\\n13\\t  HASH JOIN  \\t7498\\t333333\\t16666650\\t1065571358\\t7469\\n14\\t  INDEX FAST FULL SCAN IDX_BUSIFLOWINST_COMPOSITE\\t957\\t500000\\t7500000\\t194989133\\t952\\n15\\t  HASH JOIN  \\t5157\\t333333\\t11666655\\t713706795\\t5138\\n16\\t   NESTED LOOPS  \\t5157\\t333333\\t11666655\\t713706795\\t5138\\n17\\t  NESTED LOOPS  \\t\\t\\t\\t\\t\\n18\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n19\\t   INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1801\\t333333\\t3999996\\t217172419\\t1795\\n20\\t  INDEX RANGE SCAN IDX_BUSINODEINST_NODEINSTID\\t\\t\\t\\t\\t\\n21\\t  TABLE ACCESS BY INDEX ROWID BUSINODEINST\\t1316\\t1\\t23\\t224396555\\t1310\\n22\\t   TABLE ACCESS FULL BUSINODEINST\\t1316\\t1000000\\t23000000\\t224396555\\t1310\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推将SELECT子句简化为SELECT 1：① 消除15个无用列减少93%数据传输 ② 保持原计算逻辑不变 ③ 窗口函数分区/排序列仍在FROM子句可用，未改变计算行为\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推优化：1. 将HAVING条件转换为WHERE过滤并移除HAVING；2. 下推子查询内条件并明确表别名；3. 多表JOIN中提前过滤维度表。减少窗口函数/聚合/JOIN的数据量，性能提升预计20%-50%\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"GROUP BY 子句消除,移除了EXISTS子查询中不必要的GROUP BY jobid操作。原始分组在仅需判断行存在性的EXISTS子句中冗余且增加开销，消除后保持语义不变但减少分组排序成本，数据量大时性能提升显著\"}, {\"rule_id\": \"4\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,优化了子查询中处理jobid前缀的条件，消除隐式转换风险，提高查询效率。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE jobinfo_his_seq; CREATE TABLE jobinfo_his (id NUMBER PRIMARY KEY, jobid VARCHAR2(50) NOT NULL, tellercode VARCHAR2(50), jobname VARCHAR2(100), jobstatus VARCHAR2(10), jobstartpersname VARCHAR2(100), jobpriorpersname VARCHAR2(100), jobtype VARCHAR2(50), createtime DATE NOT NULL, tranname VARCHAR2(100), issucc VARCHAR2(1), tranprop VARCHAR2(100), trandata VARCHAR2(4000), jbjg VARCHAR2(100), jbgy VARCHAR2(100), ldlcid VARCHAR2(50)); CREATE OR REPLACE TRIGGER jobinfo_his_bi BEFORE INSERT ON jobinfo_his FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT jobinfo_his_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_jobinfo_his_jobid ON jobinfo_his(jobid);\nCREATE INDEX idx_jobinfo_his_status ON jobinfo_his(jobstatus);\nCREATE INDEX idx_jobinfo_his_createtime ON jobinfo_his(createtime);\nCREATE INDEX idx_jobinfo_his_composite ON jobinfo_his(jobid, jobstatus, createtime);\nCREATE SEQUENCE businodeinst_seq; CREATE TABLE businodeinst (id NUMBER PRIMARY KEY, nodeinstid VARCHAR2(50) NOT NULL, flowinstid VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER businodeinst_bi BEFORE INSERT ON businodeinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT businodeinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_businodeinst_nodeinstid ON businodeinst(nodeinstid);\nCREATE INDEX idx_businodeinst_flowinstid ON businodeinst(flowinstid);\nCREATE SEQUENCE busiflowinst_seq; CREATE TABLE busiflowinst (id NUMBER PRIMARY KEY, flowinstid VARCHAR2(50) NOT NULL, status VARCHAR2(10)); CREATE OR REPLACE TRIGGER busiflowinst_bi BEFORE INSERT ON busiflowinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT busiflowinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_busiflowinst_flowinstid ON busiflowinst(flowinstid);\nCREATE INDEX idx_busiflowinst_composite ON busiflowinst(flowinstid, status);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t11679\t1\t\t1903461107\t11627\n1\t  SORT AGGREGATE \t\t1\t\t\t\n2\t  VIEW  \t11679\t343333\t\t1903461107\t11627\n3\t   UNION-ALL  \t\t\t\t\t\n4\t  VIEW  \t4181\t10000\t130000\t837889750\t4158\n5\t  WINDOW SORT PUSHED RANK \t4181\t10000\t290000\t837889750\t4158\n6\t   NESTED LOOPS  \t4180\t10000\t290000\t795034459\t4158\n7\t  VIEW  VW_NSO_1\t3611\t500\t5500\t785488019\t3590\n8\t  HASH GROUP BY \t3611\t500\t12000\t785488019\t3590\n9\t   HASH JOIN RIGHT SEMI \t3609\t64600\t1550400\t702111454\t3590\n10\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1807\t3333\t39996\t433839085\t1795\n11\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1800\t1000000\t12000000\t167172419\t1795\n12\t  INDEX RANGE SCAN IDX_JOBINFO_HIS_COMPOSITE\t2\t20\t360\t19093\t2\n13\t  HASH JOIN  \t7498\t333333\t16666650\t1065571358\t7469\n14\t  INDEX FAST FULL SCAN IDX_BUSIFLOWINST_COMPOSITE\t957\t500000\t7500000\t194989133\t952\n15\t  HASH JOIN  \t5157\t333333\t11666655\t713706795\t5138\n16\t   NESTED LOOPS  \t5157\t333333\t11666655\t713706795\t5138\n17\t  NESTED LOOPS  \t\t\t\t\t\n18\t  STATISTICS COLLECTOR  \t\t\t\t\t\n19\t   INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1801\t333333\t3999996\t217172419\t1795\n20\t  INDEX RANGE SCAN IDX_BUSINODEINST_NODEINSTID\t\t\t\t\t\n21\t  TABLE ACCESS BY INDEX ROWID BUSINODEINST\t1316\t1\t23\t224396555\t1310\n22\t   TABLE ACCESS FULL BUSINODEINST\t1316\t1000000\t23000000\t224396555\t1310\n\n## Original SQL:\nselect\n  count(*)\nfrom\n  (\n  select\n   tt.jobid,\n   tt.tellercode,\n   tt.jobname,\n   tt.jobstatus,\n   tt.jobstartpersname,\n   tt.jobpriorpersname,\n   tt.jobtype,\n   tt.createtime,\n   tt.tranname,\n   tt.issucc,\n   tt.tranprop,\n   tt.trandata,\n   tt.jbjg,\n   tt.jbgy,\n   tt.ldlcid\n  from\n   (\n  select\n  t3.jobid,\n  t3.tellercode,\n  t3.jobname,\n  t3.jobstatus,\n  t3.jobstartpersname,\n  t3.jobpriorpersname,\n  t3.jobtype,\n  t3.createtime,\n  t3.tranname,\n  t3.issucc,\n  t3.tranprop,\n  t3.trandata,\n  t3.jbjg,\n  t3.jbgy,\n  t3.ldlcid,\n  row_number() over (\n   partition by\n  t3.jobid\n   order by\n  t3.createtime desc\n  ) as rn\n  from\n  jobinfo_his t3\n  where\n  exists (\n   select\n  t2.jobid\n   from\n  jobinfo_his t2\n   where\n  t2.jobid = t3.jobid\n  and exists (\n  select\n   t1.jobid\n  from\n   jobinfo_his t1\n  where\n   t1.jobid = t2.jobid\n   and t1.jobstatus = 'O'\n   and substr(jobid, 0, 1) = 'A'\n  )\n   group by\n  t2.jobid\n   having\n  count(decode(t2.jobstatus, 'N', 1, null)) = 0\n  )\n   ) tt\n  where\n   tt.rn = 1\n  union all\n  select\n   t.jobid,\n   t.tellercode,\n   t.jobname,\n   t.jobstatus,\n   t.jobstartpersname,\n   t.jobpriorpersname,\n   t.jobtype,\n   t.createtime,\n   t.tranname,\n   t.issucc,\n   t.tranprop,\n   t.trandata,\n   t.jbjg,\n   t.jbgy,\n   t.ldlcid\n  from\n   jobinfo_his t,\n   businodeinst t1,\n   busiflowinst t2\n  where\n   t.jobid = t1.nodeinstid\n   and t1.flowinstid = t2.flowinstid\n   and t2.status = '1'\n   and t.jobstatus = 'O'\n  )\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select count(*) from (select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid from (select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid, row_number() over (partition by t.jobid order by t.createtime desc) as rn from jobinfo_his t where t.jobid like 'A%' and exists (select 1 from jobinfo_his where jobid = t.jobid and jobstatus = 'O') and not exists (select 1 from jobinfo_his where jobid = t.jobid and jobstatus = 'N')) where rn = 1 union all select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid from jobinfo_his t inner join businodeinst t1 on t.jobid = t1.nodeinstid inner join busiflowinst t2 on t1.flowinstid = t2.flowinstid where t2.status = '1' and t.jobstatus = 'O')"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "29",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"29\", \"db_type\": \"oracle\", \"description\": \"改写试图通过三个方向优化：1）谓词优化：将SUBSTR函数改为LIKE谓词以便索引扫描；将HAVING COUNT(DECODE())改为简单的WHERE过滤；2）投影裁剪：对于COUNT(*)查询，将SELECT所有列改为SELECT 1，减少数据传输；3）数据预过滤：在连接前通过内联视图过滤数据。理论上这些都是常见的优化技术，但在本案例中，HAVING到WHERE的转换导致优化器基数估算失准，反而产生了更差的执行计划。\", \"create_table_statements\": [\"CREATE SEQUENCE jobinfo_his_seq; CREATE TABLE jobinfo_his (id NUMBER PRIMARY KEY, jobid VARCHAR2(50) NOT NULL, tellercode VARCHAR2(50), jobname VARCHAR2(100), jobstatus VARCHAR2(10), jobstartpersname VARCHAR2(100), jobpriorpersname VARCHAR2(100), jobtype VARCHAR2(50), createtime DATE NOT NULL, tranname VARCHAR2(100), issucc VARCHAR2(1), tranprop VARCHAR2(100), trandata VARCHAR2(4000), jbjg VARCHAR2(100), jbgy VARCHAR2(100), ldlcid VARCHAR2(50)); CREATE OR REPLACE TRIGGER jobinfo_his_bi BEFORE INSERT ON jobinfo_his FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT jobinfo_his_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_jobinfo_his_jobid ON jobinfo_his(jobid);\", \"CREATE INDEX idx_jobinfo_his_status ON jobinfo_his(jobstatus);\", \"CREATE INDEX idx_jobinfo_his_createtime ON jobinfo_his(createtime);\", \"CREATE INDEX idx_jobinfo_his_composite ON jobinfo_his(jobid, jobstatus, createtime);\", \"CREATE SEQUENCE businodeinst_seq; CREATE TABLE businodeinst (id NUMBER PRIMARY KEY, nodeinstid VARCHAR2(50) NOT NULL, flowinstid VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER businodeinst_bi BEFORE INSERT ON businodeinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT businodeinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_businodeinst_nodeinstid ON businodeinst(nodeinstid);\", \"CREATE INDEX idx_businodeinst_flowinstid ON businodeinst(flowinstid);\", \"CREATE SEQUENCE busiflowinst_seq; CREATE TABLE busiflowinst (id NUMBER PRIMARY KEY, flowinstid VARCHAR2(50) NOT NULL, status VARCHAR2(10)); CREATE OR REPLACE TRIGGER busiflowinst_bi BEFORE INSERT ON busiflowinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT busiflowinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_busiflowinst_flowinstid ON busiflowinst(flowinstid);\", \"CREATE INDEX idx_busiflowinst_composite ON busiflowinst(flowinstid, status);\"], \"sql\": \"select\\n  count(*)\\nfrom\\n  (\\n  select\\n   tt.jobid,\\n   tt.tellercode,\\n   tt.jobname,\\n   tt.jobstatus,\\n   tt.jobstartpersname,\\n   tt.jobpriorpersname,\\n   tt.jobtype,\\n   tt.createtime,\\n   tt.tranname,\\n   tt.issucc,\\n   tt.tranprop,\\n   tt.trandata,\\n   tt.jbjg,\\n   tt.jbgy,\\n   tt.ldlcid\\n  from\\n   (\\n  select\\n  t3.jobid,\\n  t3.tellercode,\\n  t3.jobname,\\n  t3.jobstatus,\\n  t3.jobstartpersname,\\n  t3.jobpriorpersname,\\n  t3.jobtype,\\n  t3.createtime,\\n  t3.tranname,\\n  t3.issucc,\\n  t3.tranprop,\\n  t3.trandata,\\n  t3.jbjg,\\n  t3.jbgy,\\n  t3.ldlcid,\\n  row_number() over (\\n   partition by\\n  t3.jobid\\n   order by\\n  t3.createtime desc\\n  ) as rn\\n  from\\n  jobinfo_his t3\\n  where\\n  exists (\\n   select\\n  t2.jobid\\n   from\\n  jobinfo_his t2\\n   where\\n  t2.jobid = t3.jobid\\n  and exists (\\n  select\\n   t1.jobid\\n  from\\n   jobinfo_his t1\\n  where\\n   t1.jobid = t2.jobid\\n   and t1.jobstatus = 'O'\\n   and substr(jobid, 0, 1) = 'A'\\n  )\\n   group by\\n  t2.jobid\\n   having\\n  count(decode(t2.jobstatus, 'N', 1, null)) = 0\\n  )\\n   ) tt\\n  where\\n   tt.rn = 1\\n  union all\\n  select\\n   t.jobid,\\n   t.tellercode,\\n   t.jobname,\\n   t.jobstatus,\\n   t.jobstartpersname,\\n   t.jobpriorpersname,\\n   t.jobtype,\\n   t.createtime,\\n   t.tranname,\\n   t.issucc,\\n   t.tranprop,\\n   t.trandata,\\n   t.jbjg,\\n   t.jbgy,\\n   t.ldlcid\\n  from\\n   jobinfo_his t,\\n   businodeinst t1,\\n   busiflowinst t2\\n  where\\n   t.jobid = t1.nodeinstid\\n   and t1.flowinstid = t2.flowinstid\\n   and t2.status = '1'\\n   and t.jobstatus = 'O'\\n  )\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t11679\\t1\\t\\t1903461107\\t11627\\n1\\t  SORT AGGREGATE \\t\\t1\\t\\t\\t\\n2\\t  VIEW  \\t11679\\t343333\\t\\t1903461107\\t11627\\n3\\t   UNION-ALL  \\t\\t\\t\\t\\t\\n4\\t  VIEW  \\t4181\\t10000\\t130000\\t837889750\\t4158\\n5\\t  WINDOW SORT PUSHED RANK \\t4181\\t10000\\t290000\\t837889750\\t4158\\n6\\t   NESTED LOOPS  \\t4180\\t10000\\t290000\\t795034459\\t4158\\n7\\t  VIEW  VW_NSO_1\\t3611\\t500\\t5500\\t785488019\\t3590\\n8\\t  HASH GROUP BY \\t3611\\t500\\t12000\\t785488019\\t3590\\n9\\t   HASH JOIN RIGHT SEMI \\t3609\\t64600\\t1550400\\t702111454\\t3590\\n10\\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1807\\t3333\\t39996\\t433839085\\t1795\\n11\\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1800\\t1000000\\t12000000\\t167172419\\t1795\\n12\\t  INDEX RANGE SCAN IDX_JOBINFO_HIS_COMPOSITE\\t2\\t20\\t360\\t19093\\t2\\n13\\t  HASH JOIN  \\t7498\\t333333\\t16666650\\t1065571358\\t7469\\n14\\t  INDEX FAST FULL SCAN IDX_BUSIFLOWINST_COMPOSITE\\t957\\t500000\\t7500000\\t194989133\\t952\\n15\\t  HASH JOIN  \\t5157\\t333333\\t11666655\\t713706795\\t5138\\n16\\t   NESTED LOOPS  \\t5157\\t333333\\t11666655\\t713706795\\t5138\\n17\\t  NESTED LOOPS  \\t\\t\\t\\t\\t\\n18\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n19\\t   INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1801\\t333333\\t3999996\\t217172419\\t1795\\n20\\t  INDEX RANGE SCAN IDX_BUSINODEINST_NODEINSTID\\t\\t\\t\\t\\t\\n21\\t  TABLE ACCESS BY INDEX ROWID BUSINODEINST\\t1316\\t1\\t23\\t224396555\\t1310\\n22\\t   TABLE ACCESS FULL BUSINODEINST\\t1316\\t1000000\\t23000000\\t224396555\\t1310\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推将SELECT子句简化为SELECT 1：① 消除15个无用列减少93%数据传输 ② 保持原计算逻辑不变 ③ 窗口函数分区/排序列仍在FROM子句可用，未改变计算行为\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推优化：1. 将HAVING条件转换为WHERE过滤并移除HAVING；2. 下推子查询内条件并明确表别名；3. 多表JOIN中提前过滤维度表。减少窗口函数/聚合/JOIN的数据量，性能提升预计20%-50%\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"GROUP BY 子句消除,移除了EXISTS子查询中不必要的GROUP BY jobid操作。原始分组在仅需判断行存在性的EXISTS子句中冗余且增加开销，消除后保持语义不变但减少分组排序成本，数据量大时性能提升显著\"}, {\"rule_id\": \"4\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,优化了子查询中处理jobid前缀的条件，消除隐式转换风险，提高查询效率。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE jobinfo_his_seq; CREATE TABLE jobinfo_his (id NUMBER PRIMARY KEY, jobid VARCHAR2(50) NOT NULL, tellercode VARCHAR2(50), jobname VARCHAR2(100), jobstatus VARCHAR2(10), jobstartpersname VARCHAR2(100), jobpriorpersname VARCHAR2(100), jobtype VARCHAR2(50), createtime DATE NOT NULL, tranname VARCHAR2(100), issucc VARCHAR2(1), tranprop VARCHAR2(100), trandata VARCHAR2(4000), jbjg VARCHAR2(100), jbgy VARCHAR2(100), ldlcid VARCHAR2(50)); CREATE OR REPLACE TRIGGER jobinfo_his_bi BEFORE INSERT ON jobinfo_his FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT jobinfo_his_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_jobinfo_his_jobid ON jobinfo_his(jobid);\nCREATE INDEX idx_jobinfo_his_status ON jobinfo_his(jobstatus);\nCREATE INDEX idx_jobinfo_his_createtime ON jobinfo_his(createtime);\nCREATE INDEX idx_jobinfo_his_composite ON jobinfo_his(jobid, jobstatus, createtime);\nCREATE SEQUENCE businodeinst_seq; CREATE TABLE businodeinst (id NUMBER PRIMARY KEY, nodeinstid VARCHAR2(50) NOT NULL, flowinstid VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER businodeinst_bi BEFORE INSERT ON businodeinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT businodeinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_businodeinst_nodeinstid ON businodeinst(nodeinstid);\nCREATE INDEX idx_businodeinst_flowinstid ON businodeinst(flowinstid);\nCREATE SEQUENCE busiflowinst_seq; CREATE TABLE busiflowinst (id NUMBER PRIMARY KEY, flowinstid VARCHAR2(50) NOT NULL, status VARCHAR2(10)); CREATE OR REPLACE TRIGGER busiflowinst_bi BEFORE INSERT ON busiflowinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT busiflowinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_busiflowinst_flowinstid ON busiflowinst(flowinstid);\nCREATE INDEX idx_busiflowinst_composite ON busiflowinst(flowinstid, status);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t11679\t1\t\t1903461107\t11627\n1\t  SORT AGGREGATE \t\t1\t\t\t\n2\t  VIEW  \t11679\t343333\t\t1903461107\t11627\n3\t   UNION-ALL  \t\t\t\t\t\n4\t  VIEW  \t4181\t10000\t130000\t837889750\t4158\n5\t  WINDOW SORT PUSHED RANK \t4181\t10000\t290000\t837889750\t4158\n6\t   NESTED LOOPS  \t4180\t10000\t290000\t795034459\t4158\n7\t  VIEW  VW_NSO_1\t3611\t500\t5500\t785488019\t3590\n8\t  HASH GROUP BY \t3611\t500\t12000\t785488019\t3590\n9\t   HASH JOIN RIGHT SEMI \t3609\t64600\t1550400\t702111454\t3590\n10\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1807\t3333\t39996\t433839085\t1795\n11\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1800\t1000000\t12000000\t167172419\t1795\n12\t  INDEX RANGE SCAN IDX_JOBINFO_HIS_COMPOSITE\t2\t20\t360\t19093\t2\n13\t  HASH JOIN  \t7498\t333333\t16666650\t1065571358\t7469\n14\t  INDEX FAST FULL SCAN IDX_BUSIFLOWINST_COMPOSITE\t957\t500000\t7500000\t194989133\t952\n15\t  HASH JOIN  \t5157\t333333\t11666655\t713706795\t5138\n16\t   NESTED LOOPS  \t5157\t333333\t11666655\t713706795\t5138\n17\t  NESTED LOOPS  \t\t\t\t\t\n18\t  STATISTICS COLLECTOR  \t\t\t\t\t\n19\t   INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1801\t333333\t3999996\t217172419\t1795\n20\t  INDEX RANGE SCAN IDX_BUSINODEINST_NODEINSTID\t\t\t\t\t\n21\t  TABLE ACCESS BY INDEX ROWID BUSINODEINST\t1316\t1\t23\t224396555\t1310\n22\t   TABLE ACCESS FULL BUSINODEINST\t1316\t1000000\t23000000\t224396555\t1310\n\n## Original SQL:\nselect\n  count(*)\nfrom\n  (\n  select\n   tt.jobid,\n   tt.tellercode,\n   tt.jobname,\n   tt.jobstatus,\n   tt.jobstartpersname,\n   tt.jobpriorpersname,\n   tt.jobtype,\n   tt.createtime,\n   tt.tranname,\n   tt.issucc,\n   tt.tranprop,\n   tt.trandata,\n   tt.jbjg,\n   tt.jbgy,\n   tt.ldlcid\n  from\n   (\n  select\n  t3.jobid,\n  t3.tellercode,\n  t3.jobname,\n  t3.jobstatus,\n  t3.jobstartpersname,\n  t3.jobpriorpersname,\n  t3.jobtype,\n  t3.createtime,\n  t3.tranname,\n  t3.issucc,\n  t3.tranprop,\n  t3.trandata,\n  t3.jbjg,\n  t3.jbgy,\n  t3.ldlcid,\n  row_number() over (\n   partition by\n  t3.jobid\n   order by\n  t3.createtime desc\n  ) as rn\n  from\n  jobinfo_his t3\n  where\n  exists (\n   select\n  t2.jobid\n   from\n  jobinfo_his t2\n   where\n  t2.jobid = t3.jobid\n  and exists (\n  select\n   t1.jobid\n  from\n   jobinfo_his t1\n  where\n   t1.jobid = t2.jobid\n   and t1.jobstatus = 'O'\n   and substr(jobid, 0, 1) = 'A'\n  )\n   group by\n  t2.jobid\n   having\n  count(decode(t2.jobstatus, 'N', 1, null)) = 0\n  )\n   ) tt\n  where\n   tt.rn = 1\n  union all\n  select\n   t.jobid,\n   t.tellercode,\n   t.jobname,\n   t.jobstatus,\n   t.jobstartpersname,\n   t.jobpriorpersname,\n   t.jobtype,\n   t.createtime,\n   t.tranname,\n   t.issucc,\n   t.tranprop,\n   t.trandata,\n   t.jbjg,\n   t.jbgy,\n   t.ldlcid\n  from\n   jobinfo_his t,\n   businodeinst t1,\n   busiflowinst t2\n  where\n   t.jobid = t1.nodeinstid\n   and t1.flowinstid = t2.flowinstid\n   and t2.status = '1'\n   and t.jobstatus = 'O'\n  )\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select count(*) from (select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid from (select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid, row_number() over (partition by t.jobid order by t.createtime desc) as rn from jobinfo_his t where t.jobid like 'A%' and exists (select 1 from jobinfo_his where jobid = t.jobid and jobstatus = 'O') and not exists (select 1 from jobinfo_his where jobid = t.jobid and jobstatus = 'N')) where rn = 1 union all select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid from jobinfo_his t inner join businodeinst t1 on t.jobid = t1.nodeinstid inner join busiflowinst t2 on t1.flowinstid = t2.flowinstid where t2.status = '1' and t.jobstatus = 'O')"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "29",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"29\", \"db_type\": \"oracle\", \"description\": \"改写试图通过三个方向优化：1）谓词优化：将SUBSTR函数改为LIKE谓词以便索引扫描；将HAVING COUNT(DECODE())改为简单的WHERE过滤；2）投影裁剪：对于COUNT(*)查询，将SELECT所有列改为SELECT 1，减少数据传输；3）数据预过滤：在连接前通过内联视图过滤数据。理论上这些都是常见的优化技术，但在本案例中，HAVING到WHERE的转换导致优化器基数估算失准，反而产生了更差的执行计划。\", \"create_table_statements\": [\"CREATE SEQUENCE jobinfo_his_seq; CREATE TABLE jobinfo_his (id NUMBER PRIMARY KEY, jobid VARCHAR2(50) NOT NULL, tellercode VARCHAR2(50), jobname VARCHAR2(100), jobstatus VARCHAR2(10), jobstartpersname VARCHAR2(100), jobpriorpersname VARCHAR2(100), jobtype VARCHAR2(50), createtime DATE NOT NULL, tranname VARCHAR2(100), issucc VARCHAR2(1), tranprop VARCHAR2(100), trandata VARCHAR2(4000), jbjg VARCHAR2(100), jbgy VARCHAR2(100), ldlcid VARCHAR2(50)); CREATE OR REPLACE TRIGGER jobinfo_his_bi BEFORE INSERT ON jobinfo_his FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT jobinfo_his_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_jobinfo_his_jobid ON jobinfo_his(jobid);\", \"CREATE INDEX idx_jobinfo_his_status ON jobinfo_his(jobstatus);\", \"CREATE INDEX idx_jobinfo_his_createtime ON jobinfo_his(createtime);\", \"CREATE INDEX idx_jobinfo_his_composite ON jobinfo_his(jobid, jobstatus, createtime);\", \"CREATE SEQUENCE businodeinst_seq; CREATE TABLE businodeinst (id NUMBER PRIMARY KEY, nodeinstid VARCHAR2(50) NOT NULL, flowinstid VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER businodeinst_bi BEFORE INSERT ON businodeinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT businodeinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_businodeinst_nodeinstid ON businodeinst(nodeinstid);\", \"CREATE INDEX idx_businodeinst_flowinstid ON businodeinst(flowinstid);\", \"CREATE SEQUENCE busiflowinst_seq; CREATE TABLE busiflowinst (id NUMBER PRIMARY KEY, flowinstid VARCHAR2(50) NOT NULL, status VARCHAR2(10)); CREATE OR REPLACE TRIGGER busiflowinst_bi BEFORE INSERT ON busiflowinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT busiflowinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_busiflowinst_flowinstid ON busiflowinst(flowinstid);\", \"CREATE INDEX idx_busiflowinst_composite ON busiflowinst(flowinstid, status);\"], \"sql\": \"select\\n  count(*)\\nfrom\\n  (\\n  select\\n   tt.jobid,\\n   tt.tellercode,\\n   tt.jobname,\\n   tt.jobstatus,\\n   tt.jobstartpersname,\\n   tt.jobpriorpersname,\\n   tt.jobtype,\\n   tt.createtime,\\n   tt.tranname,\\n   tt.issucc,\\n   tt.tranprop,\\n   tt.trandata,\\n   tt.jbjg,\\n   tt.jbgy,\\n   tt.ldlcid\\n  from\\n   (\\n  select\\n  t3.jobid,\\n  t3.tellercode,\\n  t3.jobname,\\n  t3.jobstatus,\\n  t3.jobstartpersname,\\n  t3.jobpriorpersname,\\n  t3.jobtype,\\n  t3.createtime,\\n  t3.tranname,\\n  t3.issucc,\\n  t3.tranprop,\\n  t3.trandata,\\n  t3.jbjg,\\n  t3.jbgy,\\n  t3.ldlcid,\\n  row_number() over (\\n   partition by\\n  t3.jobid\\n   order by\\n  t3.createtime desc\\n  ) as rn\\n  from\\n  jobinfo_his t3\\n  where\\n  exists (\\n   select\\n  t2.jobid\\n   from\\n  jobinfo_his t2\\n   where\\n  t2.jobid = t3.jobid\\n  and exists (\\n  select\\n   t1.jobid\\n  from\\n   jobinfo_his t1\\n  where\\n   t1.jobid = t2.jobid\\n   and t1.jobstatus = 'O'\\n   and substr(jobid, 0, 1) = 'A'\\n  )\\n   group by\\n  t2.jobid\\n   having\\n  count(decode(t2.jobstatus, 'N', 1, null)) = 0\\n  )\\n   ) tt\\n  where\\n   tt.rn = 1\\n  union all\\n  select\\n   t.jobid,\\n   t.tellercode,\\n   t.jobname,\\n   t.jobstatus,\\n   t.jobstartpersname,\\n   t.jobpriorpersname,\\n   t.jobtype,\\n   t.createtime,\\n   t.tranname,\\n   t.issucc,\\n   t.tranprop,\\n   t.trandata,\\n   t.jbjg,\\n   t.jbgy,\\n   t.ldlcid\\n  from\\n   jobinfo_his t,\\n   businodeinst t1,\\n   busiflowinst t2\\n  where\\n   t.jobid = t1.nodeinstid\\n   and t1.flowinstid = t2.flowinstid\\n   and t2.status = '1'\\n   and t.jobstatus = 'O'\\n  )\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t11679\\t1\\t\\t1903461107\\t11627\\n1\\t  SORT AGGREGATE \\t\\t1\\t\\t\\t\\n2\\t  VIEW  \\t11679\\t343333\\t\\t1903461107\\t11627\\n3\\t   UNION-ALL  \\t\\t\\t\\t\\t\\n4\\t  VIEW  \\t4181\\t10000\\t130000\\t837889750\\t4158\\n5\\t  WINDOW SORT PUSHED RANK \\t4181\\t10000\\t290000\\t837889750\\t4158\\n6\\t   NESTED LOOPS  \\t4180\\t10000\\t290000\\t795034459\\t4158\\n7\\t  VIEW  VW_NSO_1\\t3611\\t500\\t5500\\t785488019\\t3590\\n8\\t  HASH GROUP BY \\t3611\\t500\\t12000\\t785488019\\t3590\\n9\\t   HASH JOIN RIGHT SEMI \\t3609\\t64600\\t1550400\\t702111454\\t3590\\n10\\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1807\\t3333\\t39996\\t433839085\\t1795\\n11\\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1800\\t1000000\\t12000000\\t167172419\\t1795\\n12\\t  INDEX RANGE SCAN IDX_JOBINFO_HIS_COMPOSITE\\t2\\t20\\t360\\t19093\\t2\\n13\\t  HASH JOIN  \\t7498\\t333333\\t16666650\\t1065571358\\t7469\\n14\\t  INDEX FAST FULL SCAN IDX_BUSIFLOWINST_COMPOSITE\\t957\\t500000\\t7500000\\t194989133\\t952\\n15\\t  HASH JOIN  \\t5157\\t333333\\t11666655\\t713706795\\t5138\\n16\\t   NESTED LOOPS  \\t5157\\t333333\\t11666655\\t713706795\\t5138\\n17\\t  NESTED LOOPS  \\t\\t\\t\\t\\t\\n18\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n19\\t   INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1801\\t333333\\t3999996\\t217172419\\t1795\\n20\\t  INDEX RANGE SCAN IDX_BUSINODEINST_NODEINSTID\\t\\t\\t\\t\\t\\n21\\t  TABLE ACCESS BY INDEX ROWID BUSINODEINST\\t1316\\t1\\t23\\t224396555\\t1310\\n22\\t   TABLE ACCESS FULL BUSINODEINST\\t1316\\t1000000\\t23000000\\t224396555\\t1310\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推将SELECT子句简化为SELECT 1：① 消除15个无用列减少93%数据传输 ② 保持原计算逻辑不变 ③ 窗口函数分区/排序列仍在FROM子句可用，未改变计算行为\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推优化：1. 将HAVING条件转换为WHERE过滤并移除HAVING；2. 下推子查询内条件并明确表别名；3. 多表JOIN中提前过滤维度表。减少窗口函数/聚合/JOIN的数据量，性能提升预计20%-50%\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"GROUP BY 子句消除,移除了EXISTS子查询中不必要的GROUP BY jobid操作。原始分组在仅需判断行存在性的EXISTS子句中冗余且增加开销，消除后保持语义不变但减少分组排序成本，数据量大时性能提升显著\"}, {\"rule_id\": \"4\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,优化了子查询中处理jobid前缀的条件，消除隐式转换风险，提高查询效率。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE jobinfo_his_seq; CREATE TABLE jobinfo_his (id NUMBER PRIMARY KEY, jobid VARCHAR2(50) NOT NULL, tellercode VARCHAR2(50), jobname VARCHAR2(100), jobstatus VARCHAR2(10), jobstartpersname VARCHAR2(100), jobpriorpersname VARCHAR2(100), jobtype VARCHAR2(50), createtime DATE NOT NULL, tranname VARCHAR2(100), issucc VARCHAR2(1), tranprop VARCHAR2(100), trandata VARCHAR2(4000), jbjg VARCHAR2(100), jbgy VARCHAR2(100), ldlcid VARCHAR2(50)); CREATE OR REPLACE TRIGGER jobinfo_his_bi BEFORE INSERT ON jobinfo_his FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT jobinfo_his_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_jobinfo_his_jobid ON jobinfo_his(jobid);\nCREATE INDEX idx_jobinfo_his_status ON jobinfo_his(jobstatus);\nCREATE INDEX idx_jobinfo_his_createtime ON jobinfo_his(createtime);\nCREATE INDEX idx_jobinfo_his_composite ON jobinfo_his(jobid, jobstatus, createtime);\nCREATE SEQUENCE businodeinst_seq; CREATE TABLE businodeinst (id NUMBER PRIMARY KEY, nodeinstid VARCHAR2(50) NOT NULL, flowinstid VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER businodeinst_bi BEFORE INSERT ON businodeinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT businodeinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_businodeinst_nodeinstid ON businodeinst(nodeinstid);\nCREATE INDEX idx_businodeinst_flowinstid ON businodeinst(flowinstid);\nCREATE SEQUENCE busiflowinst_seq; CREATE TABLE busiflowinst (id NUMBER PRIMARY KEY, flowinstid VARCHAR2(50) NOT NULL, status VARCHAR2(10)); CREATE OR REPLACE TRIGGER busiflowinst_bi BEFORE INSERT ON busiflowinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT busiflowinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_busiflowinst_flowinstid ON busiflowinst(flowinstid);\nCREATE INDEX idx_busiflowinst_composite ON busiflowinst(flowinstid, status);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t11679\t1\t\t1903461107\t11627\n1\t  SORT AGGREGATE \t\t1\t\t\t\n2\t  VIEW  \t11679\t343333\t\t1903461107\t11627\n3\t   UNION-ALL  \t\t\t\t\t\n4\t  VIEW  \t4181\t10000\t130000\t837889750\t4158\n5\t  WINDOW SORT PUSHED RANK \t4181\t10000\t290000\t837889750\t4158\n6\t   NESTED LOOPS  \t4180\t10000\t290000\t795034459\t4158\n7\t  VIEW  VW_NSO_1\t3611\t500\t5500\t785488019\t3590\n8\t  HASH GROUP BY \t3611\t500\t12000\t785488019\t3590\n9\t   HASH JOIN RIGHT SEMI \t3609\t64600\t1550400\t702111454\t3590\n10\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1807\t3333\t39996\t433839085\t1795\n11\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1800\t1000000\t12000000\t167172419\t1795\n12\t  INDEX RANGE SCAN IDX_JOBINFO_HIS_COMPOSITE\t2\t20\t360\t19093\t2\n13\t  HASH JOIN  \t7498\t333333\t16666650\t1065571358\t7469\n14\t  INDEX FAST FULL SCAN IDX_BUSIFLOWINST_COMPOSITE\t957\t500000\t7500000\t194989133\t952\n15\t  HASH JOIN  \t5157\t333333\t11666655\t713706795\t5138\n16\t   NESTED LOOPS  \t5157\t333333\t11666655\t713706795\t5138\n17\t  NESTED LOOPS  \t\t\t\t\t\n18\t  STATISTICS COLLECTOR  \t\t\t\t\t\n19\t   INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1801\t333333\t3999996\t217172419\t1795\n20\t  INDEX RANGE SCAN IDX_BUSINODEINST_NODEINSTID\t\t\t\t\t\n21\t  TABLE ACCESS BY INDEX ROWID BUSINODEINST\t1316\t1\t23\t224396555\t1310\n22\t   TABLE ACCESS FULL BUSINODEINST\t1316\t1000000\t23000000\t224396555\t1310\n\n## Original SQL:\nselect\n  count(*)\nfrom\n  (\n  select\n   tt.jobid,\n   tt.tellercode,\n   tt.jobname,\n   tt.jobstatus,\n   tt.jobstartpersname,\n   tt.jobpriorpersname,\n   tt.jobtype,\n   tt.createtime,\n   tt.tranname,\n   tt.issucc,\n   tt.tranprop,\n   tt.trandata,\n   tt.jbjg,\n   tt.jbgy,\n   tt.ldlcid\n  from\n   (\n  select\n  t3.jobid,\n  t3.tellercode,\n  t3.jobname,\n  t3.jobstatus,\n  t3.jobstartpersname,\n  t3.jobpriorpersname,\n  t3.jobtype,\n  t3.createtime,\n  t3.tranname,\n  t3.issucc,\n  t3.tranprop,\n  t3.trandata,\n  t3.jbjg,\n  t3.jbgy,\n  t3.ldlcid,\n  row_number() over (\n   partition by\n  t3.jobid\n   order by\n  t3.createtime desc\n  ) as rn\n  from\n  jobinfo_his t3\n  where\n  exists (\n   select\n  t2.jobid\n   from\n  jobinfo_his t2\n   where\n  t2.jobid = t3.jobid\n  and exists (\n  select\n   t1.jobid\n  from\n   jobinfo_his t1\n  where\n   t1.jobid = t2.jobid\n   and t1.jobstatus = 'O'\n   and substr(jobid, 0, 1) = 'A'\n  )\n   group by\n  t2.jobid\n   having\n  count(decode(t2.jobstatus, 'N', 1, null)) = 0\n  )\n   ) tt\n  where\n   tt.rn = 1\n  union all\n  select\n   t.jobid,\n   t.tellercode,\n   t.jobname,\n   t.jobstatus,\n   t.jobstartpersname,\n   t.jobpriorpersname,\n   t.jobtype,\n   t.createtime,\n   t.tranname,\n   t.issucc,\n   t.tranprop,\n   t.trandata,\n   t.jbjg,\n   t.jbgy,\n   t.ldlcid\n  from\n   jobinfo_his t,\n   businodeinst t1,\n   busiflowinst t2\n  where\n   t.jobid = t1.nodeinstid\n   and t1.flowinstid = t2.flowinstid\n   and t2.status = '1'\n   and t.jobstatus = 'O'\n  )\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select count(*) from (select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid from (select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid, row_number() over (partition by t.jobid order by t.createtime desc) as rn from jobinfo_his t where t.jobid like 'A%' and exists (select 1 from jobinfo_his where jobid = t.jobid and jobstatus = 'O') and not exists (select 1 from jobinfo_his where jobid = t.jobid and jobstatus = 'N')) where rn = 1 union all select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid from jobinfo_his t inner join businodeinst t1 on t.jobid = t1.nodeinstid inner join busiflowinst t2 on t1.flowinstid = t2.flowinstid where t2.status = '1' and t.jobstatus = 'O')"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "29",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"29\", \"db_type\": \"oracle\", \"description\": \"改写试图通过三个方向优化：1）谓词优化：将SUBSTR函数改为LIKE谓词以便索引扫描；将HAVING COUNT(DECODE())改为简单的WHERE过滤；2）投影裁剪：对于COUNT(*)查询，将SELECT所有列改为SELECT 1，减少数据传输；3）数据预过滤：在连接前通过内联视图过滤数据。理论上这些都是常见的优化技术，但在本案例中，HAVING到WHERE的转换导致优化器基数估算失准，反而产生了更差的执行计划。\", \"create_table_statements\": [\"CREATE SEQUENCE jobinfo_his_seq; CREATE TABLE jobinfo_his (id NUMBER PRIMARY KEY, jobid VARCHAR2(50) NOT NULL, tellercode VARCHAR2(50), jobname VARCHAR2(100), jobstatus VARCHAR2(10), jobstartpersname VARCHAR2(100), jobpriorpersname VARCHAR2(100), jobtype VARCHAR2(50), createtime DATE NOT NULL, tranname VARCHAR2(100), issucc VARCHAR2(1), tranprop VARCHAR2(100), trandata VARCHAR2(4000), jbjg VARCHAR2(100), jbgy VARCHAR2(100), ldlcid VARCHAR2(50)); CREATE OR REPLACE TRIGGER jobinfo_his_bi BEFORE INSERT ON jobinfo_his FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT jobinfo_his_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_jobinfo_his_jobid ON jobinfo_his(jobid);\", \"CREATE INDEX idx_jobinfo_his_status ON jobinfo_his(jobstatus);\", \"CREATE INDEX idx_jobinfo_his_createtime ON jobinfo_his(createtime);\", \"CREATE INDEX idx_jobinfo_his_composite ON jobinfo_his(jobid, jobstatus, createtime);\", \"CREATE SEQUENCE businodeinst_seq; CREATE TABLE businodeinst (id NUMBER PRIMARY KEY, nodeinstid VARCHAR2(50) NOT NULL, flowinstid VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER businodeinst_bi BEFORE INSERT ON businodeinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT businodeinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_businodeinst_nodeinstid ON businodeinst(nodeinstid);\", \"CREATE INDEX idx_businodeinst_flowinstid ON businodeinst(flowinstid);\", \"CREATE SEQUENCE busiflowinst_seq; CREATE TABLE busiflowinst (id NUMBER PRIMARY KEY, flowinstid VARCHAR2(50) NOT NULL, status VARCHAR2(10)); CREATE OR REPLACE TRIGGER busiflowinst_bi BEFORE INSERT ON busiflowinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT busiflowinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_busiflowinst_flowinstid ON busiflowinst(flowinstid);\", \"CREATE INDEX idx_busiflowinst_composite ON busiflowinst(flowinstid, status);\"], \"sql\": \"select\\n  count(*)\\nfrom\\n  (\\n  select\\n   tt.jobid,\\n   tt.tellercode,\\n   tt.jobname,\\n   tt.jobstatus,\\n   tt.jobstartpersname,\\n   tt.jobpriorpersname,\\n   tt.jobtype,\\n   tt.createtime,\\n   tt.tranname,\\n   tt.issucc,\\n   tt.tranprop,\\n   tt.trandata,\\n   tt.jbjg,\\n   tt.jbgy,\\n   tt.ldlcid\\n  from\\n   (\\n  select\\n  t3.jobid,\\n  t3.tellercode,\\n  t3.jobname,\\n  t3.jobstatus,\\n  t3.jobstartpersname,\\n  t3.jobpriorpersname,\\n  t3.jobtype,\\n  t3.createtime,\\n  t3.tranname,\\n  t3.issucc,\\n  t3.tranprop,\\n  t3.trandata,\\n  t3.jbjg,\\n  t3.jbgy,\\n  t3.ldlcid,\\n  row_number() over (\\n   partition by\\n  t3.jobid\\n   order by\\n  t3.createtime desc\\n  ) as rn\\n  from\\n  jobinfo_his t3\\n  where\\n  exists (\\n   select\\n  t2.jobid\\n   from\\n  jobinfo_his t2\\n   where\\n  t2.jobid = t3.jobid\\n  and exists (\\n  select\\n   t1.jobid\\n  from\\n   jobinfo_his t1\\n  where\\n   t1.jobid = t2.jobid\\n   and t1.jobstatus = 'O'\\n   and substr(jobid, 0, 1) = 'A'\\n  )\\n   group by\\n  t2.jobid\\n   having\\n  count(decode(t2.jobstatus, 'N', 1, null)) = 0\\n  )\\n   ) tt\\n  where\\n   tt.rn = 1\\n  union all\\n  select\\n   t.jobid,\\n   t.tellercode,\\n   t.jobname,\\n   t.jobstatus,\\n   t.jobstartpersname,\\n   t.jobpriorpersname,\\n   t.jobtype,\\n   t.createtime,\\n   t.tranname,\\n   t.issucc,\\n   t.tranprop,\\n   t.trandata,\\n   t.jbjg,\\n   t.jbgy,\\n   t.ldlcid\\n  from\\n   jobinfo_his t,\\n   businodeinst t1,\\n   busiflowinst t2\\n  where\\n   t.jobid = t1.nodeinstid\\n   and t1.flowinstid = t2.flowinstid\\n   and t2.status = '1'\\n   and t.jobstatus = 'O'\\n  )\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t11679\\t1\\t\\t1903461107\\t11627\\n1\\t  SORT AGGREGATE \\t\\t1\\t\\t\\t\\n2\\t  VIEW  \\t11679\\t343333\\t\\t1903461107\\t11627\\n3\\t   UNION-ALL  \\t\\t\\t\\t\\t\\n4\\t  VIEW  \\t4181\\t10000\\t130000\\t837889750\\t4158\\n5\\t  WINDOW SORT PUSHED RANK \\t4181\\t10000\\t290000\\t837889750\\t4158\\n6\\t   NESTED LOOPS  \\t4180\\t10000\\t290000\\t795034459\\t4158\\n7\\t  VIEW  VW_NSO_1\\t3611\\t500\\t5500\\t785488019\\t3590\\n8\\t  HASH GROUP BY \\t3611\\t500\\t12000\\t785488019\\t3590\\n9\\t   HASH JOIN RIGHT SEMI \\t3609\\t64600\\t1550400\\t702111454\\t3590\\n10\\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1807\\t3333\\t39996\\t433839085\\t1795\\n11\\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1800\\t1000000\\t12000000\\t167172419\\t1795\\n12\\t  INDEX RANGE SCAN IDX_JOBINFO_HIS_COMPOSITE\\t2\\t20\\t360\\t19093\\t2\\n13\\t  HASH JOIN  \\t7498\\t333333\\t16666650\\t1065571358\\t7469\\n14\\t  INDEX FAST FULL SCAN IDX_BUSIFLOWINST_COMPOSITE\\t957\\t500000\\t7500000\\t194989133\\t952\\n15\\t  HASH JOIN  \\t5157\\t333333\\t11666655\\t713706795\\t5138\\n16\\t   NESTED LOOPS  \\t5157\\t333333\\t11666655\\t713706795\\t5138\\n17\\t  NESTED LOOPS  \\t\\t\\t\\t\\t\\n18\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n19\\t   INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1801\\t333333\\t3999996\\t217172419\\t1795\\n20\\t  INDEX RANGE SCAN IDX_BUSINODEINST_NODEINSTID\\t\\t\\t\\t\\t\\n21\\t  TABLE ACCESS BY INDEX ROWID BUSINODEINST\\t1316\\t1\\t23\\t224396555\\t1310\\n22\\t   TABLE ACCESS FULL BUSINODEINST\\t1316\\t1000000\\t23000000\\t224396555\\t1310\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推将SELECT子句简化为SELECT 1：① 消除15个无用列减少93%数据传输 ② 保持原计算逻辑不变 ③ 窗口函数分区/排序列仍在FROM子句可用，未改变计算行为\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推优化：1. 将HAVING条件转换为WHERE过滤并移除HAVING；2. 下推子查询内条件并明确表别名；3. 多表JOIN中提前过滤维度表。减少窗口函数/聚合/JOIN的数据量，性能提升预计20%-50%\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"GROUP BY 子句消除,移除了EXISTS子查询中不必要的GROUP BY jobid操作。原始分组在仅需判断行存在性的EXISTS子句中冗余且增加开销，消除后保持语义不变但减少分组排序成本，数据量大时性能提升显著\"}, {\"rule_id\": \"4\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,优化了子查询中处理jobid前缀的条件，消除隐式转换风险，提高查询效率。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE jobinfo_his_seq; CREATE TABLE jobinfo_his (id NUMBER PRIMARY KEY, jobid VARCHAR2(50) NOT NULL, tellercode VARCHAR2(50), jobname VARCHAR2(100), jobstatus VARCHAR2(10), jobstartpersname VARCHAR2(100), jobpriorpersname VARCHAR2(100), jobtype VARCHAR2(50), createtime DATE NOT NULL, tranname VARCHAR2(100), issucc VARCHAR2(1), tranprop VARCHAR2(100), trandata VARCHAR2(4000), jbjg VARCHAR2(100), jbgy VARCHAR2(100), ldlcid VARCHAR2(50)); CREATE OR REPLACE TRIGGER jobinfo_his_bi BEFORE INSERT ON jobinfo_his FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT jobinfo_his_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_jobinfo_his_jobid ON jobinfo_his(jobid);\nCREATE INDEX idx_jobinfo_his_status ON jobinfo_his(jobstatus);\nCREATE INDEX idx_jobinfo_his_createtime ON jobinfo_his(createtime);\nCREATE INDEX idx_jobinfo_his_composite ON jobinfo_his(jobid, jobstatus, createtime);\nCREATE SEQUENCE businodeinst_seq; CREATE TABLE businodeinst (id NUMBER PRIMARY KEY, nodeinstid VARCHAR2(50) NOT NULL, flowinstid VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER businodeinst_bi BEFORE INSERT ON businodeinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT businodeinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_businodeinst_nodeinstid ON businodeinst(nodeinstid);\nCREATE INDEX idx_businodeinst_flowinstid ON businodeinst(flowinstid);\nCREATE SEQUENCE busiflowinst_seq; CREATE TABLE busiflowinst (id NUMBER PRIMARY KEY, flowinstid VARCHAR2(50) NOT NULL, status VARCHAR2(10)); CREATE OR REPLACE TRIGGER busiflowinst_bi BEFORE INSERT ON busiflowinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT busiflowinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_busiflowinst_flowinstid ON busiflowinst(flowinstid);\nCREATE INDEX idx_busiflowinst_composite ON busiflowinst(flowinstid, status);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t11679\t1\t\t1903461107\t11627\n1\t  SORT AGGREGATE \t\t1\t\t\t\n2\t  VIEW  \t11679\t343333\t\t1903461107\t11627\n3\t   UNION-ALL  \t\t\t\t\t\n4\t  VIEW  \t4181\t10000\t130000\t837889750\t4158\n5\t  WINDOW SORT PUSHED RANK \t4181\t10000\t290000\t837889750\t4158\n6\t   NESTED LOOPS  \t4180\t10000\t290000\t795034459\t4158\n7\t  VIEW  VW_NSO_1\t3611\t500\t5500\t785488019\t3590\n8\t  HASH GROUP BY \t3611\t500\t12000\t785488019\t3590\n9\t   HASH JOIN RIGHT SEMI \t3609\t64600\t1550400\t702111454\t3590\n10\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1807\t3333\t39996\t433839085\t1795\n11\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1800\t1000000\t12000000\t167172419\t1795\n12\t  INDEX RANGE SCAN IDX_JOBINFO_HIS_COMPOSITE\t2\t20\t360\t19093\t2\n13\t  HASH JOIN  \t7498\t333333\t16666650\t1065571358\t7469\n14\t  INDEX FAST FULL SCAN IDX_BUSIFLOWINST_COMPOSITE\t957\t500000\t7500000\t194989133\t952\n15\t  HASH JOIN  \t5157\t333333\t11666655\t713706795\t5138\n16\t   NESTED LOOPS  \t5157\t333333\t11666655\t713706795\t5138\n17\t  NESTED LOOPS  \t\t\t\t\t\n18\t  STATISTICS COLLECTOR  \t\t\t\t\t\n19\t   INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1801\t333333\t3999996\t217172419\t1795\n20\t  INDEX RANGE SCAN IDX_BUSINODEINST_NODEINSTID\t\t\t\t\t\n21\t  TABLE ACCESS BY INDEX ROWID BUSINODEINST\t1316\t1\t23\t224396555\t1310\n22\t   TABLE ACCESS FULL BUSINODEINST\t1316\t1000000\t23000000\t224396555\t1310\n\n## Original SQL:\nselect\n  count(*)\nfrom\n  (\n  select\n   tt.jobid,\n   tt.tellercode,\n   tt.jobname,\n   tt.jobstatus,\n   tt.jobstartpersname,\n   tt.jobpriorpersname,\n   tt.jobtype,\n   tt.createtime,\n   tt.tranname,\n   tt.issucc,\n   tt.tranprop,\n   tt.trandata,\n   tt.jbjg,\n   tt.jbgy,\n   tt.ldlcid\n  from\n   (\n  select\n  t3.jobid,\n  t3.tellercode,\n  t3.jobname,\n  t3.jobstatus,\n  t3.jobstartpersname,\n  t3.jobpriorpersname,\n  t3.jobtype,\n  t3.createtime,\n  t3.tranname,\n  t3.issucc,\n  t3.tranprop,\n  t3.trandata,\n  t3.jbjg,\n  t3.jbgy,\n  t3.ldlcid,\n  row_number() over (\n   partition by\n  t3.jobid\n   order by\n  t3.createtime desc\n  ) as rn\n  from\n  jobinfo_his t3\n  where\n  exists (\n   select\n  t2.jobid\n   from\n  jobinfo_his t2\n   where\n  t2.jobid = t3.jobid\n  and exists (\n  select\n   t1.jobid\n  from\n   jobinfo_his t1\n  where\n   t1.jobid = t2.jobid\n   and t1.jobstatus = 'O'\n   and substr(jobid, 0, 1) = 'A'\n  )\n   group by\n  t2.jobid\n   having\n  count(decode(t2.jobstatus, 'N', 1, null)) = 0\n  )\n   ) tt\n  where\n   tt.rn = 1\n  union all\n  select\n   t.jobid,\n   t.tellercode,\n   t.jobname,\n   t.jobstatus,\n   t.jobstartpersname,\n   t.jobpriorpersname,\n   t.jobtype,\n   t.createtime,\n   t.tranname,\n   t.issucc,\n   t.tranprop,\n   t.trandata,\n   t.jbjg,\n   t.jbgy,\n   t.ldlcid\n  from\n   jobinfo_his t,\n   businodeinst t1,\n   busiflowinst t2\n  where\n   t.jobid = t1.nodeinstid\n   and t1.flowinstid = t2.flowinstid\n   and t2.status = '1'\n   and t.jobstatus = 'O'\n  )\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select count(*) from (select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid from (select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid, row_number() over (partition by t.jobid order by t.createtime desc) as rn from jobinfo_his t where t.jobid like 'A%' and exists (select 1 from jobinfo_his where jobid = t.jobid and jobstatus = 'O') and not exists (select 1 from jobinfo_his where jobid = t.jobid and jobstatus = 'N')) where rn = 1 union all select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid from jobinfo_his t inner join businodeinst t1 on t.jobid = t1.nodeinstid inner join busiflowinst t2 on t1.flowinstid = t2.flowinstid where t2.status = '1' and t.jobstatus = 'O')"
                    }
                ],
                "rule_id": "4"
            },
            {
                "case_id": "30",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"30\", \"db_type\": \"oracle\", \"description\": \"此改写的核心是将原SQL中针对nortran表的7个独立子查询(n1-n7)和1个去重子查询(z)通过CTE的GROUP BY + MAX + CASE WHEN技术合并。原SQL中每个子查询都有WHERE条件过滤不同的nortran_aufd_code，改写后通过CASE WHEN在单次扫描中同时提取所有需要的字段值，然后用MAX聚合选择每个transaction的值。这种行列转换技术将EAV(Entity-Attribute-Value)模型的多行数据透视为宽表的单行数据。同时，将nobtran的过滤条件前置，减少JOIN时的数据量。这种改写方式在OLAP场景中常用于优化维度属性的多次JOIN。\", \"create_table_statements\": [\"CREATE SEQUENCE nobtran_seq; CREATE TABLE nobtran (nobtran_id NUMBER PRIMARY KEY, nobtran_transaction_no NUMBER NOT NULL, nobtran_acat_code VARCHAR2(20), nobtran_effective_date DATE, nobtran_trans_status_ind VARCHAR2(1), nobtran_pidm NUMBER NOT NULL, nobtran_apply_ind VARCHAR2(1) DEFAULT 'N'); CREATE OR REPLACE TRIGGER nobtran_bi BEFORE INSERT ON nobtran FOR EACH ROW BEGIN IF :NEW.nobtran_id IS NULL THEN SELECT nobtran_seq.NEXTVAL INTO :NEW.nobtran_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nobtran_acat_code ON nobtran(nobtran_acat_code);\", \"CREATE INDEX idx_nobtran_pidm ON nobtran(nobtran_pidm);\", \"CREATE INDEX idx_nobtran_transaction_no ON nobtran(nobtran_transaction_no);\", \"CREATE INDEX idx_nobtran_status ON nobtran(nobtran_trans_status_ind);\", \"CREATE INDEX idx_nobtran_apply_ind ON nobtran(nobtran_apply_ind);\", \"CREATE SEQUENCE spriden_seq; CREATE TABLE spriden (spriden_pidm NUMBER PRIMARY KEY, spriden_id VARCHAR2(50) NOT NULL, spriden_last_name VARCHAR2(100) NOT NULL, spriden_first_name VARCHAR2(100), spriden_change_ind VARCHAR2(1)); CREATE OR REPLACE TRIGGER spriden_bi BEFORE INSERT ON spriden FOR EACH ROW BEGIN IF :NEW.spriden_pidm IS NULL THEN SELECT spriden_seq.NEXTVAL INTO :NEW.spriden_pidm FROM DUAL; END IF; END;\", \"CREATE INDEX idx_spriden_change_ind ON spriden(spriden_change_ind);\", \"CREATE SEQUENCE norrout_seq; CREATE TABLE norrout (norrout_id NUMBER PRIMARY KEY, norrout_transaction_no NUMBER NOT NULL, norrout_queue_status_ind VARCHAR2(1), norrout_level_no NUMBER); CREATE OR REPLACE TRIGGER norrout_bi BEFORE INSERT ON norrout FOR EACH ROW BEGIN IF :NEW.norrout_id IS NULL THEN SELECT norrout_seq.NEXTVAL INTO :NEW.norrout_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_norrout_transaction_no ON norrout(norrout_transaction_no);\", \"CREATE INDEX idx_norrout_level_no ON norrout(norrout_level_no);\", \"CREATE INDEX idx_norrout_queue_status ON norrout(norrout_queue_status_ind);\", \"CREATE SEQUENCE pebempl_seq; CREATE TABLE pebempl (pebempl_pidm NUMBER PRIMARY KEY, pebempl_ecls_code VARCHAR2(10) NOT NULL, pebempl_current_hire_date DATE); CREATE OR REPLACE TRIGGER pebempl_bi BEFORE INSERT ON pebempl FOR EACH ROW BEGIN IF :NEW.pebempl_pidm IS NULL THEN SELECT pebempl_seq.NEXTVAL INTO :NEW.pebempl_pidm FROM DUAL; END IF; END;\", \"CREATE INDEX idx_pebempl_ecls_code ON pebempl(pebempl_ecls_code);\", \"CREATE SEQUENCE nortran_seq; CREATE TABLE nortran (nortran_id NUMBER PRIMARY KEY, nortran_transaction_no NUMBER NOT NULL, nortran_apty_code VARCHAR2(20), nortran_aufd_code VARCHAR2(50) NOT NULL, nortran_value VARCHAR2(200), nortran_posn VARCHAR2(50)); CREATE OR REPLACE TRIGGER nortran_bi BEFORE INSERT ON nortran FOR EACH ROW BEGIN IF :NEW.nortran_id IS NULL THEN SELECT nortran_seq.NEXTVAL INTO :NEW.nortran_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nortran_transaction_no ON nortran(nortran_transaction_no);\", \"CREATE INDEX idx_nortran_aufd_code ON nortran(nortran_aufd_code);\", \"CREATE INDEX idx_nortran_apty_code ON nortran(nortran_apty_code);\", \"CREATE SEQUENCE nortern_seq; CREATE TABLE nortern (nortern_id NUMBER PRIMARY KEY, nortern_transaction_no NUMBER NOT NULL, nortern_effective_date DATE, nortern_earn_code VARCHAR2(20), nortern_hrs NUMBER(10,2), nortern_special_rate NUMBER(15,2)); CREATE OR REPLACE TRIGGER nortern_bi BEFORE INSERT ON nortern FOR EACH ROW BEGIN IF :NEW.nortern_id IS NULL THEN SELECT nortern_seq.NEXTVAL INTO :NEW.nortern_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nortern_transaction_no ON nortern(nortern_transaction_no);\"], \"sql\": \"select s.spriden_id EID,\\n  s.spriden_last_name ||', '||s.spriden_first_name \\\"NAME\\\",\\n  b.nobtran_transaction_no \\\"TRANS NO.\\\",\\n  z.nortran_posn \\\"POSN NO\\\",\\n  b.nobtran_effective_date \\\"QUERY DATE\\\", \\n  b.nobtran_acat_code \\\"ACAT CODE\\\",\\n  n1.nortran_value \\\"CURRENT HIRE DATE\\\",\\n  n2.nortran_value \\\"BEGIN PERSONNEL DATE\\\",\\n  n3.nortran_value \\\"SALARY GROUP\\\",\\n  n4.nortran_value \\\"APPOINTMENT PERCENT\\\",\\n  n5.nortran_value \\\"ANNUAL SALARY\\\",\\n  t1.nortern_effective_date \\\"PAY DATA EFFECTIVE DATE\\\",\\n  t1.nortern_earn_code \\\"PAY DATA EARNINGS\\\",\\n  t1.nortern_hrs \\\"PAY DATA HOURS\\\",\\n  t1.nortern_special_rate \\\"PAY DATA SPECIAL RATE\\\",\\n  n6.nortran_value \\\"END JOB EFFECTIVE DATE\\\",\\n  n7.nortran_value \\\"END PERSONNEL DATE\\\"\\n   ,case b.nobtran_trans_status_ind\\n   when 'A' then 'Approved'\\n   when 'C' then 'Completed'\\n   when 'V' then 'Voided' \\n   when 'D' then 'Disapproved'\\n   when 'R' then 'Return for Correction'\\n   when 'P' then 'Pending'\\n   when 'W' then 'Waiting'\\n   when 'T' then 'Partially Completed'\\n   when 'N' then 'Cancelled'\\n   when 'U' then 'Superuser Update'\\n  end trans_status   \\n  ,case r.norrout_queue_status_ind\\n   when 'A' then 'Approved by that Approver'\\n   when 'D' then 'Disapproved'\\n   when 'F' then 'FYI'\\n   when 'I' then 'In Queue'\\n   when 'K' then 'Acknowledged'\\n   when 'L' then 'Applied by Applier'\\n   when 'M' then 'More Information'\\n   when 'O' then 'Overridden'\\n   when 'P' then 'Pending Action by Approver/Applier '\\n   when 'Q' then 'Removed from Queue'\\n   when 'R' then 'Return for Correction'\\n  end queue_status\\n  ,r.norrout_level_no\\n  \\n\\n  from nobtran b,spriden s, norrout r, pebempl pp, /*nbrjobs nbr,*/\\n  (select nc.nortran_transaction_no,nc.nortran_apty_code,nc.nortran_aufd_code,nc.nortran_value\\n  from nortran nc\\n   where nc.nortran_aufd_code = 'PEBEMPL_CURRENT_HIRE_DATE'\\n  ) n1, /* Current Hire Date */\\n  (select nb.nortran_transaction_no,nb.nortran_apty_code,nb.nortran_aufd_code,nb.nortran_value\\n  from nortran nb\\n   where nb.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' \\n  ) n2,  /*Begin Personnnel Date*/ \\n  (select ns.nortran_transaction_no,ns.nortran_apty_code,ns.nortran_aufd_code,ns.nortran_value\\n  from nortran ns\\n   where ns.nortran_aufd_code = 'NBRJOBS_SGRP_CODE'\\n   ) n3, /* Salary Group */\\n  (select na.nortran_transaction_no,na.nortran_apty_code,na.nortran_aufd_code,na.nortran_value\\n  from nortran na\\n   where na.nortran_aufd_code = 'NBRJOBS_APPT_PCT'\\n  ) n4, /*Appointment Percent*/ \\n  (select nu.nortran_transaction_no,nu.nortran_apty_code,nu.nortran_aufd_code,nu.nortran_value\\n  from nortran nu\\n   where nu.nortran_aufd_code = 'NBRJOBS_ANN_SALARY'\\n  ) n5, /*Annual Salary*/\\n  (select nj.nortran_transaction_no,nj.nortran_apty_code,nj.nortran_aufd_code,nj.nortran_value\\n  from nortran nj\\n   where nj.nortran_aufd_code = 'NBRJOBS_EFFECTIVE_DATE'  \\n  and nj.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n6,  /*End Job Effective Date*/\\n  (select np.nortran_transaction_no,np.nortran_apty_code,np.nortran_aufd_code,np.nortran_value\\n  from nortran np\\n   where np.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE'  \\n  and np.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n7,  /*End Personnel Date*/\\n\\n  (select t.nortern_transaction_no,t.nortern_effective_date,t.nortern_earn_code,\\n   t.nortern_hrs, t.nortern_special_rate\\n  from nortern t) t1 \\n\\n   ,(select unique zz.nortran_transaction_no,zz.nortran_posn\\n  from nortran zz\\n   where zz.nortran_posn is not null\\n  ) z\\n\\n where b.nobtran_acat_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') /*employee*/\\n  /*waiting,completed,partially completedc,ancelled,supperuser update */\\n  /* and nobtran_trans_status_ind in ('W','C','T','U') */\\n   and b.nobtran_pidm = s.spriden_pidm\\n   and s.spriden_change_ind is null\\n   \\n   and b.nobtran_transaction_no = t1.nortern_transaction_no(+) /*Pay Data*/\\n   \\n   and b.nobtran_transaction_no = n1.nortran_transaction_no(+) /*Current Hire Date*/\\n   \\n   and b.nobtran_transaction_no = n2.nortran_transaction_no(+) /*Begin Personnnel Date*/\\n   \\n   and b.nobtran_transaction_no = n3.nortran_transaction_no(+) /*Salary Group*/\\n   \\n   and b.nobtran_transaction_no = n4.nortran_transaction_no(+) /*Appointment Percent*/\\n   \\n   and b.nobtran_transaction_no = n5.nortran_transaction_no(+) /*Annual Salary*/\\n   \\n   and b.nobtran_transaction_no = n6.nortran_transaction_no(+) /*End Job Effective Date*/\\n   \\n   and b.nobtran_transaction_no = n7.nortran_transaction_no(+) /*End Personnel Date*/\\n   \\n   and nobtran_transaction_no = r.norrout_transaction_no(+)\\n   --get all queue status\\n   /*and r.norrout_queue_status_ind = 'A'*/\\n   and r.norrout_level_no = 90 /* Pending HR approval Queue */\\n   -- not applied yet\\n   and b.nobtran_apply_ind = 'N' /*Applied ePAFs will not be listed*/\\n   --HR does not care about voided ePAFs\\n   and nobtran_trans_status_ind <> 'V'\\n   --get posn\\n   and b.nobtran_transaction_no = z.nortran_transaction_no\\n   and r.norrout_queue_status_ind <> 'A'\\n  -- exclude student\\n   and s.spriden_pidm = pp.pebempl_pidm\\n   and pp.pebempl_ecls_code not in ('RE','FW','GS','MW')\\n\\n   order by 3\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t68442\\t220696\\t81657520\\t10388402242\\t68160\\n1\\t  MERGE JOIN OUTER \\t68442\\t220696\\t81657520\\t10388402242\\t68160\\n2\\t  MERGE JOIN  \\t61068\\t220696\\t77243600\\t9073000336\\t60822\\n3\\t   MERGE JOIN OUTER \\t59624\\t1072825\\t366906150\\t8593654179\\t59391\\n4\\t  MERGE JOIN  \\t55673\\t1000048\\t302014496\\t8042006798\\t55455\\n5\\t  MERGE JOIN OUTER \\t40155\\t875042\\t236261340\\t5632420040\\t40002\\n6\\t   MERGE JOIN OUTER \\t36204\\t815681\\t187606630\\t5082114259\\t36066\\n7\\t  MERGE JOIN OUTER \\t32442\\t760347\\t149028012\\t4563228883\\t32318\\n8\\t  MERGE JOIN OUTER \\t28680\\t708767\\t114820254\\t4044718907\\t28570\\n9\\t   MERGE JOIN OUTER \\t24918\\t660686\\t84567808\\t3526558831\\t24822\\n10\\t  MERGE JOIN OUTER \\t21156\\t615866\\t57891404\\t3008724855\\t21074\\n11\\t  SORT JOIN \\t17394\\t574088\\t34445280\\t2491195079\\t17326\\n12\\t   HASH JOIN  \\t9138\\t574088\\t34445280\\t1827947896\\t9088\\n13\\t  HASH JOIN  \\t4697\\t656100\\t23619600\\t973767459\\t4671\\n14\\t  TABLE ACCESS FULL PEBEMPL\\t794\\t656100\\t3936600\\t362530962\\t784\\n15\\t  TABLE ACCESS FULL SPRIDEN\\t1351\\t1000000\\t30000000\\t285272492\\t1343\\n16\\t  TABLE ACCESS FULL NOBTRAN\\t1454\\t875000\\t21000000\\t548613482\\t1439\\n17\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n18\\t   TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n19\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n20\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n21\\t   SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n22\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n23\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n24\\t   TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n25\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n26\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n27\\t   SORT JOIN \\t3951\\t166667\\t6666680\\t544369681\\t3936\\n28\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t6666680\\t350105675\\t2236\\n29\\t  SORT JOIN \\t15518\\t1000000\\t32000000\\t2409581958\\t15453\\n30\\t   VIEW  \\t6805\\t1000000\\t32000000\\t1336011571\\t6769\\n31\\t  HASH UNIQUE \\t6805\\t1000000\\t12000000\\t1336011571\\t6769\\n32\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t1000000\\t12000000\\t328759001\\t2236\\n33\\t  SORT JOIN \\t3951\\t166667\\t6666680\\t544369681\\t3936\\n34\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t6666680\\t350105675\\t2236\\n35\\t   SORT JOIN \\t1444\\t180000\\t1440000\\t479346156\\t1431\\n36\\t  TABLE ACCESS FULL NORROUT\\t792\\t180000\\t1440000\\t290580962\\t784\\n37\\t  SORT JOIN \\t7374\\t1000000\\t20000000\\t1315401906\\t7338\\n38\\t   TABLE ACCESS FULL NORTERN\\t1304\\t1000000\\t20000000\\t284040483\\t1296\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推优化，消除了n1-n7子查询中的冗余字段(nortran_apty_code,nortran_aufd_code)，保留了核心事务ID和价值字段。减少了63%（7个子查询×2个字段）的数据传输量，显著降低磁盘I/O和内存占用\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推对主表b创建内联视图，提前应用高选择性过滤条件(nobtran_acat_code,nobtran_apply_ind,nobtran_trans_status_ind)，将数据过滤从连接后提前到数据源头。预估在弱优化器数据库(如MySQL 5.x)可提升20-50%性能，智能优化器数据库可提升5-15%。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"Merge Multiple Independent Subqueries Scanning Same Table,将原始SQL中7次独立的nortran表扫描合并为一个CTE，使用条件聚合在单次扫描中计算所有字段。通过内连接替代原始内连接（z子查询）和左外连接（n1~n7子查询），消除重复I/O开销。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE nobtran_seq; CREATE TABLE nobtran (nobtran_id NUMBER PRIMARY KEY, nobtran_transaction_no NUMBER NOT NULL, nobtran_acat_code VARCHAR2(20), nobtran_effective_date DATE, nobtran_trans_status_ind VARCHAR2(1), nobtran_pidm NUMBER NOT NULL, nobtran_apply_ind VARCHAR2(1) DEFAULT 'N'); CREATE OR REPLACE TRIGGER nobtran_bi BEFORE INSERT ON nobtran FOR EACH ROW BEGIN IF :NEW.nobtran_id IS NULL THEN SELECT nobtran_seq.NEXTVAL INTO :NEW.nobtran_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nobtran_acat_code ON nobtran(nobtran_acat_code);\nCREATE INDEX idx_nobtran_pidm ON nobtran(nobtran_pidm);\nCREATE INDEX idx_nobtran_transaction_no ON nobtran(nobtran_transaction_no);\nCREATE INDEX idx_nobtran_status ON nobtran(nobtran_trans_status_ind);\nCREATE INDEX idx_nobtran_apply_ind ON nobtran(nobtran_apply_ind);\nCREATE SEQUENCE spriden_seq; CREATE TABLE spriden (spriden_pidm NUMBER PRIMARY KEY, spriden_id VARCHAR2(50) NOT NULL, spriden_last_name VARCHAR2(100) NOT NULL, spriden_first_name VARCHAR2(100), spriden_change_ind VARCHAR2(1)); CREATE OR REPLACE TRIGGER spriden_bi BEFORE INSERT ON spriden FOR EACH ROW BEGIN IF :NEW.spriden_pidm IS NULL THEN SELECT spriden_seq.NEXTVAL INTO :NEW.spriden_pidm FROM DUAL; END IF; END;\nCREATE INDEX idx_spriden_change_ind ON spriden(spriden_change_ind);\nCREATE SEQUENCE norrout_seq; CREATE TABLE norrout (norrout_id NUMBER PRIMARY KEY, norrout_transaction_no NUMBER NOT NULL, norrout_queue_status_ind VARCHAR2(1), norrout_level_no NUMBER); CREATE OR REPLACE TRIGGER norrout_bi BEFORE INSERT ON norrout FOR EACH ROW BEGIN IF :NEW.norrout_id IS NULL THEN SELECT norrout_seq.NEXTVAL INTO :NEW.norrout_id FROM DUAL; END IF; END;\nCREATE INDEX idx_norrout_transaction_no ON norrout(norrout_transaction_no);\nCREATE INDEX idx_norrout_level_no ON norrout(norrout_level_no);\nCREATE INDEX idx_norrout_queue_status ON norrout(norrout_queue_status_ind);\nCREATE SEQUENCE pebempl_seq; CREATE TABLE pebempl (pebempl_pidm NUMBER PRIMARY KEY, pebempl_ecls_code VARCHAR2(10) NOT NULL, pebempl_current_hire_date DATE); CREATE OR REPLACE TRIGGER pebempl_bi BEFORE INSERT ON pebempl FOR EACH ROW BEGIN IF :NEW.pebempl_pidm IS NULL THEN SELECT pebempl_seq.NEXTVAL INTO :NEW.pebempl_pidm FROM DUAL; END IF; END;\nCREATE INDEX idx_pebempl_ecls_code ON pebempl(pebempl_ecls_code);\nCREATE SEQUENCE nortran_seq; CREATE TABLE nortran (nortran_id NUMBER PRIMARY KEY, nortran_transaction_no NUMBER NOT NULL, nortran_apty_code VARCHAR2(20), nortran_aufd_code VARCHAR2(50) NOT NULL, nortran_value VARCHAR2(200), nortran_posn VARCHAR2(50)); CREATE OR REPLACE TRIGGER nortran_bi BEFORE INSERT ON nortran FOR EACH ROW BEGIN IF :NEW.nortran_id IS NULL THEN SELECT nortran_seq.NEXTVAL INTO :NEW.nortran_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nortran_transaction_no ON nortran(nortran_transaction_no);\nCREATE INDEX idx_nortran_aufd_code ON nortran(nortran_aufd_code);\nCREATE INDEX idx_nortran_apty_code ON nortran(nortran_apty_code);\nCREATE SEQUENCE nortern_seq; CREATE TABLE nortern (nortern_id NUMBER PRIMARY KEY, nortern_transaction_no NUMBER NOT NULL, nortern_effective_date DATE, nortern_earn_code VARCHAR2(20), nortern_hrs NUMBER(10,2), nortern_special_rate NUMBER(15,2)); CREATE OR REPLACE TRIGGER nortern_bi BEFORE INSERT ON nortern FOR EACH ROW BEGIN IF :NEW.nortern_id IS NULL THEN SELECT nortern_seq.NEXTVAL INTO :NEW.nortern_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nortern_transaction_no ON nortern(nortern_transaction_no);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t68442\t220696\t81657520\t10388402242\t68160\n1\t  MERGE JOIN OUTER \t68442\t220696\t81657520\t10388402242\t68160\n2\t  MERGE JOIN  \t61068\t220696\t77243600\t9073000336\t60822\n3\t   MERGE JOIN OUTER \t59624\t1072825\t366906150\t8593654179\t59391\n4\t  MERGE JOIN  \t55673\t1000048\t302014496\t8042006798\t55455\n5\t  MERGE JOIN OUTER \t40155\t875042\t236261340\t5632420040\t40002\n6\t   MERGE JOIN OUTER \t36204\t815681\t187606630\t5082114259\t36066\n7\t  MERGE JOIN OUTER \t32442\t760347\t149028012\t4563228883\t32318\n8\t  MERGE JOIN OUTER \t28680\t708767\t114820254\t4044718907\t28570\n9\t   MERGE JOIN OUTER \t24918\t660686\t84567808\t3526558831\t24822\n10\t  MERGE JOIN OUTER \t21156\t615866\t57891404\t3008724855\t21074\n11\t  SORT JOIN \t17394\t574088\t34445280\t2491195079\t17326\n12\t   HASH JOIN  \t9138\t574088\t34445280\t1827947896\t9088\n13\t  HASH JOIN  \t4697\t656100\t23619600\t973767459\t4671\n14\t  TABLE ACCESS FULL PEBEMPL\t794\t656100\t3936600\t362530962\t784\n15\t  TABLE ACCESS FULL SPRIDEN\t1351\t1000000\t30000000\t285272492\t1343\n16\t  TABLE ACCESS FULL NOBTRAN\t1454\t875000\t21000000\t548613482\t1439\n17\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n18\t   TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n19\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n20\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n21\t   SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n22\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n23\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n24\t   TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n25\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n26\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n27\t   SORT JOIN \t3951\t166667\t6666680\t544369681\t3936\n28\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t6666680\t350105675\t2236\n29\t  SORT JOIN \t15518\t1000000\t32000000\t2409581958\t15453\n30\t   VIEW  \t6805\t1000000\t32000000\t1336011571\t6769\n31\t  HASH UNIQUE \t6805\t1000000\t12000000\t1336011571\t6769\n32\t  TABLE ACCESS FULL NORTRAN\t2245\t1000000\t12000000\t328759001\t2236\n33\t  SORT JOIN \t3951\t166667\t6666680\t544369681\t3936\n34\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t6666680\t350105675\t2236\n35\t   SORT JOIN \t1444\t180000\t1440000\t479346156\t1431\n36\t  TABLE ACCESS FULL NORROUT\t792\t180000\t1440000\t290580962\t784\n37\t  SORT JOIN \t7374\t1000000\t20000000\t1315401906\t7338\n38\t   TABLE ACCESS FULL NORTERN\t1304\t1000000\t20000000\t284040483\t1296\n\n## Original SQL:\nselect s.spriden_id EID,\n  s.spriden_last_name ||', '||s.spriden_first_name \"NAME\",\n  b.nobtran_transaction_no \"TRANS NO.\",\n  z.nortran_posn \"POSN NO\",\n  b.nobtran_effective_date \"QUERY DATE\", \n  b.nobtran_acat_code \"ACAT CODE\",\n  n1.nortran_value \"CURRENT HIRE DATE\",\n  n2.nortran_value \"BEGIN PERSONNEL DATE\",\n  n3.nortran_value \"SALARY GROUP\",\n  n4.nortran_value \"APPOINTMENT PERCENT\",\n  n5.nortran_value \"ANNUAL SALARY\",\n  t1.nortern_effective_date \"PAY DATA EFFECTIVE DATE\",\n  t1.nortern_earn_code \"PAY DATA EARNINGS\",\n  t1.nortern_hrs \"PAY DATA HOURS\",\n  t1.nortern_special_rate \"PAY DATA SPECIAL RATE\",\n  n6.nortran_value \"END JOB EFFECTIVE DATE\",\n  n7.nortran_value \"END PERSONNEL DATE\"\n   ,case b.nobtran_trans_status_ind\n   when 'A' then 'Approved'\n   when 'C' then 'Completed'\n   when 'V' then 'Voided' \n   when 'D' then 'Disapproved'\n   when 'R' then 'Return for Correction'\n   when 'P' then 'Pending'\n   when 'W' then 'Waiting'\n   when 'T' then 'Partially Completed'\n   when 'N' then 'Cancelled'\n   when 'U' then 'Superuser Update'\n  end trans_status   \n  ,case r.norrout_queue_status_ind\n   when 'A' then 'Approved by that Approver'\n   when 'D' then 'Disapproved'\n   when 'F' then 'FYI'\n   when 'I' then 'In Queue'\n   when 'K' then 'Acknowledged'\n   when 'L' then 'Applied by Applier'\n   when 'M' then 'More Information'\n   when 'O' then 'Overridden'\n   when 'P' then 'Pending Action by Approver/Applier '\n   when 'Q' then 'Removed from Queue'\n   when 'R' then 'Return for Correction'\n  end queue_status\n  ,r.norrout_level_no\n  \n\n  from nobtran b,spriden s, norrout r, pebempl pp, /*nbrjobs nbr,*/\n  (select nc.nortran_transaction_no,nc.nortran_apty_code,nc.nortran_aufd_code,nc.nortran_value\n  from nortran nc\n   where nc.nortran_aufd_code = 'PEBEMPL_CURRENT_HIRE_DATE'\n  ) n1, /* Current Hire Date */\n  (select nb.nortran_transaction_no,nb.nortran_apty_code,nb.nortran_aufd_code,nb.nortran_value\n  from nortran nb\n   where nb.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' \n  ) n2,  /*Begin Personnnel Date*/ \n  (select ns.nortran_transaction_no,ns.nortran_apty_code,ns.nortran_aufd_code,ns.nortran_value\n  from nortran ns\n   where ns.nortran_aufd_code = 'NBRJOBS_SGRP_CODE'\n   ) n3, /* Salary Group */\n  (select na.nortran_transaction_no,na.nortran_apty_code,na.nortran_aufd_code,na.nortran_value\n  from nortran na\n   where na.nortran_aufd_code = 'NBRJOBS_APPT_PCT'\n  ) n4, /*Appointment Percent*/ \n  (select nu.nortran_transaction_no,nu.nortran_apty_code,nu.nortran_aufd_code,nu.nortran_value\n  from nortran nu\n   where nu.nortran_aufd_code = 'NBRJOBS_ANN_SALARY'\n  ) n5, /*Annual Salary*/\n  (select nj.nortran_transaction_no,nj.nortran_apty_code,nj.nortran_aufd_code,nj.nortran_value\n  from nortran nj\n   where nj.nortran_aufd_code = 'NBRJOBS_EFFECTIVE_DATE'  \n  and nj.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n6,  /*End Job Effective Date*/\n  (select np.nortran_transaction_no,np.nortran_apty_code,np.nortran_aufd_code,np.nortran_value\n  from nortran np\n   where np.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE'  \n  and np.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n7,  /*End Personnel Date*/\n\n  (select t.nortern_transaction_no,t.nortern_effective_date,t.nortern_earn_code,\n   t.nortern_hrs, t.nortern_special_rate\n  from nortern t) t1 \n\n   ,(select unique zz.nortran_transaction_no,zz.nortran_posn\n  from nortran zz\n   where zz.nortran_posn is not null\n  ) z\n\n where b.nobtran_acat_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') /*employee*/\n  /*waiting,completed,partially completedc,ancelled,supperuser update */\n  /* and nobtran_trans_status_ind in ('W','C','T','U') */\n   and b.nobtran_pidm = s.spriden_pidm\n   and s.spriden_change_ind is null\n   \n   and b.nobtran_transaction_no = t1.nortern_transaction_no(+) /*Pay Data*/\n   \n   and b.nobtran_transaction_no = n1.nortran_transaction_no(+) /*Current Hire Date*/\n   \n   and b.nobtran_transaction_no = n2.nortran_transaction_no(+) /*Begin Personnnel Date*/\n   \n   and b.nobtran_transaction_no = n3.nortran_transaction_no(+) /*Salary Group*/\n   \n   and b.nobtran_transaction_no = n4.nortran_transaction_no(+) /*Appointment Percent*/\n   \n   and b.nobtran_transaction_no = n5.nortran_transaction_no(+) /*Annual Salary*/\n   \n   and b.nobtran_transaction_no = n6.nortran_transaction_no(+) /*End Job Effective Date*/\n   \n   and b.nobtran_transaction_no = n7.nortran_transaction_no(+) /*End Personnel Date*/\n   \n   and nobtran_transaction_no = r.norrout_transaction_no(+)\n   --get all queue status\n   /*and r.norrout_queue_status_ind = 'A'*/\n   and r.norrout_level_no = 90 /* Pending HR approval Queue */\n   -- not applied yet\n   and b.nobtran_apply_ind = 'N' /*Applied ePAFs will not be listed*/\n   --HR does not care about voided ePAFs\n   and nobtran_trans_status_ind <> 'V'\n   --get posn\n   and b.nobtran_transaction_no = z.nortran_transaction_no\n   and r.norrout_queue_status_ind <> 'A'\n  -- exclude student\n   and s.spriden_pidm = pp.pebempl_pidm\n   and pp.pebempl_ecls_code not in ('RE','FW','GS','MW')\n\n   order by 3\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH nt AS (SELECT nortran_transaction_no, MAX(CASE WHEN nortran_aufd_code='PEBEMPL_CURRENT_HIRE_DATE' THEN nortran_value END) n1_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_PERS_CHG_DATE' THEN nortran_value END) n2_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_SGRP_CODE' THEN nortran_value END) n3_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_APPT_PCT' THEN nortran_value END) n4_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_ANN_SALARY' THEN nortran_value END) n5_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_EFFECTIVE_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) n6_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_PERS_CHG_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) n7_val, MAX(CASE WHEN nortran_posn IS NOT NULL THEN nortran_posn END) z_posn FROM nortran GROUP BY nortran_transaction_no) SELECT s.spriden_id EID, s.spriden_last_name||', '||s.spriden_first_name \"NAME\", b.nobtran_transaction_no \"TRANS NO.\", nt.z_posn \"POSN NO\", b.nobtran_effective_date \"QUERY DATE\", b.nobtran_acat_code \"ACAT CODE\", nt.n1_val \"CURRENT HIRE DATE\", nt.n2_val \"BEGIN PERSONNEL DATE\", nt.n3_val \"SALARY GROUP\", nt.n4_val \"APPOINTMENT PERCENT\", nt.n5_val \"ANNUAL SALARY\", t1.nortern_effective_date \"PAY DATA EFFECTIVE DATE\", t1.nortern_earn_code \"PAY DATA EARNINGS\", t1.nortern_hrs \"PAY DATA HOURS\", t1.nortern_special_rate \"PAY DATA SPECIAL RATE\", nt.n6_val \"END JOB EFFECTIVE DATE\", nt.n7_val \"END PERSONNEL DATE\", CASE b.nobtran_trans_status_ind WHEN 'A' THEN 'Approved' WHEN 'C' THEN 'Completed' WHEN 'V' THEN 'Voided' WHEN 'D' THEN 'Disapproved' WHEN 'R' THEN 'Return for Correction' WHEN 'P' THEN 'Pending' WHEN 'W' THEN 'Waiting' WHEN 'T' THEN 'Partially Completed' WHEN 'N' THEN 'Cancelled' WHEN 'U' THEN 'Superuser Update' END trans_status, CASE r.norrout_queue_status_ind WHEN 'A' THEN 'Approved by that Approver' WHEN 'D' THEN 'Disapproved' WHEN 'F' THEN 'FYI' WHEN 'I' THEN 'In Queue' WHEN 'K' THEN 'Acknowledged' WHEN 'L' THEN 'Applied by Applier' WHEN 'M' THEN 'More Information' WHEN 'O' THEN 'Overridden' WHEN 'P' THEN 'Pending Action by Approver/Applier' WHEN 'Q' THEN 'Removed from Queue' WHEN 'R' THEN 'Return for Correction' END queue_status, r.norrout_level_no FROM nobtran b INNER JOIN spriden s ON b.nobtran_pidm=s.spriden_pidm AND s.spriden_change_ind IS NULL INNER JOIN pebempl pp ON s.spriden_pidm=pp.pebempl_pidm AND pp.pebempl_ecls_code NOT IN ('RE','FW','GS','MW') INNER JOIN nt ON b.nobtran_transaction_no=nt.nortran_transaction_no LEFT OUTER JOIN nortern t1 ON b.nobtran_transaction_no=t1.nortern_transaction_no LEFT OUTER JOIN norrout r ON b.nobtran_transaction_no=r.norrout_transaction_no AND r.norrout_level_no=90 WHERE b.nobtran_acat_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') AND b.nobtran_apply_ind='N' AND b.nobtran_trans_status_ind<>'V' AND (r.norrout_queue_status_ind IS NULL OR r.norrout_queue_status_ind<>'A') ORDER BY 3"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "30",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"30\", \"db_type\": \"oracle\", \"description\": \"此改写的核心是将原SQL中针对nortran表的7个独立子查询(n1-n7)和1个去重子查询(z)通过CTE的GROUP BY + MAX + CASE WHEN技术合并。原SQL中每个子查询都有WHERE条件过滤不同的nortran_aufd_code，改写后通过CASE WHEN在单次扫描中同时提取所有需要的字段值，然后用MAX聚合选择每个transaction的值。这种行列转换技术将EAV(Entity-Attribute-Value)模型的多行数据透视为宽表的单行数据。同时，将nobtran的过滤条件前置，减少JOIN时的数据量。这种改写方式在OLAP场景中常用于优化维度属性的多次JOIN。\", \"create_table_statements\": [\"CREATE SEQUENCE nobtran_seq; CREATE TABLE nobtran (nobtran_id NUMBER PRIMARY KEY, nobtran_transaction_no NUMBER NOT NULL, nobtran_acat_code VARCHAR2(20), nobtran_effective_date DATE, nobtran_trans_status_ind VARCHAR2(1), nobtran_pidm NUMBER NOT NULL, nobtran_apply_ind VARCHAR2(1) DEFAULT 'N'); CREATE OR REPLACE TRIGGER nobtran_bi BEFORE INSERT ON nobtran FOR EACH ROW BEGIN IF :NEW.nobtran_id IS NULL THEN SELECT nobtran_seq.NEXTVAL INTO :NEW.nobtran_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nobtran_acat_code ON nobtran(nobtran_acat_code);\", \"CREATE INDEX idx_nobtran_pidm ON nobtran(nobtran_pidm);\", \"CREATE INDEX idx_nobtran_transaction_no ON nobtran(nobtran_transaction_no);\", \"CREATE INDEX idx_nobtran_status ON nobtran(nobtran_trans_status_ind);\", \"CREATE INDEX idx_nobtran_apply_ind ON nobtran(nobtran_apply_ind);\", \"CREATE SEQUENCE spriden_seq; CREATE TABLE spriden (spriden_pidm NUMBER PRIMARY KEY, spriden_id VARCHAR2(50) NOT NULL, spriden_last_name VARCHAR2(100) NOT NULL, spriden_first_name VARCHAR2(100), spriden_change_ind VARCHAR2(1)); CREATE OR REPLACE TRIGGER spriden_bi BEFORE INSERT ON spriden FOR EACH ROW BEGIN IF :NEW.spriden_pidm IS NULL THEN SELECT spriden_seq.NEXTVAL INTO :NEW.spriden_pidm FROM DUAL; END IF; END;\", \"CREATE INDEX idx_spriden_change_ind ON spriden(spriden_change_ind);\", \"CREATE SEQUENCE norrout_seq; CREATE TABLE norrout (norrout_id NUMBER PRIMARY KEY, norrout_transaction_no NUMBER NOT NULL, norrout_queue_status_ind VARCHAR2(1), norrout_level_no NUMBER); CREATE OR REPLACE TRIGGER norrout_bi BEFORE INSERT ON norrout FOR EACH ROW BEGIN IF :NEW.norrout_id IS NULL THEN SELECT norrout_seq.NEXTVAL INTO :NEW.norrout_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_norrout_transaction_no ON norrout(norrout_transaction_no);\", \"CREATE INDEX idx_norrout_level_no ON norrout(norrout_level_no);\", \"CREATE INDEX idx_norrout_queue_status ON norrout(norrout_queue_status_ind);\", \"CREATE SEQUENCE pebempl_seq; CREATE TABLE pebempl (pebempl_pidm NUMBER PRIMARY KEY, pebempl_ecls_code VARCHAR2(10) NOT NULL, pebempl_current_hire_date DATE); CREATE OR REPLACE TRIGGER pebempl_bi BEFORE INSERT ON pebempl FOR EACH ROW BEGIN IF :NEW.pebempl_pidm IS NULL THEN SELECT pebempl_seq.NEXTVAL INTO :NEW.pebempl_pidm FROM DUAL; END IF; END;\", \"CREATE INDEX idx_pebempl_ecls_code ON pebempl(pebempl_ecls_code);\", \"CREATE SEQUENCE nortran_seq; CREATE TABLE nortran (nortran_id NUMBER PRIMARY KEY, nortran_transaction_no NUMBER NOT NULL, nortran_apty_code VARCHAR2(20), nortran_aufd_code VARCHAR2(50) NOT NULL, nortran_value VARCHAR2(200), nortran_posn VARCHAR2(50)); CREATE OR REPLACE TRIGGER nortran_bi BEFORE INSERT ON nortran FOR EACH ROW BEGIN IF :NEW.nortran_id IS NULL THEN SELECT nortran_seq.NEXTVAL INTO :NEW.nortran_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nortran_transaction_no ON nortran(nortran_transaction_no);\", \"CREATE INDEX idx_nortran_aufd_code ON nortran(nortran_aufd_code);\", \"CREATE INDEX idx_nortran_apty_code ON nortran(nortran_apty_code);\", \"CREATE SEQUENCE nortern_seq; CREATE TABLE nortern (nortern_id NUMBER PRIMARY KEY, nortern_transaction_no NUMBER NOT NULL, nortern_effective_date DATE, nortern_earn_code VARCHAR2(20), nortern_hrs NUMBER(10,2), nortern_special_rate NUMBER(15,2)); CREATE OR REPLACE TRIGGER nortern_bi BEFORE INSERT ON nortern FOR EACH ROW BEGIN IF :NEW.nortern_id IS NULL THEN SELECT nortern_seq.NEXTVAL INTO :NEW.nortern_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nortern_transaction_no ON nortern(nortern_transaction_no);\"], \"sql\": \"select s.spriden_id EID,\\n  s.spriden_last_name ||', '||s.spriden_first_name \\\"NAME\\\",\\n  b.nobtran_transaction_no \\\"TRANS NO.\\\",\\n  z.nortran_posn \\\"POSN NO\\\",\\n  b.nobtran_effective_date \\\"QUERY DATE\\\", \\n  b.nobtran_acat_code \\\"ACAT CODE\\\",\\n  n1.nortran_value \\\"CURRENT HIRE DATE\\\",\\n  n2.nortran_value \\\"BEGIN PERSONNEL DATE\\\",\\n  n3.nortran_value \\\"SALARY GROUP\\\",\\n  n4.nortran_value \\\"APPOINTMENT PERCENT\\\",\\n  n5.nortran_value \\\"ANNUAL SALARY\\\",\\n  t1.nortern_effective_date \\\"PAY DATA EFFECTIVE DATE\\\",\\n  t1.nortern_earn_code \\\"PAY DATA EARNINGS\\\",\\n  t1.nortern_hrs \\\"PAY DATA HOURS\\\",\\n  t1.nortern_special_rate \\\"PAY DATA SPECIAL RATE\\\",\\n  n6.nortran_value \\\"END JOB EFFECTIVE DATE\\\",\\n  n7.nortran_value \\\"END PERSONNEL DATE\\\"\\n   ,case b.nobtran_trans_status_ind\\n   when 'A' then 'Approved'\\n   when 'C' then 'Completed'\\n   when 'V' then 'Voided' \\n   when 'D' then 'Disapproved'\\n   when 'R' then 'Return for Correction'\\n   when 'P' then 'Pending'\\n   when 'W' then 'Waiting'\\n   when 'T' then 'Partially Completed'\\n   when 'N' then 'Cancelled'\\n   when 'U' then 'Superuser Update'\\n  end trans_status   \\n  ,case r.norrout_queue_status_ind\\n   when 'A' then 'Approved by that Approver'\\n   when 'D' then 'Disapproved'\\n   when 'F' then 'FYI'\\n   when 'I' then 'In Queue'\\n   when 'K' then 'Acknowledged'\\n   when 'L' then 'Applied by Applier'\\n   when 'M' then 'More Information'\\n   when 'O' then 'Overridden'\\n   when 'P' then 'Pending Action by Approver/Applier '\\n   when 'Q' then 'Removed from Queue'\\n   when 'R' then 'Return for Correction'\\n  end queue_status\\n  ,r.norrout_level_no\\n  \\n\\n  from nobtran b,spriden s, norrout r, pebempl pp, /*nbrjobs nbr,*/\\n  (select nc.nortran_transaction_no,nc.nortran_apty_code,nc.nortran_aufd_code,nc.nortran_value\\n  from nortran nc\\n   where nc.nortran_aufd_code = 'PEBEMPL_CURRENT_HIRE_DATE'\\n  ) n1, /* Current Hire Date */\\n  (select nb.nortran_transaction_no,nb.nortran_apty_code,nb.nortran_aufd_code,nb.nortran_value\\n  from nortran nb\\n   where nb.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' \\n  ) n2,  /*Begin Personnnel Date*/ \\n  (select ns.nortran_transaction_no,ns.nortran_apty_code,ns.nortran_aufd_code,ns.nortran_value\\n  from nortran ns\\n   where ns.nortran_aufd_code = 'NBRJOBS_SGRP_CODE'\\n   ) n3, /* Salary Group */\\n  (select na.nortran_transaction_no,na.nortran_apty_code,na.nortran_aufd_code,na.nortran_value\\n  from nortran na\\n   where na.nortran_aufd_code = 'NBRJOBS_APPT_PCT'\\n  ) n4, /*Appointment Percent*/ \\n  (select nu.nortran_transaction_no,nu.nortran_apty_code,nu.nortran_aufd_code,nu.nortran_value\\n  from nortran nu\\n   where nu.nortran_aufd_code = 'NBRJOBS_ANN_SALARY'\\n  ) n5, /*Annual Salary*/\\n  (select nj.nortran_transaction_no,nj.nortran_apty_code,nj.nortran_aufd_code,nj.nortran_value\\n  from nortran nj\\n   where nj.nortran_aufd_code = 'NBRJOBS_EFFECTIVE_DATE'  \\n  and nj.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n6,  /*End Job Effective Date*/\\n  (select np.nortran_transaction_no,np.nortran_apty_code,np.nortran_aufd_code,np.nortran_value\\n  from nortran np\\n   where np.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE'  \\n  and np.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n7,  /*End Personnel Date*/\\n\\n  (select t.nortern_transaction_no,t.nortern_effective_date,t.nortern_earn_code,\\n   t.nortern_hrs, t.nortern_special_rate\\n  from nortern t) t1 \\n\\n   ,(select unique zz.nortran_transaction_no,zz.nortran_posn\\n  from nortran zz\\n   where zz.nortran_posn is not null\\n  ) z\\n\\n where b.nobtran_acat_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') /*employee*/\\n  /*waiting,completed,partially completedc,ancelled,supperuser update */\\n  /* and nobtran_trans_status_ind in ('W','C','T','U') */\\n   and b.nobtran_pidm = s.spriden_pidm\\n   and s.spriden_change_ind is null\\n   \\n   and b.nobtran_transaction_no = t1.nortern_transaction_no(+) /*Pay Data*/\\n   \\n   and b.nobtran_transaction_no = n1.nortran_transaction_no(+) /*Current Hire Date*/\\n   \\n   and b.nobtran_transaction_no = n2.nortran_transaction_no(+) /*Begin Personnnel Date*/\\n   \\n   and b.nobtran_transaction_no = n3.nortran_transaction_no(+) /*Salary Group*/\\n   \\n   and b.nobtran_transaction_no = n4.nortran_transaction_no(+) /*Appointment Percent*/\\n   \\n   and b.nobtran_transaction_no = n5.nortran_transaction_no(+) /*Annual Salary*/\\n   \\n   and b.nobtran_transaction_no = n6.nortran_transaction_no(+) /*End Job Effective Date*/\\n   \\n   and b.nobtran_transaction_no = n7.nortran_transaction_no(+) /*End Personnel Date*/\\n   \\n   and nobtran_transaction_no = r.norrout_transaction_no(+)\\n   --get all queue status\\n   /*and r.norrout_queue_status_ind = 'A'*/\\n   and r.norrout_level_no = 90 /* Pending HR approval Queue */\\n   -- not applied yet\\n   and b.nobtran_apply_ind = 'N' /*Applied ePAFs will not be listed*/\\n   --HR does not care about voided ePAFs\\n   and nobtran_trans_status_ind <> 'V'\\n   --get posn\\n   and b.nobtran_transaction_no = z.nortran_transaction_no\\n   and r.norrout_queue_status_ind <> 'A'\\n  -- exclude student\\n   and s.spriden_pidm = pp.pebempl_pidm\\n   and pp.pebempl_ecls_code not in ('RE','FW','GS','MW')\\n\\n   order by 3\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t68442\\t220696\\t81657520\\t10388402242\\t68160\\n1\\t  MERGE JOIN OUTER \\t68442\\t220696\\t81657520\\t10388402242\\t68160\\n2\\t  MERGE JOIN  \\t61068\\t220696\\t77243600\\t9073000336\\t60822\\n3\\t   MERGE JOIN OUTER \\t59624\\t1072825\\t366906150\\t8593654179\\t59391\\n4\\t  MERGE JOIN  \\t55673\\t1000048\\t302014496\\t8042006798\\t55455\\n5\\t  MERGE JOIN OUTER \\t40155\\t875042\\t236261340\\t5632420040\\t40002\\n6\\t   MERGE JOIN OUTER \\t36204\\t815681\\t187606630\\t5082114259\\t36066\\n7\\t  MERGE JOIN OUTER \\t32442\\t760347\\t149028012\\t4563228883\\t32318\\n8\\t  MERGE JOIN OUTER \\t28680\\t708767\\t114820254\\t4044718907\\t28570\\n9\\t   MERGE JOIN OUTER \\t24918\\t660686\\t84567808\\t3526558831\\t24822\\n10\\t  MERGE JOIN OUTER \\t21156\\t615866\\t57891404\\t3008724855\\t21074\\n11\\t  SORT JOIN \\t17394\\t574088\\t34445280\\t2491195079\\t17326\\n12\\t   HASH JOIN  \\t9138\\t574088\\t34445280\\t1827947896\\t9088\\n13\\t  HASH JOIN  \\t4697\\t656100\\t23619600\\t973767459\\t4671\\n14\\t  TABLE ACCESS FULL PEBEMPL\\t794\\t656100\\t3936600\\t362530962\\t784\\n15\\t  TABLE ACCESS FULL SPRIDEN\\t1351\\t1000000\\t30000000\\t285272492\\t1343\\n16\\t  TABLE ACCESS FULL NOBTRAN\\t1454\\t875000\\t21000000\\t548613482\\t1439\\n17\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n18\\t   TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n19\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n20\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n21\\t   SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n22\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n23\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n24\\t   TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n25\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n26\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n27\\t   SORT JOIN \\t3951\\t166667\\t6666680\\t544369681\\t3936\\n28\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t6666680\\t350105675\\t2236\\n29\\t  SORT JOIN \\t15518\\t1000000\\t32000000\\t2409581958\\t15453\\n30\\t   VIEW  \\t6805\\t1000000\\t32000000\\t1336011571\\t6769\\n31\\t  HASH UNIQUE \\t6805\\t1000000\\t12000000\\t1336011571\\t6769\\n32\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t1000000\\t12000000\\t328759001\\t2236\\n33\\t  SORT JOIN \\t3951\\t166667\\t6666680\\t544369681\\t3936\\n34\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t6666680\\t350105675\\t2236\\n35\\t   SORT JOIN \\t1444\\t180000\\t1440000\\t479346156\\t1431\\n36\\t  TABLE ACCESS FULL NORROUT\\t792\\t180000\\t1440000\\t290580962\\t784\\n37\\t  SORT JOIN \\t7374\\t1000000\\t20000000\\t1315401906\\t7338\\n38\\t   TABLE ACCESS FULL NORTERN\\t1304\\t1000000\\t20000000\\t284040483\\t1296\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推优化，消除了n1-n7子查询中的冗余字段(nortran_apty_code,nortran_aufd_code)，保留了核心事务ID和价值字段。减少了63%（7个子查询×2个字段）的数据传输量，显著降低磁盘I/O和内存占用\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推对主表b创建内联视图，提前应用高选择性过滤条件(nobtran_acat_code,nobtran_apply_ind,nobtran_trans_status_ind)，将数据过滤从连接后提前到数据源头。预估在弱优化器数据库(如MySQL 5.x)可提升20-50%性能，智能优化器数据库可提升5-15%。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"Merge Multiple Independent Subqueries Scanning Same Table,将原始SQL中7次独立的nortran表扫描合并为一个CTE，使用条件聚合在单次扫描中计算所有字段。通过内连接替代原始内连接（z子查询）和左外连接（n1~n7子查询），消除重复I/O开销。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE nobtran_seq; CREATE TABLE nobtran (nobtran_id NUMBER PRIMARY KEY, nobtran_transaction_no NUMBER NOT NULL, nobtran_acat_code VARCHAR2(20), nobtran_effective_date DATE, nobtran_trans_status_ind VARCHAR2(1), nobtran_pidm NUMBER NOT NULL, nobtran_apply_ind VARCHAR2(1) DEFAULT 'N'); CREATE OR REPLACE TRIGGER nobtran_bi BEFORE INSERT ON nobtran FOR EACH ROW BEGIN IF :NEW.nobtran_id IS NULL THEN SELECT nobtran_seq.NEXTVAL INTO :NEW.nobtran_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nobtran_acat_code ON nobtran(nobtran_acat_code);\nCREATE INDEX idx_nobtran_pidm ON nobtran(nobtran_pidm);\nCREATE INDEX idx_nobtran_transaction_no ON nobtran(nobtran_transaction_no);\nCREATE INDEX idx_nobtran_status ON nobtran(nobtran_trans_status_ind);\nCREATE INDEX idx_nobtran_apply_ind ON nobtran(nobtran_apply_ind);\nCREATE SEQUENCE spriden_seq; CREATE TABLE spriden (spriden_pidm NUMBER PRIMARY KEY, spriden_id VARCHAR2(50) NOT NULL, spriden_last_name VARCHAR2(100) NOT NULL, spriden_first_name VARCHAR2(100), spriden_change_ind VARCHAR2(1)); CREATE OR REPLACE TRIGGER spriden_bi BEFORE INSERT ON spriden FOR EACH ROW BEGIN IF :NEW.spriden_pidm IS NULL THEN SELECT spriden_seq.NEXTVAL INTO :NEW.spriden_pidm FROM DUAL; END IF; END;\nCREATE INDEX idx_spriden_change_ind ON spriden(spriden_change_ind);\nCREATE SEQUENCE norrout_seq; CREATE TABLE norrout (norrout_id NUMBER PRIMARY KEY, norrout_transaction_no NUMBER NOT NULL, norrout_queue_status_ind VARCHAR2(1), norrout_level_no NUMBER); CREATE OR REPLACE TRIGGER norrout_bi BEFORE INSERT ON norrout FOR EACH ROW BEGIN IF :NEW.norrout_id IS NULL THEN SELECT norrout_seq.NEXTVAL INTO :NEW.norrout_id FROM DUAL; END IF; END;\nCREATE INDEX idx_norrout_transaction_no ON norrout(norrout_transaction_no);\nCREATE INDEX idx_norrout_level_no ON norrout(norrout_level_no);\nCREATE INDEX idx_norrout_queue_status ON norrout(norrout_queue_status_ind);\nCREATE SEQUENCE pebempl_seq; CREATE TABLE pebempl (pebempl_pidm NUMBER PRIMARY KEY, pebempl_ecls_code VARCHAR2(10) NOT NULL, pebempl_current_hire_date DATE); CREATE OR REPLACE TRIGGER pebempl_bi BEFORE INSERT ON pebempl FOR EACH ROW BEGIN IF :NEW.pebempl_pidm IS NULL THEN SELECT pebempl_seq.NEXTVAL INTO :NEW.pebempl_pidm FROM DUAL; END IF; END;\nCREATE INDEX idx_pebempl_ecls_code ON pebempl(pebempl_ecls_code);\nCREATE SEQUENCE nortran_seq; CREATE TABLE nortran (nortran_id NUMBER PRIMARY KEY, nortran_transaction_no NUMBER NOT NULL, nortran_apty_code VARCHAR2(20), nortran_aufd_code VARCHAR2(50) NOT NULL, nortran_value VARCHAR2(200), nortran_posn VARCHAR2(50)); CREATE OR REPLACE TRIGGER nortran_bi BEFORE INSERT ON nortran FOR EACH ROW BEGIN IF :NEW.nortran_id IS NULL THEN SELECT nortran_seq.NEXTVAL INTO :NEW.nortran_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nortran_transaction_no ON nortran(nortran_transaction_no);\nCREATE INDEX idx_nortran_aufd_code ON nortran(nortran_aufd_code);\nCREATE INDEX idx_nortran_apty_code ON nortran(nortran_apty_code);\nCREATE SEQUENCE nortern_seq; CREATE TABLE nortern (nortern_id NUMBER PRIMARY KEY, nortern_transaction_no NUMBER NOT NULL, nortern_effective_date DATE, nortern_earn_code VARCHAR2(20), nortern_hrs NUMBER(10,2), nortern_special_rate NUMBER(15,2)); CREATE OR REPLACE TRIGGER nortern_bi BEFORE INSERT ON nortern FOR EACH ROW BEGIN IF :NEW.nortern_id IS NULL THEN SELECT nortern_seq.NEXTVAL INTO :NEW.nortern_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nortern_transaction_no ON nortern(nortern_transaction_no);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t68442\t220696\t81657520\t10388402242\t68160\n1\t  MERGE JOIN OUTER \t68442\t220696\t81657520\t10388402242\t68160\n2\t  MERGE JOIN  \t61068\t220696\t77243600\t9073000336\t60822\n3\t   MERGE JOIN OUTER \t59624\t1072825\t366906150\t8593654179\t59391\n4\t  MERGE JOIN  \t55673\t1000048\t302014496\t8042006798\t55455\n5\t  MERGE JOIN OUTER \t40155\t875042\t236261340\t5632420040\t40002\n6\t   MERGE JOIN OUTER \t36204\t815681\t187606630\t5082114259\t36066\n7\t  MERGE JOIN OUTER \t32442\t760347\t149028012\t4563228883\t32318\n8\t  MERGE JOIN OUTER \t28680\t708767\t114820254\t4044718907\t28570\n9\t   MERGE JOIN OUTER \t24918\t660686\t84567808\t3526558831\t24822\n10\t  MERGE JOIN OUTER \t21156\t615866\t57891404\t3008724855\t21074\n11\t  SORT JOIN \t17394\t574088\t34445280\t2491195079\t17326\n12\t   HASH JOIN  \t9138\t574088\t34445280\t1827947896\t9088\n13\t  HASH JOIN  \t4697\t656100\t23619600\t973767459\t4671\n14\t  TABLE ACCESS FULL PEBEMPL\t794\t656100\t3936600\t362530962\t784\n15\t  TABLE ACCESS FULL SPRIDEN\t1351\t1000000\t30000000\t285272492\t1343\n16\t  TABLE ACCESS FULL NOBTRAN\t1454\t875000\t21000000\t548613482\t1439\n17\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n18\t   TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n19\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n20\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n21\t   SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n22\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n23\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n24\t   TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n25\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n26\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n27\t   SORT JOIN \t3951\t166667\t6666680\t544369681\t3936\n28\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t6666680\t350105675\t2236\n29\t  SORT JOIN \t15518\t1000000\t32000000\t2409581958\t15453\n30\t   VIEW  \t6805\t1000000\t32000000\t1336011571\t6769\n31\t  HASH UNIQUE \t6805\t1000000\t12000000\t1336011571\t6769\n32\t  TABLE ACCESS FULL NORTRAN\t2245\t1000000\t12000000\t328759001\t2236\n33\t  SORT JOIN \t3951\t166667\t6666680\t544369681\t3936\n34\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t6666680\t350105675\t2236\n35\t   SORT JOIN \t1444\t180000\t1440000\t479346156\t1431\n36\t  TABLE ACCESS FULL NORROUT\t792\t180000\t1440000\t290580962\t784\n37\t  SORT JOIN \t7374\t1000000\t20000000\t1315401906\t7338\n38\t   TABLE ACCESS FULL NORTERN\t1304\t1000000\t20000000\t284040483\t1296\n\n## Original SQL:\nselect s.spriden_id EID,\n  s.spriden_last_name ||', '||s.spriden_first_name \"NAME\",\n  b.nobtran_transaction_no \"TRANS NO.\",\n  z.nortran_posn \"POSN NO\",\n  b.nobtran_effective_date \"QUERY DATE\", \n  b.nobtran_acat_code \"ACAT CODE\",\n  n1.nortran_value \"CURRENT HIRE DATE\",\n  n2.nortran_value \"BEGIN PERSONNEL DATE\",\n  n3.nortran_value \"SALARY GROUP\",\n  n4.nortran_value \"APPOINTMENT PERCENT\",\n  n5.nortran_value \"ANNUAL SALARY\",\n  t1.nortern_effective_date \"PAY DATA EFFECTIVE DATE\",\n  t1.nortern_earn_code \"PAY DATA EARNINGS\",\n  t1.nortern_hrs \"PAY DATA HOURS\",\n  t1.nortern_special_rate \"PAY DATA SPECIAL RATE\",\n  n6.nortran_value \"END JOB EFFECTIVE DATE\",\n  n7.nortran_value \"END PERSONNEL DATE\"\n   ,case b.nobtran_trans_status_ind\n   when 'A' then 'Approved'\n   when 'C' then 'Completed'\n   when 'V' then 'Voided' \n   when 'D' then 'Disapproved'\n   when 'R' then 'Return for Correction'\n   when 'P' then 'Pending'\n   when 'W' then 'Waiting'\n   when 'T' then 'Partially Completed'\n   when 'N' then 'Cancelled'\n   when 'U' then 'Superuser Update'\n  end trans_status   \n  ,case r.norrout_queue_status_ind\n   when 'A' then 'Approved by that Approver'\n   when 'D' then 'Disapproved'\n   when 'F' then 'FYI'\n   when 'I' then 'In Queue'\n   when 'K' then 'Acknowledged'\n   when 'L' then 'Applied by Applier'\n   when 'M' then 'More Information'\n   when 'O' then 'Overridden'\n   when 'P' then 'Pending Action by Approver/Applier '\n   when 'Q' then 'Removed from Queue'\n   when 'R' then 'Return for Correction'\n  end queue_status\n  ,r.norrout_level_no\n  \n\n  from nobtran b,spriden s, norrout r, pebempl pp, /*nbrjobs nbr,*/\n  (select nc.nortran_transaction_no,nc.nortran_apty_code,nc.nortran_aufd_code,nc.nortran_value\n  from nortran nc\n   where nc.nortran_aufd_code = 'PEBEMPL_CURRENT_HIRE_DATE'\n  ) n1, /* Current Hire Date */\n  (select nb.nortran_transaction_no,nb.nortran_apty_code,nb.nortran_aufd_code,nb.nortran_value\n  from nortran nb\n   where nb.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' \n  ) n2,  /*Begin Personnnel Date*/ \n  (select ns.nortran_transaction_no,ns.nortran_apty_code,ns.nortran_aufd_code,ns.nortran_value\n  from nortran ns\n   where ns.nortran_aufd_code = 'NBRJOBS_SGRP_CODE'\n   ) n3, /* Salary Group */\n  (select na.nortran_transaction_no,na.nortran_apty_code,na.nortran_aufd_code,na.nortran_value\n  from nortran na\n   where na.nortran_aufd_code = 'NBRJOBS_APPT_PCT'\n  ) n4, /*Appointment Percent*/ \n  (select nu.nortran_transaction_no,nu.nortran_apty_code,nu.nortran_aufd_code,nu.nortran_value\n  from nortran nu\n   where nu.nortran_aufd_code = 'NBRJOBS_ANN_SALARY'\n  ) n5, /*Annual Salary*/\n  (select nj.nortran_transaction_no,nj.nortran_apty_code,nj.nortran_aufd_code,nj.nortran_value\n  from nortran nj\n   where nj.nortran_aufd_code = 'NBRJOBS_EFFECTIVE_DATE'  \n  and nj.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n6,  /*End Job Effective Date*/\n  (select np.nortran_transaction_no,np.nortran_apty_code,np.nortran_aufd_code,np.nortran_value\n  from nortran np\n   where np.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE'  \n  and np.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n7,  /*End Personnel Date*/\n\n  (select t.nortern_transaction_no,t.nortern_effective_date,t.nortern_earn_code,\n   t.nortern_hrs, t.nortern_special_rate\n  from nortern t) t1 \n\n   ,(select unique zz.nortran_transaction_no,zz.nortran_posn\n  from nortran zz\n   where zz.nortran_posn is not null\n  ) z\n\n where b.nobtran_acat_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') /*employee*/\n  /*waiting,completed,partially completedc,ancelled,supperuser update */\n  /* and nobtran_trans_status_ind in ('W','C','T','U') */\n   and b.nobtran_pidm = s.spriden_pidm\n   and s.spriden_change_ind is null\n   \n   and b.nobtran_transaction_no = t1.nortern_transaction_no(+) /*Pay Data*/\n   \n   and b.nobtran_transaction_no = n1.nortran_transaction_no(+) /*Current Hire Date*/\n   \n   and b.nobtran_transaction_no = n2.nortran_transaction_no(+) /*Begin Personnnel Date*/\n   \n   and b.nobtran_transaction_no = n3.nortran_transaction_no(+) /*Salary Group*/\n   \n   and b.nobtran_transaction_no = n4.nortran_transaction_no(+) /*Appointment Percent*/\n   \n   and b.nobtran_transaction_no = n5.nortran_transaction_no(+) /*Annual Salary*/\n   \n   and b.nobtran_transaction_no = n6.nortran_transaction_no(+) /*End Job Effective Date*/\n   \n   and b.nobtran_transaction_no = n7.nortran_transaction_no(+) /*End Personnel Date*/\n   \n   and nobtran_transaction_no = r.norrout_transaction_no(+)\n   --get all queue status\n   /*and r.norrout_queue_status_ind = 'A'*/\n   and r.norrout_level_no = 90 /* Pending HR approval Queue */\n   -- not applied yet\n   and b.nobtran_apply_ind = 'N' /*Applied ePAFs will not be listed*/\n   --HR does not care about voided ePAFs\n   and nobtran_trans_status_ind <> 'V'\n   --get posn\n   and b.nobtran_transaction_no = z.nortran_transaction_no\n   and r.norrout_queue_status_ind <> 'A'\n  -- exclude student\n   and s.spriden_pidm = pp.pebempl_pidm\n   and pp.pebempl_ecls_code not in ('RE','FW','GS','MW')\n\n   order by 3\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH nt AS (SELECT nortran_transaction_no, MAX(CASE WHEN nortran_aufd_code='PEBEMPL_CURRENT_HIRE_DATE' THEN nortran_value END) n1_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_PERS_CHG_DATE' THEN nortran_value END) n2_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_SGRP_CODE' THEN nortran_value END) n3_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_APPT_PCT' THEN nortran_value END) n4_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_ANN_SALARY' THEN nortran_value END) n5_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_EFFECTIVE_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) n6_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_PERS_CHG_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) n7_val, MAX(CASE WHEN nortran_posn IS NOT NULL THEN nortran_posn END) z_posn FROM nortran GROUP BY nortran_transaction_no) SELECT s.spriden_id EID, s.spriden_last_name||', '||s.spriden_first_name \"NAME\", b.nobtran_transaction_no \"TRANS NO.\", nt.z_posn \"POSN NO\", b.nobtran_effective_date \"QUERY DATE\", b.nobtran_acat_code \"ACAT CODE\", nt.n1_val \"CURRENT HIRE DATE\", nt.n2_val \"BEGIN PERSONNEL DATE\", nt.n3_val \"SALARY GROUP\", nt.n4_val \"APPOINTMENT PERCENT\", nt.n5_val \"ANNUAL SALARY\", t1.nortern_effective_date \"PAY DATA EFFECTIVE DATE\", t1.nortern_earn_code \"PAY DATA EARNINGS\", t1.nortern_hrs \"PAY DATA HOURS\", t1.nortern_special_rate \"PAY DATA SPECIAL RATE\", nt.n6_val \"END JOB EFFECTIVE DATE\", nt.n7_val \"END PERSONNEL DATE\", CASE b.nobtran_trans_status_ind WHEN 'A' THEN 'Approved' WHEN 'C' THEN 'Completed' WHEN 'V' THEN 'Voided' WHEN 'D' THEN 'Disapproved' WHEN 'R' THEN 'Return for Correction' WHEN 'P' THEN 'Pending' WHEN 'W' THEN 'Waiting' WHEN 'T' THEN 'Partially Completed' WHEN 'N' THEN 'Cancelled' WHEN 'U' THEN 'Superuser Update' END trans_status, CASE r.norrout_queue_status_ind WHEN 'A' THEN 'Approved by that Approver' WHEN 'D' THEN 'Disapproved' WHEN 'F' THEN 'FYI' WHEN 'I' THEN 'In Queue' WHEN 'K' THEN 'Acknowledged' WHEN 'L' THEN 'Applied by Applier' WHEN 'M' THEN 'More Information' WHEN 'O' THEN 'Overridden' WHEN 'P' THEN 'Pending Action by Approver/Applier' WHEN 'Q' THEN 'Removed from Queue' WHEN 'R' THEN 'Return for Correction' END queue_status, r.norrout_level_no FROM nobtran b INNER JOIN spriden s ON b.nobtran_pidm=s.spriden_pidm AND s.spriden_change_ind IS NULL INNER JOIN pebempl pp ON s.spriden_pidm=pp.pebempl_pidm AND pp.pebempl_ecls_code NOT IN ('RE','FW','GS','MW') INNER JOIN nt ON b.nobtran_transaction_no=nt.nortran_transaction_no LEFT OUTER JOIN nortern t1 ON b.nobtran_transaction_no=t1.nortern_transaction_no LEFT OUTER JOIN norrout r ON b.nobtran_transaction_no=r.norrout_transaction_no AND r.norrout_level_no=90 WHERE b.nobtran_acat_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') AND b.nobtran_apply_ind='N' AND b.nobtran_trans_status_ind<>'V' AND (r.norrout_queue_status_ind IS NULL OR r.norrout_queue_status_ind<>'A') ORDER BY 3"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "30",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"30\", \"db_type\": \"oracle\", \"description\": \"此改写的核心是将原SQL中针对nortran表的7个独立子查询(n1-n7)和1个去重子查询(z)通过CTE的GROUP BY + MAX + CASE WHEN技术合并。原SQL中每个子查询都有WHERE条件过滤不同的nortran_aufd_code，改写后通过CASE WHEN在单次扫描中同时提取所有需要的字段值，然后用MAX聚合选择每个transaction的值。这种行列转换技术将EAV(Entity-Attribute-Value)模型的多行数据透视为宽表的单行数据。同时，将nobtran的过滤条件前置，减少JOIN时的数据量。这种改写方式在OLAP场景中常用于优化维度属性的多次JOIN。\", \"create_table_statements\": [\"CREATE SEQUENCE nobtran_seq; CREATE TABLE nobtran (nobtran_id NUMBER PRIMARY KEY, nobtran_transaction_no NUMBER NOT NULL, nobtran_acat_code VARCHAR2(20), nobtran_effective_date DATE, nobtran_trans_status_ind VARCHAR2(1), nobtran_pidm NUMBER NOT NULL, nobtran_apply_ind VARCHAR2(1) DEFAULT 'N'); CREATE OR REPLACE TRIGGER nobtran_bi BEFORE INSERT ON nobtran FOR EACH ROW BEGIN IF :NEW.nobtran_id IS NULL THEN SELECT nobtran_seq.NEXTVAL INTO :NEW.nobtran_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nobtran_acat_code ON nobtran(nobtran_acat_code);\", \"CREATE INDEX idx_nobtran_pidm ON nobtran(nobtran_pidm);\", \"CREATE INDEX idx_nobtran_transaction_no ON nobtran(nobtran_transaction_no);\", \"CREATE INDEX idx_nobtran_status ON nobtran(nobtran_trans_status_ind);\", \"CREATE INDEX idx_nobtran_apply_ind ON nobtran(nobtran_apply_ind);\", \"CREATE SEQUENCE spriden_seq; CREATE TABLE spriden (spriden_pidm NUMBER PRIMARY KEY, spriden_id VARCHAR2(50) NOT NULL, spriden_last_name VARCHAR2(100) NOT NULL, spriden_first_name VARCHAR2(100), spriden_change_ind VARCHAR2(1)); CREATE OR REPLACE TRIGGER spriden_bi BEFORE INSERT ON spriden FOR EACH ROW BEGIN IF :NEW.spriden_pidm IS NULL THEN SELECT spriden_seq.NEXTVAL INTO :NEW.spriden_pidm FROM DUAL; END IF; END;\", \"CREATE INDEX idx_spriden_change_ind ON spriden(spriden_change_ind);\", \"CREATE SEQUENCE norrout_seq; CREATE TABLE norrout (norrout_id NUMBER PRIMARY KEY, norrout_transaction_no NUMBER NOT NULL, norrout_queue_status_ind VARCHAR2(1), norrout_level_no NUMBER); CREATE OR REPLACE TRIGGER norrout_bi BEFORE INSERT ON norrout FOR EACH ROW BEGIN IF :NEW.norrout_id IS NULL THEN SELECT norrout_seq.NEXTVAL INTO :NEW.norrout_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_norrout_transaction_no ON norrout(norrout_transaction_no);\", \"CREATE INDEX idx_norrout_level_no ON norrout(norrout_level_no);\", \"CREATE INDEX idx_norrout_queue_status ON norrout(norrout_queue_status_ind);\", \"CREATE SEQUENCE pebempl_seq; CREATE TABLE pebempl (pebempl_pidm NUMBER PRIMARY KEY, pebempl_ecls_code VARCHAR2(10) NOT NULL, pebempl_current_hire_date DATE); CREATE OR REPLACE TRIGGER pebempl_bi BEFORE INSERT ON pebempl FOR EACH ROW BEGIN IF :NEW.pebempl_pidm IS NULL THEN SELECT pebempl_seq.NEXTVAL INTO :NEW.pebempl_pidm FROM DUAL; END IF; END;\", \"CREATE INDEX idx_pebempl_ecls_code ON pebempl(pebempl_ecls_code);\", \"CREATE SEQUENCE nortran_seq; CREATE TABLE nortran (nortran_id NUMBER PRIMARY KEY, nortran_transaction_no NUMBER NOT NULL, nortran_apty_code VARCHAR2(20), nortran_aufd_code VARCHAR2(50) NOT NULL, nortran_value VARCHAR2(200), nortran_posn VARCHAR2(50)); CREATE OR REPLACE TRIGGER nortran_bi BEFORE INSERT ON nortran FOR EACH ROW BEGIN IF :NEW.nortran_id IS NULL THEN SELECT nortran_seq.NEXTVAL INTO :NEW.nortran_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nortran_transaction_no ON nortran(nortran_transaction_no);\", \"CREATE INDEX idx_nortran_aufd_code ON nortran(nortran_aufd_code);\", \"CREATE INDEX idx_nortran_apty_code ON nortran(nortran_apty_code);\", \"CREATE SEQUENCE nortern_seq; CREATE TABLE nortern (nortern_id NUMBER PRIMARY KEY, nortern_transaction_no NUMBER NOT NULL, nortern_effective_date DATE, nortern_earn_code VARCHAR2(20), nortern_hrs NUMBER(10,2), nortern_special_rate NUMBER(15,2)); CREATE OR REPLACE TRIGGER nortern_bi BEFORE INSERT ON nortern FOR EACH ROW BEGIN IF :NEW.nortern_id IS NULL THEN SELECT nortern_seq.NEXTVAL INTO :NEW.nortern_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nortern_transaction_no ON nortern(nortern_transaction_no);\"], \"sql\": \"select s.spriden_id EID,\\n  s.spriden_last_name ||', '||s.spriden_first_name \\\"NAME\\\",\\n  b.nobtran_transaction_no \\\"TRANS NO.\\\",\\n  z.nortran_posn \\\"POSN NO\\\",\\n  b.nobtran_effective_date \\\"QUERY DATE\\\", \\n  b.nobtran_acat_code \\\"ACAT CODE\\\",\\n  n1.nortran_value \\\"CURRENT HIRE DATE\\\",\\n  n2.nortran_value \\\"BEGIN PERSONNEL DATE\\\",\\n  n3.nortran_value \\\"SALARY GROUP\\\",\\n  n4.nortran_value \\\"APPOINTMENT PERCENT\\\",\\n  n5.nortran_value \\\"ANNUAL SALARY\\\",\\n  t1.nortern_effective_date \\\"PAY DATA EFFECTIVE DATE\\\",\\n  t1.nortern_earn_code \\\"PAY DATA EARNINGS\\\",\\n  t1.nortern_hrs \\\"PAY DATA HOURS\\\",\\n  t1.nortern_special_rate \\\"PAY DATA SPECIAL RATE\\\",\\n  n6.nortran_value \\\"END JOB EFFECTIVE DATE\\\",\\n  n7.nortran_value \\\"END PERSONNEL DATE\\\"\\n   ,case b.nobtran_trans_status_ind\\n   when 'A' then 'Approved'\\n   when 'C' then 'Completed'\\n   when 'V' then 'Voided' \\n   when 'D' then 'Disapproved'\\n   when 'R' then 'Return for Correction'\\n   when 'P' then 'Pending'\\n   when 'W' then 'Waiting'\\n   when 'T' then 'Partially Completed'\\n   when 'N' then 'Cancelled'\\n   when 'U' then 'Superuser Update'\\n  end trans_status   \\n  ,case r.norrout_queue_status_ind\\n   when 'A' then 'Approved by that Approver'\\n   when 'D' then 'Disapproved'\\n   when 'F' then 'FYI'\\n   when 'I' then 'In Queue'\\n   when 'K' then 'Acknowledged'\\n   when 'L' then 'Applied by Applier'\\n   when 'M' then 'More Information'\\n   when 'O' then 'Overridden'\\n   when 'P' then 'Pending Action by Approver/Applier '\\n   when 'Q' then 'Removed from Queue'\\n   when 'R' then 'Return for Correction'\\n  end queue_status\\n  ,r.norrout_level_no\\n  \\n\\n  from nobtran b,spriden s, norrout r, pebempl pp, /*nbrjobs nbr,*/\\n  (select nc.nortran_transaction_no,nc.nortran_apty_code,nc.nortran_aufd_code,nc.nortran_value\\n  from nortran nc\\n   where nc.nortran_aufd_code = 'PEBEMPL_CURRENT_HIRE_DATE'\\n  ) n1, /* Current Hire Date */\\n  (select nb.nortran_transaction_no,nb.nortran_apty_code,nb.nortran_aufd_code,nb.nortran_value\\n  from nortran nb\\n   where nb.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' \\n  ) n2,  /*Begin Personnnel Date*/ \\n  (select ns.nortran_transaction_no,ns.nortran_apty_code,ns.nortran_aufd_code,ns.nortran_value\\n  from nortran ns\\n   where ns.nortran_aufd_code = 'NBRJOBS_SGRP_CODE'\\n   ) n3, /* Salary Group */\\n  (select na.nortran_transaction_no,na.nortran_apty_code,na.nortran_aufd_code,na.nortran_value\\n  from nortran na\\n   where na.nortran_aufd_code = 'NBRJOBS_APPT_PCT'\\n  ) n4, /*Appointment Percent*/ \\n  (select nu.nortran_transaction_no,nu.nortran_apty_code,nu.nortran_aufd_code,nu.nortran_value\\n  from nortran nu\\n   where nu.nortran_aufd_code = 'NBRJOBS_ANN_SALARY'\\n  ) n5, /*Annual Salary*/\\n  (select nj.nortran_transaction_no,nj.nortran_apty_code,nj.nortran_aufd_code,nj.nortran_value\\n  from nortran nj\\n   where nj.nortran_aufd_code = 'NBRJOBS_EFFECTIVE_DATE'  \\n  and nj.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n6,  /*End Job Effective Date*/\\n  (select np.nortran_transaction_no,np.nortran_apty_code,np.nortran_aufd_code,np.nortran_value\\n  from nortran np\\n   where np.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE'  \\n  and np.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n7,  /*End Personnel Date*/\\n\\n  (select t.nortern_transaction_no,t.nortern_effective_date,t.nortern_earn_code,\\n   t.nortern_hrs, t.nortern_special_rate\\n  from nortern t) t1 \\n\\n   ,(select unique zz.nortran_transaction_no,zz.nortran_posn\\n  from nortran zz\\n   where zz.nortran_posn is not null\\n  ) z\\n\\n where b.nobtran_acat_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') /*employee*/\\n  /*waiting,completed,partially completedc,ancelled,supperuser update */\\n  /* and nobtran_trans_status_ind in ('W','C','T','U') */\\n   and b.nobtran_pidm = s.spriden_pidm\\n   and s.spriden_change_ind is null\\n   \\n   and b.nobtran_transaction_no = t1.nortern_transaction_no(+) /*Pay Data*/\\n   \\n   and b.nobtran_transaction_no = n1.nortran_transaction_no(+) /*Current Hire Date*/\\n   \\n   and b.nobtran_transaction_no = n2.nortran_transaction_no(+) /*Begin Personnnel Date*/\\n   \\n   and b.nobtran_transaction_no = n3.nortran_transaction_no(+) /*Salary Group*/\\n   \\n   and b.nobtran_transaction_no = n4.nortran_transaction_no(+) /*Appointment Percent*/\\n   \\n   and b.nobtran_transaction_no = n5.nortran_transaction_no(+) /*Annual Salary*/\\n   \\n   and b.nobtran_transaction_no = n6.nortran_transaction_no(+) /*End Job Effective Date*/\\n   \\n   and b.nobtran_transaction_no = n7.nortran_transaction_no(+) /*End Personnel Date*/\\n   \\n   and nobtran_transaction_no = r.norrout_transaction_no(+)\\n   --get all queue status\\n   /*and r.norrout_queue_status_ind = 'A'*/\\n   and r.norrout_level_no = 90 /* Pending HR approval Queue */\\n   -- not applied yet\\n   and b.nobtran_apply_ind = 'N' /*Applied ePAFs will not be listed*/\\n   --HR does not care about voided ePAFs\\n   and nobtran_trans_status_ind <> 'V'\\n   --get posn\\n   and b.nobtran_transaction_no = z.nortran_transaction_no\\n   and r.norrout_queue_status_ind <> 'A'\\n  -- exclude student\\n   and s.spriden_pidm = pp.pebempl_pidm\\n   and pp.pebempl_ecls_code not in ('RE','FW','GS','MW')\\n\\n   order by 3\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t68442\\t220696\\t81657520\\t10388402242\\t68160\\n1\\t  MERGE JOIN OUTER \\t68442\\t220696\\t81657520\\t10388402242\\t68160\\n2\\t  MERGE JOIN  \\t61068\\t220696\\t77243600\\t9073000336\\t60822\\n3\\t   MERGE JOIN OUTER \\t59624\\t1072825\\t366906150\\t8593654179\\t59391\\n4\\t  MERGE JOIN  \\t55673\\t1000048\\t302014496\\t8042006798\\t55455\\n5\\t  MERGE JOIN OUTER \\t40155\\t875042\\t236261340\\t5632420040\\t40002\\n6\\t   MERGE JOIN OUTER \\t36204\\t815681\\t187606630\\t5082114259\\t36066\\n7\\t  MERGE JOIN OUTER \\t32442\\t760347\\t149028012\\t4563228883\\t32318\\n8\\t  MERGE JOIN OUTER \\t28680\\t708767\\t114820254\\t4044718907\\t28570\\n9\\t   MERGE JOIN OUTER \\t24918\\t660686\\t84567808\\t3526558831\\t24822\\n10\\t  MERGE JOIN OUTER \\t21156\\t615866\\t57891404\\t3008724855\\t21074\\n11\\t  SORT JOIN \\t17394\\t574088\\t34445280\\t2491195079\\t17326\\n12\\t   HASH JOIN  \\t9138\\t574088\\t34445280\\t1827947896\\t9088\\n13\\t  HASH JOIN  \\t4697\\t656100\\t23619600\\t973767459\\t4671\\n14\\t  TABLE ACCESS FULL PEBEMPL\\t794\\t656100\\t3936600\\t362530962\\t784\\n15\\t  TABLE ACCESS FULL SPRIDEN\\t1351\\t1000000\\t30000000\\t285272492\\t1343\\n16\\t  TABLE ACCESS FULL NOBTRAN\\t1454\\t875000\\t21000000\\t548613482\\t1439\\n17\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n18\\t   TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n19\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n20\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n21\\t   SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n22\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n23\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n24\\t   TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n25\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n26\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n27\\t   SORT JOIN \\t3951\\t166667\\t6666680\\t544369681\\t3936\\n28\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t6666680\\t350105675\\t2236\\n29\\t  SORT JOIN \\t15518\\t1000000\\t32000000\\t2409581958\\t15453\\n30\\t   VIEW  \\t6805\\t1000000\\t32000000\\t1336011571\\t6769\\n31\\t  HASH UNIQUE \\t6805\\t1000000\\t12000000\\t1336011571\\t6769\\n32\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t1000000\\t12000000\\t328759001\\t2236\\n33\\t  SORT JOIN \\t3951\\t166667\\t6666680\\t544369681\\t3936\\n34\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t6666680\\t350105675\\t2236\\n35\\t   SORT JOIN \\t1444\\t180000\\t1440000\\t479346156\\t1431\\n36\\t  TABLE ACCESS FULL NORROUT\\t792\\t180000\\t1440000\\t290580962\\t784\\n37\\t  SORT JOIN \\t7374\\t1000000\\t20000000\\t1315401906\\t7338\\n38\\t   TABLE ACCESS FULL NORTERN\\t1304\\t1000000\\t20000000\\t284040483\\t1296\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推优化，消除了n1-n7子查询中的冗余字段(nortran_apty_code,nortran_aufd_code)，保留了核心事务ID和价值字段。减少了63%（7个子查询×2个字段）的数据传输量，显著降低磁盘I/O和内存占用\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推对主表b创建内联视图，提前应用高选择性过滤条件(nobtran_acat_code,nobtran_apply_ind,nobtran_trans_status_ind)，将数据过滤从连接后提前到数据源头。预估在弱优化器数据库(如MySQL 5.x)可提升20-50%性能，智能优化器数据库可提升5-15%。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"Merge Multiple Independent Subqueries Scanning Same Table,将原始SQL中7次独立的nortran表扫描合并为一个CTE，使用条件聚合在单次扫描中计算所有字段。通过内连接替代原始内连接（z子查询）和左外连接（n1~n7子查询），消除重复I/O开销。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE nobtran_seq; CREATE TABLE nobtran (nobtran_id NUMBER PRIMARY KEY, nobtran_transaction_no NUMBER NOT NULL, nobtran_acat_code VARCHAR2(20), nobtran_effective_date DATE, nobtran_trans_status_ind VARCHAR2(1), nobtran_pidm NUMBER NOT NULL, nobtran_apply_ind VARCHAR2(1) DEFAULT 'N'); CREATE OR REPLACE TRIGGER nobtran_bi BEFORE INSERT ON nobtran FOR EACH ROW BEGIN IF :NEW.nobtran_id IS NULL THEN SELECT nobtran_seq.NEXTVAL INTO :NEW.nobtran_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nobtran_acat_code ON nobtran(nobtran_acat_code);\nCREATE INDEX idx_nobtran_pidm ON nobtran(nobtran_pidm);\nCREATE INDEX idx_nobtran_transaction_no ON nobtran(nobtran_transaction_no);\nCREATE INDEX idx_nobtran_status ON nobtran(nobtran_trans_status_ind);\nCREATE INDEX idx_nobtran_apply_ind ON nobtran(nobtran_apply_ind);\nCREATE SEQUENCE spriden_seq; CREATE TABLE spriden (spriden_pidm NUMBER PRIMARY KEY, spriden_id VARCHAR2(50) NOT NULL, spriden_last_name VARCHAR2(100) NOT NULL, spriden_first_name VARCHAR2(100), spriden_change_ind VARCHAR2(1)); CREATE OR REPLACE TRIGGER spriden_bi BEFORE INSERT ON spriden FOR EACH ROW BEGIN IF :NEW.spriden_pidm IS NULL THEN SELECT spriden_seq.NEXTVAL INTO :NEW.spriden_pidm FROM DUAL; END IF; END;\nCREATE INDEX idx_spriden_change_ind ON spriden(spriden_change_ind);\nCREATE SEQUENCE norrout_seq; CREATE TABLE norrout (norrout_id NUMBER PRIMARY KEY, norrout_transaction_no NUMBER NOT NULL, norrout_queue_status_ind VARCHAR2(1), norrout_level_no NUMBER); CREATE OR REPLACE TRIGGER norrout_bi BEFORE INSERT ON norrout FOR EACH ROW BEGIN IF :NEW.norrout_id IS NULL THEN SELECT norrout_seq.NEXTVAL INTO :NEW.norrout_id FROM DUAL; END IF; END;\nCREATE INDEX idx_norrout_transaction_no ON norrout(norrout_transaction_no);\nCREATE INDEX idx_norrout_level_no ON norrout(norrout_level_no);\nCREATE INDEX idx_norrout_queue_status ON norrout(norrout_queue_status_ind);\nCREATE SEQUENCE pebempl_seq; CREATE TABLE pebempl (pebempl_pidm NUMBER PRIMARY KEY, pebempl_ecls_code VARCHAR2(10) NOT NULL, pebempl_current_hire_date DATE); CREATE OR REPLACE TRIGGER pebempl_bi BEFORE INSERT ON pebempl FOR EACH ROW BEGIN IF :NEW.pebempl_pidm IS NULL THEN SELECT pebempl_seq.NEXTVAL INTO :NEW.pebempl_pidm FROM DUAL; END IF; END;\nCREATE INDEX idx_pebempl_ecls_code ON pebempl(pebempl_ecls_code);\nCREATE SEQUENCE nortran_seq; CREATE TABLE nortran (nortran_id NUMBER PRIMARY KEY, nortran_transaction_no NUMBER NOT NULL, nortran_apty_code VARCHAR2(20), nortran_aufd_code VARCHAR2(50) NOT NULL, nortran_value VARCHAR2(200), nortran_posn VARCHAR2(50)); CREATE OR REPLACE TRIGGER nortran_bi BEFORE INSERT ON nortran FOR EACH ROW BEGIN IF :NEW.nortran_id IS NULL THEN SELECT nortran_seq.NEXTVAL INTO :NEW.nortran_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nortran_transaction_no ON nortran(nortran_transaction_no);\nCREATE INDEX idx_nortran_aufd_code ON nortran(nortran_aufd_code);\nCREATE INDEX idx_nortran_apty_code ON nortran(nortran_apty_code);\nCREATE SEQUENCE nortern_seq; CREATE TABLE nortern (nortern_id NUMBER PRIMARY KEY, nortern_transaction_no NUMBER NOT NULL, nortern_effective_date DATE, nortern_earn_code VARCHAR2(20), nortern_hrs NUMBER(10,2), nortern_special_rate NUMBER(15,2)); CREATE OR REPLACE TRIGGER nortern_bi BEFORE INSERT ON nortern FOR EACH ROW BEGIN IF :NEW.nortern_id IS NULL THEN SELECT nortern_seq.NEXTVAL INTO :NEW.nortern_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nortern_transaction_no ON nortern(nortern_transaction_no);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t68442\t220696\t81657520\t10388402242\t68160\n1\t  MERGE JOIN OUTER \t68442\t220696\t81657520\t10388402242\t68160\n2\t  MERGE JOIN  \t61068\t220696\t77243600\t9073000336\t60822\n3\t   MERGE JOIN OUTER \t59624\t1072825\t366906150\t8593654179\t59391\n4\t  MERGE JOIN  \t55673\t1000048\t302014496\t8042006798\t55455\n5\t  MERGE JOIN OUTER \t40155\t875042\t236261340\t5632420040\t40002\n6\t   MERGE JOIN OUTER \t36204\t815681\t187606630\t5082114259\t36066\n7\t  MERGE JOIN OUTER \t32442\t760347\t149028012\t4563228883\t32318\n8\t  MERGE JOIN OUTER \t28680\t708767\t114820254\t4044718907\t28570\n9\t   MERGE JOIN OUTER \t24918\t660686\t84567808\t3526558831\t24822\n10\t  MERGE JOIN OUTER \t21156\t615866\t57891404\t3008724855\t21074\n11\t  SORT JOIN \t17394\t574088\t34445280\t2491195079\t17326\n12\t   HASH JOIN  \t9138\t574088\t34445280\t1827947896\t9088\n13\t  HASH JOIN  \t4697\t656100\t23619600\t973767459\t4671\n14\t  TABLE ACCESS FULL PEBEMPL\t794\t656100\t3936600\t362530962\t784\n15\t  TABLE ACCESS FULL SPRIDEN\t1351\t1000000\t30000000\t285272492\t1343\n16\t  TABLE ACCESS FULL NOBTRAN\t1454\t875000\t21000000\t548613482\t1439\n17\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n18\t   TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n19\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n20\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n21\t   SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n22\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n23\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n24\t   TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n25\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n26\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n27\t   SORT JOIN \t3951\t166667\t6666680\t544369681\t3936\n28\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t6666680\t350105675\t2236\n29\t  SORT JOIN \t15518\t1000000\t32000000\t2409581958\t15453\n30\t   VIEW  \t6805\t1000000\t32000000\t1336011571\t6769\n31\t  HASH UNIQUE \t6805\t1000000\t12000000\t1336011571\t6769\n32\t  TABLE ACCESS FULL NORTRAN\t2245\t1000000\t12000000\t328759001\t2236\n33\t  SORT JOIN \t3951\t166667\t6666680\t544369681\t3936\n34\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t6666680\t350105675\t2236\n35\t   SORT JOIN \t1444\t180000\t1440000\t479346156\t1431\n36\t  TABLE ACCESS FULL NORROUT\t792\t180000\t1440000\t290580962\t784\n37\t  SORT JOIN \t7374\t1000000\t20000000\t1315401906\t7338\n38\t   TABLE ACCESS FULL NORTERN\t1304\t1000000\t20000000\t284040483\t1296\n\n## Original SQL:\nselect s.spriden_id EID,\n  s.spriden_last_name ||', '||s.spriden_first_name \"NAME\",\n  b.nobtran_transaction_no \"TRANS NO.\",\n  z.nortran_posn \"POSN NO\",\n  b.nobtran_effective_date \"QUERY DATE\", \n  b.nobtran_acat_code \"ACAT CODE\",\n  n1.nortran_value \"CURRENT HIRE DATE\",\n  n2.nortran_value \"BEGIN PERSONNEL DATE\",\n  n3.nortran_value \"SALARY GROUP\",\n  n4.nortran_value \"APPOINTMENT PERCENT\",\n  n5.nortran_value \"ANNUAL SALARY\",\n  t1.nortern_effective_date \"PAY DATA EFFECTIVE DATE\",\n  t1.nortern_earn_code \"PAY DATA EARNINGS\",\n  t1.nortern_hrs \"PAY DATA HOURS\",\n  t1.nortern_special_rate \"PAY DATA SPECIAL RATE\",\n  n6.nortran_value \"END JOB EFFECTIVE DATE\",\n  n7.nortran_value \"END PERSONNEL DATE\"\n   ,case b.nobtran_trans_status_ind\n   when 'A' then 'Approved'\n   when 'C' then 'Completed'\n   when 'V' then 'Voided' \n   when 'D' then 'Disapproved'\n   when 'R' then 'Return for Correction'\n   when 'P' then 'Pending'\n   when 'W' then 'Waiting'\n   when 'T' then 'Partially Completed'\n   when 'N' then 'Cancelled'\n   when 'U' then 'Superuser Update'\n  end trans_status   \n  ,case r.norrout_queue_status_ind\n   when 'A' then 'Approved by that Approver'\n   when 'D' then 'Disapproved'\n   when 'F' then 'FYI'\n   when 'I' then 'In Queue'\n   when 'K' then 'Acknowledged'\n   when 'L' then 'Applied by Applier'\n   when 'M' then 'More Information'\n   when 'O' then 'Overridden'\n   when 'P' then 'Pending Action by Approver/Applier '\n   when 'Q' then 'Removed from Queue'\n   when 'R' then 'Return for Correction'\n  end queue_status\n  ,r.norrout_level_no\n  \n\n  from nobtran b,spriden s, norrout r, pebempl pp, /*nbrjobs nbr,*/\n  (select nc.nortran_transaction_no,nc.nortran_apty_code,nc.nortran_aufd_code,nc.nortran_value\n  from nortran nc\n   where nc.nortran_aufd_code = 'PEBEMPL_CURRENT_HIRE_DATE'\n  ) n1, /* Current Hire Date */\n  (select nb.nortran_transaction_no,nb.nortran_apty_code,nb.nortran_aufd_code,nb.nortran_value\n  from nortran nb\n   where nb.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' \n  ) n2,  /*Begin Personnnel Date*/ \n  (select ns.nortran_transaction_no,ns.nortran_apty_code,ns.nortran_aufd_code,ns.nortran_value\n  from nortran ns\n   where ns.nortran_aufd_code = 'NBRJOBS_SGRP_CODE'\n   ) n3, /* Salary Group */\n  (select na.nortran_transaction_no,na.nortran_apty_code,na.nortran_aufd_code,na.nortran_value\n  from nortran na\n   where na.nortran_aufd_code = 'NBRJOBS_APPT_PCT'\n  ) n4, /*Appointment Percent*/ \n  (select nu.nortran_transaction_no,nu.nortran_apty_code,nu.nortran_aufd_code,nu.nortran_value\n  from nortran nu\n   where nu.nortran_aufd_code = 'NBRJOBS_ANN_SALARY'\n  ) n5, /*Annual Salary*/\n  (select nj.nortran_transaction_no,nj.nortran_apty_code,nj.nortran_aufd_code,nj.nortran_value\n  from nortran nj\n   where nj.nortran_aufd_code = 'NBRJOBS_EFFECTIVE_DATE'  \n  and nj.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n6,  /*End Job Effective Date*/\n  (select np.nortran_transaction_no,np.nortran_apty_code,np.nortran_aufd_code,np.nortran_value\n  from nortran np\n   where np.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE'  \n  and np.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n7,  /*End Personnel Date*/\n\n  (select t.nortern_transaction_no,t.nortern_effective_date,t.nortern_earn_code,\n   t.nortern_hrs, t.nortern_special_rate\n  from nortern t) t1 \n\n   ,(select unique zz.nortran_transaction_no,zz.nortran_posn\n  from nortran zz\n   where zz.nortran_posn is not null\n  ) z\n\n where b.nobtran_acat_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') /*employee*/\n  /*waiting,completed,partially completedc,ancelled,supperuser update */\n  /* and nobtran_trans_status_ind in ('W','C','T','U') */\n   and b.nobtran_pidm = s.spriden_pidm\n   and s.spriden_change_ind is null\n   \n   and b.nobtran_transaction_no = t1.nortern_transaction_no(+) /*Pay Data*/\n   \n   and b.nobtran_transaction_no = n1.nortran_transaction_no(+) /*Current Hire Date*/\n   \n   and b.nobtran_transaction_no = n2.nortran_transaction_no(+) /*Begin Personnnel Date*/\n   \n   and b.nobtran_transaction_no = n3.nortran_transaction_no(+) /*Salary Group*/\n   \n   and b.nobtran_transaction_no = n4.nortran_transaction_no(+) /*Appointment Percent*/\n   \n   and b.nobtran_transaction_no = n5.nortran_transaction_no(+) /*Annual Salary*/\n   \n   and b.nobtran_transaction_no = n6.nortran_transaction_no(+) /*End Job Effective Date*/\n   \n   and b.nobtran_transaction_no = n7.nortran_transaction_no(+) /*End Personnel Date*/\n   \n   and nobtran_transaction_no = r.norrout_transaction_no(+)\n   --get all queue status\n   /*and r.norrout_queue_status_ind = 'A'*/\n   and r.norrout_level_no = 90 /* Pending HR approval Queue */\n   -- not applied yet\n   and b.nobtran_apply_ind = 'N' /*Applied ePAFs will not be listed*/\n   --HR does not care about voided ePAFs\n   and nobtran_trans_status_ind <> 'V'\n   --get posn\n   and b.nobtran_transaction_no = z.nortran_transaction_no\n   and r.norrout_queue_status_ind <> 'A'\n  -- exclude student\n   and s.spriden_pidm = pp.pebempl_pidm\n   and pp.pebempl_ecls_code not in ('RE','FW','GS','MW')\n\n   order by 3\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH nt AS (SELECT nortran_transaction_no, MAX(CASE WHEN nortran_aufd_code='PEBEMPL_CURRENT_HIRE_DATE' THEN nortran_value END) n1_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_PERS_CHG_DATE' THEN nortran_value END) n2_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_SGRP_CODE' THEN nortran_value END) n3_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_APPT_PCT' THEN nortran_value END) n4_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_ANN_SALARY' THEN nortran_value END) n5_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_EFFECTIVE_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) n6_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_PERS_CHG_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) n7_val, MAX(CASE WHEN nortran_posn IS NOT NULL THEN nortran_posn END) z_posn FROM nortran GROUP BY nortran_transaction_no) SELECT s.spriden_id EID, s.spriden_last_name||', '||s.spriden_first_name \"NAME\", b.nobtran_transaction_no \"TRANS NO.\", nt.z_posn \"POSN NO\", b.nobtran_effective_date \"QUERY DATE\", b.nobtran_acat_code \"ACAT CODE\", nt.n1_val \"CURRENT HIRE DATE\", nt.n2_val \"BEGIN PERSONNEL DATE\", nt.n3_val \"SALARY GROUP\", nt.n4_val \"APPOINTMENT PERCENT\", nt.n5_val \"ANNUAL SALARY\", t1.nortern_effective_date \"PAY DATA EFFECTIVE DATE\", t1.nortern_earn_code \"PAY DATA EARNINGS\", t1.nortern_hrs \"PAY DATA HOURS\", t1.nortern_special_rate \"PAY DATA SPECIAL RATE\", nt.n6_val \"END JOB EFFECTIVE DATE\", nt.n7_val \"END PERSONNEL DATE\", CASE b.nobtran_trans_status_ind WHEN 'A' THEN 'Approved' WHEN 'C' THEN 'Completed' WHEN 'V' THEN 'Voided' WHEN 'D' THEN 'Disapproved' WHEN 'R' THEN 'Return for Correction' WHEN 'P' THEN 'Pending' WHEN 'W' THEN 'Waiting' WHEN 'T' THEN 'Partially Completed' WHEN 'N' THEN 'Cancelled' WHEN 'U' THEN 'Superuser Update' END trans_status, CASE r.norrout_queue_status_ind WHEN 'A' THEN 'Approved by that Approver' WHEN 'D' THEN 'Disapproved' WHEN 'F' THEN 'FYI' WHEN 'I' THEN 'In Queue' WHEN 'K' THEN 'Acknowledged' WHEN 'L' THEN 'Applied by Applier' WHEN 'M' THEN 'More Information' WHEN 'O' THEN 'Overridden' WHEN 'P' THEN 'Pending Action by Approver/Applier' WHEN 'Q' THEN 'Removed from Queue' WHEN 'R' THEN 'Return for Correction' END queue_status, r.norrout_level_no FROM nobtran b INNER JOIN spriden s ON b.nobtran_pidm=s.spriden_pidm AND s.spriden_change_ind IS NULL INNER JOIN pebempl pp ON s.spriden_pidm=pp.pebempl_pidm AND pp.pebempl_ecls_code NOT IN ('RE','FW','GS','MW') INNER JOIN nt ON b.nobtran_transaction_no=nt.nortran_transaction_no LEFT OUTER JOIN nortern t1 ON b.nobtran_transaction_no=t1.nortern_transaction_no LEFT OUTER JOIN norrout r ON b.nobtran_transaction_no=r.norrout_transaction_no AND r.norrout_level_no=90 WHERE b.nobtran_acat_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') AND b.nobtran_apply_ind='N' AND b.nobtran_trans_status_ind<>'V' AND (r.norrout_queue_status_ind IS NULL OR r.norrout_queue_status_ind<>'A') ORDER BY 3"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "31",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"31\", \"db_type\": \"oracle\", \"description\": \"本次改写是一个纯语法层面的变更，仅将派生表（子查询）的别名从't'改为't2'，并相应更新外层SELECT语句中的列引用（t.age→t2.age等）。这种改写不改变SQL的语义、执行逻辑或数据访问路径，对数据库优化器来说两个查询完全等价。从性能优化角度看，这不是一个有效的改写方案，因为它不涉及任何能够提升性能的技术手段，如索引利用、连接顺序调整、谓词下推、子查询展开等。\", \"create_table_statements\": [\"CREATE TABLE SAPR3.BSIS (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BUZEI VARCHAR2(3) NOT NULL, HKONT VARCHAR2(10), DMBTR NUMBER(15,2), WAERS VARCHAR2(3), MONAT VARCHAR2(2), BLDAT VARCHAR2(8), CONSTRAINT pk_bsis PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR, BUZEI));\", \"CREATE INDEX idx_bsis_query ON SAPR3.BSIS(GJAHR, BUKRS, HKONT, MANDT, BUZEI, WAERS, MONAT, BLDAT);\", \"CREATE INDEX idx_bsis_join ON SAPR3.BSIS(BELNR, GJAHR, BUKRS);\", \"CREATE TABLE SAPR3.BKPF (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BLDAT VARCHAR2(8), CONSTRAINT pk_bkpf PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR));\"], \"sql\": \"SELECT\\n  t.age,\\n  CASE \\n  WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days'\\n  WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days'\\n  ELSE 'Above 7 Days'\\n  END AS age_bucket,\\n  t.amount_local,\\n  t.hkont AS gl_account,\\n  t.bukrs AS company_code\\nFROM (\\n  SELECT \\n  b.BUKRS,\\n  b.HKONT,\\n  b.DMBTR AS amount_local,\\n  (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age\\n  FROM (\\n  SELECT /*+ FIRST_ROWS(30) */\\n   BELNR, GJAHR, BUKRS, HKONT, DMBTR\\n  FROM SAPR3.BSIS\\n  WHERE GJAHR = '2025'\\n  AND BUKRS = '0100'\\n  AND HKONT = '0000895200'\\n  AND MANDT = '500'\\n  AND BUZEI = '002'\\n  AND WAERS = 'INR'\\n  AND MONAT = '01'\\n  AND BLDAT = '20240401'\\n  ) b\\n  JOIN SAPR3.BKPF k\\n   ON b.BELNR = k.BELNR\\n  AND b.GJAHR = k.GJAHR\\n  AND b.BUKRS = k.BUKRS\\n) t\\nORDER BY t.age;\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t4225\\t1\\t81\\t810400605\\t4203\\n1\\t  SORT ORDER BY \\t4225\\t1\\t81\\t810400605\\t4203\\n2\\t  HASH JOIN  \\t4224\\t1\\t81\\t773532036\\t4203\\n3\\t   NESTED LOOPS  \\t4224\\t1\\t81\\t773532036\\t4203\\n4\\t  NESTED LOOPS  \\t\\t\\t\\t\\t\\n5\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n6\\t   TABLE ACCESS FULL BSIS\\t2748\\t6289\\t327028\\t456661695\\t2736\\n7\\t  INDEX UNIQUE SCAN PK_BKPF\\t\\t\\t\\t\\t\\n8\\t  TABLE ACCESS BY INDEX ROWID BKPF\\t1475\\t1\\t29\\t311326990\\t1467\\n9\\t   TABLE ACCESS FULL BKPF\\t1475\\t40000\\t1160000\\t311326990\\t1467\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推消除内层子查询中冗余的列：原始内层子查询返回7列，经分析仅需保留连接用关键列(BELNR/GJAHR)及外层实际使用的业务列(BUKRS/HKONT/DMBTR)，消除不必要的数据加载和传输\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"子查询折叠,通过子查询折叠消除一层冗余嵌套，并优化表达式避免重复计算。折叠后保留两层结构：内层子查询b保持不动，中间层（原JOIN层）增加age计算并作为结果集t2，最外层直接使用t2的列。优化后减少一层中间结果物化开销，并避免age表达式多次计算。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE SAPR3.BSIS (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BUZEI VARCHAR2(3) NOT NULL, HKONT VARCHAR2(10), DMBTR NUMBER(15,2), WAERS VARCHAR2(3), MONAT VARCHAR2(2), BLDAT VARCHAR2(8), CONSTRAINT pk_bsis PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR, BUZEI));\nCREATE INDEX idx_bsis_query ON SAPR3.BSIS(GJAHR, BUKRS, HKONT, MANDT, BUZEI, WAERS, MONAT, BLDAT);\nCREATE INDEX idx_bsis_join ON SAPR3.BSIS(BELNR, GJAHR, BUKRS);\nCREATE TABLE SAPR3.BKPF (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BLDAT VARCHAR2(8), CONSTRAINT pk_bkpf PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR));\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t4225\t1\t81\t810400605\t4203\n1\t  SORT ORDER BY \t4225\t1\t81\t810400605\t4203\n2\t  HASH JOIN  \t4224\t1\t81\t773532036\t4203\n3\t   NESTED LOOPS  \t4224\t1\t81\t773532036\t4203\n4\t  NESTED LOOPS  \t\t\t\t\t\n5\t  STATISTICS COLLECTOR  \t\t\t\t\t\n6\t   TABLE ACCESS FULL BSIS\t2748\t6289\t327028\t456661695\t2736\n7\t  INDEX UNIQUE SCAN PK_BKPF\t\t\t\t\t\n8\t  TABLE ACCESS BY INDEX ROWID BKPF\t1475\t1\t29\t311326990\t1467\n9\t   TABLE ACCESS FULL BKPF\t1475\t40000\t1160000\t311326990\t1467\n\n## Original SQL:\nSELECT\n  t.age,\n  CASE \n  WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days'\n  WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days'\n  ELSE 'Above 7 Days'\n  END AS age_bucket,\n  t.amount_local,\n  t.hkont AS gl_account,\n  t.bukrs AS company_code\nFROM (\n  SELECT \n  b.BUKRS,\n  b.HKONT,\n  b.DMBTR AS amount_local,\n  (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age\n  FROM (\n  SELECT /*+ FIRST_ROWS(30) */\n   BELNR, GJAHR, BUKRS, HKONT, DMBTR\n  FROM SAPR3.BSIS\n  WHERE GJAHR = '2025'\n  AND BUKRS = '0100'\n  AND HKONT = '0000895200'\n  AND MANDT = '500'\n  AND BUZEI = '002'\n  AND WAERS = 'INR'\n  AND MONAT = '01'\n  AND BLDAT = '20240401'\n  ) b\n  JOIN SAPR3.BKPF k\n   ON b.BELNR = k.BELNR\n  AND b.GJAHR = k.GJAHR\n  AND b.BUKRS = k.BUKRS\n) t\nORDER BY t.age;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT t.age, CASE WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days' WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days' ELSE 'Above 7 Days' END AS age_bucket, t.amount_local, t.hkont AS gl_account, t.bukrs AS company_code FROM (SELECT b.BUKRS, b.HKONT, b.DMBTR AS amount_local, (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age FROM (SELECT /*+ INDEX(BSIS idx_bsis_query) */ BELNR, GJAHR, BUKRS, HKONT, DMBTR, MANDT FROM SAPR3.BSIS WHERE GJAHR = '2025' AND BUKRS = '0100' AND HKONT = '0000895200' AND MANDT = '500' AND BUZEI = '002' AND WAERS = 'INR' AND MONAT = '01' AND BLDAT = '20240401') b JOIN SAPR3.BKPF k ON b.BELNR = k.BELNR AND b.GJAHR = k.GJAHR AND b.BUKRS = k.BUKRS AND b.MANDT = k.MANDT) t ORDER BY t.age;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "31",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"31\", \"db_type\": \"oracle\", \"description\": \"本次改写是一个纯语法层面的变更，仅将派生表（子查询）的别名从't'改为't2'，并相应更新外层SELECT语句中的列引用（t.age→t2.age等）。这种改写不改变SQL的语义、执行逻辑或数据访问路径，对数据库优化器来说两个查询完全等价。从性能优化角度看，这不是一个有效的改写方案，因为它不涉及任何能够提升性能的技术手段，如索引利用、连接顺序调整、谓词下推、子查询展开等。\", \"create_table_statements\": [\"CREATE TABLE SAPR3.BSIS (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BUZEI VARCHAR2(3) NOT NULL, HKONT VARCHAR2(10), DMBTR NUMBER(15,2), WAERS VARCHAR2(3), MONAT VARCHAR2(2), BLDAT VARCHAR2(8), CONSTRAINT pk_bsis PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR, BUZEI));\", \"CREATE INDEX idx_bsis_query ON SAPR3.BSIS(GJAHR, BUKRS, HKONT, MANDT, BUZEI, WAERS, MONAT, BLDAT);\", \"CREATE INDEX idx_bsis_join ON SAPR3.BSIS(BELNR, GJAHR, BUKRS);\", \"CREATE TABLE SAPR3.BKPF (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BLDAT VARCHAR2(8), CONSTRAINT pk_bkpf PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR));\"], \"sql\": \"SELECT\\n  t.age,\\n  CASE \\n  WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days'\\n  WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days'\\n  ELSE 'Above 7 Days'\\n  END AS age_bucket,\\n  t.amount_local,\\n  t.hkont AS gl_account,\\n  t.bukrs AS company_code\\nFROM (\\n  SELECT \\n  b.BUKRS,\\n  b.HKONT,\\n  b.DMBTR AS amount_local,\\n  (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age\\n  FROM (\\n  SELECT /*+ FIRST_ROWS(30) */\\n   BELNR, GJAHR, BUKRS, HKONT, DMBTR\\n  FROM SAPR3.BSIS\\n  WHERE GJAHR = '2025'\\n  AND BUKRS = '0100'\\n  AND HKONT = '0000895200'\\n  AND MANDT = '500'\\n  AND BUZEI = '002'\\n  AND WAERS = 'INR'\\n  AND MONAT = '01'\\n  AND BLDAT = '20240401'\\n  ) b\\n  JOIN SAPR3.BKPF k\\n   ON b.BELNR = k.BELNR\\n  AND b.GJAHR = k.GJAHR\\n  AND b.BUKRS = k.BUKRS\\n) t\\nORDER BY t.age;\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t4225\\t1\\t81\\t810400605\\t4203\\n1\\t  SORT ORDER BY \\t4225\\t1\\t81\\t810400605\\t4203\\n2\\t  HASH JOIN  \\t4224\\t1\\t81\\t773532036\\t4203\\n3\\t   NESTED LOOPS  \\t4224\\t1\\t81\\t773532036\\t4203\\n4\\t  NESTED LOOPS  \\t\\t\\t\\t\\t\\n5\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n6\\t   TABLE ACCESS FULL BSIS\\t2748\\t6289\\t327028\\t456661695\\t2736\\n7\\t  INDEX UNIQUE SCAN PK_BKPF\\t\\t\\t\\t\\t\\n8\\t  TABLE ACCESS BY INDEX ROWID BKPF\\t1475\\t1\\t29\\t311326990\\t1467\\n9\\t   TABLE ACCESS FULL BKPF\\t1475\\t40000\\t1160000\\t311326990\\t1467\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推消除内层子查询中冗余的列：原始内层子查询返回7列，经分析仅需保留连接用关键列(BELNR/GJAHR)及外层实际使用的业务列(BUKRS/HKONT/DMBTR)，消除不必要的数据加载和传输\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"子查询折叠,通过子查询折叠消除一层冗余嵌套，并优化表达式避免重复计算。折叠后保留两层结构：内层子查询b保持不动，中间层（原JOIN层）增加age计算并作为结果集t2，最外层直接使用t2的列。优化后减少一层中间结果物化开销，并避免age表达式多次计算。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE SAPR3.BSIS (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BUZEI VARCHAR2(3) NOT NULL, HKONT VARCHAR2(10), DMBTR NUMBER(15,2), WAERS VARCHAR2(3), MONAT VARCHAR2(2), BLDAT VARCHAR2(8), CONSTRAINT pk_bsis PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR, BUZEI));\nCREATE INDEX idx_bsis_query ON SAPR3.BSIS(GJAHR, BUKRS, HKONT, MANDT, BUZEI, WAERS, MONAT, BLDAT);\nCREATE INDEX idx_bsis_join ON SAPR3.BSIS(BELNR, GJAHR, BUKRS);\nCREATE TABLE SAPR3.BKPF (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BLDAT VARCHAR2(8), CONSTRAINT pk_bkpf PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR));\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t4225\t1\t81\t810400605\t4203\n1\t  SORT ORDER BY \t4225\t1\t81\t810400605\t4203\n2\t  HASH JOIN  \t4224\t1\t81\t773532036\t4203\n3\t   NESTED LOOPS  \t4224\t1\t81\t773532036\t4203\n4\t  NESTED LOOPS  \t\t\t\t\t\n5\t  STATISTICS COLLECTOR  \t\t\t\t\t\n6\t   TABLE ACCESS FULL BSIS\t2748\t6289\t327028\t456661695\t2736\n7\t  INDEX UNIQUE SCAN PK_BKPF\t\t\t\t\t\n8\t  TABLE ACCESS BY INDEX ROWID BKPF\t1475\t1\t29\t311326990\t1467\n9\t   TABLE ACCESS FULL BKPF\t1475\t40000\t1160000\t311326990\t1467\n\n## Original SQL:\nSELECT\n  t.age,\n  CASE \n  WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days'\n  WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days'\n  ELSE 'Above 7 Days'\n  END AS age_bucket,\n  t.amount_local,\n  t.hkont AS gl_account,\n  t.bukrs AS company_code\nFROM (\n  SELECT \n  b.BUKRS,\n  b.HKONT,\n  b.DMBTR AS amount_local,\n  (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age\n  FROM (\n  SELECT /*+ FIRST_ROWS(30) */\n   BELNR, GJAHR, BUKRS, HKONT, DMBTR\n  FROM SAPR3.BSIS\n  WHERE GJAHR = '2025'\n  AND BUKRS = '0100'\n  AND HKONT = '0000895200'\n  AND MANDT = '500'\n  AND BUZEI = '002'\n  AND WAERS = 'INR'\n  AND MONAT = '01'\n  AND BLDAT = '20240401'\n  ) b\n  JOIN SAPR3.BKPF k\n   ON b.BELNR = k.BELNR\n  AND b.GJAHR = k.GJAHR\n  AND b.BUKRS = k.BUKRS\n) t\nORDER BY t.age;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT t.age, CASE WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days' WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days' ELSE 'Above 7 Days' END AS age_bucket, t.amount_local, t.hkont AS gl_account, t.bukrs AS company_code FROM (SELECT b.BUKRS, b.HKONT, b.DMBTR AS amount_local, (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age FROM (SELECT /*+ INDEX(BSIS idx_bsis_query) */ BELNR, GJAHR, BUKRS, HKONT, DMBTR, MANDT FROM SAPR3.BSIS WHERE GJAHR = '2025' AND BUKRS = '0100' AND HKONT = '0000895200' AND MANDT = '500' AND BUZEI = '002' AND WAERS = 'INR' AND MONAT = '01' AND BLDAT = '20240401') b JOIN SAPR3.BKPF k ON b.BELNR = k.BELNR AND b.GJAHR = k.GJAHR AND b.BUKRS = k.BUKRS AND b.MANDT = k.MANDT) t ORDER BY t.age;"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "32",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"32\", \"db_type\": \"postgresql\", \"description\": \"本次改写采用了经典的查询优化技术组合：\\n\\n1. **谓词下推（Predicate Pushdown）**：将out_date的过滤条件从最外层WHERE子句移到tmep_ip CTE内部。这样可以尽早过滤数据，减少CTE物化的数据量，虽然在本例中优化器已经将过滤推到了Parallel Seq Scan阶段，但显式下推使逻辑更清晰，且在某些复杂场景下能帮助优化器更好地生成执行计划。\\n\\n2. **投影裁剪（Column Pruning）**：在diagnosis_ranked子查询中，移除了不再需要的diagnosis_type_name字段。该字段仅用于窗口函数的排序，在rn=1筛选后就没有实际意义了，因此在WindowAgg之后立即裁剪，避免传递到上层的GroupAggregate和Materialize节点。\\n\\n3. **聚合维度优化**：diagnosis_end的GROUP BY从4个字段减少到3个字段。因为diagnosis_type_name在窗口函数排序后已被隐含使用（通过rn=1保证了每组只保留优先级最高的记录），在最终聚合时不需要再作为分组键。这减少了哈希表的键空间和比较开销。\\n\\n4. **逻辑等价性保证**：虽然进行了多处优化，但查询的核心逻辑保持不变：\\n   - 诊断类型的优先级排序规则完全一致\\n   - ROW_NUMBER()窗口函数的分区和排序逻辑相同\\n   - MAX聚合对diagnosis_flag分组的处理逻辑相同\\n   - 最终JOIN关联条件和结果集完全一致\", \"create_table_statements\": [\"CREATE TABLE his_temp_ip_patient_info (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, inpatient_name VARCHAR(100), age INTEGER, sex VARCHAR(10), in_date TIMESTAMP, out_date TIMESTAMP, times VARCHAR(20), person_type VARCHAR(50), patient_no VARCHAR(50), current_dept_code VARCHAR(50));\", \"CREATE INDEX idx_his_temp_ip_patient_info_register_no_times ON his_temp_ip_patient_info(register_no, times);\", \"CREATE INDEX idx_his_temp_ip_patient_info_out_date ON his_temp_ip_patient_info(out_date);\", \"CREATE TABLE his_temp_ip_settle (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, times VARCHAR(20) NOT NULL, total_cost DECIMAL(12,2));\", \"CREATE INDEX idx_his_temp_ip_settle_register_no_times ON his_temp_ip_settle(register_no, times);\", \"CREATE TABLE emr_temp_ip_patient_diagnosis (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, type VARCHAR(50), diagnosis_type_name VARCHAR(100), diagnosis_flag VARCHAR(1), diagnosis_code VARCHAR(50), diagnosis_name VARCHAR(200), diagnosis_no INTEGER, file_visit_type VARCHAR(10));\", \"CREATE INDEX idx_emr_temp_ip_patient_diagnosis_file_visit ON emr_temp_ip_patient_diagnosis(file_visit_type, inp_no, visit_id);\", \"CREATE INDEX idx_emr_temp_ip_patient_diagnosis_group ON emr_temp_ip_patient_diagnosis(inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag);\", \"CREATE TABLE emr_temp_ip_patient_operation (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, operation_code VARCHAR(50), operation_no INTEGER);\", \"CREATE INDEX idx_emr_temp_ip_patient_operation_inp_visit ON emr_temp_ip_patient_operation(inp_no, visit_id);\"], \"sql\": \"with tmep_ip as (\\n  select \\n  a.register_no as patientid, \\n  a.inpatient_name as patientname, \\n  a.age,\\n  a.sex as gender, \\n  date(a.in_date) as indate, \\n  date(a.out_date) as outdate,\\n  a.times as inhospitaltimes, \\n  a.person_type as persontype, \\n  a.patient_no as serialno,\\n  b.total_cost as medicalcost, \\n  'doctor' as entrymode, \\n  'remind' as defaulttab,\\n  a.current_dept_code as deptcode, \\n  '440100' as citycode \\n  from his_temp_ip_patient_info a \\n  left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times\\n),\\ndiagnosis as (\\n  select \\n  inp_no, \\n  visit_id as times, \\n  type, \\n  diagnosis_type_name,\\n  diagnosis_flag,\\n  case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes,\\n  case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes,\\n  case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names \\n  from emr_temp_ip_patient_diagnosis \\n  where file_visit_type = '2'\\n  group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag\\n),\\ndiagnosis_ranked as (\\n  select \\n  *,\\n  row_number() over (\\n   partition by inp_no, times, type \\n   order by \\n  case \\n  when type = '病历诊断' and diagnosis_type_name = '最后诊断' then 1\\n  when type = '病历诊断' and diagnosis_type_name = '初步诊断' then 2\\n  when type = '首页诊断' and diagnosis_type_name = '出院诊断' then 1\\n  when type = '首页诊断' and diagnosis_type_name = '门诊诊断' then 2\\n  else 3\\n  end\\n  ) as rn\\n  from diagnosis\\n),\\ndiagnosis_end as (\\n  select \\n  inp_no, \\n  times, \\n  type, \\n  diagnosis_type_name,\\n  max(case when diagnosis_flag = '1' then diagnosis_codes end) as diagnosis_codes,\\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_codes end) as chinese_diagnosis_codes,\\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_names end) as chinese_diagnosis_names\\n  from diagnosis_ranked\\n  where rn = 1\\n  group by inp_no, times, type, diagnosis_type_name\\n),\\noperations as (\\n  select \\n  inp_no, \\n  visit_id as times, \\n  string_agg(operation_code, ',' order by operation_no) as operation_codes \\n  from emr_temp_ip_patient_operation\\n  group by inp_no, visit_id \\n)\\nselect \\n  t.patientid, \\n  t.patientname, \\n  t.age,\\n  t.gender, \\n  t.indate, \\n  t.outdate, \\n  t.inhospitaltimes, \\n  d.type,\\n  d.diagnosis_codes as diagnosiscode,\\n  o.operation_codes as operationcode,\\n  t.medicalcost, \\n  t.persontype, \\n  t.entrymode, \\n  t.serialno, \\n  t.defaulttab,\\n  d.chinese_diagnosis_codes as chinesediagnosiscode,\\n  d.chinese_diagnosis_names as chinesediagnosename,\\n  t.deptcode, \\n  t.citycode \\nfrom tmep_ip t \\nleft join diagnosis_end d on t.patientid = d.inp_no and t.inhospitaltimes::varchar = d.times\\nleft join operations o on t.patientid = o.inp_no and t.inhospitaltimes::varchar = o.times\\nwhere t.outdate > '2025-01-01'\\norder by t.outdate desc\", \"explain\": \"QUERY PLAN\\nSort  (cost=445130.58..445963.91 rows=333333 width=308)\\n  Sort Key: (date(a.out_date)) DESC\\n  ->  Merge Left Join  (cost=64922.35..318848.93 rows=333333 width=308)\\n  Merge Cond: (((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))\\n  ->  Gather Merge  (cost=64668.41..197286.44 rows=333333 width=111)\\n  Workers Planned: 2\\n  ->  Merge Left Join  (cost=63668.38..157811.52 rows=138889 width=111)\\n  Merge Cond: (((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))\\n  ->  Sort  (cost=63667.28..64014.50 rows=138889 width=79)\\n  Sort Key: a.register_no, a.times\\n  ->  Parallel Hash Right Join  (cost=24279.33..45629.67 rows=138889 width=79)\\n  Hash Cond: (((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))\\n  ->  Parallel Seq Scan on his_temp_ip_settle b  (cost=0.00..11519.67 rows=416667 width=22)\\n  ->  Parallel Hash  (cost=20432.00..20432.00 rows=138889 width=73)\\n  ->  Parallel Seq Scan on his_temp_ip_patient_info a  (cost=0.00..20432.00 rows=138889 width=73)\\n  Filter: (date(out_date) > '2025-01-01'::date)\\n  ->  GroupAggregate  (cost=1.11..91601.88 rows=100000 width=44)\\n  Group Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\\n  ->  Incremental Sort  (cost=1.11..82851.88 rows=1000000 width=25)\\n  Sort Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id, emr_temp_ip_patient_operation.operation_no\\n  Presorted Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\\n  ->  Index Scan using idx_emr_temp_ip_patient_operation_inp_visit on emr_temp_ip_patient_operation  (cost=0.42..51742.24 rows=1000000 width=25)\\n  ->  Materialize  (cost=253.95..118226.71 rows=489 width=121)\\n  ->  GroupAggregate  (cost=253.95..118220.60 rows=489 width=134)\\n  Group Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\\n  ->  Incremental Sort  (cost=253.95..118203.21 rows=500 width=136)\\n  Sort Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\\n  Presorted Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type\\n  ->  Subquery Scan on diagnosis_ranked  (cost=12.28..118181.09 rows=500 width=136)\\n  Filter: (diagnosis_ranked.rn = 1)\\n  ->  WindowAgg  (cost=12.28..116931.09 rows=100000 width=148)\\n  Run Condition: (row_number() OVER (?) <= 1)\\n  ->  Incremental Sort  (cost=12.28..112681.09 rows=100000 width=140)\\n  Sort Key: diagnosis.inp_no, diagnosis.times, diagnosis.type, (CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\\n  Presorted Key: diagnosis.inp_no, diagnosis.times, diagnosis.type\\n  ->  Subquery Scan on diagnosis  (cost=1.16..109570.13 rows=100000 width=140)\\n  ->  GroupAggregate  (cost=1.16..107570.13 rows=100000 width=136)\\n  Group Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag\\n  ->  Incremental Sort  (cost=1.16..87820.13 rows=1000000 width=76)\\n  Sort Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag, emr_temp_ip_patient_diagnosis.diagnosis_no\\n  Presorted Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id\\n  ->  Index Scan using idx_emr_temp_ip_patient_diagnosis_file_visit on emr_temp_ip_patient_diagnosis  (cost=0.42..56710.49 rows=1000000 width=76)\\n  Index Cond: ((file_visit_type)::text = '2'::text)\\nJIT:\\n  Functions: 59\\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 445130.58, 'Total Cost': 445963.91, 'Plan Rows': 333333, 'Plan Width': 308, 'Sort Key': ['(date(a.out_date)) DESC'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 64922.35, 'Total Cost': 318848.93, 'Plan Rows': 333333, 'Plan Width': 308, 'Inner Unique': False, 'Merge Cond': '(((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))', 'Plans': [{'Node Type': 'Gather Merge', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 64668.41, 'Total Cost': 197286.44, 'Plan Rows': 333333, 'Plan Width': 111, 'Workers Planned': 2, 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 63668.38, 'Total Cost': 157811.52, 'Plan Rows': 138889, 'Plan Width': 111, 'Inner Unique': True, 'Merge Cond': '(((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))', 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 63667.28, 'Total Cost': 64014.5, 'Plan Rows': 138889, 'Plan Width': 79, 'Sort Key': ['a.register_no', 'a.times'], 'Plans': [{'Node Type': 'Hash Join', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Join Type': 'Right', 'Startup Cost': 24279.33, 'Total Cost': 45629.67, 'Plan Rows': 138889, 'Plan Width': 79, 'Inner Unique': False, 'Hash Cond': '(((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_settle', 'Alias': 'b', 'Startup Cost': 0.0, 'Total Cost': 11519.67, 'Plan Rows': 416667, 'Plan Width': 22}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': True, 'Async Capable': False, 'Startup Cost': 20432.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_patient_info', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Filter': \\\"(date(out_date) > '2025-01-01'::date)\\\"}]}]}]}, {'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 91601.88, 'Plan Rows': 100000, 'Plan Width': 44, 'Group Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 82851.88, 'Plan Rows': 1000000, 'Plan Width': 25, 'Sort Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id', 'emr_temp_ip_patient_operation.operation_no'], 'Presorted Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_operation_inp_visit', 'Relation Name': 'emr_temp_ip_patient_operation', 'Alias': 'emr_temp_ip_patient_operation', 'Startup Cost': 0.42, 'Total Cost': 51742.24, 'Plan Rows': 1000000, 'Plan Width': 25}]}]}]}]}, {'Node Type': 'Materialize', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118226.71, 'Plan Rows': 489, 'Plan Width': 121, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118220.6, 'Plan Rows': 489, 'Plan Width': 134, 'Group Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118203.21, 'Plan Rows': 500, 'Plan Width': 136, 'Sort Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Presorted Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis_ranked', 'Startup Cost': 12.28, 'Total Cost': 118181.09, 'Plan Rows': 500, 'Plan Width': 136, 'Filter': '(diagnosis_ranked.rn = 1)', 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 116931.09, 'Plan Rows': 100000, 'Plan Width': 148, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 112681.09, 'Plan Rows': 100000, 'Plan Width': 140, 'Sort Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type', \\\"(CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\\\"], 'Presorted Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis', 'Startup Cost': 1.16, 'Total Cost': 109570.13, 'Plan Rows': 100000, 'Plan Width': 140, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 107570.13, 'Plan Rows': 100000, 'Plan Width': 136, 'Group Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 87820.13, 'Plan Rows': 1000000, 'Plan Width': 76, 'Sort Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag', 'emr_temp_ip_patient_diagnosis.diagnosis_no'], 'Presorted Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_diagnosis_file_visit', 'Relation Name': 'emr_temp_ip_patient_diagnosis', 'Alias': 'emr_temp_ip_patient_diagnosis', 'Startup Cost': 0.42, 'Total Cost': 56710.49, 'Plan Rows': 1000000, 'Plan Width': 76, 'Index Cond': \\\"((file_visit_type)::text = '2'::text)\\\"}]}]}]}]}]}]}]}]}]}]}]}, 'JIT': {'Functions': 59, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,应用投影下推优化：移除diagnosis_end中未使用的diagnosis_type_name列，消除分组操作中冗余列并精简临时表。诊断结果数据列未受影响，但查询效率显著提升。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,成功将外层WHERE条件下推到tmep_ip CTE：1) 过滤条件使用date(a.out_date)原生字段，高效利用索引 2) 提前过滤降低后续所有CTE计算量 3) 诊断CTE的窗口函数避免全局排序\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE his_temp_ip_patient_info (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, inpatient_name VARCHAR(100), age INTEGER, sex VARCHAR(10), in_date TIMESTAMP, out_date TIMESTAMP, times VARCHAR(20), person_type VARCHAR(50), patient_no VARCHAR(50), current_dept_code VARCHAR(50));\nCREATE INDEX idx_his_temp_ip_patient_info_register_no_times ON his_temp_ip_patient_info(register_no, times);\nCREATE INDEX idx_his_temp_ip_patient_info_out_date ON his_temp_ip_patient_info(out_date);\nCREATE TABLE his_temp_ip_settle (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, times VARCHAR(20) NOT NULL, total_cost DECIMAL(12,2));\nCREATE INDEX idx_his_temp_ip_settle_register_no_times ON his_temp_ip_settle(register_no, times);\nCREATE TABLE emr_temp_ip_patient_diagnosis (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, type VARCHAR(50), diagnosis_type_name VARCHAR(100), diagnosis_flag VARCHAR(1), diagnosis_code VARCHAR(50), diagnosis_name VARCHAR(200), diagnosis_no INTEGER, file_visit_type VARCHAR(10));\nCREATE INDEX idx_emr_temp_ip_patient_diagnosis_file_visit ON emr_temp_ip_patient_diagnosis(file_visit_type, inp_no, visit_id);\nCREATE INDEX idx_emr_temp_ip_patient_diagnosis_group ON emr_temp_ip_patient_diagnosis(inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag);\nCREATE TABLE emr_temp_ip_patient_operation (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, operation_code VARCHAR(50), operation_no INTEGER);\nCREATE INDEX idx_emr_temp_ip_patient_operation_inp_visit ON emr_temp_ip_patient_operation(inp_no, visit_id);\n\n## Explain Output in JSON:\nQUERY PLAN\nSort  (cost=445130.58..445963.91 rows=333333 width=308)\n  Sort Key: (date(a.out_date)) DESC\n  ->  Merge Left Join  (cost=64922.35..318848.93 rows=333333 width=308)\n  Merge Cond: (((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))\n  ->  Gather Merge  (cost=64668.41..197286.44 rows=333333 width=111)\n  Workers Planned: 2\n  ->  Merge Left Join  (cost=63668.38..157811.52 rows=138889 width=111)\n  Merge Cond: (((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))\n  ->  Sort  (cost=63667.28..64014.50 rows=138889 width=79)\n  Sort Key: a.register_no, a.times\n  ->  Parallel Hash Right Join  (cost=24279.33..45629.67 rows=138889 width=79)\n  Hash Cond: (((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))\n  ->  Parallel Seq Scan on his_temp_ip_settle b  (cost=0.00..11519.67 rows=416667 width=22)\n  ->  Parallel Hash  (cost=20432.00..20432.00 rows=138889 width=73)\n  ->  Parallel Seq Scan on his_temp_ip_patient_info a  (cost=0.00..20432.00 rows=138889 width=73)\n  Filter: (date(out_date) > '2025-01-01'::date)\n  ->  GroupAggregate  (cost=1.11..91601.88 rows=100000 width=44)\n  Group Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\n  ->  Incremental Sort  (cost=1.11..82851.88 rows=1000000 width=25)\n  Sort Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id, emr_temp_ip_patient_operation.operation_no\n  Presorted Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\n  ->  Index Scan using idx_emr_temp_ip_patient_operation_inp_visit on emr_temp_ip_patient_operation  (cost=0.42..51742.24 rows=1000000 width=25)\n  ->  Materialize  (cost=253.95..118226.71 rows=489 width=121)\n  ->  GroupAggregate  (cost=253.95..118220.60 rows=489 width=134)\n  Group Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\n  ->  Incremental Sort  (cost=253.95..118203.21 rows=500 width=136)\n  Sort Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\n  Presorted Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type\n  ->  Subquery Scan on diagnosis_ranked  (cost=12.28..118181.09 rows=500 width=136)\n  Filter: (diagnosis_ranked.rn = 1)\n  ->  WindowAgg  (cost=12.28..116931.09 rows=100000 width=148)\n  Run Condition: (row_number() OVER (?) <= 1)\n  ->  Incremental Sort  (cost=12.28..112681.09 rows=100000 width=140)\n  Sort Key: diagnosis.inp_no, diagnosis.times, diagnosis.type, (CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\n  Presorted Key: diagnosis.inp_no, diagnosis.times, diagnosis.type\n  ->  Subquery Scan on diagnosis  (cost=1.16..109570.13 rows=100000 width=140)\n  ->  GroupAggregate  (cost=1.16..107570.13 rows=100000 width=136)\n  Group Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag\n  ->  Incremental Sort  (cost=1.16..87820.13 rows=1000000 width=76)\n  Sort Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag, emr_temp_ip_patient_diagnosis.diagnosis_no\n  Presorted Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id\n  ->  Index Scan using idx_emr_temp_ip_patient_diagnosis_file_visit on emr_temp_ip_patient_diagnosis  (cost=0.42..56710.49 rows=1000000 width=76)\n  Index Cond: ((file_visit_type)::text = '2'::text)\nJIT:\n  Functions: 59\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 445130.58, 'Total Cost': 445963.91, 'Plan Rows': 333333, 'Plan Width': 308, 'Sort Key': ['(date(a.out_date)) DESC'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 64922.35, 'Total Cost': 318848.93, 'Plan Rows': 333333, 'Plan Width': 308, 'Inner Unique': False, 'Merge Cond': '(((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))', 'Plans': [{'Node Type': 'Gather Merge', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 64668.41, 'Total Cost': 197286.44, 'Plan Rows': 333333, 'Plan Width': 111, 'Workers Planned': 2, 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 63668.38, 'Total Cost': 157811.52, 'Plan Rows': 138889, 'Plan Width': 111, 'Inner Unique': True, 'Merge Cond': '(((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))', 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 63667.28, 'Total Cost': 64014.5, 'Plan Rows': 138889, 'Plan Width': 79, 'Sort Key': ['a.register_no', 'a.times'], 'Plans': [{'Node Type': 'Hash Join', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Join Type': 'Right', 'Startup Cost': 24279.33, 'Total Cost': 45629.67, 'Plan Rows': 138889, 'Plan Width': 79, 'Inner Unique': False, 'Hash Cond': '(((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_settle', 'Alias': 'b', 'Startup Cost': 0.0, 'Total Cost': 11519.67, 'Plan Rows': 416667, 'Plan Width': 22}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': True, 'Async Capable': False, 'Startup Cost': 20432.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_patient_info', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Filter': \"(date(out_date) > '2025-01-01'::date)\"}]}]}]}, {'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 91601.88, 'Plan Rows': 100000, 'Plan Width': 44, 'Group Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 82851.88, 'Plan Rows': 1000000, 'Plan Width': 25, 'Sort Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id', 'emr_temp_ip_patient_operation.operation_no'], 'Presorted Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_operation_inp_visit', 'Relation Name': 'emr_temp_ip_patient_operation', 'Alias': 'emr_temp_ip_patient_operation', 'Startup Cost': 0.42, 'Total Cost': 51742.24, 'Plan Rows': 1000000, 'Plan Width': 25}]}]}]}]}, {'Node Type': 'Materialize', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118226.71, 'Plan Rows': 489, 'Plan Width': 121, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118220.6, 'Plan Rows': 489, 'Plan Width': 134, 'Group Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118203.21, 'Plan Rows': 500, 'Plan Width': 136, 'Sort Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Presorted Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis_ranked', 'Startup Cost': 12.28, 'Total Cost': 118181.09, 'Plan Rows': 500, 'Plan Width': 136, 'Filter': '(diagnosis_ranked.rn = 1)', 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 116931.09, 'Plan Rows': 100000, 'Plan Width': 148, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 112681.09, 'Plan Rows': 100000, 'Plan Width': 140, 'Sort Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type', \"(CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\"], 'Presorted Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis', 'Startup Cost': 1.16, 'Total Cost': 109570.13, 'Plan Rows': 100000, 'Plan Width': 140, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 107570.13, 'Plan Rows': 100000, 'Plan Width': 136, 'Group Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 87820.13, 'Plan Rows': 1000000, 'Plan Width': 76, 'Sort Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag', 'emr_temp_ip_patient_diagnosis.diagnosis_no'], 'Presorted Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_diagnosis_file_visit', 'Relation Name': 'emr_temp_ip_patient_diagnosis', 'Alias': 'emr_temp_ip_patient_diagnosis', 'Startup Cost': 0.42, 'Total Cost': 56710.49, 'Plan Rows': 1000000, 'Plan Width': 76, 'Index Cond': \"((file_visit_type)::text = '2'::text)\"}]}]}]}]}]}]}]}]}]}]}]}, 'JIT': {'Functions': 59, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\n\n## Original SQL:\nwith tmep_ip as (\n  select \n  a.register_no as patientid, \n  a.inpatient_name as patientname, \n  a.age,\n  a.sex as gender, \n  date(a.in_date) as indate, \n  date(a.out_date) as outdate,\n  a.times as inhospitaltimes, \n  a.person_type as persontype, \n  a.patient_no as serialno,\n  b.total_cost as medicalcost, \n  'doctor' as entrymode, \n  'remind' as defaulttab,\n  a.current_dept_code as deptcode, \n  '440100' as citycode \n  from his_temp_ip_patient_info a \n  left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times\n),\ndiagnosis as (\n  select \n  inp_no, \n  visit_id as times, \n  type, \n  diagnosis_type_name,\n  diagnosis_flag,\n  case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes,\n  case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes,\n  case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names \n  from emr_temp_ip_patient_diagnosis \n  where file_visit_type = '2'\n  group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag\n),\ndiagnosis_ranked as (\n  select \n  *,\n  row_number() over (\n   partition by inp_no, times, type \n   order by \n  case \n  when type = '病历诊断' and diagnosis_type_name = '最后诊断' then 1\n  when type = '病历诊断' and diagnosis_type_name = '初步诊断' then 2\n  when type = '首页诊断' and diagnosis_type_name = '出院诊断' then 1\n  when type = '首页诊断' and diagnosis_type_name = '门诊诊断' then 2\n  else 3\n  end\n  ) as rn\n  from diagnosis\n),\ndiagnosis_end as (\n  select \n  inp_no, \n  times, \n  type, \n  diagnosis_type_name,\n  max(case when diagnosis_flag = '1' then diagnosis_codes end) as diagnosis_codes,\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_codes end) as chinese_diagnosis_codes,\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_names end) as chinese_diagnosis_names\n  from diagnosis_ranked\n  where rn = 1\n  group by inp_no, times, type, diagnosis_type_name\n),\noperations as (\n  select \n  inp_no, \n  visit_id as times, \n  string_agg(operation_code, ',' order by operation_no) as operation_codes \n  from emr_temp_ip_patient_operation\n  group by inp_no, visit_id \n)\nselect \n  t.patientid, \n  t.patientname, \n  t.age,\n  t.gender, \n  t.indate, \n  t.outdate, \n  t.inhospitaltimes, \n  d.type,\n  d.diagnosis_codes as diagnosiscode,\n  o.operation_codes as operationcode,\n  t.medicalcost, \n  t.persontype, \n  t.entrymode, \n  t.serialno, \n  t.defaulttab,\n  d.chinese_diagnosis_codes as chinesediagnosiscode,\n  d.chinese_diagnosis_names as chinesediagnosename,\n  t.deptcode, \n  t.citycode \nfrom tmep_ip t \nleft join diagnosis_end d on t.patientid = d.inp_no and t.inhospitaltimes::varchar = d.times\nleft join operations o on t.patientid = o.inp_no and t.inhospitaltimes::varchar = o.times\nwhere t.outdate > '2025-01-01'\norder by t.outdate desc\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "with filtered_ip as (select a.register_no, a.inpatient_name, a.age, a.sex, a.in_date, a.out_date, a.times, a.person_type, a.patient_no, a.current_dept_code, b.total_cost from his_temp_ip_patient_info a left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times where a.out_date >= '2025-01-02'::timestamp), diagnosis as (select inp_no, visit_id as times, type, diagnosis_type_name, diagnosis_flag, case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes, case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes, case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names from emr_temp_ip_patient_diagnosis where file_visit_type = '2' group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag), diagnosis_ranked as (select *, row_number() over (partition by inp_no, times, type order by case when type='病历诊断' and diagnosis_type_name='最后诊断' then 1 when type='病历诊断' and diagnosis_type_name='初步诊断' then 2 when type='首页诊断' and diagnosis_type_name='出院诊断' then 1 when type='首页诊断' and diagnosis_type_name='门诊诊断' then 2 else 3 end) as rn from diagnosis), diagnosis_final as (select inp_no, times, type, diagnosis_type_name, max(case when diagnosis_flag='1' then diagnosis_codes end) as diagnosis_codes, max(case when diagnosis_flag='0' then chinese_diagnosis_codes end) as chinese_diagnosis_codes, max(case when diagnosis_flag='0' then chinese_diagnosis_names end) as chinese_diagnosis_names from diagnosis_ranked where rn = 1 group by inp_no, times, type, diagnosis_type_name), operations as (select inp_no, visit_id as times, string_agg(operation_code, ',' order by operation_no) as operation_codes from emr_temp_ip_patient_operation group by inp_no, visit_id) select t.register_no as patientid, t.inpatient_name as patientname, t.age, t.sex as gender, date(t.in_date) as indate, date(t.out_date) as outdate, t.times as inhospitaltimes, d.type, d.diagnosis_codes as diagnosiscode, o.operation_codes as operationcode, t.total_cost as medicalcost, t.person_type as persontype, 'doctor' as entrymode, t.patient_no as serialno, 'remind' as defaulttab, d.chinese_diagnosis_codes as chinesediagnosiscode, d.chinese_diagnosis_names as chinesediagnosename, t.current_dept_code as deptcode, '440100' as citycode from filtered_ip t left join diagnosis_final d on t.register_no = d.inp_no and t.times = d.times left join operations o on t.register_no = o.inp_no and t.times = o.times order by t.out_date desc;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "32",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"32\", \"db_type\": \"postgresql\", \"description\": \"本次改写采用了经典的查询优化技术组合：\\n\\n1. **谓词下推（Predicate Pushdown）**：将out_date的过滤条件从最外层WHERE子句移到tmep_ip CTE内部。这样可以尽早过滤数据，减少CTE物化的数据量，虽然在本例中优化器已经将过滤推到了Parallel Seq Scan阶段，但显式下推使逻辑更清晰，且在某些复杂场景下能帮助优化器更好地生成执行计划。\\n\\n2. **投影裁剪（Column Pruning）**：在diagnosis_ranked子查询中，移除了不再需要的diagnosis_type_name字段。该字段仅用于窗口函数的排序，在rn=1筛选后就没有实际意义了，因此在WindowAgg之后立即裁剪，避免传递到上层的GroupAggregate和Materialize节点。\\n\\n3. **聚合维度优化**：diagnosis_end的GROUP BY从4个字段减少到3个字段。因为diagnosis_type_name在窗口函数排序后已被隐含使用（通过rn=1保证了每组只保留优先级最高的记录），在最终聚合时不需要再作为分组键。这减少了哈希表的键空间和比较开销。\\n\\n4. **逻辑等价性保证**：虽然进行了多处优化，但查询的核心逻辑保持不变：\\n   - 诊断类型的优先级排序规则完全一致\\n   - ROW_NUMBER()窗口函数的分区和排序逻辑相同\\n   - MAX聚合对diagnosis_flag分组的处理逻辑相同\\n   - 最终JOIN关联条件和结果集完全一致\", \"create_table_statements\": [\"CREATE TABLE his_temp_ip_patient_info (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, inpatient_name VARCHAR(100), age INTEGER, sex VARCHAR(10), in_date TIMESTAMP, out_date TIMESTAMP, times VARCHAR(20), person_type VARCHAR(50), patient_no VARCHAR(50), current_dept_code VARCHAR(50));\", \"CREATE INDEX idx_his_temp_ip_patient_info_register_no_times ON his_temp_ip_patient_info(register_no, times);\", \"CREATE INDEX idx_his_temp_ip_patient_info_out_date ON his_temp_ip_patient_info(out_date);\", \"CREATE TABLE his_temp_ip_settle (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, times VARCHAR(20) NOT NULL, total_cost DECIMAL(12,2));\", \"CREATE INDEX idx_his_temp_ip_settle_register_no_times ON his_temp_ip_settle(register_no, times);\", \"CREATE TABLE emr_temp_ip_patient_diagnosis (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, type VARCHAR(50), diagnosis_type_name VARCHAR(100), diagnosis_flag VARCHAR(1), diagnosis_code VARCHAR(50), diagnosis_name VARCHAR(200), diagnosis_no INTEGER, file_visit_type VARCHAR(10));\", \"CREATE INDEX idx_emr_temp_ip_patient_diagnosis_file_visit ON emr_temp_ip_patient_diagnosis(file_visit_type, inp_no, visit_id);\", \"CREATE INDEX idx_emr_temp_ip_patient_diagnosis_group ON emr_temp_ip_patient_diagnosis(inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag);\", \"CREATE TABLE emr_temp_ip_patient_operation (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, operation_code VARCHAR(50), operation_no INTEGER);\", \"CREATE INDEX idx_emr_temp_ip_patient_operation_inp_visit ON emr_temp_ip_patient_operation(inp_no, visit_id);\"], \"sql\": \"with tmep_ip as (\\n  select \\n  a.register_no as patientid, \\n  a.inpatient_name as patientname, \\n  a.age,\\n  a.sex as gender, \\n  date(a.in_date) as indate, \\n  date(a.out_date) as outdate,\\n  a.times as inhospitaltimes, \\n  a.person_type as persontype, \\n  a.patient_no as serialno,\\n  b.total_cost as medicalcost, \\n  'doctor' as entrymode, \\n  'remind' as defaulttab,\\n  a.current_dept_code as deptcode, \\n  '440100' as citycode \\n  from his_temp_ip_patient_info a \\n  left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times\\n),\\ndiagnosis as (\\n  select \\n  inp_no, \\n  visit_id as times, \\n  type, \\n  diagnosis_type_name,\\n  diagnosis_flag,\\n  case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes,\\n  case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes,\\n  case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names \\n  from emr_temp_ip_patient_diagnosis \\n  where file_visit_type = '2'\\n  group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag\\n),\\ndiagnosis_ranked as (\\n  select \\n  *,\\n  row_number() over (\\n   partition by inp_no, times, type \\n   order by \\n  case \\n  when type = '病历诊断' and diagnosis_type_name = '最后诊断' then 1\\n  when type = '病历诊断' and diagnosis_type_name = '初步诊断' then 2\\n  when type = '首页诊断' and diagnosis_type_name = '出院诊断' then 1\\n  when type = '首页诊断' and diagnosis_type_name = '门诊诊断' then 2\\n  else 3\\n  end\\n  ) as rn\\n  from diagnosis\\n),\\ndiagnosis_end as (\\n  select \\n  inp_no, \\n  times, \\n  type, \\n  diagnosis_type_name,\\n  max(case when diagnosis_flag = '1' then diagnosis_codes end) as diagnosis_codes,\\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_codes end) as chinese_diagnosis_codes,\\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_names end) as chinese_diagnosis_names\\n  from diagnosis_ranked\\n  where rn = 1\\n  group by inp_no, times, type, diagnosis_type_name\\n),\\noperations as (\\n  select \\n  inp_no, \\n  visit_id as times, \\n  string_agg(operation_code, ',' order by operation_no) as operation_codes \\n  from emr_temp_ip_patient_operation\\n  group by inp_no, visit_id \\n)\\nselect \\n  t.patientid, \\n  t.patientname, \\n  t.age,\\n  t.gender, \\n  t.indate, \\n  t.outdate, \\n  t.inhospitaltimes, \\n  d.type,\\n  d.diagnosis_codes as diagnosiscode,\\n  o.operation_codes as operationcode,\\n  t.medicalcost, \\n  t.persontype, \\n  t.entrymode, \\n  t.serialno, \\n  t.defaulttab,\\n  d.chinese_diagnosis_codes as chinesediagnosiscode,\\n  d.chinese_diagnosis_names as chinesediagnosename,\\n  t.deptcode, \\n  t.citycode \\nfrom tmep_ip t \\nleft join diagnosis_end d on t.patientid = d.inp_no and t.inhospitaltimes::varchar = d.times\\nleft join operations o on t.patientid = o.inp_no and t.inhospitaltimes::varchar = o.times\\nwhere t.outdate > '2025-01-01'\\norder by t.outdate desc\", \"explain\": \"QUERY PLAN\\nSort  (cost=445130.58..445963.91 rows=333333 width=308)\\n  Sort Key: (date(a.out_date)) DESC\\n  ->  Merge Left Join  (cost=64922.35..318848.93 rows=333333 width=308)\\n  Merge Cond: (((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))\\n  ->  Gather Merge  (cost=64668.41..197286.44 rows=333333 width=111)\\n  Workers Planned: 2\\n  ->  Merge Left Join  (cost=63668.38..157811.52 rows=138889 width=111)\\n  Merge Cond: (((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))\\n  ->  Sort  (cost=63667.28..64014.50 rows=138889 width=79)\\n  Sort Key: a.register_no, a.times\\n  ->  Parallel Hash Right Join  (cost=24279.33..45629.67 rows=138889 width=79)\\n  Hash Cond: (((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))\\n  ->  Parallel Seq Scan on his_temp_ip_settle b  (cost=0.00..11519.67 rows=416667 width=22)\\n  ->  Parallel Hash  (cost=20432.00..20432.00 rows=138889 width=73)\\n  ->  Parallel Seq Scan on his_temp_ip_patient_info a  (cost=0.00..20432.00 rows=138889 width=73)\\n  Filter: (date(out_date) > '2025-01-01'::date)\\n  ->  GroupAggregate  (cost=1.11..91601.88 rows=100000 width=44)\\n  Group Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\\n  ->  Incremental Sort  (cost=1.11..82851.88 rows=1000000 width=25)\\n  Sort Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id, emr_temp_ip_patient_operation.operation_no\\n  Presorted Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\\n  ->  Index Scan using idx_emr_temp_ip_patient_operation_inp_visit on emr_temp_ip_patient_operation  (cost=0.42..51742.24 rows=1000000 width=25)\\n  ->  Materialize  (cost=253.95..118226.71 rows=489 width=121)\\n  ->  GroupAggregate  (cost=253.95..118220.60 rows=489 width=134)\\n  Group Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\\n  ->  Incremental Sort  (cost=253.95..118203.21 rows=500 width=136)\\n  Sort Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\\n  Presorted Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type\\n  ->  Subquery Scan on diagnosis_ranked  (cost=12.28..118181.09 rows=500 width=136)\\n  Filter: (diagnosis_ranked.rn = 1)\\n  ->  WindowAgg  (cost=12.28..116931.09 rows=100000 width=148)\\n  Run Condition: (row_number() OVER (?) <= 1)\\n  ->  Incremental Sort  (cost=12.28..112681.09 rows=100000 width=140)\\n  Sort Key: diagnosis.inp_no, diagnosis.times, diagnosis.type, (CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\\n  Presorted Key: diagnosis.inp_no, diagnosis.times, diagnosis.type\\n  ->  Subquery Scan on diagnosis  (cost=1.16..109570.13 rows=100000 width=140)\\n  ->  GroupAggregate  (cost=1.16..107570.13 rows=100000 width=136)\\n  Group Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag\\n  ->  Incremental Sort  (cost=1.16..87820.13 rows=1000000 width=76)\\n  Sort Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag, emr_temp_ip_patient_diagnosis.diagnosis_no\\n  Presorted Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id\\n  ->  Index Scan using idx_emr_temp_ip_patient_diagnosis_file_visit on emr_temp_ip_patient_diagnosis  (cost=0.42..56710.49 rows=1000000 width=76)\\n  Index Cond: ((file_visit_type)::text = '2'::text)\\nJIT:\\n  Functions: 59\\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 445130.58, 'Total Cost': 445963.91, 'Plan Rows': 333333, 'Plan Width': 308, 'Sort Key': ['(date(a.out_date)) DESC'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 64922.35, 'Total Cost': 318848.93, 'Plan Rows': 333333, 'Plan Width': 308, 'Inner Unique': False, 'Merge Cond': '(((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))', 'Plans': [{'Node Type': 'Gather Merge', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 64668.41, 'Total Cost': 197286.44, 'Plan Rows': 333333, 'Plan Width': 111, 'Workers Planned': 2, 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 63668.38, 'Total Cost': 157811.52, 'Plan Rows': 138889, 'Plan Width': 111, 'Inner Unique': True, 'Merge Cond': '(((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))', 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 63667.28, 'Total Cost': 64014.5, 'Plan Rows': 138889, 'Plan Width': 79, 'Sort Key': ['a.register_no', 'a.times'], 'Plans': [{'Node Type': 'Hash Join', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Join Type': 'Right', 'Startup Cost': 24279.33, 'Total Cost': 45629.67, 'Plan Rows': 138889, 'Plan Width': 79, 'Inner Unique': False, 'Hash Cond': '(((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_settle', 'Alias': 'b', 'Startup Cost': 0.0, 'Total Cost': 11519.67, 'Plan Rows': 416667, 'Plan Width': 22}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': True, 'Async Capable': False, 'Startup Cost': 20432.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_patient_info', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Filter': \\\"(date(out_date) > '2025-01-01'::date)\\\"}]}]}]}, {'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 91601.88, 'Plan Rows': 100000, 'Plan Width': 44, 'Group Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 82851.88, 'Plan Rows': 1000000, 'Plan Width': 25, 'Sort Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id', 'emr_temp_ip_patient_operation.operation_no'], 'Presorted Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_operation_inp_visit', 'Relation Name': 'emr_temp_ip_patient_operation', 'Alias': 'emr_temp_ip_patient_operation', 'Startup Cost': 0.42, 'Total Cost': 51742.24, 'Plan Rows': 1000000, 'Plan Width': 25}]}]}]}]}, {'Node Type': 'Materialize', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118226.71, 'Plan Rows': 489, 'Plan Width': 121, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118220.6, 'Plan Rows': 489, 'Plan Width': 134, 'Group Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118203.21, 'Plan Rows': 500, 'Plan Width': 136, 'Sort Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Presorted Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis_ranked', 'Startup Cost': 12.28, 'Total Cost': 118181.09, 'Plan Rows': 500, 'Plan Width': 136, 'Filter': '(diagnosis_ranked.rn = 1)', 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 116931.09, 'Plan Rows': 100000, 'Plan Width': 148, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 112681.09, 'Plan Rows': 100000, 'Plan Width': 140, 'Sort Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type', \\\"(CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\\\"], 'Presorted Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis', 'Startup Cost': 1.16, 'Total Cost': 109570.13, 'Plan Rows': 100000, 'Plan Width': 140, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 107570.13, 'Plan Rows': 100000, 'Plan Width': 136, 'Group Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 87820.13, 'Plan Rows': 1000000, 'Plan Width': 76, 'Sort Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag', 'emr_temp_ip_patient_diagnosis.diagnosis_no'], 'Presorted Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_diagnosis_file_visit', 'Relation Name': 'emr_temp_ip_patient_diagnosis', 'Alias': 'emr_temp_ip_patient_diagnosis', 'Startup Cost': 0.42, 'Total Cost': 56710.49, 'Plan Rows': 1000000, 'Plan Width': 76, 'Index Cond': \\\"((file_visit_type)::text = '2'::text)\\\"}]}]}]}]}]}]}]}]}]}]}]}, 'JIT': {'Functions': 59, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,应用投影下推优化：移除diagnosis_end中未使用的diagnosis_type_name列，消除分组操作中冗余列并精简临时表。诊断结果数据列未受影响，但查询效率显著提升。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,成功将外层WHERE条件下推到tmep_ip CTE：1) 过滤条件使用date(a.out_date)原生字段，高效利用索引 2) 提前过滤降低后续所有CTE计算量 3) 诊断CTE的窗口函数避免全局排序\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE his_temp_ip_patient_info (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, inpatient_name VARCHAR(100), age INTEGER, sex VARCHAR(10), in_date TIMESTAMP, out_date TIMESTAMP, times VARCHAR(20), person_type VARCHAR(50), patient_no VARCHAR(50), current_dept_code VARCHAR(50));\nCREATE INDEX idx_his_temp_ip_patient_info_register_no_times ON his_temp_ip_patient_info(register_no, times);\nCREATE INDEX idx_his_temp_ip_patient_info_out_date ON his_temp_ip_patient_info(out_date);\nCREATE TABLE his_temp_ip_settle (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, times VARCHAR(20) NOT NULL, total_cost DECIMAL(12,2));\nCREATE INDEX idx_his_temp_ip_settle_register_no_times ON his_temp_ip_settle(register_no, times);\nCREATE TABLE emr_temp_ip_patient_diagnosis (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, type VARCHAR(50), diagnosis_type_name VARCHAR(100), diagnosis_flag VARCHAR(1), diagnosis_code VARCHAR(50), diagnosis_name VARCHAR(200), diagnosis_no INTEGER, file_visit_type VARCHAR(10));\nCREATE INDEX idx_emr_temp_ip_patient_diagnosis_file_visit ON emr_temp_ip_patient_diagnosis(file_visit_type, inp_no, visit_id);\nCREATE INDEX idx_emr_temp_ip_patient_diagnosis_group ON emr_temp_ip_patient_diagnosis(inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag);\nCREATE TABLE emr_temp_ip_patient_operation (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, operation_code VARCHAR(50), operation_no INTEGER);\nCREATE INDEX idx_emr_temp_ip_patient_operation_inp_visit ON emr_temp_ip_patient_operation(inp_no, visit_id);\n\n## Explain Output in JSON:\nQUERY PLAN\nSort  (cost=445130.58..445963.91 rows=333333 width=308)\n  Sort Key: (date(a.out_date)) DESC\n  ->  Merge Left Join  (cost=64922.35..318848.93 rows=333333 width=308)\n  Merge Cond: (((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))\n  ->  Gather Merge  (cost=64668.41..197286.44 rows=333333 width=111)\n  Workers Planned: 2\n  ->  Merge Left Join  (cost=63668.38..157811.52 rows=138889 width=111)\n  Merge Cond: (((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))\n  ->  Sort  (cost=63667.28..64014.50 rows=138889 width=79)\n  Sort Key: a.register_no, a.times\n  ->  Parallel Hash Right Join  (cost=24279.33..45629.67 rows=138889 width=79)\n  Hash Cond: (((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))\n  ->  Parallel Seq Scan on his_temp_ip_settle b  (cost=0.00..11519.67 rows=416667 width=22)\n  ->  Parallel Hash  (cost=20432.00..20432.00 rows=138889 width=73)\n  ->  Parallel Seq Scan on his_temp_ip_patient_info a  (cost=0.00..20432.00 rows=138889 width=73)\n  Filter: (date(out_date) > '2025-01-01'::date)\n  ->  GroupAggregate  (cost=1.11..91601.88 rows=100000 width=44)\n  Group Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\n  ->  Incremental Sort  (cost=1.11..82851.88 rows=1000000 width=25)\n  Sort Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id, emr_temp_ip_patient_operation.operation_no\n  Presorted Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\n  ->  Index Scan using idx_emr_temp_ip_patient_operation_inp_visit on emr_temp_ip_patient_operation  (cost=0.42..51742.24 rows=1000000 width=25)\n  ->  Materialize  (cost=253.95..118226.71 rows=489 width=121)\n  ->  GroupAggregate  (cost=253.95..118220.60 rows=489 width=134)\n  Group Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\n  ->  Incremental Sort  (cost=253.95..118203.21 rows=500 width=136)\n  Sort Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\n  Presorted Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type\n  ->  Subquery Scan on diagnosis_ranked  (cost=12.28..118181.09 rows=500 width=136)\n  Filter: (diagnosis_ranked.rn = 1)\n  ->  WindowAgg  (cost=12.28..116931.09 rows=100000 width=148)\n  Run Condition: (row_number() OVER (?) <= 1)\n  ->  Incremental Sort  (cost=12.28..112681.09 rows=100000 width=140)\n  Sort Key: diagnosis.inp_no, diagnosis.times, diagnosis.type, (CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\n  Presorted Key: diagnosis.inp_no, diagnosis.times, diagnosis.type\n  ->  Subquery Scan on diagnosis  (cost=1.16..109570.13 rows=100000 width=140)\n  ->  GroupAggregate  (cost=1.16..107570.13 rows=100000 width=136)\n  Group Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag\n  ->  Incremental Sort  (cost=1.16..87820.13 rows=1000000 width=76)\n  Sort Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag, emr_temp_ip_patient_diagnosis.diagnosis_no\n  Presorted Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id\n  ->  Index Scan using idx_emr_temp_ip_patient_diagnosis_file_visit on emr_temp_ip_patient_diagnosis  (cost=0.42..56710.49 rows=1000000 width=76)\n  Index Cond: ((file_visit_type)::text = '2'::text)\nJIT:\n  Functions: 59\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 445130.58, 'Total Cost': 445963.91, 'Plan Rows': 333333, 'Plan Width': 308, 'Sort Key': ['(date(a.out_date)) DESC'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 64922.35, 'Total Cost': 318848.93, 'Plan Rows': 333333, 'Plan Width': 308, 'Inner Unique': False, 'Merge Cond': '(((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))', 'Plans': [{'Node Type': 'Gather Merge', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 64668.41, 'Total Cost': 197286.44, 'Plan Rows': 333333, 'Plan Width': 111, 'Workers Planned': 2, 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 63668.38, 'Total Cost': 157811.52, 'Plan Rows': 138889, 'Plan Width': 111, 'Inner Unique': True, 'Merge Cond': '(((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))', 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 63667.28, 'Total Cost': 64014.5, 'Plan Rows': 138889, 'Plan Width': 79, 'Sort Key': ['a.register_no', 'a.times'], 'Plans': [{'Node Type': 'Hash Join', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Join Type': 'Right', 'Startup Cost': 24279.33, 'Total Cost': 45629.67, 'Plan Rows': 138889, 'Plan Width': 79, 'Inner Unique': False, 'Hash Cond': '(((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_settle', 'Alias': 'b', 'Startup Cost': 0.0, 'Total Cost': 11519.67, 'Plan Rows': 416667, 'Plan Width': 22}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': True, 'Async Capable': False, 'Startup Cost': 20432.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_patient_info', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Filter': \"(date(out_date) > '2025-01-01'::date)\"}]}]}]}, {'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 91601.88, 'Plan Rows': 100000, 'Plan Width': 44, 'Group Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 82851.88, 'Plan Rows': 1000000, 'Plan Width': 25, 'Sort Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id', 'emr_temp_ip_patient_operation.operation_no'], 'Presorted Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_operation_inp_visit', 'Relation Name': 'emr_temp_ip_patient_operation', 'Alias': 'emr_temp_ip_patient_operation', 'Startup Cost': 0.42, 'Total Cost': 51742.24, 'Plan Rows': 1000000, 'Plan Width': 25}]}]}]}]}, {'Node Type': 'Materialize', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118226.71, 'Plan Rows': 489, 'Plan Width': 121, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118220.6, 'Plan Rows': 489, 'Plan Width': 134, 'Group Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118203.21, 'Plan Rows': 500, 'Plan Width': 136, 'Sort Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Presorted Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis_ranked', 'Startup Cost': 12.28, 'Total Cost': 118181.09, 'Plan Rows': 500, 'Plan Width': 136, 'Filter': '(diagnosis_ranked.rn = 1)', 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 116931.09, 'Plan Rows': 100000, 'Plan Width': 148, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 112681.09, 'Plan Rows': 100000, 'Plan Width': 140, 'Sort Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type', \"(CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\"], 'Presorted Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis', 'Startup Cost': 1.16, 'Total Cost': 109570.13, 'Plan Rows': 100000, 'Plan Width': 140, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 107570.13, 'Plan Rows': 100000, 'Plan Width': 136, 'Group Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 87820.13, 'Plan Rows': 1000000, 'Plan Width': 76, 'Sort Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag', 'emr_temp_ip_patient_diagnosis.diagnosis_no'], 'Presorted Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_diagnosis_file_visit', 'Relation Name': 'emr_temp_ip_patient_diagnosis', 'Alias': 'emr_temp_ip_patient_diagnosis', 'Startup Cost': 0.42, 'Total Cost': 56710.49, 'Plan Rows': 1000000, 'Plan Width': 76, 'Index Cond': \"((file_visit_type)::text = '2'::text)\"}]}]}]}]}]}]}]}]}]}]}]}, 'JIT': {'Functions': 59, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\n\n## Original SQL:\nwith tmep_ip as (\n  select \n  a.register_no as patientid, \n  a.inpatient_name as patientname, \n  a.age,\n  a.sex as gender, \n  date(a.in_date) as indate, \n  date(a.out_date) as outdate,\n  a.times as inhospitaltimes, \n  a.person_type as persontype, \n  a.patient_no as serialno,\n  b.total_cost as medicalcost, \n  'doctor' as entrymode, \n  'remind' as defaulttab,\n  a.current_dept_code as deptcode, \n  '440100' as citycode \n  from his_temp_ip_patient_info a \n  left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times\n),\ndiagnosis as (\n  select \n  inp_no, \n  visit_id as times, \n  type, \n  diagnosis_type_name,\n  diagnosis_flag,\n  case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes,\n  case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes,\n  case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names \n  from emr_temp_ip_patient_diagnosis \n  where file_visit_type = '2'\n  group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag\n),\ndiagnosis_ranked as (\n  select \n  *,\n  row_number() over (\n   partition by inp_no, times, type \n   order by \n  case \n  when type = '病历诊断' and diagnosis_type_name = '最后诊断' then 1\n  when type = '病历诊断' and diagnosis_type_name = '初步诊断' then 2\n  when type = '首页诊断' and diagnosis_type_name = '出院诊断' then 1\n  when type = '首页诊断' and diagnosis_type_name = '门诊诊断' then 2\n  else 3\n  end\n  ) as rn\n  from diagnosis\n),\ndiagnosis_end as (\n  select \n  inp_no, \n  times, \n  type, \n  diagnosis_type_name,\n  max(case when diagnosis_flag = '1' then diagnosis_codes end) as diagnosis_codes,\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_codes end) as chinese_diagnosis_codes,\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_names end) as chinese_diagnosis_names\n  from diagnosis_ranked\n  where rn = 1\n  group by inp_no, times, type, diagnosis_type_name\n),\noperations as (\n  select \n  inp_no, \n  visit_id as times, \n  string_agg(operation_code, ',' order by operation_no) as operation_codes \n  from emr_temp_ip_patient_operation\n  group by inp_no, visit_id \n)\nselect \n  t.patientid, \n  t.patientname, \n  t.age,\n  t.gender, \n  t.indate, \n  t.outdate, \n  t.inhospitaltimes, \n  d.type,\n  d.diagnosis_codes as diagnosiscode,\n  o.operation_codes as operationcode,\n  t.medicalcost, \n  t.persontype, \n  t.entrymode, \n  t.serialno, \n  t.defaulttab,\n  d.chinese_diagnosis_codes as chinesediagnosiscode,\n  d.chinese_diagnosis_names as chinesediagnosename,\n  t.deptcode, \n  t.citycode \nfrom tmep_ip t \nleft join diagnosis_end d on t.patientid = d.inp_no and t.inhospitaltimes::varchar = d.times\nleft join operations o on t.patientid = o.inp_no and t.inhospitaltimes::varchar = o.times\nwhere t.outdate > '2025-01-01'\norder by t.outdate desc\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "with filtered_ip as (select a.register_no, a.inpatient_name, a.age, a.sex, a.in_date, a.out_date, a.times, a.person_type, a.patient_no, a.current_dept_code, b.total_cost from his_temp_ip_patient_info a left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times where a.out_date >= '2025-01-02'::timestamp), diagnosis as (select inp_no, visit_id as times, type, diagnosis_type_name, diagnosis_flag, case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes, case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes, case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names from emr_temp_ip_patient_diagnosis where file_visit_type = '2' group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag), diagnosis_ranked as (select *, row_number() over (partition by inp_no, times, type order by case when type='病历诊断' and diagnosis_type_name='最后诊断' then 1 when type='病历诊断' and diagnosis_type_name='初步诊断' then 2 when type='首页诊断' and diagnosis_type_name='出院诊断' then 1 when type='首页诊断' and diagnosis_type_name='门诊诊断' then 2 else 3 end) as rn from diagnosis), diagnosis_final as (select inp_no, times, type, diagnosis_type_name, max(case when diagnosis_flag='1' then diagnosis_codes end) as diagnosis_codes, max(case when diagnosis_flag='0' then chinese_diagnosis_codes end) as chinese_diagnosis_codes, max(case when diagnosis_flag='0' then chinese_diagnosis_names end) as chinese_diagnosis_names from diagnosis_ranked where rn = 1 group by inp_no, times, type, diagnosis_type_name), operations as (select inp_no, visit_id as times, string_agg(operation_code, ',' order by operation_no) as operation_codes from emr_temp_ip_patient_operation group by inp_no, visit_id) select t.register_no as patientid, t.inpatient_name as patientname, t.age, t.sex as gender, date(t.in_date) as indate, date(t.out_date) as outdate, t.times as inhospitaltimes, d.type, d.diagnosis_codes as diagnosiscode, o.operation_codes as operationcode, t.total_cost as medicalcost, t.person_type as persontype, 'doctor' as entrymode, t.patient_no as serialno, 'remind' as defaulttab, d.chinese_diagnosis_codes as chinesediagnosiscode, d.chinese_diagnosis_names as chinesediagnosename, t.current_dept_code as deptcode, '440100' as citycode from filtered_ip t left join diagnosis_final d on t.register_no = d.inp_no and t.times = d.times left join operations o on t.register_no = o.inp_no and t.times = o.times order by t.out_date desc;"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "33",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"33\", \"db_type\": \"mysql\", \"description\": \"这次改写的核心思想是消除WHERE子句中的LEFT函数调用，因为函数作用于列会阻止索引使用。改写策略是将前缀匹配逻辑展开为21个具体的等值比较条件（对应字符串'745070056000500070090'的每个前缀）。每个条件形式为：(code_length = N AND CODE = 'prefix')。理论上，这种改写可以让优化器使用索引，因为CODE列现在是等值比较而非函数参数。然而实际效果适得其反，原因是：1) 条件数量过多（21个OR）导致评估开销增加；2) 每个条件仍需调用CHAR_LENGTH函数验证长度；3) MySQL对多OR条件的索引使用优化有限，最终仍选择全表扫描。\", \"create_table_statements\": [\"CREATE TABLE t_org_architecture (ID INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(100), CODE VARCHAR(50), TYPE VARCHAR(50), principal VARCHAR(100), CATEGORY VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_code ON t_org_architecture(CODE);\"], \"sql\": \"SELECT \\n  ID, \\n  `NAME`, \\n  `CODE`, \\n  `TYPE`, \\n  principal, \\n  CATEGORY \\nFROM \\n  t_org_architecture \\nWHERE \\n  LEFT('745070056000500070090',  LENGTH(`CODE`)) = `CODE` \\nGROUP BY \\n  LENGTH(`CODE`);\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tSIMPLE\\tt_org_architecture\\t\\tALL\\tidx_code\\t\\t\\t\\t993209\\t10.0\\tUsing where; Using temporary\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"101257.36\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"using_filesort\\\": false,\\n   \\\"table\\\": {\\n   \\\"table_name\\\": \\\"t_org_architecture\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"idx_code\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 993209,\\n   \\\"rows_produced_per_join\\\": 99320,\\n   \\\"filtered\\\": \\\"10.00\\\",\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"91325.27\\\",\\n   \\\"eval_cost\\\": \\\"9932.09\\\",\\n   \\\"prefix_cost\\\": \\\"101257.36\\\",\\n   \\\"data_read_per_join\\\": \\\"134M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"ID\\\",\\n   \\\"NAME\\\",\\n   \\\"CODE\\\",\\n   \\\"TYPE\\\",\\n   \\\"principal\\\",\\n   \\\"CATEGORY\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(left('745070056000500070090',length(`test_db`.`t_org_architecture`.`CODE`)) = `test_db`.`t_org_architecture`.`CODE`)\\\"\\n   }\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"用静态可搜索参数替换动态条件,原SQL的WHERE条件使用函数LEFT作用于常量字符串和CODE列的长度，导致非SARGable。通过使用生成列code_length和静态前缀值枚举，改写为多个等值条件组合，使优化器能利用索引idx_code_length_code加速查询。GROUP BY改用生成列code_length避免函数计算。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE t_org_architecture (ID INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(100), CODE VARCHAR(50), TYPE VARCHAR(50), principal VARCHAR(100), CATEGORY VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_code ON t_org_architecture(CODE);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tSIMPLE\tt_org_architecture\t\tALL\tidx_code\t\t\t\t993209\t10.0\tUsing where; Using temporary\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"101257.36\"\n  },\n  \"grouping_operation\": {\n   \"using_temporary_table\": true,\n   \"using_filesort\": false,\n   \"table\": {\n   \"table_name\": \"t_org_architecture\",\n   \"access_type\": \"ALL\",\n   \"possible_keys\": [\n   \"idx_code\"\n   ],\n   \"rows_examined_per_scan\": 993209,\n   \"rows_produced_per_join\": 99320,\n   \"filtered\": \"10.00\",\n   \"cost_info\": {\n   \"read_cost\": \"91325.27\",\n   \"eval_cost\": \"9932.09\",\n   \"prefix_cost\": \"101257.36\",\n   \"data_read_per_join\": \"134M\"\n   },\n   \"used_columns\": [\n   \"ID\",\n   \"NAME\",\n   \"CODE\",\n   \"TYPE\",\n   \"principal\",\n   \"CATEGORY\"\n   ],\n   \"attached_condition\": \"(left('745070056000500070090',length(`test_db`.`t_org_architecture`.`CODE`)) = `test_db`.`t_org_architecture`.`CODE`)\"\n   }\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  ID, \n  `NAME`, \n  `CODE`, \n  `TYPE`, \n  principal, \n  CATEGORY \nFROM \n  t_org_architecture \nWHERE \n  LEFT('745070056000500070090',  LENGTH(`CODE`)) = `CODE` \nGROUP BY \n  LENGTH(`CODE`);\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT ID, NAME, CODE, TYPE, principal, CATEGORY FROM t_org_architecture WHERE CODE <= '745070056000500070090' AND LEFT('745070056000500070090', LENGTH(CODE)) = CODE GROUP BY LENGTH(CODE) ORDER BY NULL;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "34",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"34\", \"db_type\": \"mysql\", \"description\": \"核心技术是将非Sargable条件(索引列上的函数)改写为Sargable条件(可利用索引的条件)。对日期列使用函数会导致索引失效，改用范围查询可以充分利用索引。同时修正了数据类型不匹配问题(Flag字段定义为CHAR但与整数比较)，并清理了冗余条件。这种改写在保证结果一致性的前提下，通过技术手段显著降低了查询开销\", \"create_table_statements\": [\"CREATE TABLE m_membermain (MebID INT PRIMARY KEY AUTO_INCREMENT COMMENT '会员ID', Flag CHAR(1) NOT NULL DEFAULT '1' COMMENT '标志位', MebType TINYINT NOT NULL COMMENT '会员类型', CreateTime DATETIME NOT NULL COMMENT '创建时间') ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_flag ON m_membermain(Flag);\", \"CREATE INDEX idx_mebtype ON m_membermain(MebType);\", \"CREATE INDEX idx_createtime ON m_membermain(CreateTime);\", \"CREATE INDEX idx_flag_mebtype_createtime ON m_membermain(Flag, MebType, CreateTime);\"], \"sql\": \"SELECT \\n  count(DISTINCT MebID) \\nFROM \\n  m_membermain mm \\nWHERE \\n  mm.Flag <> '0' \\n  AND mm.MebType IN (1, 2, 5, 6, 8) \\n  AND MebID IS NOT NULL \\n  AND substring(CreateTime, 1, 10) = '2025-09-02' \\nLIMIT \\n  1000;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tSIMPLE\\tmm\\t\\trange\\tPRIMARY,idx_flag,idx_mebtype,idx_createtime,idx_flag_mebtype_createtime\\tidx_flag_mebtype_createtime\\t4\\t\\t499246\\t100.0\\tUsing where; Using index\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"100062.45\\\"\\n  },\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"mm\\\",\\n   \\\"access_type\\\": \\\"range\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"PRIMARY\\\",\\n   \\\"idx_flag\\\",\\n   \\\"idx_mebtype\\\",\\n   \\\"idx_createtime\\\",\\n   \\\"idx_flag_mebtype_createtime\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_flag_mebtype_createtime\\\",\\n   \\\"used_key_parts\\\": [\\n   \\\"Flag\\\"\\n   ],\\n   \\\"key_length\\\": \\\"4\\\",\\n   \\\"rows_examined_per_scan\\\": 499246,\\n   \\\"rows_produced_per_join\\\": 499246,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"using_index\\\": true,\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"50137.85\\\",\\n   \\\"eval_cost\\\": \\\"49924.60\\\",\\n   \\\"prefix_cost\\\": \\\"100062.45\\\",\\n   \\\"data_read_per_join\\\": \\\"7M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"MebID\\\",\\n   \\\"Flag\\\",\\n   \\\"MebType\\\",\\n   \\\"CreateTime\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`mm`.`Flag` <> '0') and (`test_db`.`mm`.`MebType` in (1,2,5,6,8)) and (substr(`test_db`.`mm`.`CreateTime`,1,10) = '2025-09-02'))\\\"\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,优化了隐式转换问题：将Flag字段的字符串比较改为整数比较，以避免类型转换导致的索引失效；将CreateTime字段的函数操作改为范围查询，以利用索引提升查询性能\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"用静态可搜索参数替换动态条件,优化移除了冗余的MebID IS NOT NULL条件。该列作为主键已定义为NOT NULL，条件始终成立且影响优化器基数估算准确性。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"WHERE子句高选择性谓词下推,通过调整WHERE条件顺序实现优化：将高选择性的标志位条件前置，中等选择性的时间范围居中，IN列表后置。利用短路求值机制减少计算量，预计提升查询性能6%-12%\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE m_membermain (MebID INT PRIMARY KEY AUTO_INCREMENT COMMENT '会员ID', Flag CHAR(1) NOT NULL DEFAULT '1' COMMENT '标志位', MebType TINYINT NOT NULL COMMENT '会员类型', CreateTime DATETIME NOT NULL COMMENT '创建时间') ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_flag ON m_membermain(Flag);\nCREATE INDEX idx_mebtype ON m_membermain(MebType);\nCREATE INDEX idx_createtime ON m_membermain(CreateTime);\nCREATE INDEX idx_flag_mebtype_createtime ON m_membermain(Flag, MebType, CreateTime);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tSIMPLE\tmm\t\trange\tPRIMARY,idx_flag,idx_mebtype,idx_createtime,idx_flag_mebtype_createtime\tidx_flag_mebtype_createtime\t4\t\t499246\t100.0\tUsing where; Using index\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"100062.45\"\n  },\n  \"table\": {\n   \"table_name\": \"mm\",\n   \"access_type\": \"range\",\n   \"possible_keys\": [\n   \"PRIMARY\",\n   \"idx_flag\",\n   \"idx_mebtype\",\n   \"idx_createtime\",\n   \"idx_flag_mebtype_createtime\"\n   ],\n   \"key\": \"idx_flag_mebtype_createtime\",\n   \"used_key_parts\": [\n   \"Flag\"\n   ],\n   \"key_length\": \"4\",\n   \"rows_examined_per_scan\": 499246,\n   \"rows_produced_per_join\": 499246,\n   \"filtered\": \"100.00\",\n   \"using_index\": true,\n   \"cost_info\": {\n   \"read_cost\": \"50137.85\",\n   \"eval_cost\": \"49924.60\",\n   \"prefix_cost\": \"100062.45\",\n   \"data_read_per_join\": \"7M\"\n   },\n   \"used_columns\": [\n   \"MebID\",\n   \"Flag\",\n   \"MebType\",\n   \"CreateTime\"\n   ],\n   \"attached_condition\": \"((`test_db`.`mm`.`Flag` <> '0') and (`test_db`.`mm`.`MebType` in (1,2,5,6,8)) and (substr(`test_db`.`mm`.`CreateTime`,1,10) = '2025-09-02'))\"\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  count(DISTINCT MebID) \nFROM \n  m_membermain mm \nWHERE \n  mm.Flag <> '0' \n  AND mm.MebType IN (1, 2, 5, 6, 8) \n  AND MebID IS NOT NULL \n  AND substring(CreateTime, 1, 10) = '2025-09-02' \nLIMIT \n  1000;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT count(DISTINCT MebID) FROM m_membermain mm WHERE mm.Flag <> '0' AND mm.MebType IN (1,2,5,6,8) AND CreateTime >= '2025-09-02' AND CreateTime < '2025-09-03'"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "34",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"34\", \"db_type\": \"mysql\", \"description\": \"核心技术是将非Sargable条件(索引列上的函数)改写为Sargable条件(可利用索引的条件)。对日期列使用函数会导致索引失效，改用范围查询可以充分利用索引。同时修正了数据类型不匹配问题(Flag字段定义为CHAR但与整数比较)，并清理了冗余条件。这种改写在保证结果一致性的前提下，通过技术手段显著降低了查询开销\", \"create_table_statements\": [\"CREATE TABLE m_membermain (MebID INT PRIMARY KEY AUTO_INCREMENT COMMENT '会员ID', Flag CHAR(1) NOT NULL DEFAULT '1' COMMENT '标志位', MebType TINYINT NOT NULL COMMENT '会员类型', CreateTime DATETIME NOT NULL COMMENT '创建时间') ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_flag ON m_membermain(Flag);\", \"CREATE INDEX idx_mebtype ON m_membermain(MebType);\", \"CREATE INDEX idx_createtime ON m_membermain(CreateTime);\", \"CREATE INDEX idx_flag_mebtype_createtime ON m_membermain(Flag, MebType, CreateTime);\"], \"sql\": \"SELECT \\n  count(DISTINCT MebID) \\nFROM \\n  m_membermain mm \\nWHERE \\n  mm.Flag <> '0' \\n  AND mm.MebType IN (1, 2, 5, 6, 8) \\n  AND MebID IS NOT NULL \\n  AND substring(CreateTime, 1, 10) = '2025-09-02' \\nLIMIT \\n  1000;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tSIMPLE\\tmm\\t\\trange\\tPRIMARY,idx_flag,idx_mebtype,idx_createtime,idx_flag_mebtype_createtime\\tidx_flag_mebtype_createtime\\t4\\t\\t499246\\t100.0\\tUsing where; Using index\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"100062.45\\\"\\n  },\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"mm\\\",\\n   \\\"access_type\\\": \\\"range\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"PRIMARY\\\",\\n   \\\"idx_flag\\\",\\n   \\\"idx_mebtype\\\",\\n   \\\"idx_createtime\\\",\\n   \\\"idx_flag_mebtype_createtime\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_flag_mebtype_createtime\\\",\\n   \\\"used_key_parts\\\": [\\n   \\\"Flag\\\"\\n   ],\\n   \\\"key_length\\\": \\\"4\\\",\\n   \\\"rows_examined_per_scan\\\": 499246,\\n   \\\"rows_produced_per_join\\\": 499246,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"using_index\\\": true,\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"50137.85\\\",\\n   \\\"eval_cost\\\": \\\"49924.60\\\",\\n   \\\"prefix_cost\\\": \\\"100062.45\\\",\\n   \\\"data_read_per_join\\\": \\\"7M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"MebID\\\",\\n   \\\"Flag\\\",\\n   \\\"MebType\\\",\\n   \\\"CreateTime\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`mm`.`Flag` <> '0') and (`test_db`.`mm`.`MebType` in (1,2,5,6,8)) and (substr(`test_db`.`mm`.`CreateTime`,1,10) = '2025-09-02'))\\\"\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,优化了隐式转换问题：将Flag字段的字符串比较改为整数比较，以避免类型转换导致的索引失效；将CreateTime字段的函数操作改为范围查询，以利用索引提升查询性能\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"用静态可搜索参数替换动态条件,优化移除了冗余的MebID IS NOT NULL条件。该列作为主键已定义为NOT NULL，条件始终成立且影响优化器基数估算准确性。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"WHERE子句高选择性谓词下推,通过调整WHERE条件顺序实现优化：将高选择性的标志位条件前置，中等选择性的时间范围居中，IN列表后置。利用短路求值机制减少计算量，预计提升查询性能6%-12%\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE m_membermain (MebID INT PRIMARY KEY AUTO_INCREMENT COMMENT '会员ID', Flag CHAR(1) NOT NULL DEFAULT '1' COMMENT '标志位', MebType TINYINT NOT NULL COMMENT '会员类型', CreateTime DATETIME NOT NULL COMMENT '创建时间') ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_flag ON m_membermain(Flag);\nCREATE INDEX idx_mebtype ON m_membermain(MebType);\nCREATE INDEX idx_createtime ON m_membermain(CreateTime);\nCREATE INDEX idx_flag_mebtype_createtime ON m_membermain(Flag, MebType, CreateTime);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tSIMPLE\tmm\t\trange\tPRIMARY,idx_flag,idx_mebtype,idx_createtime,idx_flag_mebtype_createtime\tidx_flag_mebtype_createtime\t4\t\t499246\t100.0\tUsing where; Using index\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"100062.45\"\n  },\n  \"table\": {\n   \"table_name\": \"mm\",\n   \"access_type\": \"range\",\n   \"possible_keys\": [\n   \"PRIMARY\",\n   \"idx_flag\",\n   \"idx_mebtype\",\n   \"idx_createtime\",\n   \"idx_flag_mebtype_createtime\"\n   ],\n   \"key\": \"idx_flag_mebtype_createtime\",\n   \"used_key_parts\": [\n   \"Flag\"\n   ],\n   \"key_length\": \"4\",\n   \"rows_examined_per_scan\": 499246,\n   \"rows_produced_per_join\": 499246,\n   \"filtered\": \"100.00\",\n   \"using_index\": true,\n   \"cost_info\": {\n   \"read_cost\": \"50137.85\",\n   \"eval_cost\": \"49924.60\",\n   \"prefix_cost\": \"100062.45\",\n   \"data_read_per_join\": \"7M\"\n   },\n   \"used_columns\": [\n   \"MebID\",\n   \"Flag\",\n   \"MebType\",\n   \"CreateTime\"\n   ],\n   \"attached_condition\": \"((`test_db`.`mm`.`Flag` <> '0') and (`test_db`.`mm`.`MebType` in (1,2,5,6,8)) and (substr(`test_db`.`mm`.`CreateTime`,1,10) = '2025-09-02'))\"\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  count(DISTINCT MebID) \nFROM \n  m_membermain mm \nWHERE \n  mm.Flag <> '0' \n  AND mm.MebType IN (1, 2, 5, 6, 8) \n  AND MebID IS NOT NULL \n  AND substring(CreateTime, 1, 10) = '2025-09-02' \nLIMIT \n  1000;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT count(DISTINCT MebID) FROM m_membermain mm WHERE mm.Flag <> '0' AND mm.MebType IN (1,2,5,6,8) AND CreateTime >= '2025-09-02' AND CreateTime < '2025-09-03'"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "34",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"34\", \"db_type\": \"mysql\", \"description\": \"核心技术是将非Sargable条件(索引列上的函数)改写为Sargable条件(可利用索引的条件)。对日期列使用函数会导致索引失效，改用范围查询可以充分利用索引。同时修正了数据类型不匹配问题(Flag字段定义为CHAR但与整数比较)，并清理了冗余条件。这种改写在保证结果一致性的前提下，通过技术手段显著降低了查询开销\", \"create_table_statements\": [\"CREATE TABLE m_membermain (MebID INT PRIMARY KEY AUTO_INCREMENT COMMENT '会员ID', Flag CHAR(1) NOT NULL DEFAULT '1' COMMENT '标志位', MebType TINYINT NOT NULL COMMENT '会员类型', CreateTime DATETIME NOT NULL COMMENT '创建时间') ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_flag ON m_membermain(Flag);\", \"CREATE INDEX idx_mebtype ON m_membermain(MebType);\", \"CREATE INDEX idx_createtime ON m_membermain(CreateTime);\", \"CREATE INDEX idx_flag_mebtype_createtime ON m_membermain(Flag, MebType, CreateTime);\"], \"sql\": \"SELECT \\n  count(DISTINCT MebID) \\nFROM \\n  m_membermain mm \\nWHERE \\n  mm.Flag <> '0' \\n  AND mm.MebType IN (1, 2, 5, 6, 8) \\n  AND MebID IS NOT NULL \\n  AND substring(CreateTime, 1, 10) = '2025-09-02' \\nLIMIT \\n  1000;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tSIMPLE\\tmm\\t\\trange\\tPRIMARY,idx_flag,idx_mebtype,idx_createtime,idx_flag_mebtype_createtime\\tidx_flag_mebtype_createtime\\t4\\t\\t499246\\t100.0\\tUsing where; Using index\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"100062.45\\\"\\n  },\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"mm\\\",\\n   \\\"access_type\\\": \\\"range\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"PRIMARY\\\",\\n   \\\"idx_flag\\\",\\n   \\\"idx_mebtype\\\",\\n   \\\"idx_createtime\\\",\\n   \\\"idx_flag_mebtype_createtime\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_flag_mebtype_createtime\\\",\\n   \\\"used_key_parts\\\": [\\n   \\\"Flag\\\"\\n   ],\\n   \\\"key_length\\\": \\\"4\\\",\\n   \\\"rows_examined_per_scan\\\": 499246,\\n   \\\"rows_produced_per_join\\\": 499246,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"using_index\\\": true,\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"50137.85\\\",\\n   \\\"eval_cost\\\": \\\"49924.60\\\",\\n   \\\"prefix_cost\\\": \\\"100062.45\\\",\\n   \\\"data_read_per_join\\\": \\\"7M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"MebID\\\",\\n   \\\"Flag\\\",\\n   \\\"MebType\\\",\\n   \\\"CreateTime\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`mm`.`Flag` <> '0') and (`test_db`.`mm`.`MebType` in (1,2,5,6,8)) and (substr(`test_db`.`mm`.`CreateTime`,1,10) = '2025-09-02'))\\\"\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,优化了隐式转换问题：将Flag字段的字符串比较改为整数比较，以避免类型转换导致的索引失效；将CreateTime字段的函数操作改为范围查询，以利用索引提升查询性能\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"用静态可搜索参数替换动态条件,优化移除了冗余的MebID IS NOT NULL条件。该列作为主键已定义为NOT NULL，条件始终成立且影响优化器基数估算准确性。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"WHERE子句高选择性谓词下推,通过调整WHERE条件顺序实现优化：将高选择性的标志位条件前置，中等选择性的时间范围居中，IN列表后置。利用短路求值机制减少计算量，预计提升查询性能6%-12%\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE m_membermain (MebID INT PRIMARY KEY AUTO_INCREMENT COMMENT '会员ID', Flag CHAR(1) NOT NULL DEFAULT '1' COMMENT '标志位', MebType TINYINT NOT NULL COMMENT '会员类型', CreateTime DATETIME NOT NULL COMMENT '创建时间') ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_flag ON m_membermain(Flag);\nCREATE INDEX idx_mebtype ON m_membermain(MebType);\nCREATE INDEX idx_createtime ON m_membermain(CreateTime);\nCREATE INDEX idx_flag_mebtype_createtime ON m_membermain(Flag, MebType, CreateTime);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tSIMPLE\tmm\t\trange\tPRIMARY,idx_flag,idx_mebtype,idx_createtime,idx_flag_mebtype_createtime\tidx_flag_mebtype_createtime\t4\t\t499246\t100.0\tUsing where; Using index\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"100062.45\"\n  },\n  \"table\": {\n   \"table_name\": \"mm\",\n   \"access_type\": \"range\",\n   \"possible_keys\": [\n   \"PRIMARY\",\n   \"idx_flag\",\n   \"idx_mebtype\",\n   \"idx_createtime\",\n   \"idx_flag_mebtype_createtime\"\n   ],\n   \"key\": \"idx_flag_mebtype_createtime\",\n   \"used_key_parts\": [\n   \"Flag\"\n   ],\n   \"key_length\": \"4\",\n   \"rows_examined_per_scan\": 499246,\n   \"rows_produced_per_join\": 499246,\n   \"filtered\": \"100.00\",\n   \"using_index\": true,\n   \"cost_info\": {\n   \"read_cost\": \"50137.85\",\n   \"eval_cost\": \"49924.60\",\n   \"prefix_cost\": \"100062.45\",\n   \"data_read_per_join\": \"7M\"\n   },\n   \"used_columns\": [\n   \"MebID\",\n   \"Flag\",\n   \"MebType\",\n   \"CreateTime\"\n   ],\n   \"attached_condition\": \"((`test_db`.`mm`.`Flag` <> '0') and (`test_db`.`mm`.`MebType` in (1,2,5,6,8)) and (substr(`test_db`.`mm`.`CreateTime`,1,10) = '2025-09-02'))\"\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  count(DISTINCT MebID) \nFROM \n  m_membermain mm \nWHERE \n  mm.Flag <> '0' \n  AND mm.MebType IN (1, 2, 5, 6, 8) \n  AND MebID IS NOT NULL \n  AND substring(CreateTime, 1, 10) = '2025-09-02' \nLIMIT \n  1000;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT count(DISTINCT MebID) FROM m_membermain mm WHERE mm.Flag <> '0' AND mm.MebType IN (1,2,5,6,8) AND CreateTime >= '2025-09-02' AND CreateTime < '2025-09-03'"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "35",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"35\", \"db_type\": \"mysql\", \"description\": \"这是一个典型的消除无用计算的优化案例。当外层查询只是COUNT(*)时，内层子查询中计算的所有列值（包括通过子查询计算的auditJobIdcounts）都不会影响最终结果。COUNT(*)只关心有多少行满足WHERE条件，而不关心这些行的具体内容。因此可以直接将内层子查询展开，删除所有不必要的列选择和子查询计算，只保留WHERE条件。这种改写消除了189504次依赖子查询执行、临时表物化和34个列的数据读取，大幅提升性能。\", \"create_table_statements\": [\"CREATE TABLE hotel_price_adjustment (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), brand_code VARCHAR(50), brand_name VARCHAR(200), hotel_code VARCHAR(50), hotel_name VARCHAR(200), currency VARCHAR(10), category VARCHAR(50), rate_code VARCHAR(50), rate_name VARCHAR(200), price_array_type VARCHAR(50), price_array_code VARCHAR(50), price_array_sequence INT, price_array TEXT, price_array2 TEXT, date_segment VARCHAR(100), weeks VARCHAR(50), brand_maximum_price DECIMAL(18,2), brand_minimum_price DECIMAL(18,2), room_code VARCHAR(50), room_name VARCHAR(200), room_standard_price DECIMAL(18,2), pre_adjustment_price DECIMAL(18,2), adjusted_price DECIMAL(18,2), price_adjustment_range VARCHAR(50), occupancy INT, status VARCHAR(20), reason TEXT, approve_status VARCHAR(20), approve_reason TEXT, operator VARCHAR(100), create_time DATETIME, update_time DATETIME, CREATE_USER_ID BIGINT) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_hotel_code ON hotel_price_adjustment(HOTEL_CODE);\", \"CREATE INDEX idx_create_user_id ON hotel_price_adjustment(CREATE_USER_ID);\", \"CREATE INDEX idx_apply_id ON hotel_price_adjustment(apply_id);\", \"CREATE TABLE price_adjustment_audit_job (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), job_id VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_apply_id_job_id ON price_adjustment_audit_job(apply_id, job_id);\"], \"sql\": \"SELECT \\n  COUNT(*) \\nFROM \\n  (\\n  SELECT \\n   id, \\n   apply_id, \\n   brand_code, \\n   brand_name, \\n   hotel_code, \\n   hotel_name, \\n   currency, \\n   category, \\n   rate_code, \\n   rate_name, \\n   price_array_type, \\n   price_array_code, \\n   price_array_sequence, \\n   price_array, \\n   price_array2, \\n   date_segment, \\n   weeks, \\n   brand_maximum_price, \\n   brand_minimum_price, \\n   room_code, \\n   room_name, \\n   room_standard_price, \\n   pre_adjustment_price, \\n   adjusted_price, \\n   price_adjustment_range, \\n   occupancy, \\n   status, \\n   reason, \\n   approve_status, \\n   approve_reason, \\n   operator, \\n   create_time, \\n   update_time, \\n   CREATE_USER_ID, \\n   (\\n   SELECT \\n   count(paaj.id) \\n   FROM \\n   price_adjustment_audit_job paaj \\n   WHERE \\n   paaj.apply_id = pa1.apply_id \\n   AND paaj.job_id = '4_004'\\n   ) AS auditJobIdcounts \\n  FROM \\n   hotel_price_adjustment pa1 \\n  WHERE \\n   (\\n   HOTEL_CODE IN ('6199', 'JJXRSEH802967') \\n   OR CREATE_USER_ID = 289865\\n   )\\n  ) TOTAL;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t189504\\t100.0\\t\\n2\\tDERIVED\\tpa1\\t\\tALL\\tidx_hotel_code,idx_create_user_id\\t\\t\\t\\t947046\\t20.01\\tUsing where\\n3\\tDEPENDENT SUBQUERY\\tpaaj\\t\\tref\\tidx_apply_id_job_id\\tidx_apply_id_job_id\\t606\\ttest_db.pa1.apply_id,const\\t189\\t100.0\\tUsing index\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"21321.70\\\"\\n  },\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"TOTAL\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"rows_examined_per_scan\\\": 189504,\\n   \\\"rows_produced_per_join\\\": 189504,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"2371.30\\\",\\n   \\\"eval_cost\\\": \\\"18950.40\\\",\\n   \\\"prefix_cost\\\": \\\"21321.70\\\",\\n   \\\"data_read_per_join\\\": \\\"1G\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"id\\\",\\n   \\\"apply_id\\\",\\n   \\\"brand_code\\\",\\n   \\\"brand_name\\\",\\n   \\\"hotel_code\\\",\\n   \\\"hotel_name\\\",\\n   \\\"currency\\\",\\n   \\\"category\\\",\\n   \\\"rate_code\\\",\\n   \\\"rate_name\\\",\\n   \\\"price_array_type\\\",\\n   \\\"price_array_code\\\",\\n   \\\"price_array_sequence\\\",\\n   \\\"price_array\\\",\\n   \\\"price_array2\\\",\\n   \\\"date_segment\\\",\\n   \\\"weeks\\\",\\n   \\\"brand_maximum_price\\\",\\n   \\\"brand_minimum_price\\\",\\n   \\\"room_code\\\",\\n   \\\"room_name\\\",\\n   \\\"room_standard_price\\\",\\n   \\\"pre_adjustment_price\\\",\\n   \\\"adjusted_price\\\",\\n   \\\"price_adjustment_range\\\",\\n   \\\"occupancy\\\",\\n   \\\"status\\\",\\n   \\\"reason\\\",\\n   \\\"approve_status\\\",\\n   \\\"approve_reason\\\",\\n   \\\"operator\\\",\\n   \\\"create_time\\\",\\n   \\\"update_time\\\",\\n   \\\"CREATE_USER_ID\\\",\\n   \\\"auditJobIdcounts\\\"\\n   ],\\n   \\\"materialized_from_subquery\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"dependent\\\": false,\\n   \\\"cacheable\\\": true,\\n   \\\"query_block\\\": {\\n   \\\"select_id\\\": 2,\\n   \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"119328.41\\\"\\n   },\\n   \\\"table\\\": {\\n  \\\"table_name\\\": \\\"pa1\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_hotel_code\\\",\\n  \\\"idx_create_user_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 947046,\\n  \\\"rows_produced_per_join\\\": 189504,\\n  \\\"filtered\\\": \\\"20.01\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"100378.00\\\",\\n  \\\"eval_cost\\\": \\\"18950.41\\\",\\n  \\\"prefix_cost\\\": \\\"119328.41\\\",\\n  \\\"data_read_per_join\\\": \\\"1G\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"apply_id\\\",\\n  \\\"brand_code\\\",\\n  \\\"brand_name\\\",\\n  \\\"hotel_code\\\",\\n  \\\"hotel_name\\\",\\n  \\\"currency\\\",\\n  \\\"category\\\",\\n  \\\"rate_code\\\",\\n  \\\"rate_name\\\",\\n  \\\"price_array_type\\\",\\n  \\\"price_array_code\\\",\\n  \\\"price_array_sequence\\\",\\n  \\\"price_array\\\",\\n  \\\"price_array2\\\",\\n  \\\"date_segment\\\",\\n  \\\"weeks\\\",\\n  \\\"brand_maximum_price\\\",\\n  \\\"brand_minimum_price\\\",\\n  \\\"room_code\\\",\\n  \\\"room_name\\\",\\n  \\\"room_standard_price\\\",\\n  \\\"pre_adjustment_price\\\",\\n  \\\"adjusted_price\\\",\\n  \\\"price_adjustment_range\\\",\\n  \\\"occupancy\\\",\\n  \\\"status\\\",\\n  \\\"reason\\\",\\n  \\\"approve_status\\\",\\n  \\\"approve_reason\\\",\\n  \\\"operator\\\",\\n  \\\"create_time\\\",\\n  \\\"update_time\\\",\\n  \\\"CREATE_USER_ID\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`pa1`.`hotel_code` in ('6199','JJXRSEH802967')) or (`test_db`.`pa1`.`CREATE_USER_ID` = 289865))\\\"\\n   },\\n   \\\"select_list_subqueries\\\": [\\n  {\\n  \\\"dependent\\\": true,\\n  \\\"cacheable\\\": false,\\n  \\\"query_block\\\": {\\n   \\\"select_id\\\": 3,\\n   \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"22.55\\\"\\n   },\\n   \\\"table\\\": {\\n   \\\"table_name\\\": \\\"paaj\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"idx_apply_id_job_id\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_apply_id_job_id\\\",\\n   \\\"used_key_parts\\\": [\\n   \\\"apply_id\\\",\\n   \\\"job_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"606\\\",\\n   \\\"ref\\\": [\\n   \\\"test_db.pa1.apply_id\\\",\\n   \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 189,\\n   \\\"rows_produced_per_join\\\": 189,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"using_index\\\": true,\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"3.61\\\",\\n   \\\"eval_cost\\\": \\\"18.94\\\",\\n   \\\"prefix_cost\\\": \\\"22.55\\\",\\n   \\\"data_read_per_join\\\": \\\"113K\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"id\\\",\\n   \\\"apply_id\\\",\\n   \\\"job_id\\\"\\n   ]\\n   }\\n  }\\n  }\\n   ]\\n   }\\n   }\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推消除子查询中所有冗余列，将子查询简化为SELECT 1，减少97%的数据读取量（从30+列降为1列）。该优化可显著降低磁盘I/O和内存占用，尤其适合大宽表场景。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"子查询折叠,通过子查询折叠规则优化，消除了冗余的派生表层级。改写后直接在基表上执行COUNT聚合和条件过滤，避免了中间临时表创建开销，显著降低CPU和I/O负载。语义完全等价且风险极低，预估性能提升10-20%。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,原始SQL中CREATE_USER_ID条件的整数值289865与字段类型varchar(16)不匹配，导致隐式转换和索引失效。优化后将整数转换为字符串'289865'，消除了隐式转换风险\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE hotel_price_adjustment (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), brand_code VARCHAR(50), brand_name VARCHAR(200), hotel_code VARCHAR(50), hotel_name VARCHAR(200), currency VARCHAR(10), category VARCHAR(50), rate_code VARCHAR(50), rate_name VARCHAR(200), price_array_type VARCHAR(50), price_array_code VARCHAR(50), price_array_sequence INT, price_array TEXT, price_array2 TEXT, date_segment VARCHAR(100), weeks VARCHAR(50), brand_maximum_price DECIMAL(18,2), brand_minimum_price DECIMAL(18,2), room_code VARCHAR(50), room_name VARCHAR(200), room_standard_price DECIMAL(18,2), pre_adjustment_price DECIMAL(18,2), adjusted_price DECIMAL(18,2), price_adjustment_range VARCHAR(50), occupancy INT, status VARCHAR(20), reason TEXT, approve_status VARCHAR(20), approve_reason TEXT, operator VARCHAR(100), create_time DATETIME, update_time DATETIME, CREATE_USER_ID BIGINT) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_hotel_code ON hotel_price_adjustment(HOTEL_CODE);\nCREATE INDEX idx_create_user_id ON hotel_price_adjustment(CREATE_USER_ID);\nCREATE INDEX idx_apply_id ON hotel_price_adjustment(apply_id);\nCREATE TABLE price_adjustment_audit_job (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), job_id VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_apply_id_job_id ON price_adjustment_audit_job(apply_id, job_id);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t189504\t100.0\t\n2\tDERIVED\tpa1\t\tALL\tidx_hotel_code,idx_create_user_id\t\t\t\t947046\t20.01\tUsing where\n3\tDEPENDENT SUBQUERY\tpaaj\t\tref\tidx_apply_id_job_id\tidx_apply_id_job_id\t606\ttest_db.pa1.apply_id,const\t189\t100.0\tUsing index\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"21321.70\"\n  },\n  \"table\": {\n   \"table_name\": \"TOTAL\",\n   \"access_type\": \"ALL\",\n   \"rows_examined_per_scan\": 189504,\n   \"rows_produced_per_join\": 189504,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n   \"read_cost\": \"2371.30\",\n   \"eval_cost\": \"18950.40\",\n   \"prefix_cost\": \"21321.70\",\n   \"data_read_per_join\": \"1G\"\n   },\n   \"used_columns\": [\n   \"id\",\n   \"apply_id\",\n   \"brand_code\",\n   \"brand_name\",\n   \"hotel_code\",\n   \"hotel_name\",\n   \"currency\",\n   \"category\",\n   \"rate_code\",\n   \"rate_name\",\n   \"price_array_type\",\n   \"price_array_code\",\n   \"price_array_sequence\",\n   \"price_array\",\n   \"price_array2\",\n   \"date_segment\",\n   \"weeks\",\n   \"brand_maximum_price\",\n   \"brand_minimum_price\",\n   \"room_code\",\n   \"room_name\",\n   \"room_standard_price\",\n   \"pre_adjustment_price\",\n   \"adjusted_price\",\n   \"price_adjustment_range\",\n   \"occupancy\",\n   \"status\",\n   \"reason\",\n   \"approve_status\",\n   \"approve_reason\",\n   \"operator\",\n   \"create_time\",\n   \"update_time\",\n   \"CREATE_USER_ID\",\n   \"auditJobIdcounts\"\n   ],\n   \"materialized_from_subquery\": {\n   \"using_temporary_table\": true,\n   \"dependent\": false,\n   \"cacheable\": true,\n   \"query_block\": {\n   \"select_id\": 2,\n   \"cost_info\": {\n  \"query_cost\": \"119328.41\"\n   },\n   \"table\": {\n  \"table_name\": \"pa1\",\n  \"access_type\": \"ALL\",\n  \"possible_keys\": [\n  \"idx_hotel_code\",\n  \"idx_create_user_id\"\n  ],\n  \"rows_examined_per_scan\": 947046,\n  \"rows_produced_per_join\": 189504,\n  \"filtered\": \"20.01\",\n  \"cost_info\": {\n  \"read_cost\": \"100378.00\",\n  \"eval_cost\": \"18950.41\",\n  \"prefix_cost\": \"119328.41\",\n  \"data_read_per_join\": \"1G\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"apply_id\",\n  \"brand_code\",\n  \"brand_name\",\n  \"hotel_code\",\n  \"hotel_name\",\n  \"currency\",\n  \"category\",\n  \"rate_code\",\n  \"rate_name\",\n  \"price_array_type\",\n  \"price_array_code\",\n  \"price_array_sequence\",\n  \"price_array\",\n  \"price_array2\",\n  \"date_segment\",\n  \"weeks\",\n  \"brand_maximum_price\",\n  \"brand_minimum_price\",\n  \"room_code\",\n  \"room_name\",\n  \"room_standard_price\",\n  \"pre_adjustment_price\",\n  \"adjusted_price\",\n  \"price_adjustment_range\",\n  \"occupancy\",\n  \"status\",\n  \"reason\",\n  \"approve_status\",\n  \"approve_reason\",\n  \"operator\",\n  \"create_time\",\n  \"update_time\",\n  \"CREATE_USER_ID\"\n  ],\n  \"attached_condition\": \"((`test_db`.`pa1`.`hotel_code` in ('6199','JJXRSEH802967')) or (`test_db`.`pa1`.`CREATE_USER_ID` = 289865))\"\n   },\n   \"select_list_subqueries\": [\n  {\n  \"dependent\": true,\n  \"cacheable\": false,\n  \"query_block\": {\n   \"select_id\": 3,\n   \"cost_info\": {\n   \"query_cost\": \"22.55\"\n   },\n   \"table\": {\n   \"table_name\": \"paaj\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n   \"idx_apply_id_job_id\"\n   ],\n   \"key\": \"idx_apply_id_job_id\",\n   \"used_key_parts\": [\n   \"apply_id\",\n   \"job_id\"\n   ],\n   \"key_length\": \"606\",\n   \"ref\": [\n   \"test_db.pa1.apply_id\",\n   \"const\"\n   ],\n   \"rows_examined_per_scan\": 189,\n   \"rows_produced_per_join\": 189,\n   \"filtered\": \"100.00\",\n   \"using_index\": true,\n   \"cost_info\": {\n   \"read_cost\": \"3.61\",\n   \"eval_cost\": \"18.94\",\n   \"prefix_cost\": \"22.55\",\n   \"data_read_per_join\": \"113K\"\n   },\n   \"used_columns\": [\n   \"id\",\n   \"apply_id\",\n   \"job_id\"\n   ]\n   }\n  }\n  }\n   ]\n   }\n   }\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  COUNT(*) \nFROM \n  (\n  SELECT \n   id, \n   apply_id, \n   brand_code, \n   brand_name, \n   hotel_code, \n   hotel_name, \n   currency, \n   category, \n   rate_code, \n   rate_name, \n   price_array_type, \n   price_array_code, \n   price_array_sequence, \n   price_array, \n   price_array2, \n   date_segment, \n   weeks, \n   brand_maximum_price, \n   brand_minimum_price, \n   room_code, \n   room_name, \n   room_standard_price, \n   pre_adjustment_price, \n   adjusted_price, \n   price_adjustment_range, \n   occupancy, \n   status, \n   reason, \n   approve_status, \n   approve_reason, \n   operator, \n   create_time, \n   update_time, \n   CREATE_USER_ID, \n   (\n   SELECT \n   count(paaj.id) \n   FROM \n   price_adjustment_audit_job paaj \n   WHERE \n   paaj.apply_id = pa1.apply_id \n   AND paaj.job_id = '4_004'\n   ) AS auditJobIdcounts \n  FROM \n   hotel_price_adjustment pa1 \n  WHERE \n   (\n   HOTEL_CODE IN ('6199', 'JJXRSEH802967') \n   OR CREATE_USER_ID = 289865\n   )\n  ) TOTAL;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT COUNT(*) FROM (SELECT id FROM hotel_price_adjustment WHERE hotel_code IN ('6199','JJXRSEH802967') UNION SELECT id FROM hotel_price_adjustment WHERE CREATE_USER_ID = 289865) t"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "35",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"35\", \"db_type\": \"mysql\", \"description\": \"这是一个典型的消除无用计算的优化案例。当外层查询只是COUNT(*)时，内层子查询中计算的所有列值（包括通过子查询计算的auditJobIdcounts）都不会影响最终结果。COUNT(*)只关心有多少行满足WHERE条件，而不关心这些行的具体内容。因此可以直接将内层子查询展开，删除所有不必要的列选择和子查询计算，只保留WHERE条件。这种改写消除了189504次依赖子查询执行、临时表物化和34个列的数据读取，大幅提升性能。\", \"create_table_statements\": [\"CREATE TABLE hotel_price_adjustment (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), brand_code VARCHAR(50), brand_name VARCHAR(200), hotel_code VARCHAR(50), hotel_name VARCHAR(200), currency VARCHAR(10), category VARCHAR(50), rate_code VARCHAR(50), rate_name VARCHAR(200), price_array_type VARCHAR(50), price_array_code VARCHAR(50), price_array_sequence INT, price_array TEXT, price_array2 TEXT, date_segment VARCHAR(100), weeks VARCHAR(50), brand_maximum_price DECIMAL(18,2), brand_minimum_price DECIMAL(18,2), room_code VARCHAR(50), room_name VARCHAR(200), room_standard_price DECIMAL(18,2), pre_adjustment_price DECIMAL(18,2), adjusted_price DECIMAL(18,2), price_adjustment_range VARCHAR(50), occupancy INT, status VARCHAR(20), reason TEXT, approve_status VARCHAR(20), approve_reason TEXT, operator VARCHAR(100), create_time DATETIME, update_time DATETIME, CREATE_USER_ID BIGINT) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_hotel_code ON hotel_price_adjustment(HOTEL_CODE);\", \"CREATE INDEX idx_create_user_id ON hotel_price_adjustment(CREATE_USER_ID);\", \"CREATE INDEX idx_apply_id ON hotel_price_adjustment(apply_id);\", \"CREATE TABLE price_adjustment_audit_job (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), job_id VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_apply_id_job_id ON price_adjustment_audit_job(apply_id, job_id);\"], \"sql\": \"SELECT \\n  COUNT(*) \\nFROM \\n  (\\n  SELECT \\n   id, \\n   apply_id, \\n   brand_code, \\n   brand_name, \\n   hotel_code, \\n   hotel_name, \\n   currency, \\n   category, \\n   rate_code, \\n   rate_name, \\n   price_array_type, \\n   price_array_code, \\n   price_array_sequence, \\n   price_array, \\n   price_array2, \\n   date_segment, \\n   weeks, \\n   brand_maximum_price, \\n   brand_minimum_price, \\n   room_code, \\n   room_name, \\n   room_standard_price, \\n   pre_adjustment_price, \\n   adjusted_price, \\n   price_adjustment_range, \\n   occupancy, \\n   status, \\n   reason, \\n   approve_status, \\n   approve_reason, \\n   operator, \\n   create_time, \\n   update_time, \\n   CREATE_USER_ID, \\n   (\\n   SELECT \\n   count(paaj.id) \\n   FROM \\n   price_adjustment_audit_job paaj \\n   WHERE \\n   paaj.apply_id = pa1.apply_id \\n   AND paaj.job_id = '4_004'\\n   ) AS auditJobIdcounts \\n  FROM \\n   hotel_price_adjustment pa1 \\n  WHERE \\n   (\\n   HOTEL_CODE IN ('6199', 'JJXRSEH802967') \\n   OR CREATE_USER_ID = 289865\\n   )\\n  ) TOTAL;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t189504\\t100.0\\t\\n2\\tDERIVED\\tpa1\\t\\tALL\\tidx_hotel_code,idx_create_user_id\\t\\t\\t\\t947046\\t20.01\\tUsing where\\n3\\tDEPENDENT SUBQUERY\\tpaaj\\t\\tref\\tidx_apply_id_job_id\\tidx_apply_id_job_id\\t606\\ttest_db.pa1.apply_id,const\\t189\\t100.0\\tUsing index\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"21321.70\\\"\\n  },\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"TOTAL\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"rows_examined_per_scan\\\": 189504,\\n   \\\"rows_produced_per_join\\\": 189504,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"2371.30\\\",\\n   \\\"eval_cost\\\": \\\"18950.40\\\",\\n   \\\"prefix_cost\\\": \\\"21321.70\\\",\\n   \\\"data_read_per_join\\\": \\\"1G\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"id\\\",\\n   \\\"apply_id\\\",\\n   \\\"brand_code\\\",\\n   \\\"brand_name\\\",\\n   \\\"hotel_code\\\",\\n   \\\"hotel_name\\\",\\n   \\\"currency\\\",\\n   \\\"category\\\",\\n   \\\"rate_code\\\",\\n   \\\"rate_name\\\",\\n   \\\"price_array_type\\\",\\n   \\\"price_array_code\\\",\\n   \\\"price_array_sequence\\\",\\n   \\\"price_array\\\",\\n   \\\"price_array2\\\",\\n   \\\"date_segment\\\",\\n   \\\"weeks\\\",\\n   \\\"brand_maximum_price\\\",\\n   \\\"brand_minimum_price\\\",\\n   \\\"room_code\\\",\\n   \\\"room_name\\\",\\n   \\\"room_standard_price\\\",\\n   \\\"pre_adjustment_price\\\",\\n   \\\"adjusted_price\\\",\\n   \\\"price_adjustment_range\\\",\\n   \\\"occupancy\\\",\\n   \\\"status\\\",\\n   \\\"reason\\\",\\n   \\\"approve_status\\\",\\n   \\\"approve_reason\\\",\\n   \\\"operator\\\",\\n   \\\"create_time\\\",\\n   \\\"update_time\\\",\\n   \\\"CREATE_USER_ID\\\",\\n   \\\"auditJobIdcounts\\\"\\n   ],\\n   \\\"materialized_from_subquery\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"dependent\\\": false,\\n   \\\"cacheable\\\": true,\\n   \\\"query_block\\\": {\\n   \\\"select_id\\\": 2,\\n   \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"119328.41\\\"\\n   },\\n   \\\"table\\\": {\\n  \\\"table_name\\\": \\\"pa1\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_hotel_code\\\",\\n  \\\"idx_create_user_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 947046,\\n  \\\"rows_produced_per_join\\\": 189504,\\n  \\\"filtered\\\": \\\"20.01\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"100378.00\\\",\\n  \\\"eval_cost\\\": \\\"18950.41\\\",\\n  \\\"prefix_cost\\\": \\\"119328.41\\\",\\n  \\\"data_read_per_join\\\": \\\"1G\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"apply_id\\\",\\n  \\\"brand_code\\\",\\n  \\\"brand_name\\\",\\n  \\\"hotel_code\\\",\\n  \\\"hotel_name\\\",\\n  \\\"currency\\\",\\n  \\\"category\\\",\\n  \\\"rate_code\\\",\\n  \\\"rate_name\\\",\\n  \\\"price_array_type\\\",\\n  \\\"price_array_code\\\",\\n  \\\"price_array_sequence\\\",\\n  \\\"price_array\\\",\\n  \\\"price_array2\\\",\\n  \\\"date_segment\\\",\\n  \\\"weeks\\\",\\n  \\\"brand_maximum_price\\\",\\n  \\\"brand_minimum_price\\\",\\n  \\\"room_code\\\",\\n  \\\"room_name\\\",\\n  \\\"room_standard_price\\\",\\n  \\\"pre_adjustment_price\\\",\\n  \\\"adjusted_price\\\",\\n  \\\"price_adjustment_range\\\",\\n  \\\"occupancy\\\",\\n  \\\"status\\\",\\n  \\\"reason\\\",\\n  \\\"approve_status\\\",\\n  \\\"approve_reason\\\",\\n  \\\"operator\\\",\\n  \\\"create_time\\\",\\n  \\\"update_time\\\",\\n  \\\"CREATE_USER_ID\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`pa1`.`hotel_code` in ('6199','JJXRSEH802967')) or (`test_db`.`pa1`.`CREATE_USER_ID` = 289865))\\\"\\n   },\\n   \\\"select_list_subqueries\\\": [\\n  {\\n  \\\"dependent\\\": true,\\n  \\\"cacheable\\\": false,\\n  \\\"query_block\\\": {\\n   \\\"select_id\\\": 3,\\n   \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"22.55\\\"\\n   },\\n   \\\"table\\\": {\\n   \\\"table_name\\\": \\\"paaj\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"idx_apply_id_job_id\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_apply_id_job_id\\\",\\n   \\\"used_key_parts\\\": [\\n   \\\"apply_id\\\",\\n   \\\"job_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"606\\\",\\n   \\\"ref\\\": [\\n   \\\"test_db.pa1.apply_id\\\",\\n   \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 189,\\n   \\\"rows_produced_per_join\\\": 189,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"using_index\\\": true,\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"3.61\\\",\\n   \\\"eval_cost\\\": \\\"18.94\\\",\\n   \\\"prefix_cost\\\": \\\"22.55\\\",\\n   \\\"data_read_per_join\\\": \\\"113K\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"id\\\",\\n   \\\"apply_id\\\",\\n   \\\"job_id\\\"\\n   ]\\n   }\\n  }\\n  }\\n   ]\\n   }\\n   }\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推消除子查询中所有冗余列，将子查询简化为SELECT 1，减少97%的数据读取量（从30+列降为1列）。该优化可显著降低磁盘I/O和内存占用，尤其适合大宽表场景。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"子查询折叠,通过子查询折叠规则优化，消除了冗余的派生表层级。改写后直接在基表上执行COUNT聚合和条件过滤，避免了中间临时表创建开销，显著降低CPU和I/O负载。语义完全等价且风险极低，预估性能提升10-20%。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,原始SQL中CREATE_USER_ID条件的整数值289865与字段类型varchar(16)不匹配，导致隐式转换和索引失效。优化后将整数转换为字符串'289865'，消除了隐式转换风险\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE hotel_price_adjustment (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), brand_code VARCHAR(50), brand_name VARCHAR(200), hotel_code VARCHAR(50), hotel_name VARCHAR(200), currency VARCHAR(10), category VARCHAR(50), rate_code VARCHAR(50), rate_name VARCHAR(200), price_array_type VARCHAR(50), price_array_code VARCHAR(50), price_array_sequence INT, price_array TEXT, price_array2 TEXT, date_segment VARCHAR(100), weeks VARCHAR(50), brand_maximum_price DECIMAL(18,2), brand_minimum_price DECIMAL(18,2), room_code VARCHAR(50), room_name VARCHAR(200), room_standard_price DECIMAL(18,2), pre_adjustment_price DECIMAL(18,2), adjusted_price DECIMAL(18,2), price_adjustment_range VARCHAR(50), occupancy INT, status VARCHAR(20), reason TEXT, approve_status VARCHAR(20), approve_reason TEXT, operator VARCHAR(100), create_time DATETIME, update_time DATETIME, CREATE_USER_ID BIGINT) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_hotel_code ON hotel_price_adjustment(HOTEL_CODE);\nCREATE INDEX idx_create_user_id ON hotel_price_adjustment(CREATE_USER_ID);\nCREATE INDEX idx_apply_id ON hotel_price_adjustment(apply_id);\nCREATE TABLE price_adjustment_audit_job (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), job_id VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_apply_id_job_id ON price_adjustment_audit_job(apply_id, job_id);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t189504\t100.0\t\n2\tDERIVED\tpa1\t\tALL\tidx_hotel_code,idx_create_user_id\t\t\t\t947046\t20.01\tUsing where\n3\tDEPENDENT SUBQUERY\tpaaj\t\tref\tidx_apply_id_job_id\tidx_apply_id_job_id\t606\ttest_db.pa1.apply_id,const\t189\t100.0\tUsing index\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"21321.70\"\n  },\n  \"table\": {\n   \"table_name\": \"TOTAL\",\n   \"access_type\": \"ALL\",\n   \"rows_examined_per_scan\": 189504,\n   \"rows_produced_per_join\": 189504,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n   \"read_cost\": \"2371.30\",\n   \"eval_cost\": \"18950.40\",\n   \"prefix_cost\": \"21321.70\",\n   \"data_read_per_join\": \"1G\"\n   },\n   \"used_columns\": [\n   \"id\",\n   \"apply_id\",\n   \"brand_code\",\n   \"brand_name\",\n   \"hotel_code\",\n   \"hotel_name\",\n   \"currency\",\n   \"category\",\n   \"rate_code\",\n   \"rate_name\",\n   \"price_array_type\",\n   \"price_array_code\",\n   \"price_array_sequence\",\n   \"price_array\",\n   \"price_array2\",\n   \"date_segment\",\n   \"weeks\",\n   \"brand_maximum_price\",\n   \"brand_minimum_price\",\n   \"room_code\",\n   \"room_name\",\n   \"room_standard_price\",\n   \"pre_adjustment_price\",\n   \"adjusted_price\",\n   \"price_adjustment_range\",\n   \"occupancy\",\n   \"status\",\n   \"reason\",\n   \"approve_status\",\n   \"approve_reason\",\n   \"operator\",\n   \"create_time\",\n   \"update_time\",\n   \"CREATE_USER_ID\",\n   \"auditJobIdcounts\"\n   ],\n   \"materialized_from_subquery\": {\n   \"using_temporary_table\": true,\n   \"dependent\": false,\n   \"cacheable\": true,\n   \"query_block\": {\n   \"select_id\": 2,\n   \"cost_info\": {\n  \"query_cost\": \"119328.41\"\n   },\n   \"table\": {\n  \"table_name\": \"pa1\",\n  \"access_type\": \"ALL\",\n  \"possible_keys\": [\n  \"idx_hotel_code\",\n  \"idx_create_user_id\"\n  ],\n  \"rows_examined_per_scan\": 947046,\n  \"rows_produced_per_join\": 189504,\n  \"filtered\": \"20.01\",\n  \"cost_info\": {\n  \"read_cost\": \"100378.00\",\n  \"eval_cost\": \"18950.41\",\n  \"prefix_cost\": \"119328.41\",\n  \"data_read_per_join\": \"1G\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"apply_id\",\n  \"brand_code\",\n  \"brand_name\",\n  \"hotel_code\",\n  \"hotel_name\",\n  \"currency\",\n  \"category\",\n  \"rate_code\",\n  \"rate_name\",\n  \"price_array_type\",\n  \"price_array_code\",\n  \"price_array_sequence\",\n  \"price_array\",\n  \"price_array2\",\n  \"date_segment\",\n  \"weeks\",\n  \"brand_maximum_price\",\n  \"brand_minimum_price\",\n  \"room_code\",\n  \"room_name\",\n  \"room_standard_price\",\n  \"pre_adjustment_price\",\n  \"adjusted_price\",\n  \"price_adjustment_range\",\n  \"occupancy\",\n  \"status\",\n  \"reason\",\n  \"approve_status\",\n  \"approve_reason\",\n  \"operator\",\n  \"create_time\",\n  \"update_time\",\n  \"CREATE_USER_ID\"\n  ],\n  \"attached_condition\": \"((`test_db`.`pa1`.`hotel_code` in ('6199','JJXRSEH802967')) or (`test_db`.`pa1`.`CREATE_USER_ID` = 289865))\"\n   },\n   \"select_list_subqueries\": [\n  {\n  \"dependent\": true,\n  \"cacheable\": false,\n  \"query_block\": {\n   \"select_id\": 3,\n   \"cost_info\": {\n   \"query_cost\": \"22.55\"\n   },\n   \"table\": {\n   \"table_name\": \"paaj\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n   \"idx_apply_id_job_id\"\n   ],\n   \"key\": \"idx_apply_id_job_id\",\n   \"used_key_parts\": [\n   \"apply_id\",\n   \"job_id\"\n   ],\n   \"key_length\": \"606\",\n   \"ref\": [\n   \"test_db.pa1.apply_id\",\n   \"const\"\n   ],\n   \"rows_examined_per_scan\": 189,\n   \"rows_produced_per_join\": 189,\n   \"filtered\": \"100.00\",\n   \"using_index\": true,\n   \"cost_info\": {\n   \"read_cost\": \"3.61\",\n   \"eval_cost\": \"18.94\",\n   \"prefix_cost\": \"22.55\",\n   \"data_read_per_join\": \"113K\"\n   },\n   \"used_columns\": [\n   \"id\",\n   \"apply_id\",\n   \"job_id\"\n   ]\n   }\n  }\n  }\n   ]\n   }\n   }\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  COUNT(*) \nFROM \n  (\n  SELECT \n   id, \n   apply_id, \n   brand_code, \n   brand_name, \n   hotel_code, \n   hotel_name, \n   currency, \n   category, \n   rate_code, \n   rate_name, \n   price_array_type, \n   price_array_code, \n   price_array_sequence, \n   price_array, \n   price_array2, \n   date_segment, \n   weeks, \n   brand_maximum_price, \n   brand_minimum_price, \n   room_code, \n   room_name, \n   room_standard_price, \n   pre_adjustment_price, \n   adjusted_price, \n   price_adjustment_range, \n   occupancy, \n   status, \n   reason, \n   approve_status, \n   approve_reason, \n   operator, \n   create_time, \n   update_time, \n   CREATE_USER_ID, \n   (\n   SELECT \n   count(paaj.id) \n   FROM \n   price_adjustment_audit_job paaj \n   WHERE \n   paaj.apply_id = pa1.apply_id \n   AND paaj.job_id = '4_004'\n   ) AS auditJobIdcounts \n  FROM \n   hotel_price_adjustment pa1 \n  WHERE \n   (\n   HOTEL_CODE IN ('6199', 'JJXRSEH802967') \n   OR CREATE_USER_ID = 289865\n   )\n  ) TOTAL;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT COUNT(*) FROM (SELECT id FROM hotel_price_adjustment WHERE hotel_code IN ('6199','JJXRSEH802967') UNION SELECT id FROM hotel_price_adjustment WHERE CREATE_USER_ID = 289865) t"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "35",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"35\", \"db_type\": \"mysql\", \"description\": \"这是一个典型的消除无用计算的优化案例。当外层查询只是COUNT(*)时，内层子查询中计算的所有列值（包括通过子查询计算的auditJobIdcounts）都不会影响最终结果。COUNT(*)只关心有多少行满足WHERE条件，而不关心这些行的具体内容。因此可以直接将内层子查询展开，删除所有不必要的列选择和子查询计算，只保留WHERE条件。这种改写消除了189504次依赖子查询执行、临时表物化和34个列的数据读取，大幅提升性能。\", \"create_table_statements\": [\"CREATE TABLE hotel_price_adjustment (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), brand_code VARCHAR(50), brand_name VARCHAR(200), hotel_code VARCHAR(50), hotel_name VARCHAR(200), currency VARCHAR(10), category VARCHAR(50), rate_code VARCHAR(50), rate_name VARCHAR(200), price_array_type VARCHAR(50), price_array_code VARCHAR(50), price_array_sequence INT, price_array TEXT, price_array2 TEXT, date_segment VARCHAR(100), weeks VARCHAR(50), brand_maximum_price DECIMAL(18,2), brand_minimum_price DECIMAL(18,2), room_code VARCHAR(50), room_name VARCHAR(200), room_standard_price DECIMAL(18,2), pre_adjustment_price DECIMAL(18,2), adjusted_price DECIMAL(18,2), price_adjustment_range VARCHAR(50), occupancy INT, status VARCHAR(20), reason TEXT, approve_status VARCHAR(20), approve_reason TEXT, operator VARCHAR(100), create_time DATETIME, update_time DATETIME, CREATE_USER_ID BIGINT) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_hotel_code ON hotel_price_adjustment(HOTEL_CODE);\", \"CREATE INDEX idx_create_user_id ON hotel_price_adjustment(CREATE_USER_ID);\", \"CREATE INDEX idx_apply_id ON hotel_price_adjustment(apply_id);\", \"CREATE TABLE price_adjustment_audit_job (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), job_id VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_apply_id_job_id ON price_adjustment_audit_job(apply_id, job_id);\"], \"sql\": \"SELECT \\n  COUNT(*) \\nFROM \\n  (\\n  SELECT \\n   id, \\n   apply_id, \\n   brand_code, \\n   brand_name, \\n   hotel_code, \\n   hotel_name, \\n   currency, \\n   category, \\n   rate_code, \\n   rate_name, \\n   price_array_type, \\n   price_array_code, \\n   price_array_sequence, \\n   price_array, \\n   price_array2, \\n   date_segment, \\n   weeks, \\n   brand_maximum_price, \\n   brand_minimum_price, \\n   room_code, \\n   room_name, \\n   room_standard_price, \\n   pre_adjustment_price, \\n   adjusted_price, \\n   price_adjustment_range, \\n   occupancy, \\n   status, \\n   reason, \\n   approve_status, \\n   approve_reason, \\n   operator, \\n   create_time, \\n   update_time, \\n   CREATE_USER_ID, \\n   (\\n   SELECT \\n   count(paaj.id) \\n   FROM \\n   price_adjustment_audit_job paaj \\n   WHERE \\n   paaj.apply_id = pa1.apply_id \\n   AND paaj.job_id = '4_004'\\n   ) AS auditJobIdcounts \\n  FROM \\n   hotel_price_adjustment pa1 \\n  WHERE \\n   (\\n   HOTEL_CODE IN ('6199', 'JJXRSEH802967') \\n   OR CREATE_USER_ID = 289865\\n   )\\n  ) TOTAL;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t189504\\t100.0\\t\\n2\\tDERIVED\\tpa1\\t\\tALL\\tidx_hotel_code,idx_create_user_id\\t\\t\\t\\t947046\\t20.01\\tUsing where\\n3\\tDEPENDENT SUBQUERY\\tpaaj\\t\\tref\\tidx_apply_id_job_id\\tidx_apply_id_job_id\\t606\\ttest_db.pa1.apply_id,const\\t189\\t100.0\\tUsing index\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"21321.70\\\"\\n  },\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"TOTAL\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"rows_examined_per_scan\\\": 189504,\\n   \\\"rows_produced_per_join\\\": 189504,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"2371.30\\\",\\n   \\\"eval_cost\\\": \\\"18950.40\\\",\\n   \\\"prefix_cost\\\": \\\"21321.70\\\",\\n   \\\"data_read_per_join\\\": \\\"1G\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"id\\\",\\n   \\\"apply_id\\\",\\n   \\\"brand_code\\\",\\n   \\\"brand_name\\\",\\n   \\\"hotel_code\\\",\\n   \\\"hotel_name\\\",\\n   \\\"currency\\\",\\n   \\\"category\\\",\\n   \\\"rate_code\\\",\\n   \\\"rate_name\\\",\\n   \\\"price_array_type\\\",\\n   \\\"price_array_code\\\",\\n   \\\"price_array_sequence\\\",\\n   \\\"price_array\\\",\\n   \\\"price_array2\\\",\\n   \\\"date_segment\\\",\\n   \\\"weeks\\\",\\n   \\\"brand_maximum_price\\\",\\n   \\\"brand_minimum_price\\\",\\n   \\\"room_code\\\",\\n   \\\"room_name\\\",\\n   \\\"room_standard_price\\\",\\n   \\\"pre_adjustment_price\\\",\\n   \\\"adjusted_price\\\",\\n   \\\"price_adjustment_range\\\",\\n   \\\"occupancy\\\",\\n   \\\"status\\\",\\n   \\\"reason\\\",\\n   \\\"approve_status\\\",\\n   \\\"approve_reason\\\",\\n   \\\"operator\\\",\\n   \\\"create_time\\\",\\n   \\\"update_time\\\",\\n   \\\"CREATE_USER_ID\\\",\\n   \\\"auditJobIdcounts\\\"\\n   ],\\n   \\\"materialized_from_subquery\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"dependent\\\": false,\\n   \\\"cacheable\\\": true,\\n   \\\"query_block\\\": {\\n   \\\"select_id\\\": 2,\\n   \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"119328.41\\\"\\n   },\\n   \\\"table\\\": {\\n  \\\"table_name\\\": \\\"pa1\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_hotel_code\\\",\\n  \\\"idx_create_user_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 947046,\\n  \\\"rows_produced_per_join\\\": 189504,\\n  \\\"filtered\\\": \\\"20.01\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"100378.00\\\",\\n  \\\"eval_cost\\\": \\\"18950.41\\\",\\n  \\\"prefix_cost\\\": \\\"119328.41\\\",\\n  \\\"data_read_per_join\\\": \\\"1G\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"apply_id\\\",\\n  \\\"brand_code\\\",\\n  \\\"brand_name\\\",\\n  \\\"hotel_code\\\",\\n  \\\"hotel_name\\\",\\n  \\\"currency\\\",\\n  \\\"category\\\",\\n  \\\"rate_code\\\",\\n  \\\"rate_name\\\",\\n  \\\"price_array_type\\\",\\n  \\\"price_array_code\\\",\\n  \\\"price_array_sequence\\\",\\n  \\\"price_array\\\",\\n  \\\"price_array2\\\",\\n  \\\"date_segment\\\",\\n  \\\"weeks\\\",\\n  \\\"brand_maximum_price\\\",\\n  \\\"brand_minimum_price\\\",\\n  \\\"room_code\\\",\\n  \\\"room_name\\\",\\n  \\\"room_standard_price\\\",\\n  \\\"pre_adjustment_price\\\",\\n  \\\"adjusted_price\\\",\\n  \\\"price_adjustment_range\\\",\\n  \\\"occupancy\\\",\\n  \\\"status\\\",\\n  \\\"reason\\\",\\n  \\\"approve_status\\\",\\n  \\\"approve_reason\\\",\\n  \\\"operator\\\",\\n  \\\"create_time\\\",\\n  \\\"update_time\\\",\\n  \\\"CREATE_USER_ID\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`pa1`.`hotel_code` in ('6199','JJXRSEH802967')) or (`test_db`.`pa1`.`CREATE_USER_ID` = 289865))\\\"\\n   },\\n   \\\"select_list_subqueries\\\": [\\n  {\\n  \\\"dependent\\\": true,\\n  \\\"cacheable\\\": false,\\n  \\\"query_block\\\": {\\n   \\\"select_id\\\": 3,\\n   \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"22.55\\\"\\n   },\\n   \\\"table\\\": {\\n   \\\"table_name\\\": \\\"paaj\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"idx_apply_id_job_id\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_apply_id_job_id\\\",\\n   \\\"used_key_parts\\\": [\\n   \\\"apply_id\\\",\\n   \\\"job_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"606\\\",\\n   \\\"ref\\\": [\\n   \\\"test_db.pa1.apply_id\\\",\\n   \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 189,\\n   \\\"rows_produced_per_join\\\": 189,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"using_index\\\": true,\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"3.61\\\",\\n   \\\"eval_cost\\\": \\\"18.94\\\",\\n   \\\"prefix_cost\\\": \\\"22.55\\\",\\n   \\\"data_read_per_join\\\": \\\"113K\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"id\\\",\\n   \\\"apply_id\\\",\\n   \\\"job_id\\\"\\n   ]\\n   }\\n  }\\n  }\\n   ]\\n   }\\n   }\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推消除子查询中所有冗余列，将子查询简化为SELECT 1，减少97%的数据读取量（从30+列降为1列）。该优化可显著降低磁盘I/O和内存占用，尤其适合大宽表场景。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"子查询折叠,通过子查询折叠规则优化，消除了冗余的派生表层级。改写后直接在基表上执行COUNT聚合和条件过滤，避免了中间临时表创建开销，显著降低CPU和I/O负载。语义完全等价且风险极低，预估性能提升10-20%。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,原始SQL中CREATE_USER_ID条件的整数值289865与字段类型varchar(16)不匹配，导致隐式转换和索引失效。优化后将整数转换为字符串'289865'，消除了隐式转换风险\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE hotel_price_adjustment (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), brand_code VARCHAR(50), brand_name VARCHAR(200), hotel_code VARCHAR(50), hotel_name VARCHAR(200), currency VARCHAR(10), category VARCHAR(50), rate_code VARCHAR(50), rate_name VARCHAR(200), price_array_type VARCHAR(50), price_array_code VARCHAR(50), price_array_sequence INT, price_array TEXT, price_array2 TEXT, date_segment VARCHAR(100), weeks VARCHAR(50), brand_maximum_price DECIMAL(18,2), brand_minimum_price DECIMAL(18,2), room_code VARCHAR(50), room_name VARCHAR(200), room_standard_price DECIMAL(18,2), pre_adjustment_price DECIMAL(18,2), adjusted_price DECIMAL(18,2), price_adjustment_range VARCHAR(50), occupancy INT, status VARCHAR(20), reason TEXT, approve_status VARCHAR(20), approve_reason TEXT, operator VARCHAR(100), create_time DATETIME, update_time DATETIME, CREATE_USER_ID BIGINT) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_hotel_code ON hotel_price_adjustment(HOTEL_CODE);\nCREATE INDEX idx_create_user_id ON hotel_price_adjustment(CREATE_USER_ID);\nCREATE INDEX idx_apply_id ON hotel_price_adjustment(apply_id);\nCREATE TABLE price_adjustment_audit_job (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), job_id VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_apply_id_job_id ON price_adjustment_audit_job(apply_id, job_id);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t189504\t100.0\t\n2\tDERIVED\tpa1\t\tALL\tidx_hotel_code,idx_create_user_id\t\t\t\t947046\t20.01\tUsing where\n3\tDEPENDENT SUBQUERY\tpaaj\t\tref\tidx_apply_id_job_id\tidx_apply_id_job_id\t606\ttest_db.pa1.apply_id,const\t189\t100.0\tUsing index\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"21321.70\"\n  },\n  \"table\": {\n   \"table_name\": \"TOTAL\",\n   \"access_type\": \"ALL\",\n   \"rows_examined_per_scan\": 189504,\n   \"rows_produced_per_join\": 189504,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n   \"read_cost\": \"2371.30\",\n   \"eval_cost\": \"18950.40\",\n   \"prefix_cost\": \"21321.70\",\n   \"data_read_per_join\": \"1G\"\n   },\n   \"used_columns\": [\n   \"id\",\n   \"apply_id\",\n   \"brand_code\",\n   \"brand_name\",\n   \"hotel_code\",\n   \"hotel_name\",\n   \"currency\",\n   \"category\",\n   \"rate_code\",\n   \"rate_name\",\n   \"price_array_type\",\n   \"price_array_code\",\n   \"price_array_sequence\",\n   \"price_array\",\n   \"price_array2\",\n   \"date_segment\",\n   \"weeks\",\n   \"brand_maximum_price\",\n   \"brand_minimum_price\",\n   \"room_code\",\n   \"room_name\",\n   \"room_standard_price\",\n   \"pre_adjustment_price\",\n   \"adjusted_price\",\n   \"price_adjustment_range\",\n   \"occupancy\",\n   \"status\",\n   \"reason\",\n   \"approve_status\",\n   \"approve_reason\",\n   \"operator\",\n   \"create_time\",\n   \"update_time\",\n   \"CREATE_USER_ID\",\n   \"auditJobIdcounts\"\n   ],\n   \"materialized_from_subquery\": {\n   \"using_temporary_table\": true,\n   \"dependent\": false,\n   \"cacheable\": true,\n   \"query_block\": {\n   \"select_id\": 2,\n   \"cost_info\": {\n  \"query_cost\": \"119328.41\"\n   },\n   \"table\": {\n  \"table_name\": \"pa1\",\n  \"access_type\": \"ALL\",\n  \"possible_keys\": [\n  \"idx_hotel_code\",\n  \"idx_create_user_id\"\n  ],\n  \"rows_examined_per_scan\": 947046,\n  \"rows_produced_per_join\": 189504,\n  \"filtered\": \"20.01\",\n  \"cost_info\": {\n  \"read_cost\": \"100378.00\",\n  \"eval_cost\": \"18950.41\",\n  \"prefix_cost\": \"119328.41\",\n  \"data_read_per_join\": \"1G\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"apply_id\",\n  \"brand_code\",\n  \"brand_name\",\n  \"hotel_code\",\n  \"hotel_name\",\n  \"currency\",\n  \"category\",\n  \"rate_code\",\n  \"rate_name\",\n  \"price_array_type\",\n  \"price_array_code\",\n  \"price_array_sequence\",\n  \"price_array\",\n  \"price_array2\",\n  \"date_segment\",\n  \"weeks\",\n  \"brand_maximum_price\",\n  \"brand_minimum_price\",\n  \"room_code\",\n  \"room_name\",\n  \"room_standard_price\",\n  \"pre_adjustment_price\",\n  \"adjusted_price\",\n  \"price_adjustment_range\",\n  \"occupancy\",\n  \"status\",\n  \"reason\",\n  \"approve_status\",\n  \"approve_reason\",\n  \"operator\",\n  \"create_time\",\n  \"update_time\",\n  \"CREATE_USER_ID\"\n  ],\n  \"attached_condition\": \"((`test_db`.`pa1`.`hotel_code` in ('6199','JJXRSEH802967')) or (`test_db`.`pa1`.`CREATE_USER_ID` = 289865))\"\n   },\n   \"select_list_subqueries\": [\n  {\n  \"dependent\": true,\n  \"cacheable\": false,\n  \"query_block\": {\n   \"select_id\": 3,\n   \"cost_info\": {\n   \"query_cost\": \"22.55\"\n   },\n   \"table\": {\n   \"table_name\": \"paaj\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n   \"idx_apply_id_job_id\"\n   ],\n   \"key\": \"idx_apply_id_job_id\",\n   \"used_key_parts\": [\n   \"apply_id\",\n   \"job_id\"\n   ],\n   \"key_length\": \"606\",\n   \"ref\": [\n   \"test_db.pa1.apply_id\",\n   \"const\"\n   ],\n   \"rows_examined_per_scan\": 189,\n   \"rows_produced_per_join\": 189,\n   \"filtered\": \"100.00\",\n   \"using_index\": true,\n   \"cost_info\": {\n   \"read_cost\": \"3.61\",\n   \"eval_cost\": \"18.94\",\n   \"prefix_cost\": \"22.55\",\n   \"data_read_per_join\": \"113K\"\n   },\n   \"used_columns\": [\n   \"id\",\n   \"apply_id\",\n   \"job_id\"\n   ]\n   }\n  }\n  }\n   ]\n   }\n   }\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  COUNT(*) \nFROM \n  (\n  SELECT \n   id, \n   apply_id, \n   brand_code, \n   brand_name, \n   hotel_code, \n   hotel_name, \n   currency, \n   category, \n   rate_code, \n   rate_name, \n   price_array_type, \n   price_array_code, \n   price_array_sequence, \n   price_array, \n   price_array2, \n   date_segment, \n   weeks, \n   brand_maximum_price, \n   brand_minimum_price, \n   room_code, \n   room_name, \n   room_standard_price, \n   pre_adjustment_price, \n   adjusted_price, \n   price_adjustment_range, \n   occupancy, \n   status, \n   reason, \n   approve_status, \n   approve_reason, \n   operator, \n   create_time, \n   update_time, \n   CREATE_USER_ID, \n   (\n   SELECT \n   count(paaj.id) \n   FROM \n   price_adjustment_audit_job paaj \n   WHERE \n   paaj.apply_id = pa1.apply_id \n   AND paaj.job_id = '4_004'\n   ) AS auditJobIdcounts \n  FROM \n   hotel_price_adjustment pa1 \n  WHERE \n   (\n   HOTEL_CODE IN ('6199', 'JJXRSEH802967') \n   OR CREATE_USER_ID = 289865\n   )\n  ) TOTAL;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT COUNT(*) FROM (SELECT id FROM hotel_price_adjustment WHERE hotel_code IN ('6199','JJXRSEH802967') UNION SELECT id FROM hotel_price_adjustment WHERE CREATE_USER_ID = 289865) t"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "36",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"36\", \"db_type\": \"mysql\", \"description\": \"这种改写技术通过将OR条件拆分为多个UNION子查询，理论上可以让每个子查询更充分地利用索引。在某些数据库版本或特定场景下，当OR条件导致优化器无法有效使用索引时，这种改写可能带来性能提升。但在本案例中，MySQL的index_merge优化已经能够很好地处理OR条件，反而是UNION引入的额外开销导致性能下降\", \"create_table_statements\": [\"CREATE TABLE DOCUMENT (id INT PRIMARY KEY AUTO_INCREMENT, pdfKey VARCHAR(255), fileKey VARCHAR(255)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_pdfKey ON DOCUMENT(pdfKey);\", \"CREATE INDEX idx_fileKey ON DOCUMENT(fileKey);\"], \"sql\": \"SELECT \\n  * \\nfrom \\n  DOCUMENT \\nwhere \\n  (\\n  pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne' \\n  or fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'\\n  );\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tSIMPLE\\tDOCUMENT\\t\\tindex_merge\\tidx_pdfKey,idx_fileKey\\tidx_pdfKey,idx_fileKey\\t1023,1023\\t\\t2\\t100.0\\tUsing union(idx_pdfKey,idx_fileKey); Using where\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"3.55\\\"\\n  },\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"DOCUMENT\\\",\\n   \\\"access_type\\\": \\\"index_merge\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"idx_pdfKey\\\",\\n   \\\"idx_fileKey\\\"\\n   ],\\n   \\\"key\\\": \\\"union(idx_pdfKey,idx_fileKey)\\\",\\n   \\\"key_length\\\": \\\"1023,1023\\\",\\n   \\\"rows_examined_per_scan\\\": 2,\\n   \\\"rows_produced_per_join\\\": 2,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"3.35\\\",\\n   \\\"eval_cost\\\": \\\"0.20\\\",\\n   \\\"prefix_cost\\\": \\\"3.55\\\",\\n   \\\"data_read_per_join\\\": \\\"4K\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"id\\\",\\n   \\\"pdfKey\\\",\\n   \\\"fileKey\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`DOCUMENT`.`pdfKey` = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne') or (`test_db`.`DOCUMENT`.`fileKey` = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'))\\\"\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"OR 条件转 UNION,WHERE条件中的OR连接(pdfKey/fileKey)导致可能低效的索引合并。通过UNION拆分使每个查询充分利用单列索引(IDX_DOC_PDFKEY/IDX_DOC_FILEKEY)，避免全表扫描\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE DOCUMENT (id INT PRIMARY KEY AUTO_INCREMENT, pdfKey VARCHAR(255), fileKey VARCHAR(255)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_pdfKey ON DOCUMENT(pdfKey);\nCREATE INDEX idx_fileKey ON DOCUMENT(fileKey);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tSIMPLE\tDOCUMENT\t\tindex_merge\tidx_pdfKey,idx_fileKey\tidx_pdfKey,idx_fileKey\t1023,1023\t\t2\t100.0\tUsing union(idx_pdfKey,idx_fileKey); Using where\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"3.55\"\n  },\n  \"table\": {\n   \"table_name\": \"DOCUMENT\",\n   \"access_type\": \"index_merge\",\n   \"possible_keys\": [\n   \"idx_pdfKey\",\n   \"idx_fileKey\"\n   ],\n   \"key\": \"union(idx_pdfKey,idx_fileKey)\",\n   \"key_length\": \"1023,1023\",\n   \"rows_examined_per_scan\": 2,\n   \"rows_produced_per_join\": 2,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n   \"read_cost\": \"3.35\",\n   \"eval_cost\": \"0.20\",\n   \"prefix_cost\": \"3.55\",\n   \"data_read_per_join\": \"4K\"\n   },\n   \"used_columns\": [\n   \"id\",\n   \"pdfKey\",\n   \"fileKey\"\n   ],\n   \"attached_condition\": \"((`test_db`.`DOCUMENT`.`pdfKey` = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne') or (`test_db`.`DOCUMENT`.`fileKey` = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'))\"\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  * \nfrom \n  DOCUMENT \nwhere \n  (\n  pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne' \n  or fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'\n  );\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM DOCUMENT WHERE pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne' UNION ALL SELECT * FROM DOCUMENT WHERE fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "37",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"37\", \"db_type\": \"oracle\", \"description\": \"问题概述：查询通过 CTE a1 对 FEE_LIST_D 做了大量的聚合（多个 LISTAGG、SUM、MIN 等），并在 a2 中使用 `a1.*` 再做计算和过滤后与 SETL_D_MERGED 连接。实际最终 SELECT 只使用了 a1 中的一部分列（例如 b_fee、min_amt 等列并未被外层查询引用），但由于使用了 `a1.*` 导致这些不必要的列在聚合阶段就被计算/传递，增加了 CPU、内存与 I/O 开销，同时阻止了投影下推优化。建议通过投影下推（在 a1 中仅输出外层实际需要的列，避免 a1.*）来减少中间数据量与聚合成本；同时可考虑在 a1 中下推过滤谓词并为连接列建索引以进一步降低成本。\", \"create_table_statements\": [\"CREATE TABLE FEE_LIST_D (setl_id VARCHAR2(50), MEDINS_LIST_CODG VARCHAR2(100), medins_list_name VARCHAR2(200), hilist_code VARCHAR2(100), hilist_name VARCHAR2(200), MED_CHRGITM_TYPE_NAME VARCHAR2(100), CHRGITM_LV_NAME VARCHAR2(50), BILG_DEPT_NAME VARCHAR2(200), BILG_DR_NAME VARCHAR2(200), ACORD_DEPT_NAME VARCHAR2(200), ACORD_DR_NAME VARCHAR2(200), cnt NUMBER, det_item_fee_sumamt NUMBER(18,2), pric NUMBER(18,4), inscp_amt NUMBER(18,2));\", \"CREATE INDEX idx_fee_list_d_setl_id ON FEE_LIST_D(setl_id);\", \"CREATE INDEX idx_fee_list_d_cnt ON FEE_LIST_D(cnt);\", \"CREATE TABLE SETL_D_MERGED (setl_id VARCHAR2(50) PRIMARY KEY, fixmedins_code VARCHAR2(50), fixmedins_name VARCHAR2(200), HOSP_LV_NAME VARCHAR2(50), mdtrt_id VARCHAR2(50), ipt_otp_no VARCHAR2(50), psn_no VARCHAR2(50), psn_name VARCHAR2(200), certno VARCHAR2(30), GEND_NAME VARCHAR2(20), brdy DATE, age NUMBER, insu_admdvs VARCHAR2(50), INSUTYPE_NAME VARCHAR2(100), PSN_TYPE_NAME VARCHAR2(100), SP_PSN_TYPE_NAME VARCHAR2(100), med_type_name VARCHAR2(100), PAY_LOC_NAME VARCHAR2(100), setl_time DATE, adm_dept_name VARCHAR2(200), dscg_dept_name VARCHAR2(200), begntime DATE, endtime DATE, IPT_DAYS NUMBER, chfpdr_name VARCHAR2(200), adm_diag_dscr VARCHAR2(4000), dscg_maindiag_name VARCHAR2(4000), DIAG_NAME VARCHAR2(4000), dise_no VARCHAR2(50), dise_name VARCHAR2(200), OPRN_NAME VARCHAR2(4000), medfee_sumamt NUMBER(18,2), pool_prop_selfpay NUMBER, hifp_pay NUMBER, hifmi_pay NUMBER, maf_pay NUMBER, cvlserv_pay NUMBER, othfund_pay NUMBER, acct_pay NUMBER, cash_payamt NUMBER, fund_pay_sumamt NUMBER, insutype VARCHAR2(50));\", \"CREATE INDEX idx_setl_d_merged_setl_id ON SETL_D_MERGED(setl_id);\", \"CREATE INDEX idx_setl_d_fund_pay ON SETL_D_MERGED(FUND_PAY_SUMAMT)\"], \"sql\": \"with\\na1 as (\\n  select\\n  setl_id,\\n  -- 聚合项目信息\\n  listagg(distinct MEDINS_LIST_CODG, ',') within group (order by MEDINS_LIST_CODG) b_medins_list_codg,\\n  listagg(distinct medins_list_name, ',') within group (order by medins_list_name) b_medins_list_name,\\n  listagg(distinct f.hilist_code, ',') within group (order by f.hilist_code) b_hilist_code,\\n  listagg(distinct hilist_name, ',') within group (order by hilist_name) b_hilist_name,\\n  listagg(distinct MED_CHRGITM_TYPE_NAME, ',') within group (order by MED_CHRGITM_TYPE_NAME) MED_CHRGITM_TYPE,\\n  listagg(distinct CHRGITM_LV_NAME, ',') within group (order by CHRGITM_LV_NAME) CHRGITM_LV,\\n  listagg(distinct BILG_DEPT_NAME, ',') within group (order by BILG_DEPT_NAME) BILG_DEPT_NAME,\\n  listagg(distinct BILG_DR_NAME, ',') within group (order by BILG_DR_NAME) BILG_DR_NAME,\\n  listagg(distinct ACORD_DEPT_NAME, ',') within group (order by ACORD_DEPT_NAME) ACORD_DEPT_NAME,\\n  listagg(distinct ACORD_DR_NAME, ',') within group (order by ACORD_DR_NAME) ACORD_DR_NAME,\\n  -- 统一转换为“日”单位后的总数量\\n  sum(f.cnt ) as b_cnt,\\n  -- 总费用\\n  sum(f.det_item_fee_sumamt) as b_fee,\\n  -- 转换为“日”单位后的最小单价\\n  min(f.pric ) as min_pric,\\n  -- 转换为“日”单位后的最小金额\\n  min(abs(f.inscp_amt / f.cnt) ) as min_amt\\n  from FEE_LIST_D f\\n  -- 关联单位转换系数表\\n   where f.cnt <> 0\\n   and f.CHRGITM_LV_NAME in ('甲类','乙类')\\n  -- 按结算流水号分组\\n  group by f.setl_id\\n),\\na2 as (\\n  select a1.*,\\n  -- 违规数量\\n  case\\n   when a1.b_cnt > (s.ipt_days *12+24) then a1.b_cnt - (s.ipt_days *12+24)\\n   else 0\\n  end as break_cnt,\\n  -- 违规金额\\n  case\\n   when a1.b_cnt > (s.ipt_days *12+24) then (a1.b_cnt - (s.ipt_days *12+24)) * (a1.min_pric * 1)\\n   else 0\\n  end as break_fee,\\n  -- 违规范围内金额\\n  case\\n   when a1.b_cnt > (s.ipt_days *12+24) then (a1.b_cnt - (s.ipt_days *12+24)) * (a1.min_amt * 1)\\n   else 0\\n  end as break_amt\\n  from a1\\n  -- 关联结算表获取住院天数\\n  inner join SETL_D_MERGED s on a1.setl_id = s.setl_id\\n  -- 过滤违规数据\\n  where a1.b_cnt > (s.ipt_days *12+24)\\n   and s.FUND_PAY_SUMAMT <> 0\\n)\\nselect\\n  s.fixmedins_code 医院代码,\\n  s.fixmedins_name 医院名称,\\n  s.HOSP_LV_NAME 医院级别,\\n  s.setl_id 结算单据号,\\n  s.mdtrt_id 就诊ID,\\n  s.ipt_otp_no 住院号,\\n  s.psn_no 个人编号,\\n  s.psn_name 姓名,\\n  s.certno 身份证号,\\n  s.GEND_NAME 性别,\\n  s.brdy 出生日期,\\n  s.age 年龄,\\n  s.insu_admdvs 统筹区,\\n  s.INSUTYPE_NAME 险种类型,\\n  s.PSN_TYPE_NAME 医疗人员类别,\\n  s.SP_PSN_TYPE_NAME 特殊人员身份类别,\\n  s.med_type_name 就医类型,\\n  s.PAY_LOC_NAME 支付地点类别,\\n  s.setl_time 结算日期,\\n  s.adm_dept_name 入院科室,\\n  s.dscg_dept_name 出院科室,\\n  s.begntime 入院日期,\\n  s.endtime 出院日期,\\n  s.IPT_DAYS 天数,\\n  s.chfpdr_name 主治医生,\\n  s.adm_diag_dscr 入院诊断,\\n  s.dscg_maindiag_name 出院诊断,\\n  s.DIAG_NAME 其他诊断,\\n  s.dise_no 病种编码,\\n  s.dise_name 病种名称,\\n  s.OPRN_NAME 手术及操作名称,\\n  s.medfee_sumamt 总金额,\\n  concat(to_char(s.pool_prop_selfpay * 100), '%') 基本医疗统筹支付比例,\\n  s.hifp_pay 基本医保支付,\\n  s.hifmi_pay 大病报销,\\n  s.maf_pay 医疗救助,\\n  s.cvlserv_pay 公务员补充,\\n  s.othfund_pay 其他支付,\\n  s.acct_pay 个人帐户支付,\\n  s.cash_payamt 个人现金支付,\\n  s.fund_pay_sumamt 基金支付总额,\\n  fl.MED_CHRGITM_TYPE 费用类别,\\n  fl.BILG_DEPT_NAME 开单科室名称,\\n  fl.BILG_DR_NAME 开单医生姓名,\\n  fl.ACORD_DEPT_NAME 受单科室名称,\\n  fl.ACORD_DR_NAME 受单医生姓名,\\n  null 收费日期,\\n  fl.b_medins_list_codg 违规医院项目代码,\\n  fl.b_medins_list_name 违规医院项目名称,\\n  fl.b_hilist_code 违规医保项目代码,\\n  fl.b_hilist_name 违规医保项目名称,\\n  null 正常医院项目代码,\\n  null 正常医院项目名称,\\n  null 正常医保项目代码,\\n  null 正常医保项目名称,\\n  null 正常项目数量,\\n  null 正常项目金额,\\n  fl.b_cnt 违规项目收费数量,\\n  fl.min_pric 违规项目单价,\\n  fl.break_cnt 违规项目数量,\\n  fl.CHRGITM_LV 违规项目支付类别,\\n  fl.break_fee 违规项目金额,\\n  fl.break_amt 违规项目范围内金额,\\n  gettcamount(fl.break_amt, s.pool_prop_selfpay, s.hifp_pay, s.fund_pay_sumamt) 基本统筹违规金额,\\n  getdbamount(fl.break_amt, s.insutype, s.hifmi_pay, s.fund_pay_sumamt) 大病统筹违规金额,\\n  GETMAFAMOUNT(fl.break_amt, s.maf_pay, s.fund_pay_sumamt) 医疗救助违规金额,\\n  case when substr(s.INSU_ADMDVS,1,4) != '{pool_no}' then '是' else '否' end 是否异地,\\n  'CB_0020' 违规规则代码,\\n  '超标准收费' 违规类型,\\n  '按小时收费的血液净化类诊疗项目（如自动腹膜透析、连续性血液净化等），收费数量超过实际提供的诊疗服务数量。' 违规事项,\\n  '《江西省医疗服务价格项目目录（2023年修订版）》中血液净化类诊疗项目收费的真实性。' 违规依据\\nfrom SETL_D_MERGED s\\ninner join a2 fl on s.setl_id = fl.setl_id\\nwhere s.FUND_PAY_SUMAMT <> 0\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t1250\\t1000\\t800000\\t400000\\t1200\\n1\\t  NESTED LOOPS\\t1250\\t1000\\t800000\\t400000\\t1200\\n2\\t   VIEW (A2 - FILTER & JOIN)\\t1000\\t1000\\t600000\\t300000\\t800\\n3\\t  HASH GROUP BY (A1 aggregation)\\t1000\\t1000\\t600000\\t300000\\t800\\n4\\t   TABLE ACCESS FULL FEE_LIST_D\\t900\\t10000\\t5400000\\t270000\\t700\\n5\\t   TABLE ACCESS BY INDEX ROWID SETL_D_MERGED\\t200\\t1000\\t800000\\t80000\\t400\\n6\\t  INDEX UNIQUE SCAN IDX_SETL_D_MERGED_SETL_ID\\t5\\t1000\\t8000\\t2000\\t10\\n7\\t  FILTER (s.FUND_PAY_SUMAMT <> 0 AND a1.b_cnt > (s.ipt_days*12+24))\\t---\\t---\\t---\\t---\\t---\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推，移除了a1中未使用的b_fee列，并在a2中显式指定所需的列而不是使用a1.*，减少了数据传递量，提高了查询效率。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE FEE_LIST_D (setl_id VARCHAR2(50), MEDINS_LIST_CODG VARCHAR2(100), medins_list_name VARCHAR2(200), hilist_code VARCHAR2(100), hilist_name VARCHAR2(200), MED_CHRGITM_TYPE_NAME VARCHAR2(100), CHRGITM_LV_NAME VARCHAR2(50), BILG_DEPT_NAME VARCHAR2(200), BILG_DR_NAME VARCHAR2(200), ACORD_DEPT_NAME VARCHAR2(200), ACORD_DR_NAME VARCHAR2(200), cnt NUMBER, det_item_fee_sumamt NUMBER(18,2), pric NUMBER(18,4), inscp_amt NUMBER(18,2));\nCREATE INDEX idx_fee_list_d_setl_id ON FEE_LIST_D(setl_id);\nCREATE INDEX idx_fee_list_d_cnt ON FEE_LIST_D(cnt);\nCREATE TABLE SETL_D_MERGED (setl_id VARCHAR2(50) PRIMARY KEY, fixmedins_code VARCHAR2(50), fixmedins_name VARCHAR2(200), HOSP_LV_NAME VARCHAR2(50), mdtrt_id VARCHAR2(50), ipt_otp_no VARCHAR2(50), psn_no VARCHAR2(50), psn_name VARCHAR2(200), certno VARCHAR2(30), GEND_NAME VARCHAR2(20), brdy DATE, age NUMBER, insu_admdvs VARCHAR2(50), INSUTYPE_NAME VARCHAR2(100), PSN_TYPE_NAME VARCHAR2(100), SP_PSN_TYPE_NAME VARCHAR2(100), med_type_name VARCHAR2(100), PAY_LOC_NAME VARCHAR2(100), setl_time DATE, adm_dept_name VARCHAR2(200), dscg_dept_name VARCHAR2(200), begntime DATE, endtime DATE, IPT_DAYS NUMBER, chfpdr_name VARCHAR2(200), adm_diag_dscr VARCHAR2(4000), dscg_maindiag_name VARCHAR2(4000), DIAG_NAME VARCHAR2(4000), dise_no VARCHAR2(50), dise_name VARCHAR2(200), OPRN_NAME VARCHAR2(4000), medfee_sumamt NUMBER(18,2), pool_prop_selfpay NUMBER, hifp_pay NUMBER, hifmi_pay NUMBER, maf_pay NUMBER, cvlserv_pay NUMBER, othfund_pay NUMBER, acct_pay NUMBER, cash_payamt NUMBER, fund_pay_sumamt NUMBER, insutype VARCHAR2(50));\nCREATE INDEX idx_setl_d_merged_setl_id ON SETL_D_MERGED(setl_id);\nCREATE INDEX idx_setl_d_fund_pay ON SETL_D_MERGED(FUND_PAY_SUMAMT)\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t1250\t1000\t800000\t400000\t1200\n1\t  NESTED LOOPS\t1250\t1000\t800000\t400000\t1200\n2\t   VIEW (A2 - FILTER & JOIN)\t1000\t1000\t600000\t300000\t800\n3\t  HASH GROUP BY (A1 aggregation)\t1000\t1000\t600000\t300000\t800\n4\t   TABLE ACCESS FULL FEE_LIST_D\t900\t10000\t5400000\t270000\t700\n5\t   TABLE ACCESS BY INDEX ROWID SETL_D_MERGED\t200\t1000\t800000\t80000\t400\n6\t  INDEX UNIQUE SCAN IDX_SETL_D_MERGED_SETL_ID\t5\t1000\t8000\t2000\t10\n7\t  FILTER (s.FUND_PAY_SUMAMT <> 0 AND a1.b_cnt > (s.ipt_days*12+24))\t---\t---\t---\t---\t---\n\n## Original SQL:\nwith\na1 as (\n  select\n  setl_id,\n  -- 聚合项目信息\n  listagg(distinct MEDINS_LIST_CODG, ',') within group (order by MEDINS_LIST_CODG) b_medins_list_codg,\n  listagg(distinct medins_list_name, ',') within group (order by medins_list_name) b_medins_list_name,\n  listagg(distinct f.hilist_code, ',') within group (order by f.hilist_code) b_hilist_code,\n  listagg(distinct hilist_name, ',') within group (order by hilist_name) b_hilist_name,\n  listagg(distinct MED_CHRGITM_TYPE_NAME, ',') within group (order by MED_CHRGITM_TYPE_NAME) MED_CHRGITM_TYPE,\n  listagg(distinct CHRGITM_LV_NAME, ',') within group (order by CHRGITM_LV_NAME) CHRGITM_LV,\n  listagg(distinct BILG_DEPT_NAME, ',') within group (order by BILG_DEPT_NAME) BILG_DEPT_NAME,\n  listagg(distinct BILG_DR_NAME, ',') within group (order by BILG_DR_NAME) BILG_DR_NAME,\n  listagg(distinct ACORD_DEPT_NAME, ',') within group (order by ACORD_DEPT_NAME) ACORD_DEPT_NAME,\n  listagg(distinct ACORD_DR_NAME, ',') within group (order by ACORD_DR_NAME) ACORD_DR_NAME,\n  -- 统一转换为“日”单位后的总数量\n  sum(f.cnt ) as b_cnt,\n  -- 总费用\n  sum(f.det_item_fee_sumamt) as b_fee,\n  -- 转换为“日”单位后的最小单价\n  min(f.pric ) as min_pric,\n  -- 转换为“日”单位后的最小金额\n  min(abs(f.inscp_amt / f.cnt) ) as min_amt\n  from FEE_LIST_D f\n  -- 关联单位转换系数表\n   where f.cnt <> 0\n   and f.CHRGITM_LV_NAME in ('甲类','乙类')\n  -- 按结算流水号分组\n  group by f.setl_id\n),\na2 as (\n  select a1.*,\n  -- 违规数量\n  case\n   when a1.b_cnt > (s.ipt_days *12+24) then a1.b_cnt - (s.ipt_days *12+24)\n   else 0\n  end as break_cnt,\n  -- 违规金额\n  case\n   when a1.b_cnt > (s.ipt_days *12+24) then (a1.b_cnt - (s.ipt_days *12+24)) * (a1.min_pric * 1)\n   else 0\n  end as break_fee,\n  -- 违规范围内金额\n  case\n   when a1.b_cnt > (s.ipt_days *12+24) then (a1.b_cnt - (s.ipt_days *12+24)) * (a1.min_amt * 1)\n   else 0\n  end as break_amt\n  from a1\n  -- 关联结算表获取住院天数\n  inner join SETL_D_MERGED s on a1.setl_id = s.setl_id\n  -- 过滤违规数据\n  where a1.b_cnt > (s.ipt_days *12+24)\n   and s.FUND_PAY_SUMAMT <> 0\n)\nselect\n  s.fixmedins_code 医院代码,\n  s.fixmedins_name 医院名称,\n  s.HOSP_LV_NAME 医院级别,\n  s.setl_id 结算单据号,\n  s.mdtrt_id 就诊ID,\n  s.ipt_otp_no 住院号,\n  s.psn_no 个人编号,\n  s.psn_name 姓名,\n  s.certno 身份证号,\n  s.GEND_NAME 性别,\n  s.brdy 出生日期,\n  s.age 年龄,\n  s.insu_admdvs 统筹区,\n  s.INSUTYPE_NAME 险种类型,\n  s.PSN_TYPE_NAME 医疗人员类别,\n  s.SP_PSN_TYPE_NAME 特殊人员身份类别,\n  s.med_type_name 就医类型,\n  s.PAY_LOC_NAME 支付地点类别,\n  s.setl_time 结算日期,\n  s.adm_dept_name 入院科室,\n  s.dscg_dept_name 出院科室,\n  s.begntime 入院日期,\n  s.endtime 出院日期,\n  s.IPT_DAYS 天数,\n  s.chfpdr_name 主治医生,\n  s.adm_diag_dscr 入院诊断,\n  s.dscg_maindiag_name 出院诊断,\n  s.DIAG_NAME 其他诊断,\n  s.dise_no 病种编码,\n  s.dise_name 病种名称,\n  s.OPRN_NAME 手术及操作名称,\n  s.medfee_sumamt 总金额,\n  concat(to_char(s.pool_prop_selfpay * 100), '%') 基本医疗统筹支付比例,\n  s.hifp_pay 基本医保支付,\n  s.hifmi_pay 大病报销,\n  s.maf_pay 医疗救助,\n  s.cvlserv_pay 公务员补充,\n  s.othfund_pay 其他支付,\n  s.acct_pay 个人帐户支付,\n  s.cash_payamt 个人现金支付,\n  s.fund_pay_sumamt 基金支付总额,\n  fl.MED_CHRGITM_TYPE 费用类别,\n  fl.BILG_DEPT_NAME 开单科室名称,\n  fl.BILG_DR_NAME 开单医生姓名,\n  fl.ACORD_DEPT_NAME 受单科室名称,\n  fl.ACORD_DR_NAME 受单医生姓名,\n  null 收费日期,\n  fl.b_medins_list_codg 违规医院项目代码,\n  fl.b_medins_list_name 违规医院项目名称,\n  fl.b_hilist_code 违规医保项目代码,\n  fl.b_hilist_name 违规医保项目名称,\n  null 正常医院项目代码,\n  null 正常医院项目名称,\n  null 正常医保项目代码,\n  null 正常医保项目名称,\n  null 正常项目数量,\n  null 正常项目金额,\n  fl.b_cnt 违规项目收费数量,\n  fl.min_pric 违规项目单价,\n  fl.break_cnt 违规项目数量,\n  fl.CHRGITM_LV 违规项目支付类别,\n  fl.break_fee 违规项目金额,\n  fl.break_amt 违规项目范围内金额,\n  gettcamount(fl.break_amt, s.pool_prop_selfpay, s.hifp_pay, s.fund_pay_sumamt) 基本统筹违规金额,\n  getdbamount(fl.break_amt, s.insutype, s.hifmi_pay, s.fund_pay_sumamt) 大病统筹违规金额,\n  GETMAFAMOUNT(fl.break_amt, s.maf_pay, s.fund_pay_sumamt) 医疗救助违规金额,\n  case when substr(s.INSU_ADMDVS,1,4) != '{pool_no}' then '是' else '否' end 是否异地,\n  'CB_0020' 违规规则代码,\n  '超标准收费' 违规类型,\n  '按小时收费的血液净化类诊疗项目（如自动腹膜透析、连续性血液净化等），收费数量超过实际提供的诊疗服务数量。' 违规事项,\n  '《江西省医疗服务价格项目目录（2023年修订版）》中血液净化类诊疗项目收费的真实性。' 违规依据\nfrom SETL_D_MERGED s\ninner join a2 fl on s.setl_id = fl.setl_id\nwhere s.FUND_PAY_SUMAMT <> 0\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "with a1 as (select setl_id,listagg(distinct MEDINS_LIST_CODG, ',') within group (order by MEDINS_LIST_CODG) b_medins_list_codg,listagg(distinct medins_list_name, ',') within group (order by medins_list_name) b_medins_list_name,listagg(distinct hilist_code, ',') within group (order by hilist_code) b_hilist_code,listagg(distinct hilist_name, ',') within group (order by hilist_name) b_hilist_name,listagg(distinct MED_CHRGITM_TYPE_NAME, ',') within group (order by MED_CHRGITM_TYPE_NAME) MED_CHRGITM_TYPE,listagg(distinct CHRGITM_LV_NAME, ',') within group (order by CHRGITM_LV_NAME) CHRGITM_LV,listagg(distinct BILG_DEPT_NAME, ',') within group (order by BILG_DEPT_NAME) BILG_DEPT_NAME,listagg(distinct BILG_DR_NAME, ',') within group (order by BILG_DR_NAME) BILG_DR_NAME,listagg(distinct ACORD_DEPT_NAME, ',') within group (order by ACORD_DEPT_NAME) ACORD_DEPT_NAME,listagg(distinct ACORD_DR_NAME, ',') within group (order by ACORD_DR_NAME) ACORD_DR_NAME,sum(cnt) as b_cnt,sum(det_item_fee_sumamt) as b_fee,min(pric) as min_pric,min(abs(inscp_amt/cnt)) as min_amt from FEE_LIST_D where cnt <> 0 and CHRGITM_LV_NAME in ('甲类','乙类') group by setl_id),a2 as (select a1.*,s.fixmedins_code,s.fixmedins_name,s.HOSP_LV_NAME,s.mdtrt_id,s.ipt_otp_no,s.psn_no,s.psn_name,s.certno,s.GEND_NAME,s.brdy,s.age,s.insu_admdvs,s.INSUTYPE_NAME,s.PSN_TYPE_NAME,s.SP_PSN_TYPE_NAME,s.med_type_name,s.PAY_LOC_NAME,s.setl_time,s.adm_dept_name,s.dscg_dept_name,s.begntime,s.endtime,s.IPT_DAYS,s.chfpdr_name,s.adm_diag_dscr,s.dscg_maindiag_name,s.DIAG_NAME,s.dise_no,s.dise_name,s.OPRN_NAME,s.medfee_sumamt,s.pool_prop_selfpay,s.hifp_pay,s.hifmi_pay,s.maf_pay,s.cvlserv_pay,s.othfund_pay,s.acct_pay,s.cash_payamt,s.fund_pay_sumamt,s.insutype,case when a1.b_cnt > (s.ipt_days*12+24) then a1.b_cnt - (s.ipt_days*12+24) else 0 end as break_cnt,case when a1.b_cnt > (s.ipt_days*12+24) then (a1.b_cnt - (s.ipt_days*12+24)) * (a1.min_pric * 1) else 0 end as break_fee,case when a1.b_cnt > (s.ipt_days*12+24) then (a1.b_cnt - (s.ipt_days*12+24)) * (a1.min_amt * 1) else 0 end as break_amt from a1 inner join SETL_D_MERGED s on a1.setl_id = s.setl_id where a1.b_cnt > (s.ipt_days*12+24) and s.FUND_PAY_SUMAMT <> 0) select a2.fixmedins_code 医院代码,a2.fixmedins_name 医院名称,a2.HOSP_LV_NAME 医院级别,a2.setl_id 结算单据号,a2.mdtrt_id 就诊ID,a2.ipt_otp_no 住院号,a2.psn_no 个人编号,a2.psn_name 姓名,a2.certno 身份证号,a2.GEND_NAME 性别,a2.brdy 出生日期,a2.age 年龄,a2.insu_admdvs 统筹区,a2.INSUTYPE_NAME 险种类型,a2.PSN_TYPE_NAME 医疗人员类别,a2.SP_PSN_TYPE_NAME 特殊人员身份类别,a2.med_type_name 就医类型,a2.PAY_LOC_NAME 支付地点类别,a2.setl_time 结算日期,a2.adm_dept_name 入院科室,a2.dscg_dept_name 出院科室,a2.begntime 入院日期,a2.endtime 出院日期,a2.IPT_DAYS 天数,a2.chfpdr_name 主治医生,a2.adm_diag_dscr 入院诊断,a2.dscg_maindiag_name 出院诊断,a2.DIAG_NAME 其他诊断,a2.dise_no 病种编码,a2.dise_name 病种名称,a2.OPRN_NAME 手术及操作名称,a2.medfee_sumamt 总金额,concat(to_char(a2.pool_prop_selfpay * 100), '%') 基本医疗统筹支付比例,a2.hifp_pay 基本医保支付,a2.hifmi_pay 大病报销,a2.maf_pay 医疗救助,a2.cvlserv_pay 公务员补充,a2.othfund_pay 其他支付,a2.acct_pay 个人帐户支付,a2.cash_payamt 个人现金支付,a2.fund_pay_sumamt 基金支付总额,a2.MED_CHRGITM_TYPE 费用类别,a2.BILG_DEPT_NAME 开单科室名称,a2.BILG_DR_NAME 开单医生姓名,a2.ACORD_DEPT_NAME 受单科室名称,a2.ACORD_DR_NAME 受单医生姓名,null 收费日期,a2.b_medins_list_codg 违规医院项目代码,a2.b_medins_list_name 违规医院项目名称,a2.b_hilist_code 违规医保项目代码,a2.b_hilist_name 违规医保项目名称,null 正常医院项目代码,null 正常医院项目名称,null 正常医保项目代码,null 正常医保项目名称,null 正常项目数量,null 正常项目金额,a2.b_cnt 违规项目收费数量,a2.min_pric 违规项目单价,a2.break_cnt 违规项目数量,a2.CHRGITM_LV 违规项目支付类别,a2.break_fee 违规项目金额,a2.break_amt 违规项目范围内金额,gettcamount(a2.break_amt, a2.pool_prop_selfpay, a2.hifp_pay, a2.fund_pay_sumamt) 基本统筹违规金额,getdbamount(a2.break_amt, a2.insutype, a2.hifmi_pay, a2.fund_pay_sumamt) 大病统筹违规金额,GETMAFAMOUNT(a2.break_amt, a2.maf_pay, a2.fund_pay_sumamt) 医疗救助违规金额,case when substr(a2.INSU_ADMDVS,1,4) != '{pool_no}' then '是' else '否' end 是否异地,'CB_0020' 违规规则代码,'超标准收费' 违规类型,'按小时收费的血液净化类诊疗项目（如自动腹膜透析、连续性血液净化等），收费数量超过实际提供的诊疗服务数量。' 违规事项,'《江西省医疗服务价格项目目录（2023年修订版）》中血液净化类诊疗项目收费的真实性。' 违规依据 from a2"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "38",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"38\", \"db_type\": \"oracle\", \"description\": \"问题概述：该查询在 HRM_FLOOR.C_BASE_STATION_T(B) 上有多重等值过滤（BU_ID、HAC_ID、KEY_STATION_ID 列和 MFG_PROCESS_ID、DEL_FLAG），并且在主表 P 上按 WORK_DATE 与 DEL_FLAG 进行筛选，同时包含一个关联的 EXISTS 子查询来确认员工在对应站点的有效执照记录。潜在性能问题包括：1) 如果用于比较的列与字面量类型不匹配（例如 WORK_DATE 字段若为 VARCHAR 则与 DATE 常量比较会发生隐式类型转换），会导致索引失效；2) 缺少覆盖这些谓词和关联列的复合索引，会使得优化器采用全表扫描或大量回表，增加 I/O；3) EXISTS 子查询使用逗号分隔的老式连接写法（F, H）且为相关子查询，会导致对每一行执行索引查找/范围扫描，若 H/F 没有在 (EMP_NO, LICENSE_ID) 与 (LICENSE_ID, STATION_ID) 上建立合适索引，会产生大量随机 I/O。建议：确认 WORK_DATE/相关列数据类型与谓词匹配以避免隐式转换；为 B 表建立复合索引覆盖 (BU_ID, HAC_ID, KEY_STATION_ID, MFG_PROCESS_ID, DEL_FLAG) 或拆分为多个选择性索引；为 P 表建立 (WORK_DATE, DEL_FLAG, STATION_ID, EMP_NO) 索引以支持主谓词和后续关联；为 R_KEY_STATION_MAN_T 与 R_KEY_STATION_LICENSE_T 分别建立针对 (EMP_NO, LICENSE_ID, LOSE_FLAG, DEL_FLAG) 与 (LICENSE_ID, STATION_ID, DEL_FLAG) 的索引；将 EXISTS 子查询改写为显式 JOIN 或至少使用关联索引以减少对每行的重复查找。同时建议将高选择性谓词（如 P.DEL_FLAG=0、B.DEL_FLAG=0、B.BU_ID 等）尽量作为最先评估的过滤条件，降低后续关联数据量。\", \"create_table_statements\": [\"CREATE TABLE HRM_FLOOR.C_BASE_STATION_T (ID NUMBER PRIMARY KEY, STATION_NAME_ENG VARCHAR2(200), BU_ID NUMBER, HAC_ID NUMBER, KEY_STATION_ID NUMBER, MFG_PROCESS_ID NUMBER, DEL_FLAG NUMBER);\", \"CREATE INDEX IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL ON HRM_FLOOR.C_BASE_STATION_T(BU_ID, HAC_ID, KEY_STATION_ID, MFG_PROCESS_ID, DEL_FLAG);\", \"CREATE TABLE HRM_FLOOR.R_EMP_STATION_PLAN_T (ID NUMBER PRIMARY KEY, WORK_DATE DATE, DEL_FLAG NUMBER, HWT_TYPE_ID NUMBER, LINE_ID NUMBER, STATION_ID NUMBER, EMP_NO VARCHAR2(50));\", \"CREATE INDEX IDX_R_EMP_STATION_PLAN_WORKDATE ON HRM_FLOOR.R_EMP_STATION_PLAN_T(WORK_DATE, DEL_FLAG, STATION_ID, EMP_NO);\", \"CREATE TABLE HRM_FLOOR.R_KEY_STATION_MAN_T (ID NUMBER PRIMARY KEY, LICENSE_ID NUMBER, EMP_NO VARCHAR2(50), LOSE_FLAG NUMBER, DEL_FLAG NUMBER);\", \"CREATE INDEX IDX_R_KEY_STATION_MAN_EMP_LICENSE ON HRM_FLOOR.R_KEY_STATION_MAN_T(EMP_NO, LICENSE_ID, LOSE_FLAG, DEL_FLAG);\", \"CREATE TABLE HRM_FLOOR.R_KEY_STATION_LICENSE_T (LICENSE_ID NUMBER PRIMARY KEY, STATION_ID NUMBER, DEL_FLAG NUMBER);\", \"CREATE INDEX IDX_R_KEY_STATION_LICENSE_STATION ON HRM_FLOOR.R_KEY_STATION_LICENSE_T(LICENSE_ID, STATION_ID, DEL_FLAG);\"], \"sql\": \"SELECT P.HWT_TYPE_ID,   --班別ID\\n  HRM_EMP.GET_ID_TO_DESC (P.HWT_TYPE_ID) SHIFT,   --班別\\n  B.FAMILY_ID AS MODEL_ID,   --機種ID\\n  HRM_EMP.GET_ID_TO_DESC (B.FAMILY_ID) AS MODEL_NAME,  --機種名稱\\n  P.LINE_ID,  --線體ID\\n  GET_LOCATION_INFO (P.LINE_ID, '1') AS LINE_NAME,  --線體名稱\\n  P.STATION_ID,  --工站ID\\n  B.STATION_NAME_ENG,   --工站名稱\\n  HRM_EMP.GET_ID_TO_DESC (B.KEY_STATION_ID) KEY_STATION_TYPE,  --工站類型\\n  P.EMP_NO\\n  --,P.CONFIRM_FLAG, --確認狀態\\n  FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P\\n  -- 使用INNER,以便只要 同時符合預排配和工站基礎資訊的\\n  INNER JOIN HRM_FLOOR.C_BASE_STATION_T B\\n  ON  P.STATION_ID = B.ID\\n  AND B.DEL_FLAG = 0\\n  AND B.BU_ID = 245346  --iPad\\n  AND B.HAC_ID = 7137  --CD\\n  AND B.KEY_STATION_ID IN (4976, 8877, 38131)   --K/K+/K++\\n  AND B.MFG_PROCESS_ID = 140185  --製程為Mainline\\n   WHERE  P.WORK_DATE = DATE '2025-08-04'\\n  AND P.DEL_FLAG = 0\\n  -- 確認該員工有對應的「有效執照+在職」鑰匙站記錄（仍需站點一致）\\n  AND EXISTS\\n   (SELECT 1\\n  FROM HRM_FLOOR.R_KEY_STATION_LICENSE_T F,\\n  HRM_FLOOR.R_KEY_STATION_MAN_T H\\n   WHERE  H.LICENSE_ID = F.LICENSE_ID\\n  AND H.EMP_NO = P.EMP_NO\\n  AND H.LOSE_FLAG = 10078\\n  AND H.DEL_FLAG = 0\\n  AND F.DEL_FLAG = 0\\n  AND F.STATION_ID = P.STATION_ID)\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t120\\t200\\t16000\\t8000\\t40\\n1\\t  NESTED LOOPS\\t120\\t200\\t16000\\t8000\\t40\\n2\\t   INDEX RANGE SCAN IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL\\t10\\t200\\t8000\\t1000\\t5\\n3\\t  TABLE ACCESS BY INDEX ROWID C_BASE_STATION_T\\t30\\t200\\t8000\\t2000\\t10\\n4\\t   INDEX RANGE SCAN IDX_R_EMP_STATION_PLAN_WORKDATE\\t20\\t200\\t2000\\t1000\\t5\\n5\\t  TABLE ACCESS BY INDEX ROWID R_EMP_STATION_PLAN_T\\t70\\t200\\t8000\\t5000\\t20\\n6\\t   FILTER (P.WORK_DATE = DATE '2025-08-04' AND P.DEL_FLAG = 0)\\t---\\t---\\t---\\t---\\t---\\n7\\t   NESTED LOOPS (correlated) -- EXISTS subquery\\t20\\t200\\t4000\\t2000\\t5\\n8\\t  INDEX RANGE SCAN IDX_R_KEY_STATION_MAN_EMP_LICENSE (H)\\t2\\t1\\t40\\t10\\t1\\n9\\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_MAN_T\\t5\\t1\\t40\\t20\\t1\\n10\\t  INDEX RANGE SCAN IDX_R_KEY_STATION_LICENSE_STATION (F)\\t5\\t2\\t80\\t20\\t1\\n11\\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_LICENSE_T\\t8\\t2\\t80\\t30\\t1\\n12\\t  FILTER (EXISTS-subquery conditions applied per outer row)\\t---\\t---\\t---\\t---\\t---\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,优化了时间类型字段的条件表达式，避免MySQL中的隐式转换开销\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"WHERE子句高选择性谓词下推,通过将高选择性条件 P.DEL_FLAG=0 前置，中等选择性日期条件居中，复杂子查询后置，利用短路求值机制减少无效计算。预期全表扫描场景下性能提升6%-35%，具体取决于数据分布和数据库优化器特性。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE HRM_FLOOR.C_BASE_STATION_T (ID NUMBER PRIMARY KEY, STATION_NAME_ENG VARCHAR2(200), BU_ID NUMBER, HAC_ID NUMBER, KEY_STATION_ID NUMBER, MFG_PROCESS_ID NUMBER, DEL_FLAG NUMBER);\nCREATE INDEX IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL ON HRM_FLOOR.C_BASE_STATION_T(BU_ID, HAC_ID, KEY_STATION_ID, MFG_PROCESS_ID, DEL_FLAG);\nCREATE TABLE HRM_FLOOR.R_EMP_STATION_PLAN_T (ID NUMBER PRIMARY KEY, WORK_DATE DATE, DEL_FLAG NUMBER, HWT_TYPE_ID NUMBER, LINE_ID NUMBER, STATION_ID NUMBER, EMP_NO VARCHAR2(50));\nCREATE INDEX IDX_R_EMP_STATION_PLAN_WORKDATE ON HRM_FLOOR.R_EMP_STATION_PLAN_T(WORK_DATE, DEL_FLAG, STATION_ID, EMP_NO);\nCREATE TABLE HRM_FLOOR.R_KEY_STATION_MAN_T (ID NUMBER PRIMARY KEY, LICENSE_ID NUMBER, EMP_NO VARCHAR2(50), LOSE_FLAG NUMBER, DEL_FLAG NUMBER);\nCREATE INDEX IDX_R_KEY_STATION_MAN_EMP_LICENSE ON HRM_FLOOR.R_KEY_STATION_MAN_T(EMP_NO, LICENSE_ID, LOSE_FLAG, DEL_FLAG);\nCREATE TABLE HRM_FLOOR.R_KEY_STATION_LICENSE_T (LICENSE_ID NUMBER PRIMARY KEY, STATION_ID NUMBER, DEL_FLAG NUMBER);\nCREATE INDEX IDX_R_KEY_STATION_LICENSE_STATION ON HRM_FLOOR.R_KEY_STATION_LICENSE_T(LICENSE_ID, STATION_ID, DEL_FLAG);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t120\t200\t16000\t8000\t40\n1\t  NESTED LOOPS\t120\t200\t16000\t8000\t40\n2\t   INDEX RANGE SCAN IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL\t10\t200\t8000\t1000\t5\n3\t  TABLE ACCESS BY INDEX ROWID C_BASE_STATION_T\t30\t200\t8000\t2000\t10\n4\t   INDEX RANGE SCAN IDX_R_EMP_STATION_PLAN_WORKDATE\t20\t200\t2000\t1000\t5\n5\t  TABLE ACCESS BY INDEX ROWID R_EMP_STATION_PLAN_T\t70\t200\t8000\t5000\t20\n6\t   FILTER (P.WORK_DATE = DATE '2025-08-04' AND P.DEL_FLAG = 0)\t---\t---\t---\t---\t---\n7\t   NESTED LOOPS (correlated) -- EXISTS subquery\t20\t200\t4000\t2000\t5\n8\t  INDEX RANGE SCAN IDX_R_KEY_STATION_MAN_EMP_LICENSE (H)\t2\t1\t40\t10\t1\n9\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_MAN_T\t5\t1\t40\t20\t1\n10\t  INDEX RANGE SCAN IDX_R_KEY_STATION_LICENSE_STATION (F)\t5\t2\t80\t20\t1\n11\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_LICENSE_T\t8\t2\t80\t30\t1\n12\t  FILTER (EXISTS-subquery conditions applied per outer row)\t---\t---\t---\t---\t---\n\n## Original SQL:\nSELECT P.HWT_TYPE_ID,   --班別ID\n  HRM_EMP.GET_ID_TO_DESC (P.HWT_TYPE_ID) SHIFT,   --班別\n  B.FAMILY_ID AS MODEL_ID,   --機種ID\n  HRM_EMP.GET_ID_TO_DESC (B.FAMILY_ID) AS MODEL_NAME,  --機種名稱\n  P.LINE_ID,  --線體ID\n  GET_LOCATION_INFO (P.LINE_ID, '1') AS LINE_NAME,  --線體名稱\n  P.STATION_ID,  --工站ID\n  B.STATION_NAME_ENG,   --工站名稱\n  HRM_EMP.GET_ID_TO_DESC (B.KEY_STATION_ID) KEY_STATION_TYPE,  --工站類型\n  P.EMP_NO\n  --,P.CONFIRM_FLAG, --確認狀態\n  FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P\n  -- 使用INNER,以便只要 同時符合預排配和工站基礎資訊的\n  INNER JOIN HRM_FLOOR.C_BASE_STATION_T B\n  ON  P.STATION_ID = B.ID\n  AND B.DEL_FLAG = 0\n  AND B.BU_ID = 245346  --iPad\n  AND B.HAC_ID = 7137  --CD\n  AND B.KEY_STATION_ID IN (4976, 8877, 38131)   --K/K+/K++\n  AND B.MFG_PROCESS_ID = 140185  --製程為Mainline\n   WHERE  P.WORK_DATE = DATE '2025-08-04'\n  AND P.DEL_FLAG = 0\n  -- 確認該員工有對應的「有效執照+在職」鑰匙站記錄（仍需站點一致）\n  AND EXISTS\n   (SELECT 1\n  FROM HRM_FLOOR.R_KEY_STATION_LICENSE_T F,\n  HRM_FLOOR.R_KEY_STATION_MAN_T H\n   WHERE  H.LICENSE_ID = F.LICENSE_ID\n  AND H.EMP_NO = P.EMP_NO\n  AND H.LOSE_FLAG = 10078\n  AND H.DEL_FLAG = 0\n  AND F.DEL_FLAG = 0\n  AND F.STATION_ID = P.STATION_ID)\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT DISTINCT P.HWT_TYPE_ID,HRM_EMP.GET_ID_TO_DESC(P.HWT_TYPE_ID) SHIFT,B.FAMILY_ID AS MODEL_ID,HRM_EMP.GET_ID_TO_DESC(B.FAMILY_ID) AS MODEL_NAME,P.LINE_ID,GET_LOCATION_INFO(P.LINE_ID,'1') AS LINE_NAME,P.STATION_ID,B.STATION_NAME_ENG,HRM_EMP.GET_ID_TO_DESC(B.KEY_STATION_ID) KEY_STATION_TYPE,P.EMP_NO FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P INNER JOIN HRM_FLOOR.C_BASE_STATION_T B ON P.STATION_ID=B.ID AND B.DEL_FLAG=0 AND B.BU_ID=245346 AND B.HAC_ID=7137 AND B.KEY_STATION_ID IN(4976,8877,38131) AND B.MFG_PROCESS_ID=140185 INNER JOIN HRM_FLOOR.R_KEY_STATION_MAN_T H ON H.EMP_NO=P.EMP_NO AND H.LOSE_FLAG=10078 AND H.DEL_FLAG=0 INNER JOIN HRM_FLOOR.R_KEY_STATION_LICENSE_T F ON F.LICENSE_ID=H.LICENSE_ID AND F.STATION_ID=P.STATION_ID AND F.DEL_FLAG=0 WHERE P.WORK_DATE=DATE'2025-08-04' AND P.DEL_FLAG=0"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "38",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"38\", \"db_type\": \"oracle\", \"description\": \"问题概述：该查询在 HRM_FLOOR.C_BASE_STATION_T(B) 上有多重等值过滤（BU_ID、HAC_ID、KEY_STATION_ID 列和 MFG_PROCESS_ID、DEL_FLAG），并且在主表 P 上按 WORK_DATE 与 DEL_FLAG 进行筛选，同时包含一个关联的 EXISTS 子查询来确认员工在对应站点的有效执照记录。潜在性能问题包括：1) 如果用于比较的列与字面量类型不匹配（例如 WORK_DATE 字段若为 VARCHAR 则与 DATE 常量比较会发生隐式类型转换），会导致索引失效；2) 缺少覆盖这些谓词和关联列的复合索引，会使得优化器采用全表扫描或大量回表，增加 I/O；3) EXISTS 子查询使用逗号分隔的老式连接写法（F, H）且为相关子查询，会导致对每一行执行索引查找/范围扫描，若 H/F 没有在 (EMP_NO, LICENSE_ID) 与 (LICENSE_ID, STATION_ID) 上建立合适索引，会产生大量随机 I/O。建议：确认 WORK_DATE/相关列数据类型与谓词匹配以避免隐式转换；为 B 表建立复合索引覆盖 (BU_ID, HAC_ID, KEY_STATION_ID, MFG_PROCESS_ID, DEL_FLAG) 或拆分为多个选择性索引；为 P 表建立 (WORK_DATE, DEL_FLAG, STATION_ID, EMP_NO) 索引以支持主谓词和后续关联；为 R_KEY_STATION_MAN_T 与 R_KEY_STATION_LICENSE_T 分别建立针对 (EMP_NO, LICENSE_ID, LOSE_FLAG, DEL_FLAG) 与 (LICENSE_ID, STATION_ID, DEL_FLAG) 的索引；将 EXISTS 子查询改写为显式 JOIN 或至少使用关联索引以减少对每行的重复查找。同时建议将高选择性谓词（如 P.DEL_FLAG=0、B.DEL_FLAG=0、B.BU_ID 等）尽量作为最先评估的过滤条件，降低后续关联数据量。\", \"create_table_statements\": [\"CREATE TABLE HRM_FLOOR.C_BASE_STATION_T (ID NUMBER PRIMARY KEY, STATION_NAME_ENG VARCHAR2(200), BU_ID NUMBER, HAC_ID NUMBER, KEY_STATION_ID NUMBER, MFG_PROCESS_ID NUMBER, DEL_FLAG NUMBER);\", \"CREATE INDEX IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL ON HRM_FLOOR.C_BASE_STATION_T(BU_ID, HAC_ID, KEY_STATION_ID, MFG_PROCESS_ID, DEL_FLAG);\", \"CREATE TABLE HRM_FLOOR.R_EMP_STATION_PLAN_T (ID NUMBER PRIMARY KEY, WORK_DATE DATE, DEL_FLAG NUMBER, HWT_TYPE_ID NUMBER, LINE_ID NUMBER, STATION_ID NUMBER, EMP_NO VARCHAR2(50));\", \"CREATE INDEX IDX_R_EMP_STATION_PLAN_WORKDATE ON HRM_FLOOR.R_EMP_STATION_PLAN_T(WORK_DATE, DEL_FLAG, STATION_ID, EMP_NO);\", \"CREATE TABLE HRM_FLOOR.R_KEY_STATION_MAN_T (ID NUMBER PRIMARY KEY, LICENSE_ID NUMBER, EMP_NO VARCHAR2(50), LOSE_FLAG NUMBER, DEL_FLAG NUMBER);\", \"CREATE INDEX IDX_R_KEY_STATION_MAN_EMP_LICENSE ON HRM_FLOOR.R_KEY_STATION_MAN_T(EMP_NO, LICENSE_ID, LOSE_FLAG, DEL_FLAG);\", \"CREATE TABLE HRM_FLOOR.R_KEY_STATION_LICENSE_T (LICENSE_ID NUMBER PRIMARY KEY, STATION_ID NUMBER, DEL_FLAG NUMBER);\", \"CREATE INDEX IDX_R_KEY_STATION_LICENSE_STATION ON HRM_FLOOR.R_KEY_STATION_LICENSE_T(LICENSE_ID, STATION_ID, DEL_FLAG);\"], \"sql\": \"SELECT P.HWT_TYPE_ID,   --班別ID\\n  HRM_EMP.GET_ID_TO_DESC (P.HWT_TYPE_ID) SHIFT,   --班別\\n  B.FAMILY_ID AS MODEL_ID,   --機種ID\\n  HRM_EMP.GET_ID_TO_DESC (B.FAMILY_ID) AS MODEL_NAME,  --機種名稱\\n  P.LINE_ID,  --線體ID\\n  GET_LOCATION_INFO (P.LINE_ID, '1') AS LINE_NAME,  --線體名稱\\n  P.STATION_ID,  --工站ID\\n  B.STATION_NAME_ENG,   --工站名稱\\n  HRM_EMP.GET_ID_TO_DESC (B.KEY_STATION_ID) KEY_STATION_TYPE,  --工站類型\\n  P.EMP_NO\\n  --,P.CONFIRM_FLAG, --確認狀態\\n  FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P\\n  -- 使用INNER,以便只要 同時符合預排配和工站基礎資訊的\\n  INNER JOIN HRM_FLOOR.C_BASE_STATION_T B\\n  ON  P.STATION_ID = B.ID\\n  AND B.DEL_FLAG = 0\\n  AND B.BU_ID = 245346  --iPad\\n  AND B.HAC_ID = 7137  --CD\\n  AND B.KEY_STATION_ID IN (4976, 8877, 38131)   --K/K+/K++\\n  AND B.MFG_PROCESS_ID = 140185  --製程為Mainline\\n   WHERE  P.WORK_DATE = DATE '2025-08-04'\\n  AND P.DEL_FLAG = 0\\n  -- 確認該員工有對應的「有效執照+在職」鑰匙站記錄（仍需站點一致）\\n  AND EXISTS\\n   (SELECT 1\\n  FROM HRM_FLOOR.R_KEY_STATION_LICENSE_T F,\\n  HRM_FLOOR.R_KEY_STATION_MAN_T H\\n   WHERE  H.LICENSE_ID = F.LICENSE_ID\\n  AND H.EMP_NO = P.EMP_NO\\n  AND H.LOSE_FLAG = 10078\\n  AND H.DEL_FLAG = 0\\n  AND F.DEL_FLAG = 0\\n  AND F.STATION_ID = P.STATION_ID)\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t120\\t200\\t16000\\t8000\\t40\\n1\\t  NESTED LOOPS\\t120\\t200\\t16000\\t8000\\t40\\n2\\t   INDEX RANGE SCAN IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL\\t10\\t200\\t8000\\t1000\\t5\\n3\\t  TABLE ACCESS BY INDEX ROWID C_BASE_STATION_T\\t30\\t200\\t8000\\t2000\\t10\\n4\\t   INDEX RANGE SCAN IDX_R_EMP_STATION_PLAN_WORKDATE\\t20\\t200\\t2000\\t1000\\t5\\n5\\t  TABLE ACCESS BY INDEX ROWID R_EMP_STATION_PLAN_T\\t70\\t200\\t8000\\t5000\\t20\\n6\\t   FILTER (P.WORK_DATE = DATE '2025-08-04' AND P.DEL_FLAG = 0)\\t---\\t---\\t---\\t---\\t---\\n7\\t   NESTED LOOPS (correlated) -- EXISTS subquery\\t20\\t200\\t4000\\t2000\\t5\\n8\\t  INDEX RANGE SCAN IDX_R_KEY_STATION_MAN_EMP_LICENSE (H)\\t2\\t1\\t40\\t10\\t1\\n9\\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_MAN_T\\t5\\t1\\t40\\t20\\t1\\n10\\t  INDEX RANGE SCAN IDX_R_KEY_STATION_LICENSE_STATION (F)\\t5\\t2\\t80\\t20\\t1\\n11\\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_LICENSE_T\\t8\\t2\\t80\\t30\\t1\\n12\\t  FILTER (EXISTS-subquery conditions applied per outer row)\\t---\\t---\\t---\\t---\\t---\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,优化了时间类型字段的条件表达式，避免MySQL中的隐式转换开销\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"WHERE子句高选择性谓词下推,通过将高选择性条件 P.DEL_FLAG=0 前置，中等选择性日期条件居中，复杂子查询后置，利用短路求值机制减少无效计算。预期全表扫描场景下性能提升6%-35%，具体取决于数据分布和数据库优化器特性。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE HRM_FLOOR.C_BASE_STATION_T (ID NUMBER PRIMARY KEY, STATION_NAME_ENG VARCHAR2(200), BU_ID NUMBER, HAC_ID NUMBER, KEY_STATION_ID NUMBER, MFG_PROCESS_ID NUMBER, DEL_FLAG NUMBER);\nCREATE INDEX IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL ON HRM_FLOOR.C_BASE_STATION_T(BU_ID, HAC_ID, KEY_STATION_ID, MFG_PROCESS_ID, DEL_FLAG);\nCREATE TABLE HRM_FLOOR.R_EMP_STATION_PLAN_T (ID NUMBER PRIMARY KEY, WORK_DATE DATE, DEL_FLAG NUMBER, HWT_TYPE_ID NUMBER, LINE_ID NUMBER, STATION_ID NUMBER, EMP_NO VARCHAR2(50));\nCREATE INDEX IDX_R_EMP_STATION_PLAN_WORKDATE ON HRM_FLOOR.R_EMP_STATION_PLAN_T(WORK_DATE, DEL_FLAG, STATION_ID, EMP_NO);\nCREATE TABLE HRM_FLOOR.R_KEY_STATION_MAN_T (ID NUMBER PRIMARY KEY, LICENSE_ID NUMBER, EMP_NO VARCHAR2(50), LOSE_FLAG NUMBER, DEL_FLAG NUMBER);\nCREATE INDEX IDX_R_KEY_STATION_MAN_EMP_LICENSE ON HRM_FLOOR.R_KEY_STATION_MAN_T(EMP_NO, LICENSE_ID, LOSE_FLAG, DEL_FLAG);\nCREATE TABLE HRM_FLOOR.R_KEY_STATION_LICENSE_T (LICENSE_ID NUMBER PRIMARY KEY, STATION_ID NUMBER, DEL_FLAG NUMBER);\nCREATE INDEX IDX_R_KEY_STATION_LICENSE_STATION ON HRM_FLOOR.R_KEY_STATION_LICENSE_T(LICENSE_ID, STATION_ID, DEL_FLAG);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t120\t200\t16000\t8000\t40\n1\t  NESTED LOOPS\t120\t200\t16000\t8000\t40\n2\t   INDEX RANGE SCAN IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL\t10\t200\t8000\t1000\t5\n3\t  TABLE ACCESS BY INDEX ROWID C_BASE_STATION_T\t30\t200\t8000\t2000\t10\n4\t   INDEX RANGE SCAN IDX_R_EMP_STATION_PLAN_WORKDATE\t20\t200\t2000\t1000\t5\n5\t  TABLE ACCESS BY INDEX ROWID R_EMP_STATION_PLAN_T\t70\t200\t8000\t5000\t20\n6\t   FILTER (P.WORK_DATE = DATE '2025-08-04' AND P.DEL_FLAG = 0)\t---\t---\t---\t---\t---\n7\t   NESTED LOOPS (correlated) -- EXISTS subquery\t20\t200\t4000\t2000\t5\n8\t  INDEX RANGE SCAN IDX_R_KEY_STATION_MAN_EMP_LICENSE (H)\t2\t1\t40\t10\t1\n9\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_MAN_T\t5\t1\t40\t20\t1\n10\t  INDEX RANGE SCAN IDX_R_KEY_STATION_LICENSE_STATION (F)\t5\t2\t80\t20\t1\n11\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_LICENSE_T\t8\t2\t80\t30\t1\n12\t  FILTER (EXISTS-subquery conditions applied per outer row)\t---\t---\t---\t---\t---\n\n## Original SQL:\nSELECT P.HWT_TYPE_ID,   --班別ID\n  HRM_EMP.GET_ID_TO_DESC (P.HWT_TYPE_ID) SHIFT,   --班別\n  B.FAMILY_ID AS MODEL_ID,   --機種ID\n  HRM_EMP.GET_ID_TO_DESC (B.FAMILY_ID) AS MODEL_NAME,  --機種名稱\n  P.LINE_ID,  --線體ID\n  GET_LOCATION_INFO (P.LINE_ID, '1') AS LINE_NAME,  --線體名稱\n  P.STATION_ID,  --工站ID\n  B.STATION_NAME_ENG,   --工站名稱\n  HRM_EMP.GET_ID_TO_DESC (B.KEY_STATION_ID) KEY_STATION_TYPE,  --工站類型\n  P.EMP_NO\n  --,P.CONFIRM_FLAG, --確認狀態\n  FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P\n  -- 使用INNER,以便只要 同時符合預排配和工站基礎資訊的\n  INNER JOIN HRM_FLOOR.C_BASE_STATION_T B\n  ON  P.STATION_ID = B.ID\n  AND B.DEL_FLAG = 0\n  AND B.BU_ID = 245346  --iPad\n  AND B.HAC_ID = 7137  --CD\n  AND B.KEY_STATION_ID IN (4976, 8877, 38131)   --K/K+/K++\n  AND B.MFG_PROCESS_ID = 140185  --製程為Mainline\n   WHERE  P.WORK_DATE = DATE '2025-08-04'\n  AND P.DEL_FLAG = 0\n  -- 確認該員工有對應的「有效執照+在職」鑰匙站記錄（仍需站點一致）\n  AND EXISTS\n   (SELECT 1\n  FROM HRM_FLOOR.R_KEY_STATION_LICENSE_T F,\n  HRM_FLOOR.R_KEY_STATION_MAN_T H\n   WHERE  H.LICENSE_ID = F.LICENSE_ID\n  AND H.EMP_NO = P.EMP_NO\n  AND H.LOSE_FLAG = 10078\n  AND H.DEL_FLAG = 0\n  AND F.DEL_FLAG = 0\n  AND F.STATION_ID = P.STATION_ID)\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT DISTINCT P.HWT_TYPE_ID,HRM_EMP.GET_ID_TO_DESC(P.HWT_TYPE_ID) SHIFT,B.FAMILY_ID AS MODEL_ID,HRM_EMP.GET_ID_TO_DESC(B.FAMILY_ID) AS MODEL_NAME,P.LINE_ID,GET_LOCATION_INFO(P.LINE_ID,'1') AS LINE_NAME,P.STATION_ID,B.STATION_NAME_ENG,HRM_EMP.GET_ID_TO_DESC(B.KEY_STATION_ID) KEY_STATION_TYPE,P.EMP_NO FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P INNER JOIN HRM_FLOOR.C_BASE_STATION_T B ON P.STATION_ID=B.ID AND B.DEL_FLAG=0 AND B.BU_ID=245346 AND B.HAC_ID=7137 AND B.KEY_STATION_ID IN(4976,8877,38131) AND B.MFG_PROCESS_ID=140185 INNER JOIN HRM_FLOOR.R_KEY_STATION_MAN_T H ON H.EMP_NO=P.EMP_NO AND H.LOSE_FLAG=10078 AND H.DEL_FLAG=0 INNER JOIN HRM_FLOOR.R_KEY_STATION_LICENSE_T F ON F.LICENSE_ID=H.LICENSE_ID AND F.STATION_ID=P.STATION_ID AND F.DEL_FLAG=0 WHERE P.WORK_DATE=DATE'2025-08-04' AND P.DEL_FLAG=0"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "39",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"39\", \"db_type\": \"sqlserver\", \"description\": \"问题概述：原始查询包含一个全表聚合 + 窗口函数的 CTE（rank_general），多个 LEFT JOIN 与一个 CROSS JOIN(me 子查询)，以及对 otr.otr_consulta 的行级展开 (CROSS APPLY (VALUES ...)) 再做 GROUP BY。性能瓶颈可能来自几处：\\n1) rank_general 需要对 flashdeventas.vetas_y_formas_de_pago 做 GROUP BY 并按 SUM 排序再计算 ROW_NUMBER，若无合适索引/预聚合会导致全表扫描与昂贵的排序；\\n2) me 使用常量筛选但被 CROSS JOIN 到主查，若 me 返回多行会乘扩大外层行数；即使 me 仅返回一行，保留未被外层使用的列会造成不必要的数据传递（可用投影下推移除 proveedor 与 estilo）；\\n3) otr 子查询对 otr.otr_consulta 做了 VALUES 展开后 GROUP BY，若不把高选择性谓词（c.tienda = 3064）下推，会扫描大量无关行并产生大规模聚合中间结果；\\n4) 多个 LEFT JOIN（例如 ranking_tda_jerarquia、control_asignacion_matrices）若缺乏覆盖索引，会引发大量回表和随机 I/O。\\n\\n建议（与实习生给出的规则一致）：\\n- 进行投影下推：在 me 子查询中移除未被外层用到的列（如 proveedor、estilo），减少中间结果宽度；\\n- 进行谓词下推：把高选择性条件 c.tienda = 3064 下推至 otr 的扫描/聚合子查询（即 WHERE oc.id_tienda = 3064），显著降低 otr 聚合量；\\n- 检查并建立必要索引：例如 otr.otr_consulta 上应有 (id_tienda, id_departamento, id_subdepartamento, id_clase, id_subclase, tipo_articulo) 的复合索引或至少 id_tienda 的索引；catalogos.maestro_estilos 可在 (proveedor, estilo) 建索引；catalogos.ranking_tda_jerarquia 在 (id_tienda, departamento, subdepartamento, clase, subclase) 上建索引；clusters.tienda_atributos 在 (centro_comercial, clima, tienda) 建复合/前缀索引；catalogos.tiendas 在 TIENDA 列建主键/索引。 \\n- 对 rank_general 的全表排序开销敏感时，考虑离线物化/周期维护排名表或限制计算范围（若业务允许）。\\n\\n在满足语义前提下（确保移除的列确实不被外层引用，且 c.tienda 为强选择性过滤），方式1 的投影与谓词下推是低风险且立即见效的改进；方式2（更激进的提前过滤/LEFT→INNER 等）若要采用需严格验证不会改变结果。\", \"create_table_statements\": [\"CREATE TABLE catalogos.tiendas (TIENDA INT PRIMARY KEY, nombre NVARCHAR(200), tipo CHAR(1), estatus CHAR(1), marca INT, ciudad NVARCHAR(100), estado NVARCHAR(100), m2 DECIMAL(10,2));\", \"CREATE INDEX IDX_TIENDA_TIPO_MARCA ON catalogos.tiendas(tipo, estatus, marca);\", \"CREATE TABLE flashdeventas.vetas_y_formas_de_pago (ID BIGINT PRIMARY KEY, TIENDA INT, MERCANCIASINIVA DECIMAL(18,4), FECHA DATETIME);\", \"CREATE INDEX IDX_VETAS_TIENDA ON flashdeventas.vetas_y_formas_de_pago(TIENDA);\", \"CREATE TABLE clusters.tienda_atributos (tienda INT PRIMARY KEY, centro_comercial INT, clima NVARCHAR(200));\", \"CREATE INDEX IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos(centro_comercial, clima, tienda);\", \"CREATE TABLE catalogos.maestro_estilos (departamento INT, subdepartamento INT, clase INT, subclase INT, proveedor INT, estilo NVARCHAR(100), tipo_articulo INT);\", \"CREATE INDEX IDX_MAESTRO_ESTILOS_PROV_ESTILO ON catalogos.maestro_estilos(proveedor, estilo);\", \"CREATE TABLE catalogos.ranking_tda_jerarquia (id_tienda INT, departamento INT, subdepartamento INT, clase INT, subclase INT, ranking INT);\", \"CREATE INDEX IDX_RJ_IDTIENDA_DEPT ON catalogos.ranking_tda_jerarquia(id_tienda, departamento, subdepartamento, clase, subclase);\", \"CREATE TABLE catalogos.control_asignacion_matrices (clasificacion INT, matrices_min INT);\", \"CREATE INDEX IDX_CAM_CLASIFICACION ON catalogos.control_asignacion_matrices(clasificacion);\", \"CREATE TABLE otr.otr_consulta (id_tienda INT, id_departamento INT, id_subdepartamento INT, id_clase INT, id_subclase INT, tipo_articulo INT, mes1_compra_adicional DECIMAL(18,4), mes2_compra_adicional DECIMAL(18,4), mes3_compra_adicional DECIMAL(18,4), mes4_compra_adicional DECIMAL(18,4), mes5_compra_adicional DECIMAL(18,4), mes6_compra_adicional DECIMAL(18,4), mes7_compra_adicional DECIMAL(18,4), mes8_compra_adicional DECIMAL(18,4), mes9_compra_adicional DECIMAL(18,4), mes10_compra_adicional DECIMAL(18,4), mes11_compra_adicional DECIMAL(18,4), mes12_compra_adicional DECIMAL(18,4));\", \"CREATE INDEX IDX_OTR_ID_TIENDA_FULL ON otr.otr_consulta(id_tienda, id_departamento, id_subdepartamento, id_clase, id_subclase, tipo_articulo);\", \"CREATE VIEW catalogos.vw_supervisores AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\", \"CREATE VIEW catalogos.vw_regionales AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\"], \"sql\": \";WITH rank_general AS (\\n  SELECT \\n  ta.TIENDA AS id,\\n  ROW_NUMBER() OVER (\\n  ORDER BY SUM(v.MERCANCIASINIVA) DESC\\n  ) AS actual_rank_global\\n  FROM catalogos.tiendas ta\\n  LEFT JOIN flashdeventas.vetas_y_formas_de_pago v ON v.TIENDA = ta.TIENDA\\n  WHERE ta.tipo = 'S' AND estatus = 'A' AND ta.marca = 30\\n  GROUP BY ta.TIENDA\\n) \\nSELECT \\n  rg.actual_rank_global   \\n  ,t.nombre\\n  ,vw_r.nombre as regional\\n  ,vw_s.nombre as supervisor\\n  ,t.estado\\n  ,'RUTA' as ruta  ----\\n  ,t.m2 as tienda_m2\\n  ,'TAMAÑO' as tamanio   ----\\n  ,rj.ranking as rank_jerarquia_n4\\n  ,t.ciudad\\n  ,cam.matrices_min as propuesta\\n  ,otr.abierto_otr as abierto_otr\\n  ,c.* \\nFROM clusters.tienda_atributos c\\nLEFT JOIN catalogos.tiendas t ON c.tienda = t.tienda\\nLEFT JOIN catalogos.vw_supervisores vw_s ON c.tienda = vw_s.tienda\\nLEFT JOIN catalogos.vw_regionales vw_r ON c.tienda = vw_r.tienda\\nLEFT JOIN rank_general rg ON c.tienda = rg.id\\nCROSS JOIN (\\n  SELECT departamento, subdepartamento, clase, subclase, proveedor, estilo, tipo_articulo\\n  FROM catalogos.maestro_estilos me\\n  WHERE me.proveedor = 1162 AND me.estilo = 'C21031101'\\n) me\\nLEFT JOIN catalogos.ranking_tda_jerarquia rj \\n  ON c.tienda = rj.id_tienda\\n  AND rj.departamento = me.departamento\\n  AND rj.subdepartamento = me.subdepartamento\\n  AND rj.clase = me.clase\\n  AND rj.subclase = me.subclase\\nLEFT JOIN catalogos.control_asignacion_matrices cam\\n  ON rj.ranking = cam.clasificacion\\nLEFT JOIN (\\n  SELECT\\n  oc.id_tienda,\\n  oc.id_departamento,\\n  oc.id_subdepartamento,\\n  oc.id_clase,\\n  oc.id_subclase,\\n  oc.tipo_articulo,\\n  SUM(CASE WHEN n >= MONTH(GETDATE()) THEN ISNULL(val, 0) ELSE 0 END) AS abierto_otr\\n  FROM otr.otr_consulta oc\\n  CROSS APPLY (VALUES\\n  (1,  oc.mes1_compra_adicional),\\n  (2,  oc.mes2_compra_adicional),\\n  (3,  oc.mes3_compra_adicional),\\n  (4,  oc.mes4_compra_adicional),\\n  (5,  oc.mes5_compra_adicional),\\n  (6,  oc.mes6_compra_adicional),\\n  (7,  oc.mes7_compra_adicional),\\n  (8,  oc.mes8_compra_adicional),\\n  (9,  oc.mes9_compra_adicional),\\n  (10, oc.mes10_compra_adicional),\\n  (11, oc.mes11_compra_adicional),\\n  (12, oc.mes12_compra_adicional)\\n  ) m(n, val)\\n  GROUP BY\\n  oc.id_tienda,\\n  oc.id_departamento,\\n  oc.id_subdepartamento,\\n  oc.id_clase,\\n  oc.id_subclase,\\n  oc.tipo_articulo\\n) otr\\n  ON  otr.id_tienda = c.tienda\\n  AND otr.id_departamento = me.departamento\\n  AND otr.id_subdepartamento = me.subdepartamento\\n  AND otr.id_clase = me.clase\\n  AND otr.id_subclase = me.subclase\\n  AND otr.tipo_articulo = me.tipo_articulo\\nWHERE 1=1  AND c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t15200\\t10000\\t1200000\\t452000\\t14800\\n1\\t  MERGE JOIN\\t15200\\t10000\\t1200000\\t452000\\t14800\\n2\\t   HASH AGGREGATE (rank_general: SUM + SORT for ROW_NUMBER)\\t9200\\t10000\\t600000\\t300000\\t9000\\n3\\t  TABLE SCAN flashdeventas.vetas_y_formas_de_pago\\t4800\\t10000\\t480000\\t240000\\t4800\\n4\\t   INDEX SEEK catalogos.tiendas (type/estatus/marca filter)\\t200\\t5000\\t80000\\t20000\\t200\\n5\\t   SORT\\t3000\\t10000\\t200000\\t80000\\t3000\\n6\\t   HASH MATCH (left outer join rj/cam/others)\\t2400\\t5000\\t300000\\t100000\\t2400\\n7\\t  VIEW (me CROSS JOIN) -- expands outer rows when me has >1 row\\t50\\t10\\t800\\t500\\t50\\n8\\t  HASH AGGREGATE (otr subquery grouping)\\t6800\\t8000\\t400000\\t160000\\t6800\\n9\\t   TABLE SCAN otr.otr_consulta\\t6600\\t8000\\t380000\\t150000\\t6600\\n10\\t  CROSS APPLY (VALUES ...) expansion per row\\t---\\t---\\t---\\t---\\t---\\n11\\t   NESTED LOOPS (apply joins to clusters.tienda_atributos filtered by centro_comercial/clima/tiena)\\t1200\\t1\\t160\\t600\\t120\\n12\\t  INDEX SEEK IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos (centro_comercial,clima,tienda)\\t10\\t1\\t80\\t20\\t5\\n13\\t  TABLE ACCESS BY INDEX ROWID catalogos.tiendas / vw_supervisores / vw_regionales\\t300\\t1\\t320\\t100\\t30\\n14\\t  FILTER (c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064)\\t---\\t---\\t---\\t---\\t---\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,应用投影下推规则优化 'me' 子查询：移除未使用的列 proveedor 和 estilo。外部查询仅通过JOIN条件引用其他列，被移除列仅出现在WHERE过滤中且未传递到外部。该优化减少子查询结果集的数据量及临时表内存占用，预计I/O减少10%-20%。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将外层高选择性条件c.tienda=3064下推至otr子查询内部，添加WHERE oc.id_tienda=3064，减少子查询90%以上数据处理量。rank_general CTE因窗口函数全局排名需求保留原逻辑\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE catalogos.tiendas (TIENDA INT PRIMARY KEY, nombre NVARCHAR(200), tipo CHAR(1), estatus CHAR(1), marca INT, ciudad NVARCHAR(100), estado NVARCHAR(100), m2 DECIMAL(10,2));\nCREATE INDEX IDX_TIENDA_TIPO_MARCA ON catalogos.tiendas(tipo, estatus, marca);\nCREATE TABLE flashdeventas.vetas_y_formas_de_pago (ID BIGINT PRIMARY KEY, TIENDA INT, MERCANCIASINIVA DECIMAL(18,4), FECHA DATETIME);\nCREATE INDEX IDX_VETAS_TIENDA ON flashdeventas.vetas_y_formas_de_pago(TIENDA);\nCREATE TABLE clusters.tienda_atributos (tienda INT PRIMARY KEY, centro_comercial INT, clima NVARCHAR(200));\nCREATE INDEX IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos(centro_comercial, clima, tienda);\nCREATE TABLE catalogos.maestro_estilos (departamento INT, subdepartamento INT, clase INT, subclase INT, proveedor INT, estilo NVARCHAR(100), tipo_articulo INT);\nCREATE INDEX IDX_MAESTRO_ESTILOS_PROV_ESTILO ON catalogos.maestro_estilos(proveedor, estilo);\nCREATE TABLE catalogos.ranking_tda_jerarquia (id_tienda INT, departamento INT, subdepartamento INT, clase INT, subclase INT, ranking INT);\nCREATE INDEX IDX_RJ_IDTIENDA_DEPT ON catalogos.ranking_tda_jerarquia(id_tienda, departamento, subdepartamento, clase, subclase);\nCREATE TABLE catalogos.control_asignacion_matrices (clasificacion INT, matrices_min INT);\nCREATE INDEX IDX_CAM_CLASIFICACION ON catalogos.control_asignacion_matrices(clasificacion);\nCREATE TABLE otr.otr_consulta (id_tienda INT, id_departamento INT, id_subdepartamento INT, id_clase INT, id_subclase INT, tipo_articulo INT, mes1_compra_adicional DECIMAL(18,4), mes2_compra_adicional DECIMAL(18,4), mes3_compra_adicional DECIMAL(18,4), mes4_compra_adicional DECIMAL(18,4), mes5_compra_adicional DECIMAL(18,4), mes6_compra_adicional DECIMAL(18,4), mes7_compra_adicional DECIMAL(18,4), mes8_compra_adicional DECIMAL(18,4), mes9_compra_adicional DECIMAL(18,4), mes10_compra_adicional DECIMAL(18,4), mes11_compra_adicional DECIMAL(18,4), mes12_compra_adicional DECIMAL(18,4));\nCREATE INDEX IDX_OTR_ID_TIENDA_FULL ON otr.otr_consulta(id_tienda, id_departamento, id_subdepartamento, id_clase, id_subclase, tipo_articulo);\nCREATE VIEW catalogos.vw_supervisores AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\nCREATE VIEW catalogos.vw_regionales AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t15200\t10000\t1200000\t452000\t14800\n1\t  MERGE JOIN\t15200\t10000\t1200000\t452000\t14800\n2\t   HASH AGGREGATE (rank_general: SUM + SORT for ROW_NUMBER)\t9200\t10000\t600000\t300000\t9000\n3\t  TABLE SCAN flashdeventas.vetas_y_formas_de_pago\t4800\t10000\t480000\t240000\t4800\n4\t   INDEX SEEK catalogos.tiendas (type/estatus/marca filter)\t200\t5000\t80000\t20000\t200\n5\t   SORT\t3000\t10000\t200000\t80000\t3000\n6\t   HASH MATCH (left outer join rj/cam/others)\t2400\t5000\t300000\t100000\t2400\n7\t  VIEW (me CROSS JOIN) -- expands outer rows when me has >1 row\t50\t10\t800\t500\t50\n8\t  HASH AGGREGATE (otr subquery grouping)\t6800\t8000\t400000\t160000\t6800\n9\t   TABLE SCAN otr.otr_consulta\t6600\t8000\t380000\t150000\t6600\n10\t  CROSS APPLY (VALUES ...) expansion per row\t---\t---\t---\t---\t---\n11\t   NESTED LOOPS (apply joins to clusters.tienda_atributos filtered by centro_comercial/clima/tiena)\t1200\t1\t160\t600\t120\n12\t  INDEX SEEK IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos (centro_comercial,clima,tienda)\t10\t1\t80\t20\t5\n13\t  TABLE ACCESS BY INDEX ROWID catalogos.tiendas / vw_supervisores / vw_regionales\t300\t1\t320\t100\t30\n14\t  FILTER (c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064)\t---\t---\t---\t---\t---\n\n## Original SQL:\n;WITH rank_general AS (\n  SELECT \n  ta.TIENDA AS id,\n  ROW_NUMBER() OVER (\n  ORDER BY SUM(v.MERCANCIASINIVA) DESC\n  ) AS actual_rank_global\n  FROM catalogos.tiendas ta\n  LEFT JOIN flashdeventas.vetas_y_formas_de_pago v ON v.TIENDA = ta.TIENDA\n  WHERE ta.tipo = 'S' AND estatus = 'A' AND ta.marca = 30\n  GROUP BY ta.TIENDA\n) \nSELECT \n  rg.actual_rank_global   \n  ,t.nombre\n  ,vw_r.nombre as regional\n  ,vw_s.nombre as supervisor\n  ,t.estado\n  ,'RUTA' as ruta  ----\n  ,t.m2 as tienda_m2\n  ,'TAMAÑO' as tamanio   ----\n  ,rj.ranking as rank_jerarquia_n4\n  ,t.ciudad\n  ,cam.matrices_min as propuesta\n  ,otr.abierto_otr as abierto_otr\n  ,c.* \nFROM clusters.tienda_atributos c\nLEFT JOIN catalogos.tiendas t ON c.tienda = t.tienda\nLEFT JOIN catalogos.vw_supervisores vw_s ON c.tienda = vw_s.tienda\nLEFT JOIN catalogos.vw_regionales vw_r ON c.tienda = vw_r.tienda\nLEFT JOIN rank_general rg ON c.tienda = rg.id\nCROSS JOIN (\n  SELECT departamento, subdepartamento, clase, subclase, proveedor, estilo, tipo_articulo\n  FROM catalogos.maestro_estilos me\n  WHERE me.proveedor = 1162 AND me.estilo = 'C21031101'\n) me\nLEFT JOIN catalogos.ranking_tda_jerarquia rj \n  ON c.tienda = rj.id_tienda\n  AND rj.departamento = me.departamento\n  AND rj.subdepartamento = me.subdepartamento\n  AND rj.clase = me.clase\n  AND rj.subclase = me.subclase\nLEFT JOIN catalogos.control_asignacion_matrices cam\n  ON rj.ranking = cam.clasificacion\nLEFT JOIN (\n  SELECT\n  oc.id_tienda,\n  oc.id_departamento,\n  oc.id_subdepartamento,\n  oc.id_clase,\n  oc.id_subclase,\n  oc.tipo_articulo,\n  SUM(CASE WHEN n >= MONTH(GETDATE()) THEN ISNULL(val, 0) ELSE 0 END) AS abierto_otr\n  FROM otr.otr_consulta oc\n  CROSS APPLY (VALUES\n  (1,  oc.mes1_compra_adicional),\n  (2,  oc.mes2_compra_adicional),\n  (3,  oc.mes3_compra_adicional),\n  (4,  oc.mes4_compra_adicional),\n  (5,  oc.mes5_compra_adicional),\n  (6,  oc.mes6_compra_adicional),\n  (7,  oc.mes7_compra_adicional),\n  (8,  oc.mes8_compra_adicional),\n  (9,  oc.mes9_compra_adicional),\n  (10, oc.mes10_compra_adicional),\n  (11, oc.mes11_compra_adicional),\n  (12, oc.mes12_compra_adicional)\n  ) m(n, val)\n  GROUP BY\n  oc.id_tienda,\n  oc.id_departamento,\n  oc.id_subdepartamento,\n  oc.id_clase,\n  oc.id_subclase,\n  oc.tipo_articulo\n) otr\n  ON  otr.id_tienda = c.tienda\n  AND otr.id_departamento = me.departamento\n  AND otr.id_subdepartamento = me.subdepartamento\n  AND otr.id_clase = me.clase\n  AND otr.id_subclase = me.subclase\n  AND otr.tipo_articulo = me.tipo_articulo\nWHERE 1=1  AND c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": ";WITH rank_general AS (SELECT ta.TIENDA AS id, ROW_NUMBER() OVER (ORDER BY SUM(v.MERCANCIASINIVA) DESC) AS actual_rank_global FROM catalogos.tiendas ta LEFT JOIN flashdeventas.vetas_y_formas_de_pago v ON v.TIENDA = ta.TIENDA WHERE ta.tipo = 'S' AND ta.estatus = 'A' AND ta.marca = 30 GROUP BY ta.TIENDA) SELECT rg.actual_rank_global, t.nombre, vw_r.nombre as regional, vw_s.nombre as supervisor, t.estado, 'RUTA' as ruta, t.m2 as tienda_m2, 'TAMAÑO' as tamanio, rj.ranking as rank_jerarquia_n4, t.ciudad, cam.matrices_min as propuesta, otr.abierto_otr, c.* FROM clusters.tienda_atributos c LEFT JOIN catalogos.tiendas t ON c.tienda = t.tienda LEFT JOIN catalogos.vw_supervisores vw_s ON c.tienda = vw_s.tienda LEFT JOIN catalogos.vw_regionales vw_r ON c.tienda = vw_r.tienda LEFT JOIN rank_general rg ON c.tienda = rg.id CROSS JOIN (SELECT departamento, subdepartamento, clase, subclase, proveedor, estilo, tipo_articulo FROM catalogos.maestro_estilos WHERE proveedor = 1162 AND estilo = 'C21031101') me LEFT JOIN catalogos.ranking_tda_jerarquia rj ON c.tienda = rj.id_tienda AND rj.departamento = me.departamento AND rj.subdepartamento = me.subdepartamento AND rj.clase = me.clase AND rj.subclase = me.subclase LEFT JOIN catalogos.control_asignacion_matrices cam ON rj.ranking = cam.clasificacion LEFT JOIN (SELECT oc.id_tienda, oc.id_departamento, oc.id_subdepartamento, oc.id_clase, oc.id_subclase, oc.tipo_articulo, SUM(CASE WHEN n >= MONTH(GETDATE()) THEN ISNULL(val, 0) ELSE 0 END) AS abierto_otr FROM otr.otr_consulta oc WHERE oc.id_tienda = 3064 CROSS APPLY (VALUES (1, oc.mes1_compra_adicional), (2, oc.mes2_compra_adicional), (3, oc.mes3_compra_adicional), (4, oc.mes4_compra_adicional), (5, oc.mes5_compra_adicional), (6, oc.mes6_compra_adicional), (7, oc.mes7_compra_adicional), (8, oc.mes8_compra_adicional), (9, oc.mes9_compra_adicional), (10, oc.mes10_compra_adicional), (11, oc.mes11_compra_adicional), (12, oc.mes12_compra_adicional)) m(n, val) GROUP BY oc.id_tienda, oc.id_departamento, oc.id_subdepartamento, oc.id_clase, oc.id_subclase, oc.tipo_articulo) otr ON otr.id_tienda = c.tienda AND otr.id_departamento = me.departamento AND otr.id_subdepartamento = me.subdepartamento AND otr.id_clase = me.clase AND otr.id_subclase = me.subclase AND otr.tipo_articulo = me.tipo_articulo WHERE c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "39",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"39\", \"db_type\": \"sqlserver\", \"description\": \"问题概述：原始查询包含一个全表聚合 + 窗口函数的 CTE（rank_general），多个 LEFT JOIN 与一个 CROSS JOIN(me 子查询)，以及对 otr.otr_consulta 的行级展开 (CROSS APPLY (VALUES ...)) 再做 GROUP BY。性能瓶颈可能来自几处：\\n1) rank_general 需要对 flashdeventas.vetas_y_formas_de_pago 做 GROUP BY 并按 SUM 排序再计算 ROW_NUMBER，若无合适索引/预聚合会导致全表扫描与昂贵的排序；\\n2) me 使用常量筛选但被 CROSS JOIN 到主查，若 me 返回多行会乘扩大外层行数；即使 me 仅返回一行，保留未被外层使用的列会造成不必要的数据传递（可用投影下推移除 proveedor 与 estilo）；\\n3) otr 子查询对 otr.otr_consulta 做了 VALUES 展开后 GROUP BY，若不把高选择性谓词（c.tienda = 3064）下推，会扫描大量无关行并产生大规模聚合中间结果；\\n4) 多个 LEFT JOIN（例如 ranking_tda_jerarquia、control_asignacion_matrices）若缺乏覆盖索引，会引发大量回表和随机 I/O。\\n\\n建议（与实习生给出的规则一致）：\\n- 进行投影下推：在 me 子查询中移除未被外层用到的列（如 proveedor、estilo），减少中间结果宽度；\\n- 进行谓词下推：把高选择性条件 c.tienda = 3064 下推至 otr 的扫描/聚合子查询（即 WHERE oc.id_tienda = 3064），显著降低 otr 聚合量；\\n- 检查并建立必要索引：例如 otr.otr_consulta 上应有 (id_tienda, id_departamento, id_subdepartamento, id_clase, id_subclase, tipo_articulo) 的复合索引或至少 id_tienda 的索引；catalogos.maestro_estilos 可在 (proveedor, estilo) 建索引；catalogos.ranking_tda_jerarquia 在 (id_tienda, departamento, subdepartamento, clase, subclase) 上建索引；clusters.tienda_atributos 在 (centro_comercial, clima, tienda) 建复合/前缀索引；catalogos.tiendas 在 TIENDA 列建主键/索引。 \\n- 对 rank_general 的全表排序开销敏感时，考虑离线物化/周期维护排名表或限制计算范围（若业务允许）。\\n\\n在满足语义前提下（确保移除的列确实不被外层引用，且 c.tienda 为强选择性过滤），方式1 的投影与谓词下推是低风险且立即见效的改进；方式2（更激进的提前过滤/LEFT→INNER 等）若要采用需严格验证不会改变结果。\", \"create_table_statements\": [\"CREATE TABLE catalogos.tiendas (TIENDA INT PRIMARY KEY, nombre NVARCHAR(200), tipo CHAR(1), estatus CHAR(1), marca INT, ciudad NVARCHAR(100), estado NVARCHAR(100), m2 DECIMAL(10,2));\", \"CREATE INDEX IDX_TIENDA_TIPO_MARCA ON catalogos.tiendas(tipo, estatus, marca);\", \"CREATE TABLE flashdeventas.vetas_y_formas_de_pago (ID BIGINT PRIMARY KEY, TIENDA INT, MERCANCIASINIVA DECIMAL(18,4), FECHA DATETIME);\", \"CREATE INDEX IDX_VETAS_TIENDA ON flashdeventas.vetas_y_formas_de_pago(TIENDA);\", \"CREATE TABLE clusters.tienda_atributos (tienda INT PRIMARY KEY, centro_comercial INT, clima NVARCHAR(200));\", \"CREATE INDEX IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos(centro_comercial, clima, tienda);\", \"CREATE TABLE catalogos.maestro_estilos (departamento INT, subdepartamento INT, clase INT, subclase INT, proveedor INT, estilo NVARCHAR(100), tipo_articulo INT);\", \"CREATE INDEX IDX_MAESTRO_ESTILOS_PROV_ESTILO ON catalogos.maestro_estilos(proveedor, estilo);\", \"CREATE TABLE catalogos.ranking_tda_jerarquia (id_tienda INT, departamento INT, subdepartamento INT, clase INT, subclase INT, ranking INT);\", \"CREATE INDEX IDX_RJ_IDTIENDA_DEPT ON catalogos.ranking_tda_jerarquia(id_tienda, departamento, subdepartamento, clase, subclase);\", \"CREATE TABLE catalogos.control_asignacion_matrices (clasificacion INT, matrices_min INT);\", \"CREATE INDEX IDX_CAM_CLASIFICACION ON catalogos.control_asignacion_matrices(clasificacion);\", \"CREATE TABLE otr.otr_consulta (id_tienda INT, id_departamento INT, id_subdepartamento INT, id_clase INT, id_subclase INT, tipo_articulo INT, mes1_compra_adicional DECIMAL(18,4), mes2_compra_adicional DECIMAL(18,4), mes3_compra_adicional DECIMAL(18,4), mes4_compra_adicional DECIMAL(18,4), mes5_compra_adicional DECIMAL(18,4), mes6_compra_adicional DECIMAL(18,4), mes7_compra_adicional DECIMAL(18,4), mes8_compra_adicional DECIMAL(18,4), mes9_compra_adicional DECIMAL(18,4), mes10_compra_adicional DECIMAL(18,4), mes11_compra_adicional DECIMAL(18,4), mes12_compra_adicional DECIMAL(18,4));\", \"CREATE INDEX IDX_OTR_ID_TIENDA_FULL ON otr.otr_consulta(id_tienda, id_departamento, id_subdepartamento, id_clase, id_subclase, tipo_articulo);\", \"CREATE VIEW catalogos.vw_supervisores AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\", \"CREATE VIEW catalogos.vw_regionales AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\"], \"sql\": \";WITH rank_general AS (\\n  SELECT \\n  ta.TIENDA AS id,\\n  ROW_NUMBER() OVER (\\n  ORDER BY SUM(v.MERCANCIASINIVA) DESC\\n  ) AS actual_rank_global\\n  FROM catalogos.tiendas ta\\n  LEFT JOIN flashdeventas.vetas_y_formas_de_pago v ON v.TIENDA = ta.TIENDA\\n  WHERE ta.tipo = 'S' AND estatus = 'A' AND ta.marca = 30\\n  GROUP BY ta.TIENDA\\n) \\nSELECT \\n  rg.actual_rank_global   \\n  ,t.nombre\\n  ,vw_r.nombre as regional\\n  ,vw_s.nombre as supervisor\\n  ,t.estado\\n  ,'RUTA' as ruta  ----\\n  ,t.m2 as tienda_m2\\n  ,'TAMAÑO' as tamanio   ----\\n  ,rj.ranking as rank_jerarquia_n4\\n  ,t.ciudad\\n  ,cam.matrices_min as propuesta\\n  ,otr.abierto_otr as abierto_otr\\n  ,c.* \\nFROM clusters.tienda_atributos c\\nLEFT JOIN catalogos.tiendas t ON c.tienda = t.tienda\\nLEFT JOIN catalogos.vw_supervisores vw_s ON c.tienda = vw_s.tienda\\nLEFT JOIN catalogos.vw_regionales vw_r ON c.tienda = vw_r.tienda\\nLEFT JOIN rank_general rg ON c.tienda = rg.id\\nCROSS JOIN (\\n  SELECT departamento, subdepartamento, clase, subclase, proveedor, estilo, tipo_articulo\\n  FROM catalogos.maestro_estilos me\\n  WHERE me.proveedor = 1162 AND me.estilo = 'C21031101'\\n) me\\nLEFT JOIN catalogos.ranking_tda_jerarquia rj \\n  ON c.tienda = rj.id_tienda\\n  AND rj.departamento = me.departamento\\n  AND rj.subdepartamento = me.subdepartamento\\n  AND rj.clase = me.clase\\n  AND rj.subclase = me.subclase\\nLEFT JOIN catalogos.control_asignacion_matrices cam\\n  ON rj.ranking = cam.clasificacion\\nLEFT JOIN (\\n  SELECT\\n  oc.id_tienda,\\n  oc.id_departamento,\\n  oc.id_subdepartamento,\\n  oc.id_clase,\\n  oc.id_subclase,\\n  oc.tipo_articulo,\\n  SUM(CASE WHEN n >= MONTH(GETDATE()) THEN ISNULL(val, 0) ELSE 0 END) AS abierto_otr\\n  FROM otr.otr_consulta oc\\n  CROSS APPLY (VALUES\\n  (1,  oc.mes1_compra_adicional),\\n  (2,  oc.mes2_compra_adicional),\\n  (3,  oc.mes3_compra_adicional),\\n  (4,  oc.mes4_compra_adicional),\\n  (5,  oc.mes5_compra_adicional),\\n  (6,  oc.mes6_compra_adicional),\\n  (7,  oc.mes7_compra_adicional),\\n  (8,  oc.mes8_compra_adicional),\\n  (9,  oc.mes9_compra_adicional),\\n  (10, oc.mes10_compra_adicional),\\n  (11, oc.mes11_compra_adicional),\\n  (12, oc.mes12_compra_adicional)\\n  ) m(n, val)\\n  GROUP BY\\n  oc.id_tienda,\\n  oc.id_departamento,\\n  oc.id_subdepartamento,\\n  oc.id_clase,\\n  oc.id_subclase,\\n  oc.tipo_articulo\\n) otr\\n  ON  otr.id_tienda = c.tienda\\n  AND otr.id_departamento = me.departamento\\n  AND otr.id_subdepartamento = me.subdepartamento\\n  AND otr.id_clase = me.clase\\n  AND otr.id_subclase = me.subclase\\n  AND otr.tipo_articulo = me.tipo_articulo\\nWHERE 1=1  AND c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t15200\\t10000\\t1200000\\t452000\\t14800\\n1\\t  MERGE JOIN\\t15200\\t10000\\t1200000\\t452000\\t14800\\n2\\t   HASH AGGREGATE (rank_general: SUM + SORT for ROW_NUMBER)\\t9200\\t10000\\t600000\\t300000\\t9000\\n3\\t  TABLE SCAN flashdeventas.vetas_y_formas_de_pago\\t4800\\t10000\\t480000\\t240000\\t4800\\n4\\t   INDEX SEEK catalogos.tiendas (type/estatus/marca filter)\\t200\\t5000\\t80000\\t20000\\t200\\n5\\t   SORT\\t3000\\t10000\\t200000\\t80000\\t3000\\n6\\t   HASH MATCH (left outer join rj/cam/others)\\t2400\\t5000\\t300000\\t100000\\t2400\\n7\\t  VIEW (me CROSS JOIN) -- expands outer rows when me has >1 row\\t50\\t10\\t800\\t500\\t50\\n8\\t  HASH AGGREGATE (otr subquery grouping)\\t6800\\t8000\\t400000\\t160000\\t6800\\n9\\t   TABLE SCAN otr.otr_consulta\\t6600\\t8000\\t380000\\t150000\\t6600\\n10\\t  CROSS APPLY (VALUES ...) expansion per row\\t---\\t---\\t---\\t---\\t---\\n11\\t   NESTED LOOPS (apply joins to clusters.tienda_atributos filtered by centro_comercial/clima/tiena)\\t1200\\t1\\t160\\t600\\t120\\n12\\t  INDEX SEEK IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos (centro_comercial,clima,tienda)\\t10\\t1\\t80\\t20\\t5\\n13\\t  TABLE ACCESS BY INDEX ROWID catalogos.tiendas / vw_supervisores / vw_regionales\\t300\\t1\\t320\\t100\\t30\\n14\\t  FILTER (c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064)\\t---\\t---\\t---\\t---\\t---\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,应用投影下推规则优化 'me' 子查询：移除未使用的列 proveedor 和 estilo。外部查询仅通过JOIN条件引用其他列，被移除列仅出现在WHERE过滤中且未传递到外部。该优化减少子查询结果集的数据量及临时表内存占用，预计I/O减少10%-20%。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将外层高选择性条件c.tienda=3064下推至otr子查询内部，添加WHERE oc.id_tienda=3064，减少子查询90%以上数据处理量。rank_general CTE因窗口函数全局排名需求保留原逻辑\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE catalogos.tiendas (TIENDA INT PRIMARY KEY, nombre NVARCHAR(200), tipo CHAR(1), estatus CHAR(1), marca INT, ciudad NVARCHAR(100), estado NVARCHAR(100), m2 DECIMAL(10,2));\nCREATE INDEX IDX_TIENDA_TIPO_MARCA ON catalogos.tiendas(tipo, estatus, marca);\nCREATE TABLE flashdeventas.vetas_y_formas_de_pago (ID BIGINT PRIMARY KEY, TIENDA INT, MERCANCIASINIVA DECIMAL(18,4), FECHA DATETIME);\nCREATE INDEX IDX_VETAS_TIENDA ON flashdeventas.vetas_y_formas_de_pago(TIENDA);\nCREATE TABLE clusters.tienda_atributos (tienda INT PRIMARY KEY, centro_comercial INT, clima NVARCHAR(200));\nCREATE INDEX IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos(centro_comercial, clima, tienda);\nCREATE TABLE catalogos.maestro_estilos (departamento INT, subdepartamento INT, clase INT, subclase INT, proveedor INT, estilo NVARCHAR(100), tipo_articulo INT);\nCREATE INDEX IDX_MAESTRO_ESTILOS_PROV_ESTILO ON catalogos.maestro_estilos(proveedor, estilo);\nCREATE TABLE catalogos.ranking_tda_jerarquia (id_tienda INT, departamento INT, subdepartamento INT, clase INT, subclase INT, ranking INT);\nCREATE INDEX IDX_RJ_IDTIENDA_DEPT ON catalogos.ranking_tda_jerarquia(id_tienda, departamento, subdepartamento, clase, subclase);\nCREATE TABLE catalogos.control_asignacion_matrices (clasificacion INT, matrices_min INT);\nCREATE INDEX IDX_CAM_CLASIFICACION ON catalogos.control_asignacion_matrices(clasificacion);\nCREATE TABLE otr.otr_consulta (id_tienda INT, id_departamento INT, id_subdepartamento INT, id_clase INT, id_subclase INT, tipo_articulo INT, mes1_compra_adicional DECIMAL(18,4), mes2_compra_adicional DECIMAL(18,4), mes3_compra_adicional DECIMAL(18,4), mes4_compra_adicional DECIMAL(18,4), mes5_compra_adicional DECIMAL(18,4), mes6_compra_adicional DECIMAL(18,4), mes7_compra_adicional DECIMAL(18,4), mes8_compra_adicional DECIMAL(18,4), mes9_compra_adicional DECIMAL(18,4), mes10_compra_adicional DECIMAL(18,4), mes11_compra_adicional DECIMAL(18,4), mes12_compra_adicional DECIMAL(18,4));\nCREATE INDEX IDX_OTR_ID_TIENDA_FULL ON otr.otr_consulta(id_tienda, id_departamento, id_subdepartamento, id_clase, id_subclase, tipo_articulo);\nCREATE VIEW catalogos.vw_supervisores AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\nCREATE VIEW catalogos.vw_regionales AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t15200\t10000\t1200000\t452000\t14800\n1\t  MERGE JOIN\t15200\t10000\t1200000\t452000\t14800\n2\t   HASH AGGREGATE (rank_general: SUM + SORT for ROW_NUMBER)\t9200\t10000\t600000\t300000\t9000\n3\t  TABLE SCAN flashdeventas.vetas_y_formas_de_pago\t4800\t10000\t480000\t240000\t4800\n4\t   INDEX SEEK catalogos.tiendas (type/estatus/marca filter)\t200\t5000\t80000\t20000\t200\n5\t   SORT\t3000\t10000\t200000\t80000\t3000\n6\t   HASH MATCH (left outer join rj/cam/others)\t2400\t5000\t300000\t100000\t2400\n7\t  VIEW (me CROSS JOIN) -- expands outer rows when me has >1 row\t50\t10\t800\t500\t50\n8\t  HASH AGGREGATE (otr subquery grouping)\t6800\t8000\t400000\t160000\t6800\n9\t   TABLE SCAN otr.otr_consulta\t6600\t8000\t380000\t150000\t6600\n10\t  CROSS APPLY (VALUES ...) expansion per row\t---\t---\t---\t---\t---\n11\t   NESTED LOOPS (apply joins to clusters.tienda_atributos filtered by centro_comercial/clima/tiena)\t1200\t1\t160\t600\t120\n12\t  INDEX SEEK IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos (centro_comercial,clima,tienda)\t10\t1\t80\t20\t5\n13\t  TABLE ACCESS BY INDEX ROWID catalogos.tiendas / vw_supervisores / vw_regionales\t300\t1\t320\t100\t30\n14\t  FILTER (c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064)\t---\t---\t---\t---\t---\n\n## Original SQL:\n;WITH rank_general AS (\n  SELECT \n  ta.TIENDA AS id,\n  ROW_NUMBER() OVER (\n  ORDER BY SUM(v.MERCANCIASINIVA) DESC\n  ) AS actual_rank_global\n  FROM catalogos.tiendas ta\n  LEFT JOIN flashdeventas.vetas_y_formas_de_pago v ON v.TIENDA = ta.TIENDA\n  WHERE ta.tipo = 'S' AND estatus = 'A' AND ta.marca = 30\n  GROUP BY ta.TIENDA\n) \nSELECT \n  rg.actual_rank_global   \n  ,t.nombre\n  ,vw_r.nombre as regional\n  ,vw_s.nombre as supervisor\n  ,t.estado\n  ,'RUTA' as ruta  ----\n  ,t.m2 as tienda_m2\n  ,'TAMAÑO' as tamanio   ----\n  ,rj.ranking as rank_jerarquia_n4\n  ,t.ciudad\n  ,cam.matrices_min as propuesta\n  ,otr.abierto_otr as abierto_otr\n  ,c.* \nFROM clusters.tienda_atributos c\nLEFT JOIN catalogos.tiendas t ON c.tienda = t.tienda\nLEFT JOIN catalogos.vw_supervisores vw_s ON c.tienda = vw_s.tienda\nLEFT JOIN catalogos.vw_regionales vw_r ON c.tienda = vw_r.tienda\nLEFT JOIN rank_general rg ON c.tienda = rg.id\nCROSS JOIN (\n  SELECT departamento, subdepartamento, clase, subclase, proveedor, estilo, tipo_articulo\n  FROM catalogos.maestro_estilos me\n  WHERE me.proveedor = 1162 AND me.estilo = 'C21031101'\n) me\nLEFT JOIN catalogos.ranking_tda_jerarquia rj \n  ON c.tienda = rj.id_tienda\n  AND rj.departamento = me.departamento\n  AND rj.subdepartamento = me.subdepartamento\n  AND rj.clase = me.clase\n  AND rj.subclase = me.subclase\nLEFT JOIN catalogos.control_asignacion_matrices cam\n  ON rj.ranking = cam.clasificacion\nLEFT JOIN (\n  SELECT\n  oc.id_tienda,\n  oc.id_departamento,\n  oc.id_subdepartamento,\n  oc.id_clase,\n  oc.id_subclase,\n  oc.tipo_articulo,\n  SUM(CASE WHEN n >= MONTH(GETDATE()) THEN ISNULL(val, 0) ELSE 0 END) AS abierto_otr\n  FROM otr.otr_consulta oc\n  CROSS APPLY (VALUES\n  (1,  oc.mes1_compra_adicional),\n  (2,  oc.mes2_compra_adicional),\n  (3,  oc.mes3_compra_adicional),\n  (4,  oc.mes4_compra_adicional),\n  (5,  oc.mes5_compra_adicional),\n  (6,  oc.mes6_compra_adicional),\n  (7,  oc.mes7_compra_adicional),\n  (8,  oc.mes8_compra_adicional),\n  (9,  oc.mes9_compra_adicional),\n  (10, oc.mes10_compra_adicional),\n  (11, oc.mes11_compra_adicional),\n  (12, oc.mes12_compra_adicional)\n  ) m(n, val)\n  GROUP BY\n  oc.id_tienda,\n  oc.id_departamento,\n  oc.id_subdepartamento,\n  oc.id_clase,\n  oc.id_subclase,\n  oc.tipo_articulo\n) otr\n  ON  otr.id_tienda = c.tienda\n  AND otr.id_departamento = me.departamento\n  AND otr.id_subdepartamento = me.subdepartamento\n  AND otr.id_clase = me.clase\n  AND otr.id_subclase = me.subclase\n  AND otr.tipo_articulo = me.tipo_articulo\nWHERE 1=1  AND c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": ";WITH rank_general AS (SELECT ta.TIENDA AS id, ROW_NUMBER() OVER (ORDER BY SUM(v.MERCANCIASINIVA) DESC) AS actual_rank_global FROM catalogos.tiendas ta LEFT JOIN flashdeventas.vetas_y_formas_de_pago v ON v.TIENDA = ta.TIENDA WHERE ta.tipo = 'S' AND ta.estatus = 'A' AND ta.marca = 30 GROUP BY ta.TIENDA) SELECT rg.actual_rank_global, t.nombre, vw_r.nombre as regional, vw_s.nombre as supervisor, t.estado, 'RUTA' as ruta, t.m2 as tienda_m2, 'TAMAÑO' as tamanio, rj.ranking as rank_jerarquia_n4, t.ciudad, cam.matrices_min as propuesta, otr.abierto_otr, c.* FROM clusters.tienda_atributos c LEFT JOIN catalogos.tiendas t ON c.tienda = t.tienda LEFT JOIN catalogos.vw_supervisores vw_s ON c.tienda = vw_s.tienda LEFT JOIN catalogos.vw_regionales vw_r ON c.tienda = vw_r.tienda LEFT JOIN rank_general rg ON c.tienda = rg.id CROSS JOIN (SELECT departamento, subdepartamento, clase, subclase, proveedor, estilo, tipo_articulo FROM catalogos.maestro_estilos WHERE proveedor = 1162 AND estilo = 'C21031101') me LEFT JOIN catalogos.ranking_tda_jerarquia rj ON c.tienda = rj.id_tienda AND rj.departamento = me.departamento AND rj.subdepartamento = me.subdepartamento AND rj.clase = me.clase AND rj.subclase = me.subclase LEFT JOIN catalogos.control_asignacion_matrices cam ON rj.ranking = cam.clasificacion LEFT JOIN (SELECT oc.id_tienda, oc.id_departamento, oc.id_subdepartamento, oc.id_clase, oc.id_subclase, oc.tipo_articulo, SUM(CASE WHEN n >= MONTH(GETDATE()) THEN ISNULL(val, 0) ELSE 0 END) AS abierto_otr FROM otr.otr_consulta oc WHERE oc.id_tienda = 3064 CROSS APPLY (VALUES (1, oc.mes1_compra_adicional), (2, oc.mes2_compra_adicional), (3, oc.mes3_compra_adicional), (4, oc.mes4_compra_adicional), (5, oc.mes5_compra_adicional), (6, oc.mes6_compra_adicional), (7, oc.mes7_compra_adicional), (8, oc.mes8_compra_adicional), (9, oc.mes9_compra_adicional), (10, oc.mes10_compra_adicional), (11, oc.mes11_compra_adicional), (12, oc.mes12_compra_adicional)) m(n, val) GROUP BY oc.id_tienda, oc.id_departamento, oc.id_subdepartamento, oc.id_clase, oc.id_subclase, oc.tipo_articulo) otr ON otr.id_tienda = c.tienda AND otr.id_departamento = me.departamento AND otr.id_subdepartamento = me.subdepartamento AND otr.id_clase = me.clase AND otr.id_subclase = me.subclase AND otr.tipo_articulo = me.tipo_articulo WHERE c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "40",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"40\", \"db_type\": \"oracle\", \"description\": \"问题概述：此查询包含三层嵌套用于实现基于 ROWNUM 的分页（最内层包含大范围的 SELECT + 多个 LEFT JOIN + 多个标量子查询与函数调用；中间一层再包一层并限制 ROWNUM<=10；最外层再按 rn>0 过滤），导致不必要的视图物化与数据传递开销。主要性能隐患还有：1) 大量标量子查询（例如从 RES_SYS.PUB_MFR、RES_SYS.PUB_DIC_EQP_TYPE、RES_SYS.PUB_RME_EQP_MODEL 等按 ID 查询名称）会对每一行触发独立索引/表访问，开销成倍放大；2) 频繁调用的行级函数（RES_ENTITY.SF_GET_DESC_CHINA / SF_GET_STAFF_NAME 等）若未缓存，会导致大量 CPU 时间；3) IN 子查询包含 CONNECT BY 的递归层次查询，若不先将其物化为较小集合，会使主表筛选成本增高；4) 宽表 SELECT *（以及许多未必要的列和文本转换）增加了 I/O 与网络传输量。建议：删除最外层冗余的 `where rn > 0` 并把分页逻辑简化；把 `ROWNUM <= 10` 的限制尽量下推或改为 `FETCH FIRST 10 ROWS` / 使用 FIRST_ROWS 优化；将标量子查询改写为 LEFT JOIN（或事先使用单表缓存/物化视图）以避免每行重复访问；为常用的连接/过滤列（ENT_ENTITY.ENTITY_ID、ENT_ROOM.ENTITY_ID、ENT_ENTITY.STATION_CODE、STA_STATION.STATION_CODE/ STATION_ID、STA_APP_INFO.STATION_ID、STA_BIZ_INFO.STATION_CODE、REG_MANAGE.REGION_ID）建立合适索引；对昂贵的行级函数考虑结果缓存或提前物化；对 CONNECT BY 结果先计算并临时表化以减少重复计算。这样可显著减少全表扫描、嵌套循环和重复的随机 I/O。\", \"create_table_statements\": [\"CREATE TABLE RES_ENTITY.ENT_ENTITY (ENTITY_ID VARCHAR2(50) PRIMARY KEY, DELETE_STATE VARCHAR2(2), RES_TYPE_ID NUMBER, STATION_CODE VARCHAR2(50), TIME_TO_OVERDUE VARCHAR2(50), CHECK_MODE_ID NUMBER, BUSINESS_ID NUMBER, SUB_BUSINESS_ID NUMBER, PROP_ID NUMBER, OLD_PROP_ID NUMBER, PROPERTY_ID NUMBER, ENTITY_STATE_ID NUMBER, IS_LOCKED_ID NUMBER, IS_FAULT_ID NUMBER, IS_OVERDUE NUMBER, WARRANTY_GRADE_ID NUMBER, IS_OUTMAINTENANCE_ID NUMBER, ASSETS_RECEIVE_TYPE_ID NUMBER, ENTITY_CREATE_SOURCE_ID NUMBER, SOURCE_SYSTEM_ID NUMBER, CHECK_RESULT_ID NUMBER, SERVICE_STATE_ID NUMBER, IS_MONITOR_ID NUMBER, MONITOR_STYLE_ID NUMBER, IS_UPLOAD_PHOTO NUMBER, STORAGE_STATE_ID NUMBER, IS_STORAGE NUMBER, RES_FROM_PROJBUILDTYPE_ID NUMBER, SPLIT_MERGE_REASON_ID NUMBER, SOURCE_RES_NO VARCHAR2(100), ROOM_ID VARCHAR2(50), RES_TYPE_ID_TEXT VARCHAR2(100), DEV_TYPE_ID NUMBER, DEV_MODEL_ID NUMBER, OLD_DEV_MODEL_ID NUMBER, MFR_ID NUMBER, DW_MFR_ID NUMBER, OLD_DW_MFR_ID NUMBER, MNT_MFR_ID NUMBER, MODIFY_OP VARCHAR2(50), CREATE_OP VARCHAR2(50), CHECK_PERSON VARCHAR2(50), STATION_CODE_ALT VARCHAR2(50));\", \"CREATE INDEX IDX_ENT_ENTITY_DELETE_RES_TYPE_STCODE ON RES_ENTITY.ENT_ENTITY(DELETE_STATE, RES_TYPE_ID, STATION_CODE);\", \"CREATE TABLE RES_ENTITY.ENT_ROOM (ENTITY_ID VARCHAR2(50), WIDTH NUMBER, LENGTH NUMBER, HEIGHT NUMBER, AREA NUMBER, FLOOR_NO NUMBER, IS_OIL_MACH_ROOM NUMBER, IS_HAVE_WALL NUMBER, STRUCTURE_ID NUMBER, ADDRESS VARCHAR2(400), AIRBLAST_STYLE NUMBER, VACANT_CABLE_SEAT NUMBER, CONTACTS VARCHAR2(200), LINK_TEL VARCHAR2(50), NUM_HOLE_FEED NUMBER, NUM_HOLE_FEED_OCCU NUMBER, NUM_HOLE_FEED_FREE NUMBER, LIGHT_PROTECTION_BRAND VARCHAR2(200), LIGHT_PROTECTION_MODE VARCHAR2(200), FIRE_EXTINGUISHER_TYPE VARCHAR2(100), NUM_FIRE_EXTINGUISHER NUMBER, STATION_ROAD_ID NUMBER, DEGREE_ARRIVAL_ID NUMBER, REASON_UNARRIVAL VARCHAR2(400), IS_ARRIVEL NUMBER, IS_POWER NUMBER, REASON_UNPOWER VARCHAR2(400), INOUT_MODE NUMBER, PLATE_DRAWINGS_ID VARCHAR2(50), DECORATION_DRAWINGS_ID VARCHAR2(50), DESIGN_DRAWINGS_ID VARCHAR2(50), GROUND_SYSTEM_DRAWINGS_ID VARCHAR2(50), IS_EXPAND_OIL_ROOM NUMBER, SECURITY_ENVIRONMENT_ID NUMBER, GENERATION_TIME DATE, WNG_STYLE NUMBER, ROOM_GRADE_ID NUMBER, NUM_RMEBAY_TOTAL NUMBER, NUM_RMEBAY_FREE NUMBER, PRODUCT_TYPE NUMBER, ENT_AUDIT_RESULT_ID NUMBER, AUDIT_FLOW_RESULT_ID NUMBER, MANUAL_IDENT_RESULT_ID NUMBER, AGENT_MNT_CONTACT VARCHAR2(50), IS_VR_FULLSCENE_ID NUMBER, IS_SHARE NUMBER, SHARE_UNIT_ID VARCHAR2(50), INTEG_CABINET_SPACE_NUM NUMBER, INTEG_CABINET_AC_BRAND VARCHAR2(200), INTEG_CABINET_AC_MODEL_DC VARCHAR2(200), INTEG_CABINET_AC_NUM_DC NUMBER, INTEG_CABINET_AC_MODEL VARCHAR2(200), INTEG_CABINET_AC_NUM_DC_AC NUMBER, INTEG_CABINET_AC_NUM_ID VARCHAR2(50), INTEG_CABINET_AC_MFR_ID NUMBER, INTEG_CABINET_AC_NUM_ID_TEXT VARCHAR2(200));\", \"CREATE INDEX IDX_ENT_ROOM_ENTITY_ID ON RES_ENTITY.ENT_ROOM(ENTITY_ID);\", \"CREATE TABLE RES_ENTITY.STA_STATION (STATION_ID NUMBER PRIMARY KEY, STATION_CODE VARCHAR2(50), DISTRICT_PROVINCE_ID VARCHAR2(50), DISTRICT_REGION_ID VARCHAR2(50), DISTRICT_COUNTY_ID VARCHAR2(50), STATION_NAME VARCHAR2(200));\", \"CREATE INDEX IDX_STA_STATION_STATION_CODE ON RES_ENTITY.STA_STATION(STATION_CODE);\", \"CREATE TABLE RES_ENTITY.STA_APP_INFO (STATION_ID NUMBER, APP_REGION_ID VARCHAR2(50));\", \"CREATE INDEX IDX_STA_APP_INFO_STATION_ID ON RES_ENTITY.STA_APP_INFO(STATION_ID);\", \"CREATE TABLE RES_ENTITY.STA_BIZ_INFO (STATION_CODE VARCHAR2(50), REGION_ID VARCHAR2(50));\", \"CREATE INDEX IDX_STA_BIZ_INFO_REGION_ID ON RES_ENTITY.STA_BIZ_INFO(REGION_ID);\", \"CREATE TABLE RES_ENTITY.REG_MANAGE (REGION_ID VARCHAR2(50) PRIMARY KEY, SUPER_REGION_ID VARCHAR2(50), REGION_NAME VARCHAR2(200), DELETE_STATE VARCHAR2(2));\", \"CREATE INDEX IDX_REG_MANAGE_REGION_ID ON RES_ENTITY.REG_MANAGE(REGION_ID);\", \"CREATE TABLE RES_SYS.PUB_MFR (MFR_ID NUMBER PRIMARY KEY, MFR VARCHAR2(200), DELETE_STATE VARCHAR2(2));\", \"CREATE INDEX IDX_PUB_MFR_MFR_ID ON RES_SYS.PUB_MFR(MFR_ID);\", \"CREATE TABLE RES_SYS.PUB_DIC_EQP_TYPE (EQP_TYPE_ID NUMBER PRIMARY KEY, EQP_TYPE VARCHAR2(200), DELETE_STATE VARCHAR2(2));\", \"CREATE INDEX IDX_PUB_DIC_EQP_TYPE_ID ON RES_SYS.PUB_DIC_EQP_TYPE(EQP_TYPE_ID);\", \"CREATE TABLE RES_SYS.PUB_RME_EQP_MODEL (EQP_MODEL_ID NUMBER PRIMARY KEY, EQP_MODEL VARCHAR2(200), DELETE_STATE VARCHAR2(2));\", \"CREATE INDEX IDX_PUB_RME_EQP_MODEL_ID ON RES_SYS.PUB_RME_EQP_MODEL(EQP_MODEL_ID);\"], \"sql\": \"select *  from (select t.*,ROWNUM AS rn  from (SELECT\\n\\tEE.*,\\n\\tB.WIDTH,\\n\\tB.LENGTH,\\n\\tB.HEIGHT,\\n\\tB.AREA,\\n\\tB.FLOOR_NO,\\n\\tB.IS_OIL_MACH_ROOM,\\n\\tB.IS_HAVE_WALL,\\n\\tB.STRUCTURE_ID,\\n\\tB.ADDRESS,\\n\\tB.AIRBLAST_STYLE,\\n\\tB.VACANT_CABLE_SEAT,\\n\\tB.CONTACTS,\\n\\tB.LINK_TEL,\\n\\tB.NUM_HOLE_FEED,\\n\\tB.NUM_HOLE_FEED_OCCU,\\n\\tB.NUM_HOLE_FEED_FREE,\\n\\tB.LIGHT_PROTECTION_BRAND,\\n\\tB.LIGHT_PROTECTION_MODE,\\n\\tB.FIRE_EXTINGUISHER_TYPE,\\n\\tB.NUM_FIRE_EXTINGUISHER,\\n\\tB.STATION_ROAD_ID,\\n\\tB.DEGREE_ARRIVAL_ID,\\n\\tB.REASON_UNARRIVAL,\\n\\tB.IS_ARRIVEL,\\n\\tB.IS_POWER,\\n\\tB.REASON_UNPOWER,\\n\\tB.INOUT_MODE,\\n\\tB.PLATE_DRAWINGS_ID,\\n\\tB.DECORATION_DRAWINGS_ID,\\n\\tB.DESIGN_DRAWINGS_ID,\\n\\tB.GROUND_SYSTEM_DRAWINGS_ID,\\n\\tB.IS_EXPAND_OIL_ROOM,\\n\\tB.SECURITY_ENVIRONMENT_ID,\\n\\tB.GENERATION_TIME,\\n\\tB.WNG_STYLE,\\n\\tB.ROOM_GRADE_ID,\\n\\tB.NUM_RMEBAY_TOTAL,\\n\\tB.NUM_RMEBAY_FREE,\\n\\tB.PRODUCT_TYPE,\\n\\tB.ENT_AUDIT_RESULT_ID,\\n\\tB.AUDIT_FLOW_RESULT_ID,\\n\\tB.MANUAL_IDENT_RESULT_ID,\\n\\tB.AGENT_MNT_CONTACT,\\n\\tB.IS_VR_FULLSCENE_ID,\\n\\tB.IS_SHARE,\\n\\tB.SHARE_UNIT_ID,\\n\\tB.INTEG_CABINET_SPACE_NUM,\\n\\tB.INTEG_CABINET_AC_BRAND,\\n\\tB.INTEG_CABINET_AC_MODEL_DC,\\n\\tB.INTEG_CABINET_AC_NUM_DC,\\n\\tB.INTEG_CABINET_AC_MODEL,\\n\\tB.INTEG_CABINET_AC_NUM_DC_AC,\\n\\tB.INTEG_CABINET_SPACE_NUM AS INTEG_CABINET_SPACE_NUM_TEXT,\\n\\tEE.RES_FROM_PROJECT_NAME AS RES_FROM_PROJECT_NAME_TEXT,\\n\\tB.INTEG_CABINET_AC_NUM_ID,\\n\\tres_entity.SF_GET_DESC_CHINA(B.INTEG_CABINET_AC_NUM_ID) AS INTEG_CABINET_AC_NUM_ID_TEXT,\\n\\tB.INTEG_CABINET_AC_MFR_ID,\\n\\tB.INTEG_CABINET_AC_MODEL,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=B.INTEG_CABINET_AC_MFR_ID and delete_state='0') AS INTEG_CABINET_AC_MFR_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.TIME_TO_OVERDUE) AS TIME_TO_OVERDUE_TEXT,\\n\\t(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=B.MANUAL_IDENT_RESULT_ID AND DELETE_STATE = '0') AS MANUAL_IDENT_RESULT_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_STAFF_NAME(B.AGENT_MNT_CONTACT) AS AGENT_MNT_CONTACT_TEXT,\\n\\tCASE WHEN B.IS_VR_FULLSCENE_ID = 1 THEN '有' WHEN B.IS_VR_FULLSCENE_ID= 0 THEN '无' END AS IS_VR_FULLSCENE_ID_TEXT,\\n\\tCASE WHEN B.AIRBLAST_STYLE = 1 THEN '下送风' WHEN B.AIRBLAST_STYLE= 0 THEN '上送风' END AS AIRBLAST_STYLE_TEXT,\\n\\tCASE WHEN B.WNG_STYLE = 1 THEN '上走线' WHEN B.WNG_STYLE= 0 THEN '下走线' END AS WNG_STYLE_STYLE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_SHARE) AS IS_SHARE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.SHARE_UNIT_ID) AS SHARE_UNIT_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.AUDIT_FLOW_RESULT_ID) AS AUDIT_FLOW_RESULT_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.ENT_AUDIT_RESULT_ID) AS ENT_AUDIT_RESULT_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.PRODUCT_TYPE) AS PRODUCT_TYPE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_OIL_MACH_ROOM) AS IS_OIL_MACH_ROOM_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_HAVE_WALL) AS IS_HAVE_WALL_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.STRUCTURE_ID) AS STRUCTURE_ID_TEXT, \\n\\tres_entity.SF_GET_DESC_CHINA(B.VACANT_CABLE_SEAT) AS VACANT_CABLE_SEAT_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.STATION_ROAD_ID) AS STATION_ROAD_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.DEGREE_ARRIVAL_ID) AS DEGREE_ARRIVAL_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_ARRIVEL) AS IS_ARRIVEL_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_POWER) AS IS_POWER_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.INOUT_MODE) AS INOUT_MODE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_EXPAND_OIL_ROOM) AS IS_EXPAND_OIL_ROOM_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.SECURITY_ENVIRONMENT_ID) AS SECURITY_ENVIRONMENT_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.WNG_STYLE) AS WNG_STYLE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.ROOM_GRADE_ID) AS ROOM_GRADE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_MODE_ID) AS CHECK_MODE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.BUSINESS_ID) AS BUSINESS_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SUB_BUSINESS_ID) AS SUB_BUSINESS_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.PROP_ID) AS PROP_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.OLD_PROP_ID) AS OLD_PROP_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.PROPERTY_ID) AS PROPERTY_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_STATE_ID) AS ENTITY_STATE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_LOCKED_ID) AS IS_LOCKED_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_FAULT_ID) AS IS_FAULT_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OVERDUE) AS IS_OVERDUE_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.WARRANTY_GRADE_ID) AS WARRANTY_GRADE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OUTMAINTENANCE_ID) AS IS_OUTMAINTENANCE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ASSETS_RECEIVE_TYPE_ID) AS ASSETS_RECEIVE_TYPE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_CREATE_SOURCE_ID) AS ENTITY_CREATE_SOURCE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SOURCE_SYSTEM_ID) AS SOURCE_SYSTEM_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_RESULT_ID) AS CHECK_RESULT_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SERVICE_STATE_ID) AS SERVICE_STATE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_MONITOR_ID) AS IS_MONITOR_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.MONITOR_STYLE_ID) AS MONITOR_STYLE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_UPLOAD_PHOTO) AS IS_UPLOAD_PHOTO_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.STORAGE_STATE_ID) AS STORAGE_STATE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_STORAGE) AS IS_STORAGE_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.RES_FROM_PROJBUILDTYPE_ID) AS RES_FROM_PROJBUILDTYPE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SPLIT_MERGE_REASON_ID) AS SPLIT_MERGE_REASON_ID_TEXT,\\n\\tEE.SOURCE_RES_NO AS SOURCE_RES_NO_TEXT,\\n\\t(SELECT ENTITY_NAME FROM res_entity.ent_entity WHERE ENTITY_ID=EE.ROOM_ID and res_type_id='205' and delete_state='0') AS ROOM_ID_TEXT,\\n\\t(SELECT RES_TYPE FROM RES_SYS.PUB_DIC_RES_TYPE WHERE RES_TYPE_ID=EE.RES_TYPE_ID and delete_state='0') AS RES_TYPE_ID_TEXT,\\n\\t(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=EE.DEV_TYPE_ID and delete_state='0') AS DEV_TYPE_ID_TEXT,\\n\\t(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.DEV_MODEL_ID and delete_state='0') AS DEV_MODEL_ID_TEXT,\\n\\t(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.OLD_DEV_MODEL_ID and delete_state='0') AS OLD_DEV_MODEL_ID_TEXT,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MFR_ID and delete_state='0') AS MFR_ID_TEXT,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.DW_MFR_ID and delete_state='0') AS DW_MFR_ID_TEXT,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.OLD_DW_MFR_ID and delete_state='0') AS OLD_DW_MFR_ID_TEXT,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MNT_MFR_ID and delete_state='0') AS MNT_MFR_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_STAFF_NAME(EE.MODIFY_OP) AS MODIFY_OP_TEXT,\\n\\tRES_ENTITY.SF_GET_STAFF_NAME(EE.CREATE_OP) AS CREATE_OP_TEXT,\\n\\tRES_ENTITY.SF_GET_STAFF_NAME(EE.CHECK_PERSON) AS CHECK_PERSON_TEXT,\\n\\tST.DISTRICT_PROVINCE_ID,\\n\\tST.DISTRICT_REGION_ID,\\n\\tST.DISTRICT_COUNTY_ID,\\n\\tST.STATION_NAME,\\n\\tST.STATION_NAME AS STATION_ID_TEXT,\\n\\tD.APP_REGION_ID,\\n\\t(SELECT REGION_NAME FROM res_entity.REG_MANAGE WHERE REGION_ID = D.APP_REGION_ID AND delete_state = '0') AS APP_REGION_ID_TEXT,\\n\\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) AS DISTRICT_PROVINCE_ID_TEXT,\\n\\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) AS DISTRICT_REGION_ID_TEXT,\\n\\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS DISTRICT_COUNTY_ID_TEXT,\\n\\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS REGION_ID_TEXT \\nFROM RES_ENTITY.ENT_ENTITY EE \\nLEFT JOIN RES_ENTITY.ENT_ROOM B ON B.ENTITY_ID = EE.ENTITY_ID\\nLEFT JOIN RES_ENTITY.STA_STATION ST ON ST.STATION_CODE = EE.STATION_CODE  \\nLEFT JOIN RES_ENTITY.STA_APP_INFO D ON ST.STATION_ID=D.STATION_ID\\nWHERE EE.DELETE_STATE = '0' AND EE.RES_TYPE_ID=205  \\nAND EE.STATION_CODE in  (select station_code  from res_entity.sta_biz_info  where  REGION_ID in (  select REGION_ID from res_entity.reg_manage  connect by prior REGION_ID = SUPER_REGION_ID and nvl(delete_state, '0') = '0' start with region_id in ('000102000000000000370100') ) ) \\n)t where ROWNUM <= 10) where rn > 0;\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t4200\\t10\\t120000\\t360000\\t14000\\n1\\t  NESTED LOOPS\\t4200\\t10\\t120000\\t360000\\t14000\\n2\\t   TABLE ACCESS FULL RES_ENTITY.ENT_ENTITY\\t3000\\t10000\\t800000\\t240000\\t10000\\n3\\t  FILTER (EE.DELETE_STATE='0' AND EE.RES_TYPE_ID=205 AND EE.STATION_CODE IN (... CONNECT BY result ...))\\t---\\t---\\t---\\t---\\t---\\n4\\t   NESTED LOOPS\\t1200\\t10\\t24000\\t80000\\t4000\\n5\\t  INDEX UNIQUE SCAN IDX_ENT_ROOM_ENTITY_ID (ENT_ROOM)\\t10\\t10\\t800\\t4000\\t50\\n6\\t   TABLE ACCESS BY INDEX ROWID RES_ENTITY.ENT_ROOM\\t20\\t10\\t800\\t2000\\t100\\n7\\t  INDEX RANGE SCAN IDX_STA_STATION_STATION_CODE (STA_STATION)\\t50\\t10\\t2000\\t5000\\t200\\n8\\t   TABLE ACCESS BY INDEX ROWID RES_ENTITY.STA_STATION\\t60\\t10\\t2000\\t4000\\t200\\n9\\t  TABLE ACCESS BY INDEX ROWID RES_ENTITY.STA_APP_INFO\\t40\\t10\\t1600\\t3000\\t150\\n10\\t  NESTED LOOPS (correlated scalar subquery evaluations)\\t800\\t10\\t20000\\t60000\\t3000\\n11\\t   INDEX RANGE SCAN IDX_PUB_MFR_MFR_ID (RES_SYS.PUB_MFR)\\t5\\t10\\t800\\t2000\\t20\\n12\\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_MFR\\t10\\t10\\t800\\t2000\\t30\\n13\\t   INDEX RANGE SCAN IDX_PUB_DIC_EQP_TYPE_ID (RES_SYS.PUB_DIC_EQP_TYPE)\\t5\\t10\\t800\\t2000\\t20\\n14\\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_DIC_EQP_TYPE\\t10\\t10\\t800\\t2000\\t30\\n15\\t   INDEX RANGE SCAN IDX_PUB_RME_EQP_MODEL_ID (RES_SYS.PUB_RME_EQP_MODEL)\\t5\\t10\\t800\\t2000\\t20\\n16\\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_RME_EQP_MODEL\\t10\\t10\\t800\\t2000\\t30\\n17\\t  FILTER (ROWNUM <= 10 applied in inner view)\\t---\\t---\\t---\\t---\\t---\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"Oracle ROWNUM冗余嵌套消除,通过移除冗余的最外层分页条件（rn>0）和内层嵌套，将三层ROWNUM分页查询简化为两层，减少视图物化和数据传递，提高性能。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE RES_ENTITY.ENT_ENTITY (ENTITY_ID VARCHAR2(50) PRIMARY KEY, DELETE_STATE VARCHAR2(2), RES_TYPE_ID NUMBER, STATION_CODE VARCHAR2(50), TIME_TO_OVERDUE VARCHAR2(50), CHECK_MODE_ID NUMBER, BUSINESS_ID NUMBER, SUB_BUSINESS_ID NUMBER, PROP_ID NUMBER, OLD_PROP_ID NUMBER, PROPERTY_ID NUMBER, ENTITY_STATE_ID NUMBER, IS_LOCKED_ID NUMBER, IS_FAULT_ID NUMBER, IS_OVERDUE NUMBER, WARRANTY_GRADE_ID NUMBER, IS_OUTMAINTENANCE_ID NUMBER, ASSETS_RECEIVE_TYPE_ID NUMBER, ENTITY_CREATE_SOURCE_ID NUMBER, SOURCE_SYSTEM_ID NUMBER, CHECK_RESULT_ID NUMBER, SERVICE_STATE_ID NUMBER, IS_MONITOR_ID NUMBER, MONITOR_STYLE_ID NUMBER, IS_UPLOAD_PHOTO NUMBER, STORAGE_STATE_ID NUMBER, IS_STORAGE NUMBER, RES_FROM_PROJBUILDTYPE_ID NUMBER, SPLIT_MERGE_REASON_ID NUMBER, SOURCE_RES_NO VARCHAR2(100), ROOM_ID VARCHAR2(50), RES_TYPE_ID_TEXT VARCHAR2(100), DEV_TYPE_ID NUMBER, DEV_MODEL_ID NUMBER, OLD_DEV_MODEL_ID NUMBER, MFR_ID NUMBER, DW_MFR_ID NUMBER, OLD_DW_MFR_ID NUMBER, MNT_MFR_ID NUMBER, MODIFY_OP VARCHAR2(50), CREATE_OP VARCHAR2(50), CHECK_PERSON VARCHAR2(50), STATION_CODE_ALT VARCHAR2(50));\nCREATE INDEX IDX_ENT_ENTITY_DELETE_RES_TYPE_STCODE ON RES_ENTITY.ENT_ENTITY(DELETE_STATE, RES_TYPE_ID, STATION_CODE);\nCREATE TABLE RES_ENTITY.ENT_ROOM (ENTITY_ID VARCHAR2(50), WIDTH NUMBER, LENGTH NUMBER, HEIGHT NUMBER, AREA NUMBER, FLOOR_NO NUMBER, IS_OIL_MACH_ROOM NUMBER, IS_HAVE_WALL NUMBER, STRUCTURE_ID NUMBER, ADDRESS VARCHAR2(400), AIRBLAST_STYLE NUMBER, VACANT_CABLE_SEAT NUMBER, CONTACTS VARCHAR2(200), LINK_TEL VARCHAR2(50), NUM_HOLE_FEED NUMBER, NUM_HOLE_FEED_OCCU NUMBER, NUM_HOLE_FEED_FREE NUMBER, LIGHT_PROTECTION_BRAND VARCHAR2(200), LIGHT_PROTECTION_MODE VARCHAR2(200), FIRE_EXTINGUISHER_TYPE VARCHAR2(100), NUM_FIRE_EXTINGUISHER NUMBER, STATION_ROAD_ID NUMBER, DEGREE_ARRIVAL_ID NUMBER, REASON_UNARRIVAL VARCHAR2(400), IS_ARRIVEL NUMBER, IS_POWER NUMBER, REASON_UNPOWER VARCHAR2(400), INOUT_MODE NUMBER, PLATE_DRAWINGS_ID VARCHAR2(50), DECORATION_DRAWINGS_ID VARCHAR2(50), DESIGN_DRAWINGS_ID VARCHAR2(50), GROUND_SYSTEM_DRAWINGS_ID VARCHAR2(50), IS_EXPAND_OIL_ROOM NUMBER, SECURITY_ENVIRONMENT_ID NUMBER, GENERATION_TIME DATE, WNG_STYLE NUMBER, ROOM_GRADE_ID NUMBER, NUM_RMEBAY_TOTAL NUMBER, NUM_RMEBAY_FREE NUMBER, PRODUCT_TYPE NUMBER, ENT_AUDIT_RESULT_ID NUMBER, AUDIT_FLOW_RESULT_ID NUMBER, MANUAL_IDENT_RESULT_ID NUMBER, AGENT_MNT_CONTACT VARCHAR2(50), IS_VR_FULLSCENE_ID NUMBER, IS_SHARE NUMBER, SHARE_UNIT_ID VARCHAR2(50), INTEG_CABINET_SPACE_NUM NUMBER, INTEG_CABINET_AC_BRAND VARCHAR2(200), INTEG_CABINET_AC_MODEL_DC VARCHAR2(200), INTEG_CABINET_AC_NUM_DC NUMBER, INTEG_CABINET_AC_MODEL VARCHAR2(200), INTEG_CABINET_AC_NUM_DC_AC NUMBER, INTEG_CABINET_AC_NUM_ID VARCHAR2(50), INTEG_CABINET_AC_MFR_ID NUMBER, INTEG_CABINET_AC_NUM_ID_TEXT VARCHAR2(200));\nCREATE INDEX IDX_ENT_ROOM_ENTITY_ID ON RES_ENTITY.ENT_ROOM(ENTITY_ID);\nCREATE TABLE RES_ENTITY.STA_STATION (STATION_ID NUMBER PRIMARY KEY, STATION_CODE VARCHAR2(50), DISTRICT_PROVINCE_ID VARCHAR2(50), DISTRICT_REGION_ID VARCHAR2(50), DISTRICT_COUNTY_ID VARCHAR2(50), STATION_NAME VARCHAR2(200));\nCREATE INDEX IDX_STA_STATION_STATION_CODE ON RES_ENTITY.STA_STATION(STATION_CODE);\nCREATE TABLE RES_ENTITY.STA_APP_INFO (STATION_ID NUMBER, APP_REGION_ID VARCHAR2(50));\nCREATE INDEX IDX_STA_APP_INFO_STATION_ID ON RES_ENTITY.STA_APP_INFO(STATION_ID);\nCREATE TABLE RES_ENTITY.STA_BIZ_INFO (STATION_CODE VARCHAR2(50), REGION_ID VARCHAR2(50));\nCREATE INDEX IDX_STA_BIZ_INFO_REGION_ID ON RES_ENTITY.STA_BIZ_INFO(REGION_ID);\nCREATE TABLE RES_ENTITY.REG_MANAGE (REGION_ID VARCHAR2(50) PRIMARY KEY, SUPER_REGION_ID VARCHAR2(50), REGION_NAME VARCHAR2(200), DELETE_STATE VARCHAR2(2));\nCREATE INDEX IDX_REG_MANAGE_REGION_ID ON RES_ENTITY.REG_MANAGE(REGION_ID);\nCREATE TABLE RES_SYS.PUB_MFR (MFR_ID NUMBER PRIMARY KEY, MFR VARCHAR2(200), DELETE_STATE VARCHAR2(2));\nCREATE INDEX IDX_PUB_MFR_MFR_ID ON RES_SYS.PUB_MFR(MFR_ID);\nCREATE TABLE RES_SYS.PUB_DIC_EQP_TYPE (EQP_TYPE_ID NUMBER PRIMARY KEY, EQP_TYPE VARCHAR2(200), DELETE_STATE VARCHAR2(2));\nCREATE INDEX IDX_PUB_DIC_EQP_TYPE_ID ON RES_SYS.PUB_DIC_EQP_TYPE(EQP_TYPE_ID);\nCREATE TABLE RES_SYS.PUB_RME_EQP_MODEL (EQP_MODEL_ID NUMBER PRIMARY KEY, EQP_MODEL VARCHAR2(200), DELETE_STATE VARCHAR2(2));\nCREATE INDEX IDX_PUB_RME_EQP_MODEL_ID ON RES_SYS.PUB_RME_EQP_MODEL(EQP_MODEL_ID);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t4200\t10\t120000\t360000\t14000\n1\t  NESTED LOOPS\t4200\t10\t120000\t360000\t14000\n2\t   TABLE ACCESS FULL RES_ENTITY.ENT_ENTITY\t3000\t10000\t800000\t240000\t10000\n3\t  FILTER (EE.DELETE_STATE='0' AND EE.RES_TYPE_ID=205 AND EE.STATION_CODE IN (... CONNECT BY result ...))\t---\t---\t---\t---\t---\n4\t   NESTED LOOPS\t1200\t10\t24000\t80000\t4000\n5\t  INDEX UNIQUE SCAN IDX_ENT_ROOM_ENTITY_ID (ENT_ROOM)\t10\t10\t800\t4000\t50\n6\t   TABLE ACCESS BY INDEX ROWID RES_ENTITY.ENT_ROOM\t20\t10\t800\t2000\t100\n7\t  INDEX RANGE SCAN IDX_STA_STATION_STATION_CODE (STA_STATION)\t50\t10\t2000\t5000\t200\n8\t   TABLE ACCESS BY INDEX ROWID RES_ENTITY.STA_STATION\t60\t10\t2000\t4000\t200\n9\t  TABLE ACCESS BY INDEX ROWID RES_ENTITY.STA_APP_INFO\t40\t10\t1600\t3000\t150\n10\t  NESTED LOOPS (correlated scalar subquery evaluations)\t800\t10\t20000\t60000\t3000\n11\t   INDEX RANGE SCAN IDX_PUB_MFR_MFR_ID (RES_SYS.PUB_MFR)\t5\t10\t800\t2000\t20\n12\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_MFR\t10\t10\t800\t2000\t30\n13\t   INDEX RANGE SCAN IDX_PUB_DIC_EQP_TYPE_ID (RES_SYS.PUB_DIC_EQP_TYPE)\t5\t10\t800\t2000\t20\n14\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_DIC_EQP_TYPE\t10\t10\t800\t2000\t30\n15\t   INDEX RANGE SCAN IDX_PUB_RME_EQP_MODEL_ID (RES_SYS.PUB_RME_EQP_MODEL)\t5\t10\t800\t2000\t20\n16\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_RME_EQP_MODEL\t10\t10\t800\t2000\t30\n17\t  FILTER (ROWNUM <= 10 applied in inner view)\t---\t---\t---\t---\t---\n\n## Original SQL:\nselect *  from (select t.*,ROWNUM AS rn  from (SELECT\n\tEE.*,\n\tB.WIDTH,\n\tB.LENGTH,\n\tB.HEIGHT,\n\tB.AREA,\n\tB.FLOOR_NO,\n\tB.IS_OIL_MACH_ROOM,\n\tB.IS_HAVE_WALL,\n\tB.STRUCTURE_ID,\n\tB.ADDRESS,\n\tB.AIRBLAST_STYLE,\n\tB.VACANT_CABLE_SEAT,\n\tB.CONTACTS,\n\tB.LINK_TEL,\n\tB.NUM_HOLE_FEED,\n\tB.NUM_HOLE_FEED_OCCU,\n\tB.NUM_HOLE_FEED_FREE,\n\tB.LIGHT_PROTECTION_BRAND,\n\tB.LIGHT_PROTECTION_MODE,\n\tB.FIRE_EXTINGUISHER_TYPE,\n\tB.NUM_FIRE_EXTINGUISHER,\n\tB.STATION_ROAD_ID,\n\tB.DEGREE_ARRIVAL_ID,\n\tB.REASON_UNARRIVAL,\n\tB.IS_ARRIVEL,\n\tB.IS_POWER,\n\tB.REASON_UNPOWER,\n\tB.INOUT_MODE,\n\tB.PLATE_DRAWINGS_ID,\n\tB.DECORATION_DRAWINGS_ID,\n\tB.DESIGN_DRAWINGS_ID,\n\tB.GROUND_SYSTEM_DRAWINGS_ID,\n\tB.IS_EXPAND_OIL_ROOM,\n\tB.SECURITY_ENVIRONMENT_ID,\n\tB.GENERATION_TIME,\n\tB.WNG_STYLE,\n\tB.ROOM_GRADE_ID,\n\tB.NUM_RMEBAY_TOTAL,\n\tB.NUM_RMEBAY_FREE,\n\tB.PRODUCT_TYPE,\n\tB.ENT_AUDIT_RESULT_ID,\n\tB.AUDIT_FLOW_RESULT_ID,\n\tB.MANUAL_IDENT_RESULT_ID,\n\tB.AGENT_MNT_CONTACT,\n\tB.IS_VR_FULLSCENE_ID,\n\tB.IS_SHARE,\n\tB.SHARE_UNIT_ID,\n\tB.INTEG_CABINET_SPACE_NUM,\n\tB.INTEG_CABINET_AC_BRAND,\n\tB.INTEG_CABINET_AC_MODEL_DC,\n\tB.INTEG_CABINET_AC_NUM_DC,\n\tB.INTEG_CABINET_AC_MODEL,\n\tB.INTEG_CABINET_AC_NUM_DC_AC,\n\tB.INTEG_CABINET_SPACE_NUM AS INTEG_CABINET_SPACE_NUM_TEXT,\n\tEE.RES_FROM_PROJECT_NAME AS RES_FROM_PROJECT_NAME_TEXT,\n\tB.INTEG_CABINET_AC_NUM_ID,\n\tres_entity.SF_GET_DESC_CHINA(B.INTEG_CABINET_AC_NUM_ID) AS INTEG_CABINET_AC_NUM_ID_TEXT,\n\tB.INTEG_CABINET_AC_MFR_ID,\n\tB.INTEG_CABINET_AC_MODEL,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=B.INTEG_CABINET_AC_MFR_ID and delete_state='0') AS INTEG_CABINET_AC_MFR_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.TIME_TO_OVERDUE) AS TIME_TO_OVERDUE_TEXT,\n\t(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=B.MANUAL_IDENT_RESULT_ID AND DELETE_STATE = '0') AS MANUAL_IDENT_RESULT_ID_TEXT,\n\tRES_ENTITY.SF_GET_STAFF_NAME(B.AGENT_MNT_CONTACT) AS AGENT_MNT_CONTACT_TEXT,\n\tCASE WHEN B.IS_VR_FULLSCENE_ID = 1 THEN '有' WHEN B.IS_VR_FULLSCENE_ID= 0 THEN '无' END AS IS_VR_FULLSCENE_ID_TEXT,\n\tCASE WHEN B.AIRBLAST_STYLE = 1 THEN '下送风' WHEN B.AIRBLAST_STYLE= 0 THEN '上送风' END AS AIRBLAST_STYLE_TEXT,\n\tCASE WHEN B.WNG_STYLE = 1 THEN '上走线' WHEN B.WNG_STYLE= 0 THEN '下走线' END AS WNG_STYLE_STYLE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_SHARE) AS IS_SHARE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.SHARE_UNIT_ID) AS SHARE_UNIT_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.AUDIT_FLOW_RESULT_ID) AS AUDIT_FLOW_RESULT_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.ENT_AUDIT_RESULT_ID) AS ENT_AUDIT_RESULT_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.PRODUCT_TYPE) AS PRODUCT_TYPE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_OIL_MACH_ROOM) AS IS_OIL_MACH_ROOM_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_HAVE_WALL) AS IS_HAVE_WALL_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.STRUCTURE_ID) AS STRUCTURE_ID_TEXT, \n\tres_entity.SF_GET_DESC_CHINA(B.VACANT_CABLE_SEAT) AS VACANT_CABLE_SEAT_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.STATION_ROAD_ID) AS STATION_ROAD_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.DEGREE_ARRIVAL_ID) AS DEGREE_ARRIVAL_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_ARRIVEL) AS IS_ARRIVEL_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_POWER) AS IS_POWER_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.INOUT_MODE) AS INOUT_MODE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_EXPAND_OIL_ROOM) AS IS_EXPAND_OIL_ROOM_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.SECURITY_ENVIRONMENT_ID) AS SECURITY_ENVIRONMENT_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.WNG_STYLE) AS WNG_STYLE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.ROOM_GRADE_ID) AS ROOM_GRADE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_MODE_ID) AS CHECK_MODE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.BUSINESS_ID) AS BUSINESS_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SUB_BUSINESS_ID) AS SUB_BUSINESS_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.PROP_ID) AS PROP_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.OLD_PROP_ID) AS OLD_PROP_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.PROPERTY_ID) AS PROPERTY_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_STATE_ID) AS ENTITY_STATE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_LOCKED_ID) AS IS_LOCKED_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_FAULT_ID) AS IS_FAULT_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OVERDUE) AS IS_OVERDUE_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.WARRANTY_GRADE_ID) AS WARRANTY_GRADE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OUTMAINTENANCE_ID) AS IS_OUTMAINTENANCE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ASSETS_RECEIVE_TYPE_ID) AS ASSETS_RECEIVE_TYPE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_CREATE_SOURCE_ID) AS ENTITY_CREATE_SOURCE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SOURCE_SYSTEM_ID) AS SOURCE_SYSTEM_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_RESULT_ID) AS CHECK_RESULT_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SERVICE_STATE_ID) AS SERVICE_STATE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_MONITOR_ID) AS IS_MONITOR_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.MONITOR_STYLE_ID) AS MONITOR_STYLE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_UPLOAD_PHOTO) AS IS_UPLOAD_PHOTO_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.STORAGE_STATE_ID) AS STORAGE_STATE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_STORAGE) AS IS_STORAGE_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.RES_FROM_PROJBUILDTYPE_ID) AS RES_FROM_PROJBUILDTYPE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SPLIT_MERGE_REASON_ID) AS SPLIT_MERGE_REASON_ID_TEXT,\n\tEE.SOURCE_RES_NO AS SOURCE_RES_NO_TEXT,\n\t(SELECT ENTITY_NAME FROM res_entity.ent_entity WHERE ENTITY_ID=EE.ROOM_ID and res_type_id='205' and delete_state='0') AS ROOM_ID_TEXT,\n\t(SELECT RES_TYPE FROM RES_SYS.PUB_DIC_RES_TYPE WHERE RES_TYPE_ID=EE.RES_TYPE_ID and delete_state='0') AS RES_TYPE_ID_TEXT,\n\t(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=EE.DEV_TYPE_ID and delete_state='0') AS DEV_TYPE_ID_TEXT,\n\t(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.DEV_MODEL_ID and delete_state='0') AS DEV_MODEL_ID_TEXT,\n\t(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.OLD_DEV_MODEL_ID and delete_state='0') AS OLD_DEV_MODEL_ID_TEXT,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MFR_ID and delete_state='0') AS MFR_ID_TEXT,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.DW_MFR_ID and delete_state='0') AS DW_MFR_ID_TEXT,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.OLD_DW_MFR_ID and delete_state='0') AS OLD_DW_MFR_ID_TEXT,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MNT_MFR_ID and delete_state='0') AS MNT_MFR_ID_TEXT,\n\tRES_ENTITY.SF_GET_STAFF_NAME(EE.MODIFY_OP) AS MODIFY_OP_TEXT,\n\tRES_ENTITY.SF_GET_STAFF_NAME(EE.CREATE_OP) AS CREATE_OP_TEXT,\n\tRES_ENTITY.SF_GET_STAFF_NAME(EE.CHECK_PERSON) AS CHECK_PERSON_TEXT,\n\tST.DISTRICT_PROVINCE_ID,\n\tST.DISTRICT_REGION_ID,\n\tST.DISTRICT_COUNTY_ID,\n\tST.STATION_NAME,\n\tST.STATION_NAME AS STATION_ID_TEXT,\n\tD.APP_REGION_ID,\n\t(SELECT REGION_NAME FROM res_entity.REG_MANAGE WHERE REGION_ID = D.APP_REGION_ID AND delete_state = '0') AS APP_REGION_ID_TEXT,\n\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) AS DISTRICT_PROVINCE_ID_TEXT,\n\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) AS DISTRICT_REGION_ID_TEXT,\n\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS DISTRICT_COUNTY_ID_TEXT,\n\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS REGION_ID_TEXT \nFROM RES_ENTITY.ENT_ENTITY EE \nLEFT JOIN RES_ENTITY.ENT_ROOM B ON B.ENTITY_ID = EE.ENTITY_ID\nLEFT JOIN RES_ENTITY.STA_STATION ST ON ST.STATION_CODE = EE.STATION_CODE  \nLEFT JOIN RES_ENTITY.STA_APP_INFO D ON ST.STATION_ID=D.STATION_ID\nWHERE EE.DELETE_STATE = '0' AND EE.RES_TYPE_ID=205  \nAND EE.STATION_CODE in  (select station_code  from res_entity.sta_biz_info  where  REGION_ID in (  select REGION_ID from res_entity.reg_manage  connect by prior REGION_ID = SUPER_REGION_ID and nvl(delete_state, '0') = '0' start with region_id in ('000102000000000000370100') ) ) \n)t where ROWNUM <= 10) where rn > 0;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select * from (select t.*,row_number()over(order by t.entity_id)as rn from(select/*+use_hash(ee sb rm dt em rt)*/ee.*,b.width,b.length,b.height,b.area,b.floor_no,b.is_oil_mach_room,b.is_have_wall,b.structure_id,b.address,b.airblast_style,b.vacant_cable_seat,b.contacts,b.link_tel,b.num_hole_feed,b.num_hole_feed_occu,b.num_hole_feed_free,b.light_protection_brand,b.light_protection_mode,b.fire_extinguisher_type,b.num_fire_extinguisher,b.station_road_id,b.degree_arrival_id,b.reason_unarrival,b.is_arrivel,b.is_power,b.reason_unpower,b.inout_mode,b.plate_drawings_id,b.decoration_drawings_id,b.design_drawings_id,b.ground_system_drawings_id,b.is_expand_oil_room,b.security_environment_id,b.generation_time,b.wng_style,b.room_grade_id,b.num_rmebay_total,b.num_rmebay_free,b.product_type,b.ent_audit_result_id,b.audit_flow_result_id,b.manual_ident_result_id,b.agent_mnt_contact,b.is_vr_fullscene_id,b.is_share,b.share_unit_id,b.integ_cabinet_space_num,b.integ_cabinet_ac_brand,b.integ_cabinet_ac_model_dc,b.integ_cabinet_ac_num_dc,b.integ_cabinet_ac_model,b.integ_cabinet_ac_num_dc_ac,b.integ_cabinet_space_num,ee.res_from_project_name,b.integ_cabinet_ac_num_id,res_entity.sf_get_desc_china(b.integ_cabinet_ac_num_id),b.integ_cabinet_ac_mfr_id,b.integ_cabinet_ac_model,mf1.mfr,res_entity.sf_get_desc_china(ee.time_to_overdue),eqt1.eqp_type,res_entity.sf_get_staff_name(b.agent_mnt_contact),case when b.is_vr_fullscene_id=1then'有'when b.is_vr_fullscene_id=0then'无'end,case when b.airblast_style=1then'下送风'when b.airblast_style=0then'上送风'end,case when b.wng_style=1then'上走线'when b.wng_style=0then'下走线'end,res_entity.sf_get_desc_china(b.is_share),res_entity.sf_get_desc_china(b.share_unit_id),res_entity.sf_get_desc_china(b.audit_flow_result_id),res_entity.sf_get_desc_china(b.ent_audit_result_id),res_entity.sf_get_desc_china(b.product_type),res_entity.sf_get_desc_china(b.is_oil_mach_room),res_entity.sf_get_desc_china(b.is_have_wall),res_entity.sf_get_desc_china(b.structure_id),res_entity.sf_get_desc_china(b.vacant_cable_seat),res_entity.sf_get_desc_china(b.station_road_id),res_entity.sf_get_desc_china(b.degree_arrival_id),res_entity.sf_get_desc_china(b.is_arrivel),res_entity.sf_get_desc_china(b.is_power),res_entity.sf_get_desc_china(b.inout_mode),res_entity.sf_get_desc_china(b.is_expand_oil_room),res_entity.sf_get_desc_china(b.security_environment_id),res_entity.sf_get_desc_china(b.wng_style),res_entity.sf_get_desc_china(b.room_grade_id),res_entity.sf_get_desc_china(ee.check_mode_id),res_entity.sf_get_desc_china(ee.business_id),res_entity.sf_get_desc_china(ee.sub_business_id),res_entity.sf_get_desc_china(ee.prop_id),res_entity.sf_get_desc_china(ee.old_prop_id),res_entity.sf_get_desc_china(ee.property_id),res_entity.sf_get_desc_china(ee.entity_state_id),res_entity.sf_get_desc_china(ee.is_locked_id),res_entity.sf_get_desc_china(ee.is_fault_id),res_entity.sf_get_desc_china(ee.is_overdue),res_entity.sf_get_desc_china(ee.warranty_grade_id),res_entity.sf_get_desc_china(ee.is_outmaintenance_id),res_entity.sf_get_desc_china(ee.assets_receive_type_id),res_entity.sf_get_desc_china(ee.entity_create_source_id),res_entity.sf_get_desc_china(ee.source_system_id),res_entity.sf_get_desc_china(ee.check_result_id),res_entity.sf_get_desc_china(ee.service_state_id),res_entity.sf_get_desc_china(ee.is_monitor_id),res_entity.sf_get_desc_china(ee.monitor_style_id),res_entity.sf_get_desc_china(ee.is_upload_photo),res_entity.sf_get_desc_china(ee.storage_state_id),res_entity.sf_get_desc_china(ee.is_storage),res_entity.sf_get_desc_china(ee.res_from_projbuildtype_id),res_entity.sf_get_desc_china(ee.split_merge_reason_id),ee.source_res_no,(select entity_name from res_entity.ent_entity where entity_id=ee.room_id and res_type_id='205'and delete_state='0'),rt.res_type,eqt2.eqp_type,em1.eqp_model,em2.eqp_model,mf2.mfr,mf3.mfr,mf4.mfr,mf5.mfr,res_entity.sf_get_staff_name(ee.modify_op),res_entity.sf_get_staff_name(ee.create_op),res_entity.sf_get_staff_name(ee.check_person),st.district_province_id,st.district_region_id,st.district_county_id,st.station_name,st.station_name,d.app_region_id,(select region_name from res_entity.reg_manage where region_id=d.app_region_id and delete_state='0'),res_entity.sf_get_district_name(st.district_province_id),res_entity.sf_get_district_name(st.district_region_id),res_entity.sf_get_district_name(st.district_county_id),res_entity.sf_get_district_name(st.district_province_id)||res_entity.sf_get_district_name(st.district_region_id)||res_entity.sf_get_district_name(st.district_county_id)from res_entity.ent_entity ee left join res_entity.ent_room b on b.entity_id=ee.entity_id left join res_entity.sta_station st on st.station_code=ee.station_code left join res_entity.sta_app_info d on st.station_id=d.station_id left join res_sys.pub_mfr mf1 on mf1.mfr_id=b.integ_cabinet_ac_mfr_id and mf1.delete_state='0'left join res_sys.pub_dic_eqp_type eqt1 on eqt1.eqp_type_id=b.manual_ident_result_id and eqt1.delete_state='0'left join res_sys.pub_dic_res_type rt on rt.res_type_id=ee.res_type_id and rt.delete_state='0'left join res_sys.pub_dic_eqp_type eqt2 on eqt2.eqp_type_id=ee.dev_type_id and eqt2.delete_state='0'left join res_sys.pub_rme_eqp_model em1 on em1.eqp_model_id=ee.dev_model_id and em1.delete_state='0'left join res_sys.pub_rme_eqp_model em2 on em2.eqp_model_id=ee.old_dev_model_id and em2.delete_state='0'left join res_sys.pub_mfr mf2 on mf2.mfr_id=ee.mfr_id and mf2.delete_state='0'left join res_sys.pub_mfr mf3 on mf3.mfr_id=ee.dw_mfr_id and mf3.delete_state='0'left join res_sys.pub_mfr mf4 on mf4.mfr_id=ee.old_dw_mfr_id and mf4.delete_state='0'left join res_sys.pub_mfr mf5 on mf5.mfr_id=ee.mnt_mfr_id and mf5.delete_state='0'where ee.delete_state='0'and ee.res_type_id=205 and ee.station_code in(select distinct station_code from res_entity.sta_biz_info where region_id in(select region_id from res_entity.reg_manage where delete_state='0'connect by prior region_id=super_region_id start with region_id in('000102000000000000370100'))))t where rn<=10"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "41",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"41\", \"db_type\": \"postgresql\", \"description\": \"该SQL旨在统计四个不同时间窗口内（过去7、13、25、2小时），各行政区划的'zdjs'指标最大值。存在显著的性能问题：1. **冗余列投影**：最内层查询选取了`zdbh`、`zxjs`等后续聚合不需要的字段，增加了不必要的I/O和内存开销。2. **无效排序**：四个作为JOIN源表的子查询（Derived Table）内部均包含`ORDER BY \\\"zdjs\\\" desc`但无`LIMIT`，这种排序在关联操作中是无意义的，且可能触发额外的排序操作。3. **多层嵌套**：存在冗余的子查询层级，导致生成不必要的临时结果集。优化方向包括移除无效排序、裁剪非必要列以及子查询扁平化。\", \"create_table_statements\": [\"CREATE SCHEMA IF NOT EXISTS WHYJ_SJZL;\", \"CREATE TABLE WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" (\\\"xzqhdm\\\" VARCHAR(50), \\\"zdbh\\\" VARCHAR(50), \\\"zdjs\\\" NUMERIC, \\\"zxjs\\\" NUMERIC, \\\"gxsj\\\" TIMESTAMP);\", \"CREATE INDEX idx_ds_dm_tqyj_jssk_gxsj ON WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\"(\\\"gxsj\\\");\", \"CREATE INDEX idx_ds_dm_tqyj_jssk_xzqhdm ON WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\"(\\\"xzqhdm\\\");\"], \"sql\": \"select \\\"a\\\".\\\"qh\\\" as \\\"qhmc\\\",\\\"d\\\".\\\"zdjs\\\" as \\\"1xszdjs\\\",\\\"a\\\".\\\"zdjs\\\" as \\\"6xszdjs\\\",\\\"b\\\".\\\"zdjs\\\" as \\\"12xszdjs\\\",\\\"c\\\".\\\"zdjs\\\" as \\\"24xszdjs\\\" from\\n(select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '7' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"a\\\" \\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '13' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"b\\\" on \\\"a\\\".\\\"qh\\\" = \\\"b\\\".\\\"qh\\\" \\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '25' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"c\\\" on \\\"a\\\".\\\"qh\\\" = \\\"c\\\".\\\"qh\\\"\\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '2' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"d\\\" on \\\"a\\\".\\\"qh\\\" = \\\"d\\\".\\\"qh\\\"\\norder by \\\"6xszdjs\\\" desc\", \"explain\": \"Sort  (cost=10890.12..10890.62 rows=200 width=160)\\n  Sort Key: a.zdjs DESC\\n  ->  Hash Left Join  (cost=8167.58..10882.48 rows=200 width=160)\\n  Hash Cond: (a.qh = d.qh)\\n  ->  Hash Left Join  (cost=5445.05..8159.95 rows=200 width=128)\\n  Hash Cond: (a.qh = c.qh)\\n  ->  Hash Left Join  (cost=2722.53..5437.43 rows=200 width=96)\\n  Hash Cond: (a.qh = b.qh)\\n  ->  Subquery Scan on a  (cost=0.00..2714.90 rows=200 width=64)\\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\\n  Sort Key: (max(sum(ds_dm_tqyj_jssk.zdjs))) DESC\\n  ->  HashAggregate  (cost=2704.40..2706.90 rows=200 width=42)\\n  Group Key: CASE substr(ds_dm_tqyj_jssk.xzqhdm, 1, 6) ... END\\n  ->  HashAggregate  (cost=2500.00..2600.00 rows=2000 width=18)\\n  Group Key: ds_dm_tqyj_jssk.xzqhdm\\n  ->  Seq Scan on ds_dm_tqyj_jssk  (cost=0.00..2200.00 rows=100000 width=58)\\n  Filter: (gxsj >= (now() - '07:00:00'::interval))\\n  ->  Hash  (cost=2714.90..2714.90 rows=200 width=64)\\n  ->  Subquery Scan on b  (cost=0.00..2714.90 rows=200 width=64)\\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\\n  ->  HashAggregate ...\\n  ->  Seq Scan on ds_dm_tqyj_jssk ...\\n  ->  Hash ...\\n  ->  Subquery Scan on c ...\\n  ->  Hash ...\\n  ->  Subquery Scan on d ...\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推消除子查询中多余的列，精简最内层查询的select列表，减少I/O和内存开销。优化后最内层查询仅保留分组聚合必需的xzqhdm列和聚合计算的zdjs列，删除zdbh、zxjs、gxsj三个冗余列。预计可显著降低数据扫描量和临时表内存占用。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过消除冗余的子查询层，减少临时表生成和内存占用。将每个子查询的过滤与分组合并后，数据库优化器能更高效地执行索引扫描和聚合计算，避免多余的数据中转。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"没有LIMIT的子查询排序消除,消除四个作为JOIN源表的子查询中的冗余排序操作，这些子查询无LIMIT且排序在JOIN后失效\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SCHEMA IF NOT EXISTS WHYJ_SJZL;\nCREATE TABLE WHYJ_SJZL.\"ds_dm_tqyj_jssk\" (\"xzqhdm\" VARCHAR(50), \"zdbh\" VARCHAR(50), \"zdjs\" NUMERIC, \"zxjs\" NUMERIC, \"gxsj\" TIMESTAMP);\nCREATE INDEX idx_ds_dm_tqyj_jssk_gxsj ON WHYJ_SJZL.\"ds_dm_tqyj_jssk\"(\"gxsj\");\nCREATE INDEX idx_ds_dm_tqyj_jssk_xzqhdm ON WHYJ_SJZL.\"ds_dm_tqyj_jssk\"(\"xzqhdm\");\n\n## Explain Output in JSON:\nSort  (cost=10890.12..10890.62 rows=200 width=160)\n  Sort Key: a.zdjs DESC\n  ->  Hash Left Join  (cost=8167.58..10882.48 rows=200 width=160)\n  Hash Cond: (a.qh = d.qh)\n  ->  Hash Left Join  (cost=5445.05..8159.95 rows=200 width=128)\n  Hash Cond: (a.qh = c.qh)\n  ->  Hash Left Join  (cost=2722.53..5437.43 rows=200 width=96)\n  Hash Cond: (a.qh = b.qh)\n  ->  Subquery Scan on a  (cost=0.00..2714.90 rows=200 width=64)\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\n  Sort Key: (max(sum(ds_dm_tqyj_jssk.zdjs))) DESC\n  ->  HashAggregate  (cost=2704.40..2706.90 rows=200 width=42)\n  Group Key: CASE substr(ds_dm_tqyj_jssk.xzqhdm, 1, 6) ... END\n  ->  HashAggregate  (cost=2500.00..2600.00 rows=2000 width=18)\n  Group Key: ds_dm_tqyj_jssk.xzqhdm\n  ->  Seq Scan on ds_dm_tqyj_jssk  (cost=0.00..2200.00 rows=100000 width=58)\n  Filter: (gxsj >= (now() - '07:00:00'::interval))\n  ->  Hash  (cost=2714.90..2714.90 rows=200 width=64)\n  ->  Subquery Scan on b  (cost=0.00..2714.90 rows=200 width=64)\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\n  ->  HashAggregate ...\n  ->  Seq Scan on ds_dm_tqyj_jssk ...\n  ->  Hash ...\n  ->  Subquery Scan on c ...\n  ->  Hash ...\n  ->  Subquery Scan on d ...\n\n## Original SQL:\nselect \"a\".\"qh\" as \"qhmc\",\"d\".\"zdjs\" as \"1xszdjs\",\"a\".\"zdjs\" as \"6xszdjs\",\"b\".\"zdjs\" as \"12xszdjs\",\"c\".\"zdjs\" as \"24xszdjs\" from\n(select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '7' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"a\" \nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '13' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"b\" on \"a\".\"qh\" = \"b\".\"qh\" \nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '25' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"c\" on \"a\".\"qh\" = \"c\".\"qh\"\nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '2' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"d\" on \"a\".\"qh\" = \"d\".\"qh\"\norder by \"6xszdjs\" desc\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH district_map AS (SELECT '420102' as \"code\", '江岸区' as \"name\" UNION ALL SELECT '420103', '江汉区' UNION ALL SELECT '420104', '硚口区' UNION ALL SELECT '420105', '汉阳区' UNION ALL SELECT '420106', '武昌区' UNION ALL SELECT '420107', '青山区' UNION ALL SELECT '420111', '洪山区' UNION ALL SELECT '420112', '东西湖区' UNION ALL SELECT '420113', '汉南区' UNION ALL SELECT '420114', '蔡甸区' UNION ALL SELECT '420115', '江夏区' UNION ALL SELECT '420116', '黄陂区' UNION ALL SELECT '420117', '新洲区'), window_sums AS (SELECT \"xzqhdm\", SUBSTR(\"xzqhdm\", 1, 6) as \"district_code\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '7' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_7h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '13' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_13h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '25' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_25h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '2' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_2h\" FROM WHYJ_SJZL.\"ds_dm_tqyj_jssk\" WHERE \"gxsj\" >= NOW() - INTERVAL '25' HOUR GROUP BY \"xzqhdm\", SUBSTR(\"xzqhdm\", 1, 6)), district_results AS (SELECT d.\"name\" as \"qh\", MAX(\"sum_7h\") as \"max_7h\", MAX(\"sum_13h\") as \"max_13h\", MAX(\"sum_25h\") as \"max_25h\", MAX(\"sum_2h\") as \"max_2h\" FROM window_sums ws JOIN district_map d ON ws.\"district_code\" = d.\"code\" GROUP BY d.\"name\") SELECT \"qh\" as \"qhmc\", \"max_2h\" as \"1xszdjs\", \"max_7h\" as \"6xszdjs\", \"max_13h\" as \"12xszdjs\", \"max_25h\" as \"24xszdjs\" FROM district_results ORDER BY \"6xszdjs\" DESC;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "41",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"41\", \"db_type\": \"postgresql\", \"description\": \"该SQL旨在统计四个不同时间窗口内（过去7、13、25、2小时），各行政区划的'zdjs'指标最大值。存在显著的性能问题：1. **冗余列投影**：最内层查询选取了`zdbh`、`zxjs`等后续聚合不需要的字段，增加了不必要的I/O和内存开销。2. **无效排序**：四个作为JOIN源表的子查询（Derived Table）内部均包含`ORDER BY \\\"zdjs\\\" desc`但无`LIMIT`，这种排序在关联操作中是无意义的，且可能触发额外的排序操作。3. **多层嵌套**：存在冗余的子查询层级，导致生成不必要的临时结果集。优化方向包括移除无效排序、裁剪非必要列以及子查询扁平化。\", \"create_table_statements\": [\"CREATE SCHEMA IF NOT EXISTS WHYJ_SJZL;\", \"CREATE TABLE WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" (\\\"xzqhdm\\\" VARCHAR(50), \\\"zdbh\\\" VARCHAR(50), \\\"zdjs\\\" NUMERIC, \\\"zxjs\\\" NUMERIC, \\\"gxsj\\\" TIMESTAMP);\", \"CREATE INDEX idx_ds_dm_tqyj_jssk_gxsj ON WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\"(\\\"gxsj\\\");\", \"CREATE INDEX idx_ds_dm_tqyj_jssk_xzqhdm ON WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\"(\\\"xzqhdm\\\");\"], \"sql\": \"select \\\"a\\\".\\\"qh\\\" as \\\"qhmc\\\",\\\"d\\\".\\\"zdjs\\\" as \\\"1xszdjs\\\",\\\"a\\\".\\\"zdjs\\\" as \\\"6xszdjs\\\",\\\"b\\\".\\\"zdjs\\\" as \\\"12xszdjs\\\",\\\"c\\\".\\\"zdjs\\\" as \\\"24xszdjs\\\" from\\n(select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '7' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"a\\\" \\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '13' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"b\\\" on \\\"a\\\".\\\"qh\\\" = \\\"b\\\".\\\"qh\\\" \\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '25' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"c\\\" on \\\"a\\\".\\\"qh\\\" = \\\"c\\\".\\\"qh\\\"\\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '2' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"d\\\" on \\\"a\\\".\\\"qh\\\" = \\\"d\\\".\\\"qh\\\"\\norder by \\\"6xszdjs\\\" desc\", \"explain\": \"Sort  (cost=10890.12..10890.62 rows=200 width=160)\\n  Sort Key: a.zdjs DESC\\n  ->  Hash Left Join  (cost=8167.58..10882.48 rows=200 width=160)\\n  Hash Cond: (a.qh = d.qh)\\n  ->  Hash Left Join  (cost=5445.05..8159.95 rows=200 width=128)\\n  Hash Cond: (a.qh = c.qh)\\n  ->  Hash Left Join  (cost=2722.53..5437.43 rows=200 width=96)\\n  Hash Cond: (a.qh = b.qh)\\n  ->  Subquery Scan on a  (cost=0.00..2714.90 rows=200 width=64)\\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\\n  Sort Key: (max(sum(ds_dm_tqyj_jssk.zdjs))) DESC\\n  ->  HashAggregate  (cost=2704.40..2706.90 rows=200 width=42)\\n  Group Key: CASE substr(ds_dm_tqyj_jssk.xzqhdm, 1, 6) ... END\\n  ->  HashAggregate  (cost=2500.00..2600.00 rows=2000 width=18)\\n  Group Key: ds_dm_tqyj_jssk.xzqhdm\\n  ->  Seq Scan on ds_dm_tqyj_jssk  (cost=0.00..2200.00 rows=100000 width=58)\\n  Filter: (gxsj >= (now() - '07:00:00'::interval))\\n  ->  Hash  (cost=2714.90..2714.90 rows=200 width=64)\\n  ->  Subquery Scan on b  (cost=0.00..2714.90 rows=200 width=64)\\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\\n  ->  HashAggregate ...\\n  ->  Seq Scan on ds_dm_tqyj_jssk ...\\n  ->  Hash ...\\n  ->  Subquery Scan on c ...\\n  ->  Hash ...\\n  ->  Subquery Scan on d ...\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推消除子查询中多余的列，精简最内层查询的select列表，减少I/O和内存开销。优化后最内层查询仅保留分组聚合必需的xzqhdm列和聚合计算的zdjs列，删除zdbh、zxjs、gxsj三个冗余列。预计可显著降低数据扫描量和临时表内存占用。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过消除冗余的子查询层，减少临时表生成和内存占用。将每个子查询的过滤与分组合并后，数据库优化器能更高效地执行索引扫描和聚合计算，避免多余的数据中转。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"没有LIMIT的子查询排序消除,消除四个作为JOIN源表的子查询中的冗余排序操作，这些子查询无LIMIT且排序在JOIN后失效\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SCHEMA IF NOT EXISTS WHYJ_SJZL;\nCREATE TABLE WHYJ_SJZL.\"ds_dm_tqyj_jssk\" (\"xzqhdm\" VARCHAR(50), \"zdbh\" VARCHAR(50), \"zdjs\" NUMERIC, \"zxjs\" NUMERIC, \"gxsj\" TIMESTAMP);\nCREATE INDEX idx_ds_dm_tqyj_jssk_gxsj ON WHYJ_SJZL.\"ds_dm_tqyj_jssk\"(\"gxsj\");\nCREATE INDEX idx_ds_dm_tqyj_jssk_xzqhdm ON WHYJ_SJZL.\"ds_dm_tqyj_jssk\"(\"xzqhdm\");\n\n## Explain Output in JSON:\nSort  (cost=10890.12..10890.62 rows=200 width=160)\n  Sort Key: a.zdjs DESC\n  ->  Hash Left Join  (cost=8167.58..10882.48 rows=200 width=160)\n  Hash Cond: (a.qh = d.qh)\n  ->  Hash Left Join  (cost=5445.05..8159.95 rows=200 width=128)\n  Hash Cond: (a.qh = c.qh)\n  ->  Hash Left Join  (cost=2722.53..5437.43 rows=200 width=96)\n  Hash Cond: (a.qh = b.qh)\n  ->  Subquery Scan on a  (cost=0.00..2714.90 rows=200 width=64)\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\n  Sort Key: (max(sum(ds_dm_tqyj_jssk.zdjs))) DESC\n  ->  HashAggregate  (cost=2704.40..2706.90 rows=200 width=42)\n  Group Key: CASE substr(ds_dm_tqyj_jssk.xzqhdm, 1, 6) ... END\n  ->  HashAggregate  (cost=2500.00..2600.00 rows=2000 width=18)\n  Group Key: ds_dm_tqyj_jssk.xzqhdm\n  ->  Seq Scan on ds_dm_tqyj_jssk  (cost=0.00..2200.00 rows=100000 width=58)\n  Filter: (gxsj >= (now() - '07:00:00'::interval))\n  ->  Hash  (cost=2714.90..2714.90 rows=200 width=64)\n  ->  Subquery Scan on b  (cost=0.00..2714.90 rows=200 width=64)\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\n  ->  HashAggregate ...\n  ->  Seq Scan on ds_dm_tqyj_jssk ...\n  ->  Hash ...\n  ->  Subquery Scan on c ...\n  ->  Hash ...\n  ->  Subquery Scan on d ...\n\n## Original SQL:\nselect \"a\".\"qh\" as \"qhmc\",\"d\".\"zdjs\" as \"1xszdjs\",\"a\".\"zdjs\" as \"6xszdjs\",\"b\".\"zdjs\" as \"12xszdjs\",\"c\".\"zdjs\" as \"24xszdjs\" from\n(select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '7' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"a\" \nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '13' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"b\" on \"a\".\"qh\" = \"b\".\"qh\" \nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '25' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"c\" on \"a\".\"qh\" = \"c\".\"qh\"\nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '2' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"d\" on \"a\".\"qh\" = \"d\".\"qh\"\norder by \"6xszdjs\" desc\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH district_map AS (SELECT '420102' as \"code\", '江岸区' as \"name\" UNION ALL SELECT '420103', '江汉区' UNION ALL SELECT '420104', '硚口区' UNION ALL SELECT '420105', '汉阳区' UNION ALL SELECT '420106', '武昌区' UNION ALL SELECT '420107', '青山区' UNION ALL SELECT '420111', '洪山区' UNION ALL SELECT '420112', '东西湖区' UNION ALL SELECT '420113', '汉南区' UNION ALL SELECT '420114', '蔡甸区' UNION ALL SELECT '420115', '江夏区' UNION ALL SELECT '420116', '黄陂区' UNION ALL SELECT '420117', '新洲区'), window_sums AS (SELECT \"xzqhdm\", SUBSTR(\"xzqhdm\", 1, 6) as \"district_code\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '7' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_7h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '13' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_13h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '25' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_25h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '2' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_2h\" FROM WHYJ_SJZL.\"ds_dm_tqyj_jssk\" WHERE \"gxsj\" >= NOW() - INTERVAL '25' HOUR GROUP BY \"xzqhdm\", SUBSTR(\"xzqhdm\", 1, 6)), district_results AS (SELECT d.\"name\" as \"qh\", MAX(\"sum_7h\") as \"max_7h\", MAX(\"sum_13h\") as \"max_13h\", MAX(\"sum_25h\") as \"max_25h\", MAX(\"sum_2h\") as \"max_2h\" FROM window_sums ws JOIN district_map d ON ws.\"district_code\" = d.\"code\" GROUP BY d.\"name\") SELECT \"qh\" as \"qhmc\", \"max_2h\" as \"1xszdjs\", \"max_7h\" as \"6xszdjs\", \"max_13h\" as \"12xszdjs\", \"max_25h\" as \"24xszdjs\" FROM district_results ORDER BY \"6xszdjs\" DESC;"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "41",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"41\", \"db_type\": \"postgresql\", \"description\": \"该SQL旨在统计四个不同时间窗口内（过去7、13、25、2小时），各行政区划的'zdjs'指标最大值。存在显著的性能问题：1. **冗余列投影**：最内层查询选取了`zdbh`、`zxjs`等后续聚合不需要的字段，增加了不必要的I/O和内存开销。2. **无效排序**：四个作为JOIN源表的子查询（Derived Table）内部均包含`ORDER BY \\\"zdjs\\\" desc`但无`LIMIT`，这种排序在关联操作中是无意义的，且可能触发额外的排序操作。3. **多层嵌套**：存在冗余的子查询层级，导致生成不必要的临时结果集。优化方向包括移除无效排序、裁剪非必要列以及子查询扁平化。\", \"create_table_statements\": [\"CREATE SCHEMA IF NOT EXISTS WHYJ_SJZL;\", \"CREATE TABLE WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" (\\\"xzqhdm\\\" VARCHAR(50), \\\"zdbh\\\" VARCHAR(50), \\\"zdjs\\\" NUMERIC, \\\"zxjs\\\" NUMERIC, \\\"gxsj\\\" TIMESTAMP);\", \"CREATE INDEX idx_ds_dm_tqyj_jssk_gxsj ON WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\"(\\\"gxsj\\\");\", \"CREATE INDEX idx_ds_dm_tqyj_jssk_xzqhdm ON WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\"(\\\"xzqhdm\\\");\"], \"sql\": \"select \\\"a\\\".\\\"qh\\\" as \\\"qhmc\\\",\\\"d\\\".\\\"zdjs\\\" as \\\"1xszdjs\\\",\\\"a\\\".\\\"zdjs\\\" as \\\"6xszdjs\\\",\\\"b\\\".\\\"zdjs\\\" as \\\"12xszdjs\\\",\\\"c\\\".\\\"zdjs\\\" as \\\"24xszdjs\\\" from\\n(select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '7' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"a\\\" \\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '13' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"b\\\" on \\\"a\\\".\\\"qh\\\" = \\\"b\\\".\\\"qh\\\" \\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '25' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"c\\\" on \\\"a\\\".\\\"qh\\\" = \\\"c\\\".\\\"qh\\\"\\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '2' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"d\\\" on \\\"a\\\".\\\"qh\\\" = \\\"d\\\".\\\"qh\\\"\\norder by \\\"6xszdjs\\\" desc\", \"explain\": \"Sort  (cost=10890.12..10890.62 rows=200 width=160)\\n  Sort Key: a.zdjs DESC\\n  ->  Hash Left Join  (cost=8167.58..10882.48 rows=200 width=160)\\n  Hash Cond: (a.qh = d.qh)\\n  ->  Hash Left Join  (cost=5445.05..8159.95 rows=200 width=128)\\n  Hash Cond: (a.qh = c.qh)\\n  ->  Hash Left Join  (cost=2722.53..5437.43 rows=200 width=96)\\n  Hash Cond: (a.qh = b.qh)\\n  ->  Subquery Scan on a  (cost=0.00..2714.90 rows=200 width=64)\\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\\n  Sort Key: (max(sum(ds_dm_tqyj_jssk.zdjs))) DESC\\n  ->  HashAggregate  (cost=2704.40..2706.90 rows=200 width=42)\\n  Group Key: CASE substr(ds_dm_tqyj_jssk.xzqhdm, 1, 6) ... END\\n  ->  HashAggregate  (cost=2500.00..2600.00 rows=2000 width=18)\\n  Group Key: ds_dm_tqyj_jssk.xzqhdm\\n  ->  Seq Scan on ds_dm_tqyj_jssk  (cost=0.00..2200.00 rows=100000 width=58)\\n  Filter: (gxsj >= (now() - '07:00:00'::interval))\\n  ->  Hash  (cost=2714.90..2714.90 rows=200 width=64)\\n  ->  Subquery Scan on b  (cost=0.00..2714.90 rows=200 width=64)\\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\\n  ->  HashAggregate ...\\n  ->  Seq Scan on ds_dm_tqyj_jssk ...\\n  ->  Hash ...\\n  ->  Subquery Scan on c ...\\n  ->  Hash ...\\n  ->  Subquery Scan on d ...\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推消除子查询中多余的列，精简最内层查询的select列表，减少I/O和内存开销。优化后最内层查询仅保留分组聚合必需的xzqhdm列和聚合计算的zdjs列，删除zdbh、zxjs、gxsj三个冗余列。预计可显著降低数据扫描量和临时表内存占用。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过消除冗余的子查询层，减少临时表生成和内存占用。将每个子查询的过滤与分组合并后，数据库优化器能更高效地执行索引扫描和聚合计算，避免多余的数据中转。\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"没有LIMIT的子查询排序消除,消除四个作为JOIN源表的子查询中的冗余排序操作，这些子查询无LIMIT且排序在JOIN后失效\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SCHEMA IF NOT EXISTS WHYJ_SJZL;\nCREATE TABLE WHYJ_SJZL.\"ds_dm_tqyj_jssk\" (\"xzqhdm\" VARCHAR(50), \"zdbh\" VARCHAR(50), \"zdjs\" NUMERIC, \"zxjs\" NUMERIC, \"gxsj\" TIMESTAMP);\nCREATE INDEX idx_ds_dm_tqyj_jssk_gxsj ON WHYJ_SJZL.\"ds_dm_tqyj_jssk\"(\"gxsj\");\nCREATE INDEX idx_ds_dm_tqyj_jssk_xzqhdm ON WHYJ_SJZL.\"ds_dm_tqyj_jssk\"(\"xzqhdm\");\n\n## Explain Output in JSON:\nSort  (cost=10890.12..10890.62 rows=200 width=160)\n  Sort Key: a.zdjs DESC\n  ->  Hash Left Join  (cost=8167.58..10882.48 rows=200 width=160)\n  Hash Cond: (a.qh = d.qh)\n  ->  Hash Left Join  (cost=5445.05..8159.95 rows=200 width=128)\n  Hash Cond: (a.qh = c.qh)\n  ->  Hash Left Join  (cost=2722.53..5437.43 rows=200 width=96)\n  Hash Cond: (a.qh = b.qh)\n  ->  Subquery Scan on a  (cost=0.00..2714.90 rows=200 width=64)\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\n  Sort Key: (max(sum(ds_dm_tqyj_jssk.zdjs))) DESC\n  ->  HashAggregate  (cost=2704.40..2706.90 rows=200 width=42)\n  Group Key: CASE substr(ds_dm_tqyj_jssk.xzqhdm, 1, 6) ... END\n  ->  HashAggregate  (cost=2500.00..2600.00 rows=2000 width=18)\n  Group Key: ds_dm_tqyj_jssk.xzqhdm\n  ->  Seq Scan on ds_dm_tqyj_jssk  (cost=0.00..2200.00 rows=100000 width=58)\n  Filter: (gxsj >= (now() - '07:00:00'::interval))\n  ->  Hash  (cost=2714.90..2714.90 rows=200 width=64)\n  ->  Subquery Scan on b  (cost=0.00..2714.90 rows=200 width=64)\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\n  ->  HashAggregate ...\n  ->  Seq Scan on ds_dm_tqyj_jssk ...\n  ->  Hash ...\n  ->  Subquery Scan on c ...\n  ->  Hash ...\n  ->  Subquery Scan on d ...\n\n## Original SQL:\nselect \"a\".\"qh\" as \"qhmc\",\"d\".\"zdjs\" as \"1xszdjs\",\"a\".\"zdjs\" as \"6xszdjs\",\"b\".\"zdjs\" as \"12xszdjs\",\"c\".\"zdjs\" as \"24xszdjs\" from\n(select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '7' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"a\" \nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '13' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"b\" on \"a\".\"qh\" = \"b\".\"qh\" \nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '25' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"c\" on \"a\".\"qh\" = \"c\".\"qh\"\nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '2' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"d\" on \"a\".\"qh\" = \"d\".\"qh\"\norder by \"6xszdjs\" desc\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH district_map AS (SELECT '420102' as \"code\", '江岸区' as \"name\" UNION ALL SELECT '420103', '江汉区' UNION ALL SELECT '420104', '硚口区' UNION ALL SELECT '420105', '汉阳区' UNION ALL SELECT '420106', '武昌区' UNION ALL SELECT '420107', '青山区' UNION ALL SELECT '420111', '洪山区' UNION ALL SELECT '420112', '东西湖区' UNION ALL SELECT '420113', '汉南区' UNION ALL SELECT '420114', '蔡甸区' UNION ALL SELECT '420115', '江夏区' UNION ALL SELECT '420116', '黄陂区' UNION ALL SELECT '420117', '新洲区'), window_sums AS (SELECT \"xzqhdm\", SUBSTR(\"xzqhdm\", 1, 6) as \"district_code\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '7' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_7h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '13' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_13h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '25' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_25h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '2' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_2h\" FROM WHYJ_SJZL.\"ds_dm_tqyj_jssk\" WHERE \"gxsj\" >= NOW() - INTERVAL '25' HOUR GROUP BY \"xzqhdm\", SUBSTR(\"xzqhdm\", 1, 6)), district_results AS (SELECT d.\"name\" as \"qh\", MAX(\"sum_7h\") as \"max_7h\", MAX(\"sum_13h\") as \"max_13h\", MAX(\"sum_25h\") as \"max_25h\", MAX(\"sum_2h\") as \"max_2h\" FROM window_sums ws JOIN district_map d ON ws.\"district_code\" = d.\"code\" GROUP BY d.\"name\") SELECT \"qh\" as \"qhmc\", \"max_2h\" as \"1xszdjs\", \"max_7h\" as \"6xszdjs\", \"max_13h\" as \"12xszdjs\", \"max_25h\" as \"24xszdjs\" FROM district_results ORDER BY \"6xszdjs\" DESC;"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "42",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"42\", \"db_type\": \"mysql\", \"description\": \"该SQL查询存在显著的性能瓶颈，主要体现为：1. **谓词未下推**：核心过滤条件`CUSTOMER_ID`位于最外层，导致内部巨大的UNION ALL派生表（由四部分组成）必须先全量物化及聚合，无法利用索引提前过滤数据。2. **隐式内连接**：对LEFT JOIN表`t_dgm_send_info`的字段进行了`SEND_STATE='70'`的等值过滤，语义上已变为内连接，但写法可能误导优化器或导致低效的执行路径。3. **冗余的聚合与排序**：外层的`GROUP BY temp.MIXED_NO`在业务逻辑上可能是冗余的（子查询已确保唯一性或JOIN关系未导致膨胀），且`HAVING`子句中包含了本应在WHERE中过滤的非聚合条件，导致了不必要的临时表和排序开销。4. **宽表投影**：派生表输出了大量后续未使用的列，增加了内存和I/O负担。\", \"create_table_statements\": [\"CREATE DATABASE IF NOT EXISTS zjjs_mpm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_rmm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_qdm;\", \"CREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\", \"CREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\", \"CREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\", \"CREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\", \"CREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\", \"CREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\", \"CREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\", \"CREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\", \"CREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\", \"CREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\", \"CREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\"], \"sql\": \"SELECT\\n  temp.*,\\n  t_rmm_store.STORE_NAME,\\n  t_rmm_location.LOCATION_NAME,\\n  t_qdm_standard.STANDARD_NAME,\\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\\n  ) AS `SEND_NUMBER`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\\n  ) AS `RETURN_NUMBER`\\nFROM\\n  t_dgm_send_info_detail\\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\\n  LEFT JOIN (\\n  SELECT\\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\\n   IFNULL(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   ) AS MIXED_NO,\\n   '30' AS SPOT_TYPE,\\n   v_pre_product_material.MATERIAL_NO,\\n   v_pre_product_material.PACKAGE_NO,\\n   v_pre_product_material.PSR_ID,\\n   v_pre_product_material.CUSTOMER_ID,\\n   v_pre_product_material.CONTRACT_ID,\\n   v_pre_product_material.CONTRACT_NO,\\n   v_pre_product_material.NUMBER,\\n   v_pre_product_material.NET_WEIGHT,\\n   v_pre_product_material.GROSS_WT,\\n   v_pre_product_material.STORE_ID,\\n   v_pre_product_material.LOCATION_ID,\\n   v_pre_product_material.STANDARD_ID,\\n   v_pre_product_material.STEEL_GRADE,\\n   v_pre_product_material.SURFACE_GROUP_DESC,\\n   v_pre_product_material.CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (v_pre_product_material.LENGTH IS NOT NULL)\\n  AND (v_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*',\\n  v_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   SUM(\\n  IF (\\n  t_sam_contract_detail.BUY_UNIT = '10',\\n  -- 单位测试\\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\\n  )\\n   ) AS `PRICE`\\n  FROM\\n   v_pre_product_material\\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\\n  WHERE\\n   v_pre_product_material.IS_ISSUED = '1'\\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\\n   AND v_pre_product_material.NI36_TAG = '0'\\n   AND v_pre_product_material.MATERIAL_STATE != '110'\\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\\n   AND NOT EXISTS (\\n  SELECT\\n  1\\n  FROM\\n  v_pre_product_material v2\\n  WHERE\\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\\n  GROUP BY\\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\\n  HAVING\\n  SUM(\\n   CASE\\n  WHEN IS_ISSUED != '1' THEN 1\\n  ELSE 0\\n   END\\n  ) > 0\\n   )\\n  GROUP BY\\n   COALESCE(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   )\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '10' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   NULL AS `PACKAGE_NO`,\\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   1 AS NUMBER,\\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\\n   t_inm_store_info.STORE_ID AS STORE_ID,\\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_inm_store_info.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   t_inm_store_info.VARIETY_ID,\\n   IF (\\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  t_inm_store_info.MATERIAL_LENGTH\\n  ),\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  'C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '30' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\\n   t_pre_product_material.PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   t_pre_product_material.NUMBER AS NUMBER,\\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\\n   t_pre_product_material.STORE_ID AS STORE_ID,\\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\\n   t_pre_product_material.STEEL_GRADE,\\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (t_pre_product_material.LENGTH IS NOT NULL)\\n  AND (t_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*',\\n  t_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   NULL AS NUMBER,\\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\\n   NULL AS GROSS_WT,\\n   '/' AS STORE_ID,\\n   '/' AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_pre_scrap.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   NULL AS specs,\\n   -- 单位测试\\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_pre_scrap.BATCH_NO\\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\\nWHERE\\n  t_dgm_send_info.SEND_STATE = '70'\\n  AND temp.CUSTOMER_ID = '1930921074703462401'\\ngroup by\\n  temp.MIXED_NO\\nhaving\\n  SEND_NUMBER > RETURN_NUMBER\\nLIMIT\\n  100\", \"explain\": \"id\\tselect_type\\ttable\\ttype\\tkey\\trows\\tExtra\\n1\\tPRIMARY\\tt_dgm_send_info\\tALL\\tPRIMARY\\t1000\\tUsing where; Using temporary; Using filesort\\n1\\tPRIMARY\\tt_dgm_send_info_detail\\tref\\tSEND_ID\\t10\\tUsing where\\n1\\tPRIMARY\\t<derived2>\\tref\\t<auto_key0>\\t150\\tUsing where\\n1\\tPRIMARY\\tt_rmm_store\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_rmm_location\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_qdm_standard\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_bdm_column\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_dgm_send_info_return_detail\\tref\\tCONNECT_DETAIL_ID\\t1\\tUsing where\\n2\\tDERIVED\\tv_pre_product_material\\tALL\\tNULL\\t50000\\tUsing where; Using temporary; Using filesort\\n2\\tDERIVED\\tmaterial\\tref\\tMATERIAL_NO\\t1\\tUsing index\\n2\\tDERIVED\\tpackage\\tref\\tPACKAGE_NO\\t1\\tUsing index\\n3\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n3\\tUNION\\tt_sam_contract\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n4\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n5\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t10000\\tUsing where\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,成功应用投影下推规则，消除了UNION ALL临时表中的23个冗余列。优化后临时表宽度从30+列降至6列，预计减少80%以上的I/O和内存占用，尤其在处理大数据量分组场景时性能提升显著。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推优化: (1)将客户ID过滤条件下推到UNION ALL派生表的各个子查询中，提前过滤数据源；(2)将发送状态条件封装在子查询中实现预过滤。避免派生表和连接表处理不必要的数据，减少中间结果集大小\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"HAVING 条件下推,已将HAVING子句中不依赖聚合函数的条件『SEND_NUMBER > RETURN_NUMBER』下推到WHERE子句，减少分组处理的数据量。原始表达式完整复制以保证逻辑等价性。\"}, {\"rule_id\": \"4\", \"difficulty_level\": \"3\", \"rationale\": \"GROUP BY 子句消除,消除冗余的GROUP BY子句，因为分组列temp.MIXED_NO在子查询中已是唯一值。无聚合函数且分组不改变结果集，移除后可避免不必要的排序和临时表创建，提升查询性能。\"}, {\"rule_id\": \"5\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,通过将LEFT JOIN改为INNER JOIN并删除冗余过滤条件，优化连接效率和执行计划。子查询已确保SEND_STATE='70'，INNER JOIN可减少中间结果集大小，同时语义保持不变。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE DATABASE IF NOT EXISTS zjjs_mpm;\nCREATE DATABASE IF NOT EXISTS zjjs_rmm;\nCREATE DATABASE IF NOT EXISTS zjjs_qdm;\nCREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\nCREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\nCREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\nCREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\nCREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\nCREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\nCREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\nCREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\nCREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\nCREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\nCREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\nCREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\nCREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\nCREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\nCREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\n\n## Explain Output in JSON:\nid\tselect_type\ttable\ttype\tkey\trows\tExtra\n1\tPRIMARY\tt_dgm_send_info\tALL\tPRIMARY\t1000\tUsing where; Using temporary; Using filesort\n1\tPRIMARY\tt_dgm_send_info_detail\tref\tSEND_ID\t10\tUsing where\n1\tPRIMARY\t<derived2>\tref\t<auto_key0>\t150\tUsing where\n1\tPRIMARY\tt_rmm_store\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_rmm_location\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_qdm_standard\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_bdm_column\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_dgm_send_info_return_detail\tref\tCONNECT_DETAIL_ID\t1\tUsing where\n2\tDERIVED\tv_pre_product_material\tALL\tNULL\t50000\tUsing where; Using temporary; Using filesort\n2\tDERIVED\tmaterial\tref\tMATERIAL_NO\t1\tUsing index\n2\tDERIVED\tpackage\tref\tPACKAGE_NO\t1\tUsing index\n3\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n3\tUNION\tt_sam_contract\teq_ref\tPRIMARY\t1\tUsing where\n4\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n5\tUNION\tt_sam_contract_detail\tALL\tNULL\t10000\tUsing where\n\n## Original SQL:\nSELECT\n  temp.*,\n  t_rmm_store.STORE_NAME,\n  t_rmm_location.LOCATION_NAME,\n  t_qdm_standard.STANDARD_NAME,\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\n  ) AS `SEND_NUMBER`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\n  ) AS `RETURN_NUMBER`\nFROM\n  t_dgm_send_info_detail\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\n  LEFT JOIN (\n  SELECT\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\n   IFNULL(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   ) AS MIXED_NO,\n   '30' AS SPOT_TYPE,\n   v_pre_product_material.MATERIAL_NO,\n   v_pre_product_material.PACKAGE_NO,\n   v_pre_product_material.PSR_ID,\n   v_pre_product_material.CUSTOMER_ID,\n   v_pre_product_material.CONTRACT_ID,\n   v_pre_product_material.CONTRACT_NO,\n   v_pre_product_material.NUMBER,\n   v_pre_product_material.NET_WEIGHT,\n   v_pre_product_material.GROSS_WT,\n   v_pre_product_material.STORE_ID,\n   v_pre_product_material.LOCATION_ID,\n   v_pre_product_material.STANDARD_ID,\n   v_pre_product_material.STEEL_GRADE,\n   v_pre_product_material.SURFACE_GROUP_DESC,\n   v_pre_product_material.CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (v_pre_product_material.LENGTH IS NOT NULL)\n  AND (v_pre_product_material.LENGTH != 0),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*',\n  v_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   SUM(\n  IF (\n  t_sam_contract_detail.BUY_UNIT = '10',\n  -- 单位测试\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\n  )\n   ) AS `PRICE`\n  FROM\n   v_pre_product_material\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\n  WHERE\n   v_pre_product_material.IS_ISSUED = '1'\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\n   AND v_pre_product_material.NI36_TAG = '0'\n   AND v_pre_product_material.MATERIAL_STATE != '110'\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\n   AND NOT EXISTS (\n  SELECT\n  1\n  FROM\n  v_pre_product_material v2\n  WHERE\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\n  GROUP BY\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\n  HAVING\n  SUM(\n   CASE\n  WHEN IS_ISSUED != '1' THEN 1\n  ELSE 0\n   END\n  ) > 0\n   )\n  GROUP BY\n   COALESCE(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   )\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '10' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   NULL AS `PACKAGE_NO`,\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   1 AS NUMBER,\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\n   t_inm_store_info.STORE_ID AS STORE_ID,\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_inm_store_info.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   t_inm_store_info.VARIETY_ID,\n   IF (\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  t_inm_store_info.MATERIAL_LENGTH\n  ),\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  'C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '30' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\n   t_pre_product_material.PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   t_pre_product_material.NUMBER AS NUMBER,\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\n   t_pre_product_material.STORE_ID AS STORE_ID,\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\n   t_pre_product_material.STEEL_GRADE,\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (t_pre_product_material.LENGTH IS NOT NULL)\n  AND (t_pre_product_material.LENGTH != 0),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*',\n  t_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   NULL AS NUMBER,\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\n   NULL AS GROSS_WT,\n   '/' AS STORE_ID,\n   '/' AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_pre_scrap.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   NULL AS specs,\n   -- 单位测试\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_pre_scrap.BATCH_NO\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\nWHERE\n  t_dgm_send_info.SEND_STATE = '70'\n  AND temp.CUSTOMER_ID = '1930921074703462401'\ngroup by\n  temp.MIXED_NO\nhaving\n  SEND_NUMBER > RETURN_NUMBER\nLIMIT\n  100\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT temp.*,t_rmm_store.STORE_NAME,t_rmm_location.LOCATION_NAME,t_qdm_standard.STANDARD_NAME,t_bdm_column.COLUMN_NAME AS STEEL_GRADE_NAME,t_dgm_send_info.SEND_ID AS CONNECT_ID,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS CONNECT_DETAIL_ID,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0)) AS SEND_NUMBER,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) AS RETURN_NUMBER FROM t_dgm_send_info_detail INNER JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID=t_dgm_send_info_detail.SEND_ID AND t_dgm_send_info.SEND_STATE='70' LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID=t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID INNER JOIN (SELECT v_pre_product_material.PRODUCE_MATERIAL_ID,IFNULL(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) AS MIXED_NO,'30' AS SPOT_TYPE,v_pre_product_material.MATERIAL_NO,v_pre_product_material.PACKAGE_NO,v_pre_product_material.PSR_ID,v_pre_product_material.CUSTOMER_ID,v_pre_product_material.CONTRACT_ID,v_pre_product_material.CONTRACT_NO,v_pre_product_material.NUMBER,v_pre_product_material.NET_WEIGHT,v_pre_product_material.GROSS_WT,v_pre_product_material.STORE_ID,v_pre_product_material.LOCATION_ID,v_pre_product_material.STANDARD_ID,v_pre_product_material.STEEL_GRADE,v_pre_product_material.SURFACE_GROUP_DESC,v_pre_product_material.CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((v_pre_product_material.LENGTH IS NOT NULL) AND (v_pre_product_material.LENGTH!=0),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*',v_pre_product_material.LENGTH),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*C')) AS specs,SUM(IF(t_sam_contract_detail.BUY_UNIT='10',t_sam_contract_detail.TAX_PRICE*v_pre_product_material.NET_WEIGHT,t_sam_contract_detail.TAX_PRICE*IFNULL(t_sam_contract_detail.NUMBER,1))) AS PRICE FROM v_pre_product_material LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID=v_pre_product_material.CONTRACT_DELIVERY_ID LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID=t_sam_contract_detail.CONTRACT_DETAILS_ID WHERE v_pre_product_material.IS_ISSUED='1' AND v_pre_product_material.IS_SPOT_RESOURCE='0' AND v_pre_product_material.NI36_TAG='0' AND v_pre_product_material.MATERIAL_STATE!='110' AND v_pre_product_material.CONTRACT_TYPE!='60' AND v_pre_product_material.CUSTOMER_ID='1930921074703462401' GROUP BY COALESCE(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) UNION ALL SELECT t_sam_contract_detail.CONTRACT_DETAILS_ID AS PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'10' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,NULL AS PACKAGE_NO,t_bdm_column.COLUMN_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,1 AS NUMBER,t_inm_store_info.NEW_WEIGHT AS NET_WEIGHT,t_inm_store_info.GROSS_WT,t_inm_store_info.STORE_ID,t_inm_store_info.LOCATION_ID,NULL AS STANDARD_ID,t_inm_store_info.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,t_inm_store_info.VARIETY_ID,IF(t_inm_store_info.MATERIAL_LENGTH IS NOT NULL AND t_inm_store_info.MATERIAL_LENGTH!=0,CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,t_inm_store_info.MATERIAL_LENGTH),CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,'C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='10' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO=t_sam_contract_detail.PRODUCT_MATERIAL_NO AND t_inm_store_info.STOCK_ID IS NOT NULL LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID=t_bdm_column.COLUMN_ID GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_pre_product_material.PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'30' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,t_pre_product_material.PACKAGE_NO,t_pre_product_material.PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,t_pre_product_material.NUMBER,t_pre_product_material.NET_WEIGHT,t_pre_product_material.GROSS_WT,t_pre_product_material.STORE_ID,t_pre_product_material.LOCATION_ID,t_pre_product_material.STANDARD_ID,t_pre_product_material.STEEL_GRADE,t_pre_product_material.SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((t_pre_product_material.LENGTH IS NOT NULL) AND (t_pre_product_material.LENGTH!=0),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*',t_pre_product_material.LENGTH),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE IN('20','30') AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' INNER JOIN t_pre_product_material ON(t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.PACKAGE_NO OR t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.MATERIAL_NO) AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_sam_contract_detail.SCRAP_INFO_ID AS PRODUCE_MATERIAL_ID,t_pre_scrap.BATCH_NO AS MIXED_NO,t_sam_contract_detail.SPOT_TYPE,t_pre_scrap.BATCH_NO AS MATERIAL_NO,t_pre_scrap.BATCH_NO AS PACKAGE_NO,t_pre_scrap.PRODUCT_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,NULL AS NUMBER,t_pre_scrap.WEIGHT AS NET_WEIGHT,NULL AS GROSS_WT,'/' AS STORE_ID,'/' AS LOCATION_ID,NULL AS STANDARD_ID,t_pre_scrap.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID,NULL AS VARIETY_ID,NULL AS specs,t_pre_scrap.WEIGHT*t_sam_contract_detail.TAX_PRICE AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='40' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID=t_sam_contract_detail.SCRAP_INFO_ID GROUP BY t_pre_scrap.BATCH_NO) as temp ON temp.MIXED_NO=t_dgm_send_info_detail.MIXED_NO LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store ON t_rmm_store.STORE_ID=temp.STORE_ID LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location ON t_rmm_location.LOCATION_ID=temp.LOCATION_ID LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard ON t_qdm_standard.STANDARD_ID=temp.STANDARD_ID LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_bdm_column.COLUMN_ID=temp.STEEL_GRADE GROUP BY temp.MIXED_NO,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID HAVING IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0))>IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) LIMIT 100"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "42",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"42\", \"db_type\": \"mysql\", \"description\": \"该SQL查询存在显著的性能瓶颈，主要体现为：1. **谓词未下推**：核心过滤条件`CUSTOMER_ID`位于最外层，导致内部巨大的UNION ALL派生表（由四部分组成）必须先全量物化及聚合，无法利用索引提前过滤数据。2. **隐式内连接**：对LEFT JOIN表`t_dgm_send_info`的字段进行了`SEND_STATE='70'`的等值过滤，语义上已变为内连接，但写法可能误导优化器或导致低效的执行路径。3. **冗余的聚合与排序**：外层的`GROUP BY temp.MIXED_NO`在业务逻辑上可能是冗余的（子查询已确保唯一性或JOIN关系未导致膨胀），且`HAVING`子句中包含了本应在WHERE中过滤的非聚合条件，导致了不必要的临时表和排序开销。4. **宽表投影**：派生表输出了大量后续未使用的列，增加了内存和I/O负担。\", \"create_table_statements\": [\"CREATE DATABASE IF NOT EXISTS zjjs_mpm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_rmm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_qdm;\", \"CREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\", \"CREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\", \"CREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\", \"CREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\", \"CREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\", \"CREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\", \"CREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\", \"CREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\", \"CREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\", \"CREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\", \"CREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\"], \"sql\": \"SELECT\\n  temp.*,\\n  t_rmm_store.STORE_NAME,\\n  t_rmm_location.LOCATION_NAME,\\n  t_qdm_standard.STANDARD_NAME,\\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\\n  ) AS `SEND_NUMBER`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\\n  ) AS `RETURN_NUMBER`\\nFROM\\n  t_dgm_send_info_detail\\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\\n  LEFT JOIN (\\n  SELECT\\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\\n   IFNULL(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   ) AS MIXED_NO,\\n   '30' AS SPOT_TYPE,\\n   v_pre_product_material.MATERIAL_NO,\\n   v_pre_product_material.PACKAGE_NO,\\n   v_pre_product_material.PSR_ID,\\n   v_pre_product_material.CUSTOMER_ID,\\n   v_pre_product_material.CONTRACT_ID,\\n   v_pre_product_material.CONTRACT_NO,\\n   v_pre_product_material.NUMBER,\\n   v_pre_product_material.NET_WEIGHT,\\n   v_pre_product_material.GROSS_WT,\\n   v_pre_product_material.STORE_ID,\\n   v_pre_product_material.LOCATION_ID,\\n   v_pre_product_material.STANDARD_ID,\\n   v_pre_product_material.STEEL_GRADE,\\n   v_pre_product_material.SURFACE_GROUP_DESC,\\n   v_pre_product_material.CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (v_pre_product_material.LENGTH IS NOT NULL)\\n  AND (v_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*',\\n  v_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   SUM(\\n  IF (\\n  t_sam_contract_detail.BUY_UNIT = '10',\\n  -- 单位测试\\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\\n  )\\n   ) AS `PRICE`\\n  FROM\\n   v_pre_product_material\\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\\n  WHERE\\n   v_pre_product_material.IS_ISSUED = '1'\\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\\n   AND v_pre_product_material.NI36_TAG = '0'\\n   AND v_pre_product_material.MATERIAL_STATE != '110'\\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\\n   AND NOT EXISTS (\\n  SELECT\\n  1\\n  FROM\\n  v_pre_product_material v2\\n  WHERE\\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\\n  GROUP BY\\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\\n  HAVING\\n  SUM(\\n   CASE\\n  WHEN IS_ISSUED != '1' THEN 1\\n  ELSE 0\\n   END\\n  ) > 0\\n   )\\n  GROUP BY\\n   COALESCE(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   )\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '10' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   NULL AS `PACKAGE_NO`,\\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   1 AS NUMBER,\\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\\n   t_inm_store_info.STORE_ID AS STORE_ID,\\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_inm_store_info.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   t_inm_store_info.VARIETY_ID,\\n   IF (\\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  t_inm_store_info.MATERIAL_LENGTH\\n  ),\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  'C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '30' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\\n   t_pre_product_material.PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   t_pre_product_material.NUMBER AS NUMBER,\\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\\n   t_pre_product_material.STORE_ID AS STORE_ID,\\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\\n   t_pre_product_material.STEEL_GRADE,\\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (t_pre_product_material.LENGTH IS NOT NULL)\\n  AND (t_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*',\\n  t_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   NULL AS NUMBER,\\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\\n   NULL AS GROSS_WT,\\n   '/' AS STORE_ID,\\n   '/' AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_pre_scrap.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   NULL AS specs,\\n   -- 单位测试\\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_pre_scrap.BATCH_NO\\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\\nWHERE\\n  t_dgm_send_info.SEND_STATE = '70'\\n  AND temp.CUSTOMER_ID = '1930921074703462401'\\ngroup by\\n  temp.MIXED_NO\\nhaving\\n  SEND_NUMBER > RETURN_NUMBER\\nLIMIT\\n  100\", \"explain\": \"id\\tselect_type\\ttable\\ttype\\tkey\\trows\\tExtra\\n1\\tPRIMARY\\tt_dgm_send_info\\tALL\\tPRIMARY\\t1000\\tUsing where; Using temporary; Using filesort\\n1\\tPRIMARY\\tt_dgm_send_info_detail\\tref\\tSEND_ID\\t10\\tUsing where\\n1\\tPRIMARY\\t<derived2>\\tref\\t<auto_key0>\\t150\\tUsing where\\n1\\tPRIMARY\\tt_rmm_store\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_rmm_location\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_qdm_standard\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_bdm_column\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_dgm_send_info_return_detail\\tref\\tCONNECT_DETAIL_ID\\t1\\tUsing where\\n2\\tDERIVED\\tv_pre_product_material\\tALL\\tNULL\\t50000\\tUsing where; Using temporary; Using filesort\\n2\\tDERIVED\\tmaterial\\tref\\tMATERIAL_NO\\t1\\tUsing index\\n2\\tDERIVED\\tpackage\\tref\\tPACKAGE_NO\\t1\\tUsing index\\n3\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n3\\tUNION\\tt_sam_contract\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n4\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n5\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t10000\\tUsing where\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,成功应用投影下推规则，消除了UNION ALL临时表中的23个冗余列。优化后临时表宽度从30+列降至6列，预计减少80%以上的I/O和内存占用，尤其在处理大数据量分组场景时性能提升显著。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推优化: (1)将客户ID过滤条件下推到UNION ALL派生表的各个子查询中，提前过滤数据源；(2)将发送状态条件封装在子查询中实现预过滤。避免派生表和连接表处理不必要的数据，减少中间结果集大小\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"HAVING 条件下推,已将HAVING子句中不依赖聚合函数的条件『SEND_NUMBER > RETURN_NUMBER』下推到WHERE子句，减少分组处理的数据量。原始表达式完整复制以保证逻辑等价性。\"}, {\"rule_id\": \"4\", \"difficulty_level\": \"3\", \"rationale\": \"GROUP BY 子句消除,消除冗余的GROUP BY子句，因为分组列temp.MIXED_NO在子查询中已是唯一值。无聚合函数且分组不改变结果集，移除后可避免不必要的排序和临时表创建，提升查询性能。\"}, {\"rule_id\": \"5\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,通过将LEFT JOIN改为INNER JOIN并删除冗余过滤条件，优化连接效率和执行计划。子查询已确保SEND_STATE='70'，INNER JOIN可减少中间结果集大小，同时语义保持不变。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE DATABASE IF NOT EXISTS zjjs_mpm;\nCREATE DATABASE IF NOT EXISTS zjjs_rmm;\nCREATE DATABASE IF NOT EXISTS zjjs_qdm;\nCREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\nCREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\nCREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\nCREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\nCREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\nCREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\nCREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\nCREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\nCREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\nCREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\nCREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\nCREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\nCREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\nCREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\nCREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\n\n## Explain Output in JSON:\nid\tselect_type\ttable\ttype\tkey\trows\tExtra\n1\tPRIMARY\tt_dgm_send_info\tALL\tPRIMARY\t1000\tUsing where; Using temporary; Using filesort\n1\tPRIMARY\tt_dgm_send_info_detail\tref\tSEND_ID\t10\tUsing where\n1\tPRIMARY\t<derived2>\tref\t<auto_key0>\t150\tUsing where\n1\tPRIMARY\tt_rmm_store\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_rmm_location\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_qdm_standard\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_bdm_column\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_dgm_send_info_return_detail\tref\tCONNECT_DETAIL_ID\t1\tUsing where\n2\tDERIVED\tv_pre_product_material\tALL\tNULL\t50000\tUsing where; Using temporary; Using filesort\n2\tDERIVED\tmaterial\tref\tMATERIAL_NO\t1\tUsing index\n2\tDERIVED\tpackage\tref\tPACKAGE_NO\t1\tUsing index\n3\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n3\tUNION\tt_sam_contract\teq_ref\tPRIMARY\t1\tUsing where\n4\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n5\tUNION\tt_sam_contract_detail\tALL\tNULL\t10000\tUsing where\n\n## Original SQL:\nSELECT\n  temp.*,\n  t_rmm_store.STORE_NAME,\n  t_rmm_location.LOCATION_NAME,\n  t_qdm_standard.STANDARD_NAME,\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\n  ) AS `SEND_NUMBER`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\n  ) AS `RETURN_NUMBER`\nFROM\n  t_dgm_send_info_detail\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\n  LEFT JOIN (\n  SELECT\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\n   IFNULL(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   ) AS MIXED_NO,\n   '30' AS SPOT_TYPE,\n   v_pre_product_material.MATERIAL_NO,\n   v_pre_product_material.PACKAGE_NO,\n   v_pre_product_material.PSR_ID,\n   v_pre_product_material.CUSTOMER_ID,\n   v_pre_product_material.CONTRACT_ID,\n   v_pre_product_material.CONTRACT_NO,\n   v_pre_product_material.NUMBER,\n   v_pre_product_material.NET_WEIGHT,\n   v_pre_product_material.GROSS_WT,\n   v_pre_product_material.STORE_ID,\n   v_pre_product_material.LOCATION_ID,\n   v_pre_product_material.STANDARD_ID,\n   v_pre_product_material.STEEL_GRADE,\n   v_pre_product_material.SURFACE_GROUP_DESC,\n   v_pre_product_material.CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (v_pre_product_material.LENGTH IS NOT NULL)\n  AND (v_pre_product_material.LENGTH != 0),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*',\n  v_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   SUM(\n  IF (\n  t_sam_contract_detail.BUY_UNIT = '10',\n  -- 单位测试\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\n  )\n   ) AS `PRICE`\n  FROM\n   v_pre_product_material\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\n  WHERE\n   v_pre_product_material.IS_ISSUED = '1'\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\n   AND v_pre_product_material.NI36_TAG = '0'\n   AND v_pre_product_material.MATERIAL_STATE != '110'\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\n   AND NOT EXISTS (\n  SELECT\n  1\n  FROM\n  v_pre_product_material v2\n  WHERE\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\n  GROUP BY\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\n  HAVING\n  SUM(\n   CASE\n  WHEN IS_ISSUED != '1' THEN 1\n  ELSE 0\n   END\n  ) > 0\n   )\n  GROUP BY\n   COALESCE(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   )\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '10' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   NULL AS `PACKAGE_NO`,\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   1 AS NUMBER,\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\n   t_inm_store_info.STORE_ID AS STORE_ID,\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_inm_store_info.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   t_inm_store_info.VARIETY_ID,\n   IF (\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  t_inm_store_info.MATERIAL_LENGTH\n  ),\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  'C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '30' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\n   t_pre_product_material.PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   t_pre_product_material.NUMBER AS NUMBER,\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\n   t_pre_product_material.STORE_ID AS STORE_ID,\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\n   t_pre_product_material.STEEL_GRADE,\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (t_pre_product_material.LENGTH IS NOT NULL)\n  AND (t_pre_product_material.LENGTH != 0),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*',\n  t_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   NULL AS NUMBER,\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\n   NULL AS GROSS_WT,\n   '/' AS STORE_ID,\n   '/' AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_pre_scrap.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   NULL AS specs,\n   -- 单位测试\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_pre_scrap.BATCH_NO\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\nWHERE\n  t_dgm_send_info.SEND_STATE = '70'\n  AND temp.CUSTOMER_ID = '1930921074703462401'\ngroup by\n  temp.MIXED_NO\nhaving\n  SEND_NUMBER > RETURN_NUMBER\nLIMIT\n  100\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT temp.*,t_rmm_store.STORE_NAME,t_rmm_location.LOCATION_NAME,t_qdm_standard.STANDARD_NAME,t_bdm_column.COLUMN_NAME AS STEEL_GRADE_NAME,t_dgm_send_info.SEND_ID AS CONNECT_ID,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS CONNECT_DETAIL_ID,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0)) AS SEND_NUMBER,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) AS RETURN_NUMBER FROM t_dgm_send_info_detail INNER JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID=t_dgm_send_info_detail.SEND_ID AND t_dgm_send_info.SEND_STATE='70' LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID=t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID INNER JOIN (SELECT v_pre_product_material.PRODUCE_MATERIAL_ID,IFNULL(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) AS MIXED_NO,'30' AS SPOT_TYPE,v_pre_product_material.MATERIAL_NO,v_pre_product_material.PACKAGE_NO,v_pre_product_material.PSR_ID,v_pre_product_material.CUSTOMER_ID,v_pre_product_material.CONTRACT_ID,v_pre_product_material.CONTRACT_NO,v_pre_product_material.NUMBER,v_pre_product_material.NET_WEIGHT,v_pre_product_material.GROSS_WT,v_pre_product_material.STORE_ID,v_pre_product_material.LOCATION_ID,v_pre_product_material.STANDARD_ID,v_pre_product_material.STEEL_GRADE,v_pre_product_material.SURFACE_GROUP_DESC,v_pre_product_material.CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((v_pre_product_material.LENGTH IS NOT NULL) AND (v_pre_product_material.LENGTH!=0),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*',v_pre_product_material.LENGTH),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*C')) AS specs,SUM(IF(t_sam_contract_detail.BUY_UNIT='10',t_sam_contract_detail.TAX_PRICE*v_pre_product_material.NET_WEIGHT,t_sam_contract_detail.TAX_PRICE*IFNULL(t_sam_contract_detail.NUMBER,1))) AS PRICE FROM v_pre_product_material LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID=v_pre_product_material.CONTRACT_DELIVERY_ID LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID=t_sam_contract_detail.CONTRACT_DETAILS_ID WHERE v_pre_product_material.IS_ISSUED='1' AND v_pre_product_material.IS_SPOT_RESOURCE='0' AND v_pre_product_material.NI36_TAG='0' AND v_pre_product_material.MATERIAL_STATE!='110' AND v_pre_product_material.CONTRACT_TYPE!='60' AND v_pre_product_material.CUSTOMER_ID='1930921074703462401' GROUP BY COALESCE(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) UNION ALL SELECT t_sam_contract_detail.CONTRACT_DETAILS_ID AS PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'10' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,NULL AS PACKAGE_NO,t_bdm_column.COLUMN_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,1 AS NUMBER,t_inm_store_info.NEW_WEIGHT AS NET_WEIGHT,t_inm_store_info.GROSS_WT,t_inm_store_info.STORE_ID,t_inm_store_info.LOCATION_ID,NULL AS STANDARD_ID,t_inm_store_info.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,t_inm_store_info.VARIETY_ID,IF(t_inm_store_info.MATERIAL_LENGTH IS NOT NULL AND t_inm_store_info.MATERIAL_LENGTH!=0,CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,t_inm_store_info.MATERIAL_LENGTH),CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,'C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='10' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO=t_sam_contract_detail.PRODUCT_MATERIAL_NO AND t_inm_store_info.STOCK_ID IS NOT NULL LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID=t_bdm_column.COLUMN_ID GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_pre_product_material.PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'30' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,t_pre_product_material.PACKAGE_NO,t_pre_product_material.PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,t_pre_product_material.NUMBER,t_pre_product_material.NET_WEIGHT,t_pre_product_material.GROSS_WT,t_pre_product_material.STORE_ID,t_pre_product_material.LOCATION_ID,t_pre_product_material.STANDARD_ID,t_pre_product_material.STEEL_GRADE,t_pre_product_material.SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((t_pre_product_material.LENGTH IS NOT NULL) AND (t_pre_product_material.LENGTH!=0),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*',t_pre_product_material.LENGTH),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE IN('20','30') AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' INNER JOIN t_pre_product_material ON(t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.PACKAGE_NO OR t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.MATERIAL_NO) AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_sam_contract_detail.SCRAP_INFO_ID AS PRODUCE_MATERIAL_ID,t_pre_scrap.BATCH_NO AS MIXED_NO,t_sam_contract_detail.SPOT_TYPE,t_pre_scrap.BATCH_NO AS MATERIAL_NO,t_pre_scrap.BATCH_NO AS PACKAGE_NO,t_pre_scrap.PRODUCT_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,NULL AS NUMBER,t_pre_scrap.WEIGHT AS NET_WEIGHT,NULL AS GROSS_WT,'/' AS STORE_ID,'/' AS LOCATION_ID,NULL AS STANDARD_ID,t_pre_scrap.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID,NULL AS VARIETY_ID,NULL AS specs,t_pre_scrap.WEIGHT*t_sam_contract_detail.TAX_PRICE AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='40' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID=t_sam_contract_detail.SCRAP_INFO_ID GROUP BY t_pre_scrap.BATCH_NO) as temp ON temp.MIXED_NO=t_dgm_send_info_detail.MIXED_NO LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store ON t_rmm_store.STORE_ID=temp.STORE_ID LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location ON t_rmm_location.LOCATION_ID=temp.LOCATION_ID LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard ON t_qdm_standard.STANDARD_ID=temp.STANDARD_ID LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_bdm_column.COLUMN_ID=temp.STEEL_GRADE GROUP BY temp.MIXED_NO,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID HAVING IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0))>IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) LIMIT 100"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "42",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"42\", \"db_type\": \"mysql\", \"description\": \"该SQL查询存在显著的性能瓶颈，主要体现为：1. **谓词未下推**：核心过滤条件`CUSTOMER_ID`位于最外层，导致内部巨大的UNION ALL派生表（由四部分组成）必须先全量物化及聚合，无法利用索引提前过滤数据。2. **隐式内连接**：对LEFT JOIN表`t_dgm_send_info`的字段进行了`SEND_STATE='70'`的等值过滤，语义上已变为内连接，但写法可能误导优化器或导致低效的执行路径。3. **冗余的聚合与排序**：外层的`GROUP BY temp.MIXED_NO`在业务逻辑上可能是冗余的（子查询已确保唯一性或JOIN关系未导致膨胀），且`HAVING`子句中包含了本应在WHERE中过滤的非聚合条件，导致了不必要的临时表和排序开销。4. **宽表投影**：派生表输出了大量后续未使用的列，增加了内存和I/O负担。\", \"create_table_statements\": [\"CREATE DATABASE IF NOT EXISTS zjjs_mpm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_rmm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_qdm;\", \"CREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\", \"CREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\", \"CREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\", \"CREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\", \"CREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\", \"CREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\", \"CREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\", \"CREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\", \"CREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\", \"CREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\", \"CREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\"], \"sql\": \"SELECT\\n  temp.*,\\n  t_rmm_store.STORE_NAME,\\n  t_rmm_location.LOCATION_NAME,\\n  t_qdm_standard.STANDARD_NAME,\\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\\n  ) AS `SEND_NUMBER`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\\n  ) AS `RETURN_NUMBER`\\nFROM\\n  t_dgm_send_info_detail\\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\\n  LEFT JOIN (\\n  SELECT\\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\\n   IFNULL(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   ) AS MIXED_NO,\\n   '30' AS SPOT_TYPE,\\n   v_pre_product_material.MATERIAL_NO,\\n   v_pre_product_material.PACKAGE_NO,\\n   v_pre_product_material.PSR_ID,\\n   v_pre_product_material.CUSTOMER_ID,\\n   v_pre_product_material.CONTRACT_ID,\\n   v_pre_product_material.CONTRACT_NO,\\n   v_pre_product_material.NUMBER,\\n   v_pre_product_material.NET_WEIGHT,\\n   v_pre_product_material.GROSS_WT,\\n   v_pre_product_material.STORE_ID,\\n   v_pre_product_material.LOCATION_ID,\\n   v_pre_product_material.STANDARD_ID,\\n   v_pre_product_material.STEEL_GRADE,\\n   v_pre_product_material.SURFACE_GROUP_DESC,\\n   v_pre_product_material.CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (v_pre_product_material.LENGTH IS NOT NULL)\\n  AND (v_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*',\\n  v_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   SUM(\\n  IF (\\n  t_sam_contract_detail.BUY_UNIT = '10',\\n  -- 单位测试\\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\\n  )\\n   ) AS `PRICE`\\n  FROM\\n   v_pre_product_material\\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\\n  WHERE\\n   v_pre_product_material.IS_ISSUED = '1'\\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\\n   AND v_pre_product_material.NI36_TAG = '0'\\n   AND v_pre_product_material.MATERIAL_STATE != '110'\\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\\n   AND NOT EXISTS (\\n  SELECT\\n  1\\n  FROM\\n  v_pre_product_material v2\\n  WHERE\\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\\n  GROUP BY\\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\\n  HAVING\\n  SUM(\\n   CASE\\n  WHEN IS_ISSUED != '1' THEN 1\\n  ELSE 0\\n   END\\n  ) > 0\\n   )\\n  GROUP BY\\n   COALESCE(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   )\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '10' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   NULL AS `PACKAGE_NO`,\\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   1 AS NUMBER,\\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\\n   t_inm_store_info.STORE_ID AS STORE_ID,\\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_inm_store_info.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   t_inm_store_info.VARIETY_ID,\\n   IF (\\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  t_inm_store_info.MATERIAL_LENGTH\\n  ),\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  'C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '30' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\\n   t_pre_product_material.PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   t_pre_product_material.NUMBER AS NUMBER,\\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\\n   t_pre_product_material.STORE_ID AS STORE_ID,\\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\\n   t_pre_product_material.STEEL_GRADE,\\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (t_pre_product_material.LENGTH IS NOT NULL)\\n  AND (t_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*',\\n  t_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   NULL AS NUMBER,\\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\\n   NULL AS GROSS_WT,\\n   '/' AS STORE_ID,\\n   '/' AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_pre_scrap.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   NULL AS specs,\\n   -- 单位测试\\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_pre_scrap.BATCH_NO\\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\\nWHERE\\n  t_dgm_send_info.SEND_STATE = '70'\\n  AND temp.CUSTOMER_ID = '1930921074703462401'\\ngroup by\\n  temp.MIXED_NO\\nhaving\\n  SEND_NUMBER > RETURN_NUMBER\\nLIMIT\\n  100\", \"explain\": \"id\\tselect_type\\ttable\\ttype\\tkey\\trows\\tExtra\\n1\\tPRIMARY\\tt_dgm_send_info\\tALL\\tPRIMARY\\t1000\\tUsing where; Using temporary; Using filesort\\n1\\tPRIMARY\\tt_dgm_send_info_detail\\tref\\tSEND_ID\\t10\\tUsing where\\n1\\tPRIMARY\\t<derived2>\\tref\\t<auto_key0>\\t150\\tUsing where\\n1\\tPRIMARY\\tt_rmm_store\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_rmm_location\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_qdm_standard\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_bdm_column\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_dgm_send_info_return_detail\\tref\\tCONNECT_DETAIL_ID\\t1\\tUsing where\\n2\\tDERIVED\\tv_pre_product_material\\tALL\\tNULL\\t50000\\tUsing where; Using temporary; Using filesort\\n2\\tDERIVED\\tmaterial\\tref\\tMATERIAL_NO\\t1\\tUsing index\\n2\\tDERIVED\\tpackage\\tref\\tPACKAGE_NO\\t1\\tUsing index\\n3\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n3\\tUNION\\tt_sam_contract\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n4\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n5\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t10000\\tUsing where\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,成功应用投影下推规则，消除了UNION ALL临时表中的23个冗余列。优化后临时表宽度从30+列降至6列，预计减少80%以上的I/O和内存占用，尤其在处理大数据量分组场景时性能提升显著。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推优化: (1)将客户ID过滤条件下推到UNION ALL派生表的各个子查询中，提前过滤数据源；(2)将发送状态条件封装在子查询中实现预过滤。避免派生表和连接表处理不必要的数据，减少中间结果集大小\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"HAVING 条件下推,已将HAVING子句中不依赖聚合函数的条件『SEND_NUMBER > RETURN_NUMBER』下推到WHERE子句，减少分组处理的数据量。原始表达式完整复制以保证逻辑等价性。\"}, {\"rule_id\": \"4\", \"difficulty_level\": \"3\", \"rationale\": \"GROUP BY 子句消除,消除冗余的GROUP BY子句，因为分组列temp.MIXED_NO在子查询中已是唯一值。无聚合函数且分组不改变结果集，移除后可避免不必要的排序和临时表创建，提升查询性能。\"}, {\"rule_id\": \"5\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,通过将LEFT JOIN改为INNER JOIN并删除冗余过滤条件，优化连接效率和执行计划。子查询已确保SEND_STATE='70'，INNER JOIN可减少中间结果集大小，同时语义保持不变。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE DATABASE IF NOT EXISTS zjjs_mpm;\nCREATE DATABASE IF NOT EXISTS zjjs_rmm;\nCREATE DATABASE IF NOT EXISTS zjjs_qdm;\nCREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\nCREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\nCREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\nCREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\nCREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\nCREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\nCREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\nCREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\nCREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\nCREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\nCREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\nCREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\nCREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\nCREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\nCREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\n\n## Explain Output in JSON:\nid\tselect_type\ttable\ttype\tkey\trows\tExtra\n1\tPRIMARY\tt_dgm_send_info\tALL\tPRIMARY\t1000\tUsing where; Using temporary; Using filesort\n1\tPRIMARY\tt_dgm_send_info_detail\tref\tSEND_ID\t10\tUsing where\n1\tPRIMARY\t<derived2>\tref\t<auto_key0>\t150\tUsing where\n1\tPRIMARY\tt_rmm_store\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_rmm_location\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_qdm_standard\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_bdm_column\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_dgm_send_info_return_detail\tref\tCONNECT_DETAIL_ID\t1\tUsing where\n2\tDERIVED\tv_pre_product_material\tALL\tNULL\t50000\tUsing where; Using temporary; Using filesort\n2\tDERIVED\tmaterial\tref\tMATERIAL_NO\t1\tUsing index\n2\tDERIVED\tpackage\tref\tPACKAGE_NO\t1\tUsing index\n3\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n3\tUNION\tt_sam_contract\teq_ref\tPRIMARY\t1\tUsing where\n4\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n5\tUNION\tt_sam_contract_detail\tALL\tNULL\t10000\tUsing where\n\n## Original SQL:\nSELECT\n  temp.*,\n  t_rmm_store.STORE_NAME,\n  t_rmm_location.LOCATION_NAME,\n  t_qdm_standard.STANDARD_NAME,\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\n  ) AS `SEND_NUMBER`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\n  ) AS `RETURN_NUMBER`\nFROM\n  t_dgm_send_info_detail\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\n  LEFT JOIN (\n  SELECT\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\n   IFNULL(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   ) AS MIXED_NO,\n   '30' AS SPOT_TYPE,\n   v_pre_product_material.MATERIAL_NO,\n   v_pre_product_material.PACKAGE_NO,\n   v_pre_product_material.PSR_ID,\n   v_pre_product_material.CUSTOMER_ID,\n   v_pre_product_material.CONTRACT_ID,\n   v_pre_product_material.CONTRACT_NO,\n   v_pre_product_material.NUMBER,\n   v_pre_product_material.NET_WEIGHT,\n   v_pre_product_material.GROSS_WT,\n   v_pre_product_material.STORE_ID,\n   v_pre_product_material.LOCATION_ID,\n   v_pre_product_material.STANDARD_ID,\n   v_pre_product_material.STEEL_GRADE,\n   v_pre_product_material.SURFACE_GROUP_DESC,\n   v_pre_product_material.CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (v_pre_product_material.LENGTH IS NOT NULL)\n  AND (v_pre_product_material.LENGTH != 0),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*',\n  v_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   SUM(\n  IF (\n  t_sam_contract_detail.BUY_UNIT = '10',\n  -- 单位测试\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\n  )\n   ) AS `PRICE`\n  FROM\n   v_pre_product_material\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\n  WHERE\n   v_pre_product_material.IS_ISSUED = '1'\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\n   AND v_pre_product_material.NI36_TAG = '0'\n   AND v_pre_product_material.MATERIAL_STATE != '110'\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\n   AND NOT EXISTS (\n  SELECT\n  1\n  FROM\n  v_pre_product_material v2\n  WHERE\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\n  GROUP BY\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\n  HAVING\n  SUM(\n   CASE\n  WHEN IS_ISSUED != '1' THEN 1\n  ELSE 0\n   END\n  ) > 0\n   )\n  GROUP BY\n   COALESCE(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   )\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '10' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   NULL AS `PACKAGE_NO`,\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   1 AS NUMBER,\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\n   t_inm_store_info.STORE_ID AS STORE_ID,\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_inm_store_info.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   t_inm_store_info.VARIETY_ID,\n   IF (\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  t_inm_store_info.MATERIAL_LENGTH\n  ),\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  'C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '30' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\n   t_pre_product_material.PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   t_pre_product_material.NUMBER AS NUMBER,\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\n   t_pre_product_material.STORE_ID AS STORE_ID,\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\n   t_pre_product_material.STEEL_GRADE,\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (t_pre_product_material.LENGTH IS NOT NULL)\n  AND (t_pre_product_material.LENGTH != 0),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*',\n  t_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   NULL AS NUMBER,\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\n   NULL AS GROSS_WT,\n   '/' AS STORE_ID,\n   '/' AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_pre_scrap.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   NULL AS specs,\n   -- 单位测试\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_pre_scrap.BATCH_NO\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\nWHERE\n  t_dgm_send_info.SEND_STATE = '70'\n  AND temp.CUSTOMER_ID = '1930921074703462401'\ngroup by\n  temp.MIXED_NO\nhaving\n  SEND_NUMBER > RETURN_NUMBER\nLIMIT\n  100\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT temp.*,t_rmm_store.STORE_NAME,t_rmm_location.LOCATION_NAME,t_qdm_standard.STANDARD_NAME,t_bdm_column.COLUMN_NAME AS STEEL_GRADE_NAME,t_dgm_send_info.SEND_ID AS CONNECT_ID,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS CONNECT_DETAIL_ID,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0)) AS SEND_NUMBER,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) AS RETURN_NUMBER FROM t_dgm_send_info_detail INNER JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID=t_dgm_send_info_detail.SEND_ID AND t_dgm_send_info.SEND_STATE='70' LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID=t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID INNER JOIN (SELECT v_pre_product_material.PRODUCE_MATERIAL_ID,IFNULL(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) AS MIXED_NO,'30' AS SPOT_TYPE,v_pre_product_material.MATERIAL_NO,v_pre_product_material.PACKAGE_NO,v_pre_product_material.PSR_ID,v_pre_product_material.CUSTOMER_ID,v_pre_product_material.CONTRACT_ID,v_pre_product_material.CONTRACT_NO,v_pre_product_material.NUMBER,v_pre_product_material.NET_WEIGHT,v_pre_product_material.GROSS_WT,v_pre_product_material.STORE_ID,v_pre_product_material.LOCATION_ID,v_pre_product_material.STANDARD_ID,v_pre_product_material.STEEL_GRADE,v_pre_product_material.SURFACE_GROUP_DESC,v_pre_product_material.CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((v_pre_product_material.LENGTH IS NOT NULL) AND (v_pre_product_material.LENGTH!=0),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*',v_pre_product_material.LENGTH),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*C')) AS specs,SUM(IF(t_sam_contract_detail.BUY_UNIT='10',t_sam_contract_detail.TAX_PRICE*v_pre_product_material.NET_WEIGHT,t_sam_contract_detail.TAX_PRICE*IFNULL(t_sam_contract_detail.NUMBER,1))) AS PRICE FROM v_pre_product_material LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID=v_pre_product_material.CONTRACT_DELIVERY_ID LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID=t_sam_contract_detail.CONTRACT_DETAILS_ID WHERE v_pre_product_material.IS_ISSUED='1' AND v_pre_product_material.IS_SPOT_RESOURCE='0' AND v_pre_product_material.NI36_TAG='0' AND v_pre_product_material.MATERIAL_STATE!='110' AND v_pre_product_material.CONTRACT_TYPE!='60' AND v_pre_product_material.CUSTOMER_ID='1930921074703462401' GROUP BY COALESCE(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) UNION ALL SELECT t_sam_contract_detail.CONTRACT_DETAILS_ID AS PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'10' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,NULL AS PACKAGE_NO,t_bdm_column.COLUMN_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,1 AS NUMBER,t_inm_store_info.NEW_WEIGHT AS NET_WEIGHT,t_inm_store_info.GROSS_WT,t_inm_store_info.STORE_ID,t_inm_store_info.LOCATION_ID,NULL AS STANDARD_ID,t_inm_store_info.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,t_inm_store_info.VARIETY_ID,IF(t_inm_store_info.MATERIAL_LENGTH IS NOT NULL AND t_inm_store_info.MATERIAL_LENGTH!=0,CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,t_inm_store_info.MATERIAL_LENGTH),CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,'C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='10' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO=t_sam_contract_detail.PRODUCT_MATERIAL_NO AND t_inm_store_info.STOCK_ID IS NOT NULL LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID=t_bdm_column.COLUMN_ID GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_pre_product_material.PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'30' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,t_pre_product_material.PACKAGE_NO,t_pre_product_material.PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,t_pre_product_material.NUMBER,t_pre_product_material.NET_WEIGHT,t_pre_product_material.GROSS_WT,t_pre_product_material.STORE_ID,t_pre_product_material.LOCATION_ID,t_pre_product_material.STANDARD_ID,t_pre_product_material.STEEL_GRADE,t_pre_product_material.SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((t_pre_product_material.LENGTH IS NOT NULL) AND (t_pre_product_material.LENGTH!=0),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*',t_pre_product_material.LENGTH),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE IN('20','30') AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' INNER JOIN t_pre_product_material ON(t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.PACKAGE_NO OR t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.MATERIAL_NO) AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_sam_contract_detail.SCRAP_INFO_ID AS PRODUCE_MATERIAL_ID,t_pre_scrap.BATCH_NO AS MIXED_NO,t_sam_contract_detail.SPOT_TYPE,t_pre_scrap.BATCH_NO AS MATERIAL_NO,t_pre_scrap.BATCH_NO AS PACKAGE_NO,t_pre_scrap.PRODUCT_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,NULL AS NUMBER,t_pre_scrap.WEIGHT AS NET_WEIGHT,NULL AS GROSS_WT,'/' AS STORE_ID,'/' AS LOCATION_ID,NULL AS STANDARD_ID,t_pre_scrap.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID,NULL AS VARIETY_ID,NULL AS specs,t_pre_scrap.WEIGHT*t_sam_contract_detail.TAX_PRICE AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='40' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID=t_sam_contract_detail.SCRAP_INFO_ID GROUP BY t_pre_scrap.BATCH_NO) as temp ON temp.MIXED_NO=t_dgm_send_info_detail.MIXED_NO LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store ON t_rmm_store.STORE_ID=temp.STORE_ID LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location ON t_rmm_location.LOCATION_ID=temp.LOCATION_ID LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard ON t_qdm_standard.STANDARD_ID=temp.STANDARD_ID LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_bdm_column.COLUMN_ID=temp.STEEL_GRADE GROUP BY temp.MIXED_NO,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID HAVING IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0))>IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) LIMIT 100"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "42",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"42\", \"db_type\": \"mysql\", \"description\": \"该SQL查询存在显著的性能瓶颈，主要体现为：1. **谓词未下推**：核心过滤条件`CUSTOMER_ID`位于最外层，导致内部巨大的UNION ALL派生表（由四部分组成）必须先全量物化及聚合，无法利用索引提前过滤数据。2. **隐式内连接**：对LEFT JOIN表`t_dgm_send_info`的字段进行了`SEND_STATE='70'`的等值过滤，语义上已变为内连接，但写法可能误导优化器或导致低效的执行路径。3. **冗余的聚合与排序**：外层的`GROUP BY temp.MIXED_NO`在业务逻辑上可能是冗余的（子查询已确保唯一性或JOIN关系未导致膨胀），且`HAVING`子句中包含了本应在WHERE中过滤的非聚合条件，导致了不必要的临时表和排序开销。4. **宽表投影**：派生表输出了大量后续未使用的列，增加了内存和I/O负担。\", \"create_table_statements\": [\"CREATE DATABASE IF NOT EXISTS zjjs_mpm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_rmm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_qdm;\", \"CREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\", \"CREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\", \"CREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\", \"CREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\", \"CREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\", \"CREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\", \"CREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\", \"CREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\", \"CREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\", \"CREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\", \"CREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\"], \"sql\": \"SELECT\\n  temp.*,\\n  t_rmm_store.STORE_NAME,\\n  t_rmm_location.LOCATION_NAME,\\n  t_qdm_standard.STANDARD_NAME,\\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\\n  ) AS `SEND_NUMBER`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\\n  ) AS `RETURN_NUMBER`\\nFROM\\n  t_dgm_send_info_detail\\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\\n  LEFT JOIN (\\n  SELECT\\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\\n   IFNULL(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   ) AS MIXED_NO,\\n   '30' AS SPOT_TYPE,\\n   v_pre_product_material.MATERIAL_NO,\\n   v_pre_product_material.PACKAGE_NO,\\n   v_pre_product_material.PSR_ID,\\n   v_pre_product_material.CUSTOMER_ID,\\n   v_pre_product_material.CONTRACT_ID,\\n   v_pre_product_material.CONTRACT_NO,\\n   v_pre_product_material.NUMBER,\\n   v_pre_product_material.NET_WEIGHT,\\n   v_pre_product_material.GROSS_WT,\\n   v_pre_product_material.STORE_ID,\\n   v_pre_product_material.LOCATION_ID,\\n   v_pre_product_material.STANDARD_ID,\\n   v_pre_product_material.STEEL_GRADE,\\n   v_pre_product_material.SURFACE_GROUP_DESC,\\n   v_pre_product_material.CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (v_pre_product_material.LENGTH IS NOT NULL)\\n  AND (v_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*',\\n  v_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   SUM(\\n  IF (\\n  t_sam_contract_detail.BUY_UNIT = '10',\\n  -- 单位测试\\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\\n  )\\n   ) AS `PRICE`\\n  FROM\\n   v_pre_product_material\\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\\n  WHERE\\n   v_pre_product_material.IS_ISSUED = '1'\\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\\n   AND v_pre_product_material.NI36_TAG = '0'\\n   AND v_pre_product_material.MATERIAL_STATE != '110'\\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\\n   AND NOT EXISTS (\\n  SELECT\\n  1\\n  FROM\\n  v_pre_product_material v2\\n  WHERE\\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\\n  GROUP BY\\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\\n  HAVING\\n  SUM(\\n   CASE\\n  WHEN IS_ISSUED != '1' THEN 1\\n  ELSE 0\\n   END\\n  ) > 0\\n   )\\n  GROUP BY\\n   COALESCE(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   )\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '10' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   NULL AS `PACKAGE_NO`,\\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   1 AS NUMBER,\\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\\n   t_inm_store_info.STORE_ID AS STORE_ID,\\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_inm_store_info.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   t_inm_store_info.VARIETY_ID,\\n   IF (\\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  t_inm_store_info.MATERIAL_LENGTH\\n  ),\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  'C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '30' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\\n   t_pre_product_material.PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   t_pre_product_material.NUMBER AS NUMBER,\\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\\n   t_pre_product_material.STORE_ID AS STORE_ID,\\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\\n   t_pre_product_material.STEEL_GRADE,\\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (t_pre_product_material.LENGTH IS NOT NULL)\\n  AND (t_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*',\\n  t_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   NULL AS NUMBER,\\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\\n   NULL AS GROSS_WT,\\n   '/' AS STORE_ID,\\n   '/' AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_pre_scrap.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   NULL AS specs,\\n   -- 单位测试\\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_pre_scrap.BATCH_NO\\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\\nWHERE\\n  t_dgm_send_info.SEND_STATE = '70'\\n  AND temp.CUSTOMER_ID = '1930921074703462401'\\ngroup by\\n  temp.MIXED_NO\\nhaving\\n  SEND_NUMBER > RETURN_NUMBER\\nLIMIT\\n  100\", \"explain\": \"id\\tselect_type\\ttable\\ttype\\tkey\\trows\\tExtra\\n1\\tPRIMARY\\tt_dgm_send_info\\tALL\\tPRIMARY\\t1000\\tUsing where; Using temporary; Using filesort\\n1\\tPRIMARY\\tt_dgm_send_info_detail\\tref\\tSEND_ID\\t10\\tUsing where\\n1\\tPRIMARY\\t<derived2>\\tref\\t<auto_key0>\\t150\\tUsing where\\n1\\tPRIMARY\\tt_rmm_store\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_rmm_location\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_qdm_standard\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_bdm_column\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_dgm_send_info_return_detail\\tref\\tCONNECT_DETAIL_ID\\t1\\tUsing where\\n2\\tDERIVED\\tv_pre_product_material\\tALL\\tNULL\\t50000\\tUsing where; Using temporary; Using filesort\\n2\\tDERIVED\\tmaterial\\tref\\tMATERIAL_NO\\t1\\tUsing index\\n2\\tDERIVED\\tpackage\\tref\\tPACKAGE_NO\\t1\\tUsing index\\n3\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n3\\tUNION\\tt_sam_contract\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n4\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n5\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t10000\\tUsing where\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,成功应用投影下推规则，消除了UNION ALL临时表中的23个冗余列。优化后临时表宽度从30+列降至6列，预计减少80%以上的I/O和内存占用，尤其在处理大数据量分组场景时性能提升显著。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推优化: (1)将客户ID过滤条件下推到UNION ALL派生表的各个子查询中，提前过滤数据源；(2)将发送状态条件封装在子查询中实现预过滤。避免派生表和连接表处理不必要的数据，减少中间结果集大小\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"HAVING 条件下推,已将HAVING子句中不依赖聚合函数的条件『SEND_NUMBER > RETURN_NUMBER』下推到WHERE子句，减少分组处理的数据量。原始表达式完整复制以保证逻辑等价性。\"}, {\"rule_id\": \"4\", \"difficulty_level\": \"3\", \"rationale\": \"GROUP BY 子句消除,消除冗余的GROUP BY子句，因为分组列temp.MIXED_NO在子查询中已是唯一值。无聚合函数且分组不改变结果集，移除后可避免不必要的排序和临时表创建，提升查询性能。\"}, {\"rule_id\": \"5\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,通过将LEFT JOIN改为INNER JOIN并删除冗余过滤条件，优化连接效率和执行计划。子查询已确保SEND_STATE='70'，INNER JOIN可减少中间结果集大小，同时语义保持不变。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE DATABASE IF NOT EXISTS zjjs_mpm;\nCREATE DATABASE IF NOT EXISTS zjjs_rmm;\nCREATE DATABASE IF NOT EXISTS zjjs_qdm;\nCREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\nCREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\nCREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\nCREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\nCREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\nCREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\nCREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\nCREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\nCREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\nCREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\nCREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\nCREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\nCREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\nCREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\nCREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\n\n## Explain Output in JSON:\nid\tselect_type\ttable\ttype\tkey\trows\tExtra\n1\tPRIMARY\tt_dgm_send_info\tALL\tPRIMARY\t1000\tUsing where; Using temporary; Using filesort\n1\tPRIMARY\tt_dgm_send_info_detail\tref\tSEND_ID\t10\tUsing where\n1\tPRIMARY\t<derived2>\tref\t<auto_key0>\t150\tUsing where\n1\tPRIMARY\tt_rmm_store\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_rmm_location\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_qdm_standard\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_bdm_column\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_dgm_send_info_return_detail\tref\tCONNECT_DETAIL_ID\t1\tUsing where\n2\tDERIVED\tv_pre_product_material\tALL\tNULL\t50000\tUsing where; Using temporary; Using filesort\n2\tDERIVED\tmaterial\tref\tMATERIAL_NO\t1\tUsing index\n2\tDERIVED\tpackage\tref\tPACKAGE_NO\t1\tUsing index\n3\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n3\tUNION\tt_sam_contract\teq_ref\tPRIMARY\t1\tUsing where\n4\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n5\tUNION\tt_sam_contract_detail\tALL\tNULL\t10000\tUsing where\n\n## Original SQL:\nSELECT\n  temp.*,\n  t_rmm_store.STORE_NAME,\n  t_rmm_location.LOCATION_NAME,\n  t_qdm_standard.STANDARD_NAME,\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\n  ) AS `SEND_NUMBER`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\n  ) AS `RETURN_NUMBER`\nFROM\n  t_dgm_send_info_detail\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\n  LEFT JOIN (\n  SELECT\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\n   IFNULL(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   ) AS MIXED_NO,\n   '30' AS SPOT_TYPE,\n   v_pre_product_material.MATERIAL_NO,\n   v_pre_product_material.PACKAGE_NO,\n   v_pre_product_material.PSR_ID,\n   v_pre_product_material.CUSTOMER_ID,\n   v_pre_product_material.CONTRACT_ID,\n   v_pre_product_material.CONTRACT_NO,\n   v_pre_product_material.NUMBER,\n   v_pre_product_material.NET_WEIGHT,\n   v_pre_product_material.GROSS_WT,\n   v_pre_product_material.STORE_ID,\n   v_pre_product_material.LOCATION_ID,\n   v_pre_product_material.STANDARD_ID,\n   v_pre_product_material.STEEL_GRADE,\n   v_pre_product_material.SURFACE_GROUP_DESC,\n   v_pre_product_material.CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (v_pre_product_material.LENGTH IS NOT NULL)\n  AND (v_pre_product_material.LENGTH != 0),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*',\n  v_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   SUM(\n  IF (\n  t_sam_contract_detail.BUY_UNIT = '10',\n  -- 单位测试\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\n  )\n   ) AS `PRICE`\n  FROM\n   v_pre_product_material\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\n  WHERE\n   v_pre_product_material.IS_ISSUED = '1'\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\n   AND v_pre_product_material.NI36_TAG = '0'\n   AND v_pre_product_material.MATERIAL_STATE != '110'\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\n   AND NOT EXISTS (\n  SELECT\n  1\n  FROM\n  v_pre_product_material v2\n  WHERE\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\n  GROUP BY\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\n  HAVING\n  SUM(\n   CASE\n  WHEN IS_ISSUED != '1' THEN 1\n  ELSE 0\n   END\n  ) > 0\n   )\n  GROUP BY\n   COALESCE(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   )\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '10' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   NULL AS `PACKAGE_NO`,\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   1 AS NUMBER,\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\n   t_inm_store_info.STORE_ID AS STORE_ID,\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_inm_store_info.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   t_inm_store_info.VARIETY_ID,\n   IF (\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  t_inm_store_info.MATERIAL_LENGTH\n  ),\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  'C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '30' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\n   t_pre_product_material.PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   t_pre_product_material.NUMBER AS NUMBER,\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\n   t_pre_product_material.STORE_ID AS STORE_ID,\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\n   t_pre_product_material.STEEL_GRADE,\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (t_pre_product_material.LENGTH IS NOT NULL)\n  AND (t_pre_product_material.LENGTH != 0),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*',\n  t_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   NULL AS NUMBER,\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\n   NULL AS GROSS_WT,\n   '/' AS STORE_ID,\n   '/' AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_pre_scrap.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   NULL AS specs,\n   -- 单位测试\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_pre_scrap.BATCH_NO\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\nWHERE\n  t_dgm_send_info.SEND_STATE = '70'\n  AND temp.CUSTOMER_ID = '1930921074703462401'\ngroup by\n  temp.MIXED_NO\nhaving\n  SEND_NUMBER > RETURN_NUMBER\nLIMIT\n  100\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT temp.*,t_rmm_store.STORE_NAME,t_rmm_location.LOCATION_NAME,t_qdm_standard.STANDARD_NAME,t_bdm_column.COLUMN_NAME AS STEEL_GRADE_NAME,t_dgm_send_info.SEND_ID AS CONNECT_ID,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS CONNECT_DETAIL_ID,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0)) AS SEND_NUMBER,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) AS RETURN_NUMBER FROM t_dgm_send_info_detail INNER JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID=t_dgm_send_info_detail.SEND_ID AND t_dgm_send_info.SEND_STATE='70' LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID=t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID INNER JOIN (SELECT v_pre_product_material.PRODUCE_MATERIAL_ID,IFNULL(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) AS MIXED_NO,'30' AS SPOT_TYPE,v_pre_product_material.MATERIAL_NO,v_pre_product_material.PACKAGE_NO,v_pre_product_material.PSR_ID,v_pre_product_material.CUSTOMER_ID,v_pre_product_material.CONTRACT_ID,v_pre_product_material.CONTRACT_NO,v_pre_product_material.NUMBER,v_pre_product_material.NET_WEIGHT,v_pre_product_material.GROSS_WT,v_pre_product_material.STORE_ID,v_pre_product_material.LOCATION_ID,v_pre_product_material.STANDARD_ID,v_pre_product_material.STEEL_GRADE,v_pre_product_material.SURFACE_GROUP_DESC,v_pre_product_material.CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((v_pre_product_material.LENGTH IS NOT NULL) AND (v_pre_product_material.LENGTH!=0),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*',v_pre_product_material.LENGTH),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*C')) AS specs,SUM(IF(t_sam_contract_detail.BUY_UNIT='10',t_sam_contract_detail.TAX_PRICE*v_pre_product_material.NET_WEIGHT,t_sam_contract_detail.TAX_PRICE*IFNULL(t_sam_contract_detail.NUMBER,1))) AS PRICE FROM v_pre_product_material LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID=v_pre_product_material.CONTRACT_DELIVERY_ID LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID=t_sam_contract_detail.CONTRACT_DETAILS_ID WHERE v_pre_product_material.IS_ISSUED='1' AND v_pre_product_material.IS_SPOT_RESOURCE='0' AND v_pre_product_material.NI36_TAG='0' AND v_pre_product_material.MATERIAL_STATE!='110' AND v_pre_product_material.CONTRACT_TYPE!='60' AND v_pre_product_material.CUSTOMER_ID='1930921074703462401' GROUP BY COALESCE(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) UNION ALL SELECT t_sam_contract_detail.CONTRACT_DETAILS_ID AS PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'10' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,NULL AS PACKAGE_NO,t_bdm_column.COLUMN_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,1 AS NUMBER,t_inm_store_info.NEW_WEIGHT AS NET_WEIGHT,t_inm_store_info.GROSS_WT,t_inm_store_info.STORE_ID,t_inm_store_info.LOCATION_ID,NULL AS STANDARD_ID,t_inm_store_info.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,t_inm_store_info.VARIETY_ID,IF(t_inm_store_info.MATERIAL_LENGTH IS NOT NULL AND t_inm_store_info.MATERIAL_LENGTH!=0,CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,t_inm_store_info.MATERIAL_LENGTH),CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,'C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='10' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO=t_sam_contract_detail.PRODUCT_MATERIAL_NO AND t_inm_store_info.STOCK_ID IS NOT NULL LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID=t_bdm_column.COLUMN_ID GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_pre_product_material.PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'30' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,t_pre_product_material.PACKAGE_NO,t_pre_product_material.PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,t_pre_product_material.NUMBER,t_pre_product_material.NET_WEIGHT,t_pre_product_material.GROSS_WT,t_pre_product_material.STORE_ID,t_pre_product_material.LOCATION_ID,t_pre_product_material.STANDARD_ID,t_pre_product_material.STEEL_GRADE,t_pre_product_material.SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((t_pre_product_material.LENGTH IS NOT NULL) AND (t_pre_product_material.LENGTH!=0),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*',t_pre_product_material.LENGTH),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE IN('20','30') AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' INNER JOIN t_pre_product_material ON(t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.PACKAGE_NO OR t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.MATERIAL_NO) AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_sam_contract_detail.SCRAP_INFO_ID AS PRODUCE_MATERIAL_ID,t_pre_scrap.BATCH_NO AS MIXED_NO,t_sam_contract_detail.SPOT_TYPE,t_pre_scrap.BATCH_NO AS MATERIAL_NO,t_pre_scrap.BATCH_NO AS PACKAGE_NO,t_pre_scrap.PRODUCT_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,NULL AS NUMBER,t_pre_scrap.WEIGHT AS NET_WEIGHT,NULL AS GROSS_WT,'/' AS STORE_ID,'/' AS LOCATION_ID,NULL AS STANDARD_ID,t_pre_scrap.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID,NULL AS VARIETY_ID,NULL AS specs,t_pre_scrap.WEIGHT*t_sam_contract_detail.TAX_PRICE AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='40' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID=t_sam_contract_detail.SCRAP_INFO_ID GROUP BY t_pre_scrap.BATCH_NO) as temp ON temp.MIXED_NO=t_dgm_send_info_detail.MIXED_NO LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store ON t_rmm_store.STORE_ID=temp.STORE_ID LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location ON t_rmm_location.LOCATION_ID=temp.LOCATION_ID LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard ON t_qdm_standard.STANDARD_ID=temp.STANDARD_ID LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_bdm_column.COLUMN_ID=temp.STEEL_GRADE GROUP BY temp.MIXED_NO,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID HAVING IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0))>IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) LIMIT 100"
                    }
                ],
                "rule_id": "4"
            },
            {
                "case_id": "42",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"42\", \"db_type\": \"mysql\", \"description\": \"该SQL查询存在显著的性能瓶颈，主要体现为：1. **谓词未下推**：核心过滤条件`CUSTOMER_ID`位于最外层，导致内部巨大的UNION ALL派生表（由四部分组成）必须先全量物化及聚合，无法利用索引提前过滤数据。2. **隐式内连接**：对LEFT JOIN表`t_dgm_send_info`的字段进行了`SEND_STATE='70'`的等值过滤，语义上已变为内连接，但写法可能误导优化器或导致低效的执行路径。3. **冗余的聚合与排序**：外层的`GROUP BY temp.MIXED_NO`在业务逻辑上可能是冗余的（子查询已确保唯一性或JOIN关系未导致膨胀），且`HAVING`子句中包含了本应在WHERE中过滤的非聚合条件，导致了不必要的临时表和排序开销。4. **宽表投影**：派生表输出了大量后续未使用的列，增加了内存和I/O负担。\", \"create_table_statements\": [\"CREATE DATABASE IF NOT EXISTS zjjs_mpm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_rmm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_qdm;\", \"CREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\", \"CREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\", \"CREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\", \"CREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\", \"CREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\", \"CREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\", \"CREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\", \"CREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\", \"CREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\", \"CREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\", \"CREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\"], \"sql\": \"SELECT\\n  temp.*,\\n  t_rmm_store.STORE_NAME,\\n  t_rmm_location.LOCATION_NAME,\\n  t_qdm_standard.STANDARD_NAME,\\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\\n  ) AS `SEND_NUMBER`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\\n  ) AS `RETURN_NUMBER`\\nFROM\\n  t_dgm_send_info_detail\\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\\n  LEFT JOIN (\\n  SELECT\\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\\n   IFNULL(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   ) AS MIXED_NO,\\n   '30' AS SPOT_TYPE,\\n   v_pre_product_material.MATERIAL_NO,\\n   v_pre_product_material.PACKAGE_NO,\\n   v_pre_product_material.PSR_ID,\\n   v_pre_product_material.CUSTOMER_ID,\\n   v_pre_product_material.CONTRACT_ID,\\n   v_pre_product_material.CONTRACT_NO,\\n   v_pre_product_material.NUMBER,\\n   v_pre_product_material.NET_WEIGHT,\\n   v_pre_product_material.GROSS_WT,\\n   v_pre_product_material.STORE_ID,\\n   v_pre_product_material.LOCATION_ID,\\n   v_pre_product_material.STANDARD_ID,\\n   v_pre_product_material.STEEL_GRADE,\\n   v_pre_product_material.SURFACE_GROUP_DESC,\\n   v_pre_product_material.CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (v_pre_product_material.LENGTH IS NOT NULL)\\n  AND (v_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*',\\n  v_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   SUM(\\n  IF (\\n  t_sam_contract_detail.BUY_UNIT = '10',\\n  -- 单位测试\\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\\n  )\\n   ) AS `PRICE`\\n  FROM\\n   v_pre_product_material\\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\\n  WHERE\\n   v_pre_product_material.IS_ISSUED = '1'\\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\\n   AND v_pre_product_material.NI36_TAG = '0'\\n   AND v_pre_product_material.MATERIAL_STATE != '110'\\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\\n   AND NOT EXISTS (\\n  SELECT\\n  1\\n  FROM\\n  v_pre_product_material v2\\n  WHERE\\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\\n  GROUP BY\\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\\n  HAVING\\n  SUM(\\n   CASE\\n  WHEN IS_ISSUED != '1' THEN 1\\n  ELSE 0\\n   END\\n  ) > 0\\n   )\\n  GROUP BY\\n   COALESCE(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   )\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '10' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   NULL AS `PACKAGE_NO`,\\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   1 AS NUMBER,\\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\\n   t_inm_store_info.STORE_ID AS STORE_ID,\\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_inm_store_info.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   t_inm_store_info.VARIETY_ID,\\n   IF (\\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  t_inm_store_info.MATERIAL_LENGTH\\n  ),\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  'C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '30' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\\n   t_pre_product_material.PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   t_pre_product_material.NUMBER AS NUMBER,\\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\\n   t_pre_product_material.STORE_ID AS STORE_ID,\\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\\n   t_pre_product_material.STEEL_GRADE,\\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (t_pre_product_material.LENGTH IS NOT NULL)\\n  AND (t_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*',\\n  t_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   NULL AS NUMBER,\\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\\n   NULL AS GROSS_WT,\\n   '/' AS STORE_ID,\\n   '/' AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_pre_scrap.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   NULL AS specs,\\n   -- 单位测试\\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_pre_scrap.BATCH_NO\\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\\nWHERE\\n  t_dgm_send_info.SEND_STATE = '70'\\n  AND temp.CUSTOMER_ID = '1930921074703462401'\\ngroup by\\n  temp.MIXED_NO\\nhaving\\n  SEND_NUMBER > RETURN_NUMBER\\nLIMIT\\n  100\", \"explain\": \"id\\tselect_type\\ttable\\ttype\\tkey\\trows\\tExtra\\n1\\tPRIMARY\\tt_dgm_send_info\\tALL\\tPRIMARY\\t1000\\tUsing where; Using temporary; Using filesort\\n1\\tPRIMARY\\tt_dgm_send_info_detail\\tref\\tSEND_ID\\t10\\tUsing where\\n1\\tPRIMARY\\t<derived2>\\tref\\t<auto_key0>\\t150\\tUsing where\\n1\\tPRIMARY\\tt_rmm_store\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_rmm_location\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_qdm_standard\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_bdm_column\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_dgm_send_info_return_detail\\tref\\tCONNECT_DETAIL_ID\\t1\\tUsing where\\n2\\tDERIVED\\tv_pre_product_material\\tALL\\tNULL\\t50000\\tUsing where; Using temporary; Using filesort\\n2\\tDERIVED\\tmaterial\\tref\\tMATERIAL_NO\\t1\\tUsing index\\n2\\tDERIVED\\tpackage\\tref\\tPACKAGE_NO\\t1\\tUsing index\\n3\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n3\\tUNION\\tt_sam_contract\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n4\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n5\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t10000\\tUsing where\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,成功应用投影下推规则，消除了UNION ALL临时表中的23个冗余列。优化后临时表宽度从30+列降至6列，预计减少80%以上的I/O和内存占用，尤其在处理大数据量分组场景时性能提升显著。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推优化: (1)将客户ID过滤条件下推到UNION ALL派生表的各个子查询中，提前过滤数据源；(2)将发送状态条件封装在子查询中实现预过滤。避免派生表和连接表处理不必要的数据，减少中间结果集大小\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"HAVING 条件下推,已将HAVING子句中不依赖聚合函数的条件『SEND_NUMBER > RETURN_NUMBER』下推到WHERE子句，减少分组处理的数据量。原始表达式完整复制以保证逻辑等价性。\"}, {\"rule_id\": \"4\", \"difficulty_level\": \"3\", \"rationale\": \"GROUP BY 子句消除,消除冗余的GROUP BY子句，因为分组列temp.MIXED_NO在子查询中已是唯一值。无聚合函数且分组不改变结果集，移除后可避免不必要的排序和临时表创建，提升查询性能。\"}, {\"rule_id\": \"5\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,通过将LEFT JOIN改为INNER JOIN并删除冗余过滤条件，优化连接效率和执行计划。子查询已确保SEND_STATE='70'，INNER JOIN可减少中间结果集大小，同时语义保持不变。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE DATABASE IF NOT EXISTS zjjs_mpm;\nCREATE DATABASE IF NOT EXISTS zjjs_rmm;\nCREATE DATABASE IF NOT EXISTS zjjs_qdm;\nCREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\nCREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\nCREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\nCREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\nCREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\nCREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\nCREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\nCREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\nCREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\nCREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\nCREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\nCREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\nCREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\nCREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\nCREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\n\n## Explain Output in JSON:\nid\tselect_type\ttable\ttype\tkey\trows\tExtra\n1\tPRIMARY\tt_dgm_send_info\tALL\tPRIMARY\t1000\tUsing where; Using temporary; Using filesort\n1\tPRIMARY\tt_dgm_send_info_detail\tref\tSEND_ID\t10\tUsing where\n1\tPRIMARY\t<derived2>\tref\t<auto_key0>\t150\tUsing where\n1\tPRIMARY\tt_rmm_store\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_rmm_location\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_qdm_standard\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_bdm_column\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_dgm_send_info_return_detail\tref\tCONNECT_DETAIL_ID\t1\tUsing where\n2\tDERIVED\tv_pre_product_material\tALL\tNULL\t50000\tUsing where; Using temporary; Using filesort\n2\tDERIVED\tmaterial\tref\tMATERIAL_NO\t1\tUsing index\n2\tDERIVED\tpackage\tref\tPACKAGE_NO\t1\tUsing index\n3\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n3\tUNION\tt_sam_contract\teq_ref\tPRIMARY\t1\tUsing where\n4\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n5\tUNION\tt_sam_contract_detail\tALL\tNULL\t10000\tUsing where\n\n## Original SQL:\nSELECT\n  temp.*,\n  t_rmm_store.STORE_NAME,\n  t_rmm_location.LOCATION_NAME,\n  t_qdm_standard.STANDARD_NAME,\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\n  ) AS `SEND_NUMBER`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\n  ) AS `RETURN_NUMBER`\nFROM\n  t_dgm_send_info_detail\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\n  LEFT JOIN (\n  SELECT\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\n   IFNULL(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   ) AS MIXED_NO,\n   '30' AS SPOT_TYPE,\n   v_pre_product_material.MATERIAL_NO,\n   v_pre_product_material.PACKAGE_NO,\n   v_pre_product_material.PSR_ID,\n   v_pre_product_material.CUSTOMER_ID,\n   v_pre_product_material.CONTRACT_ID,\n   v_pre_product_material.CONTRACT_NO,\n   v_pre_product_material.NUMBER,\n   v_pre_product_material.NET_WEIGHT,\n   v_pre_product_material.GROSS_WT,\n   v_pre_product_material.STORE_ID,\n   v_pre_product_material.LOCATION_ID,\n   v_pre_product_material.STANDARD_ID,\n   v_pre_product_material.STEEL_GRADE,\n   v_pre_product_material.SURFACE_GROUP_DESC,\n   v_pre_product_material.CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (v_pre_product_material.LENGTH IS NOT NULL)\n  AND (v_pre_product_material.LENGTH != 0),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*',\n  v_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   SUM(\n  IF (\n  t_sam_contract_detail.BUY_UNIT = '10',\n  -- 单位测试\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\n  )\n   ) AS `PRICE`\n  FROM\n   v_pre_product_material\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\n  WHERE\n   v_pre_product_material.IS_ISSUED = '1'\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\n   AND v_pre_product_material.NI36_TAG = '0'\n   AND v_pre_product_material.MATERIAL_STATE != '110'\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\n   AND NOT EXISTS (\n  SELECT\n  1\n  FROM\n  v_pre_product_material v2\n  WHERE\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\n  GROUP BY\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\n  HAVING\n  SUM(\n   CASE\n  WHEN IS_ISSUED != '1' THEN 1\n  ELSE 0\n   END\n  ) > 0\n   )\n  GROUP BY\n   COALESCE(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   )\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '10' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   NULL AS `PACKAGE_NO`,\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   1 AS NUMBER,\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\n   t_inm_store_info.STORE_ID AS STORE_ID,\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_inm_store_info.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   t_inm_store_info.VARIETY_ID,\n   IF (\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  t_inm_store_info.MATERIAL_LENGTH\n  ),\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  'C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '30' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\n   t_pre_product_material.PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   t_pre_product_material.NUMBER AS NUMBER,\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\n   t_pre_product_material.STORE_ID AS STORE_ID,\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\n   t_pre_product_material.STEEL_GRADE,\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (t_pre_product_material.LENGTH IS NOT NULL)\n  AND (t_pre_product_material.LENGTH != 0),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*',\n  t_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   NULL AS NUMBER,\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\n   NULL AS GROSS_WT,\n   '/' AS STORE_ID,\n   '/' AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_pre_scrap.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   NULL AS specs,\n   -- 单位测试\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_pre_scrap.BATCH_NO\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\nWHERE\n  t_dgm_send_info.SEND_STATE = '70'\n  AND temp.CUSTOMER_ID = '1930921074703462401'\ngroup by\n  temp.MIXED_NO\nhaving\n  SEND_NUMBER > RETURN_NUMBER\nLIMIT\n  100\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT temp.*,t_rmm_store.STORE_NAME,t_rmm_location.LOCATION_NAME,t_qdm_standard.STANDARD_NAME,t_bdm_column.COLUMN_NAME AS STEEL_GRADE_NAME,t_dgm_send_info.SEND_ID AS CONNECT_ID,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS CONNECT_DETAIL_ID,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0)) AS SEND_NUMBER,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) AS RETURN_NUMBER FROM t_dgm_send_info_detail INNER JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID=t_dgm_send_info_detail.SEND_ID AND t_dgm_send_info.SEND_STATE='70' LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID=t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID INNER JOIN (SELECT v_pre_product_material.PRODUCE_MATERIAL_ID,IFNULL(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) AS MIXED_NO,'30' AS SPOT_TYPE,v_pre_product_material.MATERIAL_NO,v_pre_product_material.PACKAGE_NO,v_pre_product_material.PSR_ID,v_pre_product_material.CUSTOMER_ID,v_pre_product_material.CONTRACT_ID,v_pre_product_material.CONTRACT_NO,v_pre_product_material.NUMBER,v_pre_product_material.NET_WEIGHT,v_pre_product_material.GROSS_WT,v_pre_product_material.STORE_ID,v_pre_product_material.LOCATION_ID,v_pre_product_material.STANDARD_ID,v_pre_product_material.STEEL_GRADE,v_pre_product_material.SURFACE_GROUP_DESC,v_pre_product_material.CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((v_pre_product_material.LENGTH IS NOT NULL) AND (v_pre_product_material.LENGTH!=0),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*',v_pre_product_material.LENGTH),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*C')) AS specs,SUM(IF(t_sam_contract_detail.BUY_UNIT='10',t_sam_contract_detail.TAX_PRICE*v_pre_product_material.NET_WEIGHT,t_sam_contract_detail.TAX_PRICE*IFNULL(t_sam_contract_detail.NUMBER,1))) AS PRICE FROM v_pre_product_material LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID=v_pre_product_material.CONTRACT_DELIVERY_ID LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID=t_sam_contract_detail.CONTRACT_DETAILS_ID WHERE v_pre_product_material.IS_ISSUED='1' AND v_pre_product_material.IS_SPOT_RESOURCE='0' AND v_pre_product_material.NI36_TAG='0' AND v_pre_product_material.MATERIAL_STATE!='110' AND v_pre_product_material.CONTRACT_TYPE!='60' AND v_pre_product_material.CUSTOMER_ID='1930921074703462401' GROUP BY COALESCE(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) UNION ALL SELECT t_sam_contract_detail.CONTRACT_DETAILS_ID AS PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'10' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,NULL AS PACKAGE_NO,t_bdm_column.COLUMN_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,1 AS NUMBER,t_inm_store_info.NEW_WEIGHT AS NET_WEIGHT,t_inm_store_info.GROSS_WT,t_inm_store_info.STORE_ID,t_inm_store_info.LOCATION_ID,NULL AS STANDARD_ID,t_inm_store_info.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,t_inm_store_info.VARIETY_ID,IF(t_inm_store_info.MATERIAL_LENGTH IS NOT NULL AND t_inm_store_info.MATERIAL_LENGTH!=0,CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,t_inm_store_info.MATERIAL_LENGTH),CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,'C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='10' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO=t_sam_contract_detail.PRODUCT_MATERIAL_NO AND t_inm_store_info.STOCK_ID IS NOT NULL LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID=t_bdm_column.COLUMN_ID GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_pre_product_material.PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'30' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,t_pre_product_material.PACKAGE_NO,t_pre_product_material.PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,t_pre_product_material.NUMBER,t_pre_product_material.NET_WEIGHT,t_pre_product_material.GROSS_WT,t_pre_product_material.STORE_ID,t_pre_product_material.LOCATION_ID,t_pre_product_material.STANDARD_ID,t_pre_product_material.STEEL_GRADE,t_pre_product_material.SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((t_pre_product_material.LENGTH IS NOT NULL) AND (t_pre_product_material.LENGTH!=0),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*',t_pre_product_material.LENGTH),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE IN('20','30') AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' INNER JOIN t_pre_product_material ON(t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.PACKAGE_NO OR t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.MATERIAL_NO) AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_sam_contract_detail.SCRAP_INFO_ID AS PRODUCE_MATERIAL_ID,t_pre_scrap.BATCH_NO AS MIXED_NO,t_sam_contract_detail.SPOT_TYPE,t_pre_scrap.BATCH_NO AS MATERIAL_NO,t_pre_scrap.BATCH_NO AS PACKAGE_NO,t_pre_scrap.PRODUCT_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,NULL AS NUMBER,t_pre_scrap.WEIGHT AS NET_WEIGHT,NULL AS GROSS_WT,'/' AS STORE_ID,'/' AS LOCATION_ID,NULL AS STANDARD_ID,t_pre_scrap.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID,NULL AS VARIETY_ID,NULL AS specs,t_pre_scrap.WEIGHT*t_sam_contract_detail.TAX_PRICE AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='40' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID=t_sam_contract_detail.SCRAP_INFO_ID GROUP BY t_pre_scrap.BATCH_NO) as temp ON temp.MIXED_NO=t_dgm_send_info_detail.MIXED_NO LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store ON t_rmm_store.STORE_ID=temp.STORE_ID LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location ON t_rmm_location.LOCATION_ID=temp.LOCATION_ID LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard ON t_qdm_standard.STANDARD_ID=temp.STANDARD_ID LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_bdm_column.COLUMN_ID=temp.STEEL_GRADE GROUP BY temp.MIXED_NO,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID HAVING IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0))>IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) LIMIT 100"
                    }
                ],
                "rule_id": "5"
            },
            {
                "case_id": "43",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"43\", \"db_type\": \"mysql\", \"description\": \"改写前的SQL在子查询条件（col_pk_varchar）中使用了数值字面量进行范围查询（BETWEEN 192 AND 171），而col_pk_varchar列是VARCHAR类型。MySQL在比较不同类型时可能触发类型隐式转换，导致索引失效（本次场景中未失效但引发了多余扫描）。改写后显式使用字符串字面量（BETWEEN '192' AND '171'），确保类型一致，使优化器能准确评估区间有效性。同时，由于数字192大于171，字符集下同样不成立，优化器能立即识别并跳过该子查询扫描。\", \"create_table_statements\": [\"CREATE TABLE dble_jumpstringhash_int_1 (col_int_auto_increment INT NOT NULL AUTO_INCREMENT, col_pk_char CHAR(1) NOT NULL, col_pk_varchar VARCHAR(100) NOT NULL, col_pk_date DATE NOT NULL, col_pk_decimal_not_null DECIMAL(10,0) NOT NULL, col_pk_numeric_not_null DECIMAL(10,0) NOT NULL, col_int_not_null INT NOT NULL, col_int_not_null__1 INT NOT NULL, col_int_8_not_null TINYINT NOT NULL, col_int_8_not_null__1 TINYINT NOT NULL, col_bigint_not_null BIGINT NOT NULL, col_smallint_not_null SMALLINT NOT NULL, col_tinyint_not_null TINYINT NOT NULL, col_float_not_null FLOAT NOT NULL, col_double_not_null DOUBLE NOT NULL, col_decimal_not_null DECIMAL(10,0) NOT NULL, col_numeric_not_null DECIMAL(10,0) NOT NULL, col_bit_not_null BIT(1) NOT NULL, col_bit_not_null__1 BIT(1) NOT NULL, col_char_3_not_null CHAR(3) NOT NULL, col_char_255_not_null CHAR(255) NOT NULL, col_varchar_1_not_null VARCHAR(1) NOT NULL, col_varchar_64_not_null VARCHAR(64) NOT NULL, col_varchar_2048_not_null VARCHAR(2048) NOT NULL, col_binary_8_not_null BINARY(8) NOT NULL, col_varbinary_8_not_null VARBINARY(8) NOT NULL, col_date_not_null DATE NOT NULL, col_time_not_null TIME NOT NULL, col_datetime_not_null DATETIME NOT NULL, col_year_not_null YEAR NOT NULL, col_text_not_null TEXT NOT NULL, col_bool_not_null TINYINT(1) NOT NULL, col_boolean_not_null TINYINT(1) NOT NULL, col_longtext_not_null LONGTEXT NOT NULL, col_mediumtext_not_null MEDIUMTEXT NOT NULL, col_tinyblob_not_null TINYBLOB NOT NULL, col_mediumblob_not_null MEDIUMBLOB NOT NULL, col_longblob_not_null LONGBLOB NOT NULL, col_blob_not_null BLOB NOT NULL, PRIMARY KEY (col_int_auto_increment, col_pk_char, col_pk_varchar, col_pk_date, col_pk_decimal_not_null, col_pk_numeric_not_null)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_dble_jumpstringhash_int_1_col_varchar_64_not_null ON dble_jumpstringhash_int_1(col_varchar_64_not_null);\", \"CREATE TABLE dble_stringhash_datetime_2 (col_pk_varchar VARCHAR(100) NOT NULL, PRIMARY KEY (col_pk_varchar)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_dble_stringhash_datetime_2_col_pk_varchar ON dble_stringhash_datetime_2(col_pk_varchar);\"], \"sql\": \"SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM ( SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM dble_jumpstringhash_int_1 WHERE NOT EXISTS (SELECT 1 FROM dble_stringhash_datetime_2 WHERE col_pk_varchar BETWEEN 192 AND 171) ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39 LIMIT 97 OFFSET 5) AS t WHERE col_varchar_64_not_null LIKE '%p%' ORDER BY col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null DESC LIMIT 215 OFFSET 3;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t102\\t11.11\\tUsing where; Using temporary; Using filesort\\n2\\tDERIVED\\tdble_jumpstringhash_int_1\\t\\tALL\\t\\t\\t\\t\\t416710\\t100.0\\tUsing filesort\\n3\\tSUBQUERY\\tdble_stringhash_datetime_2\\t\\tindex\\tPRIMARY,idx_dble_stringhash_datetime_2_col_pk_varchar\\tPRIMARY\\t402\\t\\t505934\\t11.11\\tUsing where; Using index\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"25.31\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_filesort\\\": false,\\n  \\\"duplicates_removal\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"11.33\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"t\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 102,\\n  \\\"rows_produced_per_join\\\": 11,\\n  \\\"filtered\\\": \\\"11.11\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"12.84\\\",\\n  \\\"eval_cost\\\": \\\"1.13\\\",\\n  \\\"prefix_cost\\\": \\\"13.98\\\",\\n  \\\"data_read_per_join\\\": \\\"111K\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"col_int_auto_increment\\\",\\n  \\\"col_pk_char\\\",\\n  \\\"col_pk_varchar\\\",\\n  \\\"col_pk_date\\\",\\n  \\\"col_pk_decimal_not_null\\\",\\n  \\\"col_pk_numeric_not_null\\\",\\n  \\\"col_int_not_null\\\",\\n  \\\"col_int_not_null__1\\\",\\n  \\\"col_int_8_not_null\\\",\\n  \\\"col_int_8_not_null__1\\\",\\n  \\\"col_bigint_not_null\\\",\\n  \\\"col_smallint_not_null\\\",\\n  \\\"col_tinyint_not_null\\\",\\n  \\\"col_float_not_null\\\",\\n  \\\"col_double_not_null\\\",\\n  \\\"col_decimal_not_null\\\",\\n  \\\"col_numeric_not_null\\\",\\n  \\\"col_bit_not_null\\\",\\n  \\\"col_bit_not_null__1\\\",\\n  \\\"col_char_3_not_null\\\",\\n  \\\"col_char_255_not_null\\\",\\n  \\\"col_varchar_1_not_null\\\",\\n  \\\"col_varchar_64_not_null\\\",\\n  \\\"col_varchar_2048_not_null\\\",\\n  \\\"col_binary_8_not_null\\\",\\n  \\\"col_varbinary_8_not_null\\\",\\n  \\\"col_date_not_null\\\",\\n  \\\"col_time_not_null\\\",\\n  \\\"col_datetime_not_null\\\",\\n  \\\"col_year_not_null\\\",\\n  \\\"col_text_not_null\\\",\\n  \\\"col_bool_not_null\\\",\\n  \\\"col_boolean_not_null\\\",\\n  \\\"col_longtext_not_null\\\",\\n  \\\"col_mediumtext_not_null\\\",\\n  \\\"col_tinyblob_not_null\\\",\\n  \\\"col_mediumblob_not_null\\\",\\n  \\\"col_longblob_not_null\\\",\\n  \\\"col_blob_not_null\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`t`.`col_varchar_64_not_null` like '%p%')\\\",\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"121752.86\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_filesort\\\": true,\\n  \\\"duplicates_removal\\\": {\\n  \\\"using_filesort\\\": false,\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"dble_jumpstringhash_int_1\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 416710,\\n  \\\"rows_produced_per_join\\\": 416710,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"80081.86\\\",\\n  \\\"eval_cost\\\": \\\"41671.00\\\",\\n  \\\"prefix_cost\\\": \\\"121752.86\\\",\\n  \\\"data_read_per_join\\\": \\\"3G\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"col_int_auto_increment\\\",\\n  \\\"col_pk_char\\\",\\n  \\\"col_pk_varchar\\\",\\n  \\\"col_pk_date\\\",\\n  \\\"col_pk_decimal_not_null\\\",\\n  \\\"col_pk_numeric_not_null\\\",\\n  \\\"col_int_not_null\\\",\\n  \\\"col_int_not_null__1\\\",\\n  \\\"col_int_8_not_null\\\",\\n  \\\"col_int_8_not_null__1\\\",\\n  \\\"col_bigint_not_null\\\",\\n  \\\"col_smallint_not_null\\\",\\n  \\\"col_tinyint_not_null\\\",\\n  \\\"col_float_not_null\\\",\\n  \\\"col_double_not_null\\\",\\n  \\\"col_decimal_not_null\\\",\\n  \\\"col_numeric_not_null\\\",\\n  \\\"col_bit_not_null\\\",\\n  \\\"col_bit_not_null__1\\\",\\n  \\\"col_char_3_not_null\\\",\\n  \\\"col_char_255_not_null\\\",\\n  \\\"col_varchar_1_not_null\\\",\\n  \\\"col_varchar_64_not_null\\\",\\n  \\\"col_varchar_2048_not_null\\\",\\n  \\\"col_binary_8_not_null\\\",\\n  \\\"col_varbinary_8_not_null\\\",\\n  \\\"col_date_not_null\\\",\\n  \\\"col_time_not_null\\\",\\n  \\\"col_datetime_not_null\\\",\\n  \\\"col_year_not_null\\\",\\n  \\\"col_text_not_null\\\",\\n  \\\"col_bool_not_null\\\",\\n  \\\"col_boolean_not_null\\\",\\n  \\\"col_longtext_not_null\\\",\\n  \\\"col_mediumtext_not_null\\\",\\n  \\\"col_tinyblob_not_null\\\",\\n  \\\"col_mediumblob_not_null\\\",\\n  \\\"col_longblob_not_null\\\",\\n  \\\"col_blob_not_null\\\"\\n  ]\\n  },\\n  \\\"optimized_away_subqueries\\\": [\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"51146.65\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"dble_stringhash_datetime_2\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_dble_stringhash_datetime_2_col_pk_varchar\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"col_pk_varchar\\\"\\n  ],\\n  \\\"key_length\\\": \\\"402\\\",\\n  \\\"rows_examined_per_scan\\\": 505934,\\n  \\\"rows_produced_per_join\\\": 56209,\\n  \\\"filtered\\\": \\\"11.11\\\",\\n  \\\"using_index\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"45525.72\\\",\\n  \\\"eval_cost\\\": \\\"5620.93\\\",\\n  \\\"prefix_cost\\\": \\\"51146.65\\\",\\n  \\\"data_read_per_join\\\": \\\"21M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"col_pk_varchar\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`dble_jumpstringhash_int`.`dble_stringhash_datetime_2`.`col_pk_varchar` between 192 and 171)\\\"\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,通过将子查询中的整数常量转换为字符串常量，避免了字段的隐式转换，优化了查询性能。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE dble_jumpstringhash_int_1 (col_int_auto_increment INT NOT NULL AUTO_INCREMENT, col_pk_char CHAR(1) NOT NULL, col_pk_varchar VARCHAR(100) NOT NULL, col_pk_date DATE NOT NULL, col_pk_decimal_not_null DECIMAL(10,0) NOT NULL, col_pk_numeric_not_null DECIMAL(10,0) NOT NULL, col_int_not_null INT NOT NULL, col_int_not_null__1 INT NOT NULL, col_int_8_not_null TINYINT NOT NULL, col_int_8_not_null__1 TINYINT NOT NULL, col_bigint_not_null BIGINT NOT NULL, col_smallint_not_null SMALLINT NOT NULL, col_tinyint_not_null TINYINT NOT NULL, col_float_not_null FLOAT NOT NULL, col_double_not_null DOUBLE NOT NULL, col_decimal_not_null DECIMAL(10,0) NOT NULL, col_numeric_not_null DECIMAL(10,0) NOT NULL, col_bit_not_null BIT(1) NOT NULL, col_bit_not_null__1 BIT(1) NOT NULL, col_char_3_not_null CHAR(3) NOT NULL, col_char_255_not_null CHAR(255) NOT NULL, col_varchar_1_not_null VARCHAR(1) NOT NULL, col_varchar_64_not_null VARCHAR(64) NOT NULL, col_varchar_2048_not_null VARCHAR(2048) NOT NULL, col_binary_8_not_null BINARY(8) NOT NULL, col_varbinary_8_not_null VARBINARY(8) NOT NULL, col_date_not_null DATE NOT NULL, col_time_not_null TIME NOT NULL, col_datetime_not_null DATETIME NOT NULL, col_year_not_null YEAR NOT NULL, col_text_not_null TEXT NOT NULL, col_bool_not_null TINYINT(1) NOT NULL, col_boolean_not_null TINYINT(1) NOT NULL, col_longtext_not_null LONGTEXT NOT NULL, col_mediumtext_not_null MEDIUMTEXT NOT NULL, col_tinyblob_not_null TINYBLOB NOT NULL, col_mediumblob_not_null MEDIUMBLOB NOT NULL, col_longblob_not_null LONGBLOB NOT NULL, col_blob_not_null BLOB NOT NULL, PRIMARY KEY (col_int_auto_increment, col_pk_char, col_pk_varchar, col_pk_date, col_pk_decimal_not_null, col_pk_numeric_not_null)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_dble_jumpstringhash_int_1_col_varchar_64_not_null ON dble_jumpstringhash_int_1(col_varchar_64_not_null);\nCREATE TABLE dble_stringhash_datetime_2 (col_pk_varchar VARCHAR(100) NOT NULL, PRIMARY KEY (col_pk_varchar)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_dble_stringhash_datetime_2_col_pk_varchar ON dble_stringhash_datetime_2(col_pk_varchar);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t102\t11.11\tUsing where; Using temporary; Using filesort\n2\tDERIVED\tdble_jumpstringhash_int_1\t\tALL\t\t\t\t\t416710\t100.0\tUsing filesort\n3\tSUBQUERY\tdble_stringhash_datetime_2\t\tindex\tPRIMARY,idx_dble_stringhash_datetime_2_col_pk_varchar\tPRIMARY\t402\t\t505934\t11.11\tUsing where; Using index\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"25.31\"\n  },\n  \"ordering_operation\": {\n  \"using_filesort\": false,\n  \"duplicates_removal\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": true,\n  \"cost_info\": {\n  \"sort_cost\": \"11.33\"\n  },\n  \"table\": {\n  \"table_name\": \"t\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 102,\n  \"rows_produced_per_join\": 11,\n  \"filtered\": \"11.11\",\n  \"cost_info\": {\n  \"read_cost\": \"12.84\",\n  \"eval_cost\": \"1.13\",\n  \"prefix_cost\": \"13.98\",\n  \"data_read_per_join\": \"111K\"\n  },\n  \"used_columns\": [\n  \"col_int_auto_increment\",\n  \"col_pk_char\",\n  \"col_pk_varchar\",\n  \"col_pk_date\",\n  \"col_pk_decimal_not_null\",\n  \"col_pk_numeric_not_null\",\n  \"col_int_not_null\",\n  \"col_int_not_null__1\",\n  \"col_int_8_not_null\",\n  \"col_int_8_not_null__1\",\n  \"col_bigint_not_null\",\n  \"col_smallint_not_null\",\n  \"col_tinyint_not_null\",\n  \"col_float_not_null\",\n  \"col_double_not_null\",\n  \"col_decimal_not_null\",\n  \"col_numeric_not_null\",\n  \"col_bit_not_null\",\n  \"col_bit_not_null__1\",\n  \"col_char_3_not_null\",\n  \"col_char_255_not_null\",\n  \"col_varchar_1_not_null\",\n  \"col_varchar_64_not_null\",\n  \"col_varchar_2048_not_null\",\n  \"col_binary_8_not_null\",\n  \"col_varbinary_8_not_null\",\n  \"col_date_not_null\",\n  \"col_time_not_null\",\n  \"col_datetime_not_null\",\n  \"col_year_not_null\",\n  \"col_text_not_null\",\n  \"col_bool_not_null\",\n  \"col_boolean_not_null\",\n  \"col_longtext_not_null\",\n  \"col_mediumtext_not_null\",\n  \"col_tinyblob_not_null\",\n  \"col_mediumblob_not_null\",\n  \"col_longblob_not_null\",\n  \"col_blob_not_null\"\n  ],\n  \"attached_condition\": \"(`t`.`col_varchar_64_not_null` like '%p%')\",\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"121752.86\"\n  },\n  \"ordering_operation\": {\n  \"using_filesort\": true,\n  \"duplicates_removal\": {\n  \"using_filesort\": false,\n  \"table\": {\n  \"table_name\": \"dble_jumpstringhash_int_1\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 416710,\n  \"rows_produced_per_join\": 416710,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"80081.86\",\n  \"eval_cost\": \"41671.00\",\n  \"prefix_cost\": \"121752.86\",\n  \"data_read_per_join\": \"3G\"\n  },\n  \"used_columns\": [\n  \"col_int_auto_increment\",\n  \"col_pk_char\",\n  \"col_pk_varchar\",\n  \"col_pk_date\",\n  \"col_pk_decimal_not_null\",\n  \"col_pk_numeric_not_null\",\n  \"col_int_not_null\",\n  \"col_int_not_null__1\",\n  \"col_int_8_not_null\",\n  \"col_int_8_not_null__1\",\n  \"col_bigint_not_null\",\n  \"col_smallint_not_null\",\n  \"col_tinyint_not_null\",\n  \"col_float_not_null\",\n  \"col_double_not_null\",\n  \"col_decimal_not_null\",\n  \"col_numeric_not_null\",\n  \"col_bit_not_null\",\n  \"col_bit_not_null__1\",\n  \"col_char_3_not_null\",\n  \"col_char_255_not_null\",\n  \"col_varchar_1_not_null\",\n  \"col_varchar_64_not_null\",\n  \"col_varchar_2048_not_null\",\n  \"col_binary_8_not_null\",\n  \"col_varbinary_8_not_null\",\n  \"col_date_not_null\",\n  \"col_time_not_null\",\n  \"col_datetime_not_null\",\n  \"col_year_not_null\",\n  \"col_text_not_null\",\n  \"col_bool_not_null\",\n  \"col_boolean_not_null\",\n  \"col_longtext_not_null\",\n  \"col_mediumtext_not_null\",\n  \"col_tinyblob_not_null\",\n  \"col_mediumblob_not_null\",\n  \"col_longblob_not_null\",\n  \"col_blob_not_null\"\n  ]\n  },\n  \"optimized_away_subqueries\": [\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"51146.65\"\n  },\n  \"table\": {\n  \"table_name\": \"dble_stringhash_datetime_2\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_dble_stringhash_datetime_2_col_pk_varchar\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"col_pk_varchar\"\n  ],\n  \"key_length\": \"402\",\n  \"rows_examined_per_scan\": 505934,\n  \"rows_produced_per_join\": 56209,\n  \"filtered\": \"11.11\",\n  \"using_index\": true,\n  \"cost_info\": {\n  \"read_cost\": \"45525.72\",\n  \"eval_cost\": \"5620.93\",\n  \"prefix_cost\": \"51146.65\",\n  \"data_read_per_join\": \"21M\"\n  },\n  \"used_columns\": [\n  \"col_pk_varchar\"\n  ],\n  \"attached_condition\": \"(`dble_jumpstringhash_int`.`dble_stringhash_datetime_2`.`col_pk_varchar` between 192 and 171)\"\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n}\n\n## Original SQL:\nSELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM ( SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM dble_jumpstringhash_int_1 WHERE NOT EXISTS (SELECT 1 FROM dble_stringhash_datetime_2 WHERE col_pk_varchar BETWEEN 192 AND 171) ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39 LIMIT 97 OFFSET 5) AS t WHERE col_varchar_64_not_null LIKE '%p%' ORDER BY col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null DESC LIMIT 215 OFFSET 3;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM (SELECT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM dble_jumpstringhash_int_1 ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39 LIMIT 97 OFFSET 5) AS t WHERE col_varchar_64_not_null LIKE '%p%' ORDER BY col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null DESC LIMIT 215 OFFSET 3;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "44",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"44\", \"db_type\": \"mysql\", \"description\": \"该改写方法消除了UNION ALL结构，避免了重复扫描表和创建临时表的开销。核心策略是将两个分支的冲突条件（一个包含特定uuid列表且无视private，另一个排除该列表且要求private=0）用OR组合起来，集成到同一个查询中。同时保持非重复性过滤条件（如全文检索和标签过滤）在最外层执行一次，避免了冗余操作。\", \"create_table_statements\": [\"CREATE TABLE document_template (id VARCHAR(36) PRIMARY KEY, title VARCHAR(255) NOT NULL, owner_id VARCHAR(36) NOT NULL, private TINYINT(1) NOT NULL DEFAULT 0, deleted_at TIMESTAMP NULL DEFAULT NULL, FULLTEXT INDEX idx_title (title)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_owner_id ON document_template(owner_id);\", \"CREATE INDEX idx_deleted_at ON document_template(deleted_at);\", \"CREATE INDEX idx_private ON document_template(private);\", \"CREATE TABLE `user` (id VARCHAR(36) PRIMARY KEY, uuid VARCHAR(36) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_uuid ON `user`(uuid);\", \"CREATE TABLE tag_thing (document_template_id VARCHAR(36) NOT NULL, tag_id VARCHAR(36) NOT NULL, deleted_at TIMESTAMP NULL DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_document_template_id ON tag_thing(document_template_id);\", \"CREATE INDEX idx_tag_id ON tag_thing(tag_id);\", \"CREATE INDEX idx_deleted_at ON tag_thing(deleted_at);\"], \"sql\": \"(SELECT d.id, d.title\\r\\n  FROM document_template d\\r\\n  JOIN `user` u ON u.id = d.owner_id\\r\\n  WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\\r\\n  SELECT 1 FROM tag_thing tt0\\r\\n  WHERE tt0.document_template_id = d.id\\r\\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\\r\\n  AND tt0.deleted_at IS NULL\\r\\n  )) UNION ALL (SELECT d.id, d.title\\r\\n  FROM document_template d\\r\\n  JOIN `user` u ON u.id = d.owner_id\\r\\n  WHERE d.private = 0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\\r\\n  SELECT 1 FROM tag_thing tt0\\r\\n  WHERE tt0.document_template_id = d.id\\r\\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\\r\\n  AND tt0.deleted_at IS NULL\\r\\n  )) ORDER BY title ASC LIMIT 10 OFFSET 0;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\td\\t\\tfulltext\\tPRIMARY,idx_owner_id,idx_deleted_at,idx_title\\tidx_title\\t0\\tconst\\t1\\t18.14\\tUsing where; Ft_hints: rank > 0\\n1\\tPRIMARY\\tu\\t\\teq_ref\\tPRIMARY,idx_uuid\\tPRIMARY\\t146\\ttest_db.d.owner_id\\t1\\t5.0\\tUsing where\\n1\\tPRIMARY\\ttt0\\t\\tref\\tidx_document_template_id,idx_tag_id,idx_deleted_at\\tidx_document_template_id\\t146\\ttest_db.d.id\\t4\\t25.0\\tUsing where; FirstMatch(u)\\n3\\tUNION\\td\\t\\tfulltext\\tPRIMARY,idx_owner_id,idx_deleted_at,idx_private,idx_title\\tidx_title\\t0\\tconst\\t1\\t9.07\\tUsing where; Ft_hints: rank > 0\\n3\\tUNION\\tu\\t\\teq_ref\\tPRIMARY,idx_uuid\\tPRIMARY\\t146\\ttest_db.d.owner_id\\t1\\t50.0\\tUsing where\\n3\\tUNION\\ttt0\\t\\tref\\tidx_document_template_id,idx_tag_id,idx_deleted_at\\tidx_document_template_id\\t146\\ttest_db.d.id\\t4\\t25.0\\tUsing where; FirstMatch(u)\\n5\\tUNION RESULT\\t<union1,3>\\t\\tALL\\t\\t\\t\\t\\t\\t\\tUsing temporary; Using filesort\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"union_result\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"select_id\\\": 5,\\n  \\\"table_name\\\": \\\"<union1,3>\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"using_filesort\\\": true,\\n  \\\"query_specifications\\\": [\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"1.31\\\"\\n  },\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"d\\\",\\n  \\\"access_type\\\": \\\"fulltext\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_owner_id\\\",\\n  \\\"idx_deleted_at\\\",\\n  \\\"idx_title\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_title\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"title\\\"\\n  ],\\n  \\\"key_length\\\": \\\"0\\\",\\n  \\\"ref\\\": [\\n  \\\"const\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"18.14\\\",\\n  \\\"ft_hints\\\": \\\"rank > 0\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1.00\\\",\\n  \\\"eval_cost\\\": \\\"0.02\\\",\\n  \\\"prefix_cost\\\": \\\"1.10\\\",\\n  \\\"data_read_per_join\\\": \\\"239\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"title\\\",\\n  \\\"owner_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_uuid\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.owner_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"5.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.18\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.29\\\",\\n  \\\"data_read_per_join\\\": \\\"2\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"uuid\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`uuid` in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"tt0\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_document_template_id\\\",\\n  \\\"idx_tag_id\\\",\\n  \\\"idx_deleted_at\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_document_template_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"document_template_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 4,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"25.00\\\",\\n  \\\"first_match\\\": \\\"u\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.02\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.31\\\",\\n  \\\"data_read_per_join\\\": \\\"2\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"document_template_id\\\",\\n  \\\"tag_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\\\"\\n  }\\n  }\\n  ]\\n  }\\n  },\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"1.29\\\"\\n  },\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"d\\\",\\n  \\\"access_type\\\": \\\"fulltext\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_owner_id\\\",\\n  \\\"idx_deleted_at\\\",\\n  \\\"idx_private\\\",\\n  \\\"idx_title\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_title\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"title\\\"\\n  ],\\n  \\\"key_length\\\": \\\"0\\\",\\n  \\\"ref\\\": [\\n  \\\"const\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"9.07\\\",\\n  \\\"ft_hints\\\": \\\"rank > 0\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1.00\\\",\\n  \\\"eval_cost\\\": \\\"0.01\\\",\\n  \\\"prefix_cost\\\": \\\"1.10\\\",\\n  \\\"data_read_per_join\\\": \\\"119\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"title\\\",\\n  \\\"owner_id\\\",\\n  \\\"private\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`d`.`private` = 0) and (`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_uuid\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.owner_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"50.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.09\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.19\\\",\\n  \\\"data_read_per_join\\\": \\\"13\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"uuid\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`uuid` not in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"tt0\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_document_template_id\\\",\\n  \\\"idx_tag_id\\\",\\n  \\\"idx_deleted_at\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_document_template_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"document_template_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 4,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"25.00\\\",\\n  \\\"first_match\\\": \\\"u\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.08\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.30\\\",\\n  \\\"data_read_per_join\\\": \\\"13\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"document_template_id\\\",\\n  \\\"tag_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\\\"\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  ]\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将user.uuid过滤条件下推到EXISTS子查询内部，优化标签过滤的执行顺序。改写后数据库可先验证用户权限再执行标签匹配，减少不必要的tag_thing表扫描。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,将无输出JOIN转换为EXISTS半连接：1) 主查询JOIN user改为EXISTS验证 2) 移除EXISTS子查询中冗余JOIN user。通过一对一关系确保语义等价，消除重复JOIN操作，减少数据处理量和内存消耗\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"UNION消除优化,通过合并UNION ALL分支实现单次表扫描：将user.uuid的互斥条件整合为OR逻辑，消除重复扫描并保留所有过滤条件。预估减少50% I/O开销，避免临时表物化。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE document_template (id VARCHAR(36) PRIMARY KEY, title VARCHAR(255) NOT NULL, owner_id VARCHAR(36) NOT NULL, private TINYINT(1) NOT NULL DEFAULT 0, deleted_at TIMESTAMP NULL DEFAULT NULL, FULLTEXT INDEX idx_title (title)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_owner_id ON document_template(owner_id);\nCREATE INDEX idx_deleted_at ON document_template(deleted_at);\nCREATE INDEX idx_private ON document_template(private);\nCREATE TABLE `user` (id VARCHAR(36) PRIMARY KEY, uuid VARCHAR(36) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_uuid ON `user`(uuid);\nCREATE TABLE tag_thing (document_template_id VARCHAR(36) NOT NULL, tag_id VARCHAR(36) NOT NULL, deleted_at TIMESTAMP NULL DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_document_template_id ON tag_thing(document_template_id);\nCREATE INDEX idx_tag_id ON tag_thing(tag_id);\nCREATE INDEX idx_deleted_at ON tag_thing(deleted_at);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\td\t\tfulltext\tPRIMARY,idx_owner_id,idx_deleted_at,idx_title\tidx_title\t0\tconst\t1\t18.14\tUsing where; Ft_hints: rank > 0\n1\tPRIMARY\tu\t\teq_ref\tPRIMARY,idx_uuid\tPRIMARY\t146\ttest_db.d.owner_id\t1\t5.0\tUsing where\n1\tPRIMARY\ttt0\t\tref\tidx_document_template_id,idx_tag_id,idx_deleted_at\tidx_document_template_id\t146\ttest_db.d.id\t4\t25.0\tUsing where; FirstMatch(u)\n3\tUNION\td\t\tfulltext\tPRIMARY,idx_owner_id,idx_deleted_at,idx_private,idx_title\tidx_title\t0\tconst\t1\t9.07\tUsing where; Ft_hints: rank > 0\n3\tUNION\tu\t\teq_ref\tPRIMARY,idx_uuid\tPRIMARY\t146\ttest_db.d.owner_id\t1\t50.0\tUsing where\n3\tUNION\ttt0\t\tref\tidx_document_template_id,idx_tag_id,idx_deleted_at\tidx_document_template_id\t146\ttest_db.d.id\t4\t25.0\tUsing where; FirstMatch(u)\n5\tUNION RESULT\t<union1,3>\t\tALL\t\t\t\t\t\t\tUsing temporary; Using filesort\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"union_result\": {\n  \"using_temporary_table\": true,\n  \"select_id\": 5,\n  \"table_name\": \"<union1,3>\",\n  \"access_type\": \"ALL\",\n  \"using_filesort\": true,\n  \"query_specifications\": [\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"1.31\"\n  },\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"d\",\n  \"access_type\": \"fulltext\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_owner_id\",\n  \"idx_deleted_at\",\n  \"idx_title\"\n  ],\n  \"key\": \"idx_title\",\n  \"used_key_parts\": [\n  \"title\"\n  ],\n  \"key_length\": \"0\",\n  \"ref\": [\n  \"const\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"18.14\",\n  \"ft_hints\": \"rank > 0\",\n  \"cost_info\": {\n  \"read_cost\": \"1.00\",\n  \"eval_cost\": \"0.02\",\n  \"prefix_cost\": \"1.10\",\n  \"data_read_per_join\": \"239\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"title\",\n  \"owner_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_uuid\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.owner_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"5.00\",\n  \"cost_info\": {\n  \"read_cost\": \"0.18\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.29\",\n  \"data_read_per_join\": \"2\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"uuid\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`uuid` in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"tt0\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_document_template_id\",\n  \"idx_tag_id\",\n  \"idx_deleted_at\"\n  ],\n  \"key\": \"idx_document_template_id\",\n  \"used_key_parts\": [\n  \"document_template_id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.id\"\n  ],\n  \"rows_examined_per_scan\": 4,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"25.00\",\n  \"first_match\": \"u\",\n  \"cost_info\": {\n  \"read_cost\": \"0.02\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.31\",\n  \"data_read_per_join\": \"2\"\n  },\n  \"used_columns\": [\n  \"document_template_id\",\n  \"tag_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\"\n  }\n  }\n  ]\n  }\n  },\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"1.29\"\n  },\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"d\",\n  \"access_type\": \"fulltext\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_owner_id\",\n  \"idx_deleted_at\",\n  \"idx_private\",\n  \"idx_title\"\n  ],\n  \"key\": \"idx_title\",\n  \"used_key_parts\": [\n  \"title\"\n  ],\n  \"key_length\": \"0\",\n  \"ref\": [\n  \"const\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"9.07\",\n  \"ft_hints\": \"rank > 0\",\n  \"cost_info\": {\n  \"read_cost\": \"1.00\",\n  \"eval_cost\": \"0.01\",\n  \"prefix_cost\": \"1.10\",\n  \"data_read_per_join\": \"119\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"title\",\n  \"owner_id\",\n  \"private\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`d`.`private` = 0) and (`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_uuid\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.owner_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"50.00\",\n  \"cost_info\": {\n  \"read_cost\": \"0.09\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.19\",\n  \"data_read_per_join\": \"13\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"uuid\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`uuid` not in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"tt0\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_document_template_id\",\n  \"idx_tag_id\",\n  \"idx_deleted_at\"\n  ],\n  \"key\": \"idx_document_template_id\",\n  \"used_key_parts\": [\n  \"document_template_id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.id\"\n  ],\n  \"rows_examined_per_scan\": 4,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"25.00\",\n  \"first_match\": \"u\",\n  \"cost_info\": {\n  \"read_cost\": \"0.08\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.30\",\n  \"data_read_per_join\": \"13\"\n  },\n  \"used_columns\": [\n  \"document_template_id\",\n  \"tag_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\"\n  }\n  }\n  ]\n  }\n  }\n  ]\n  }\n  }\n}\n\n## Original SQL:\n(SELECT d.id, d.title\r\n  FROM document_template d\r\n  JOIN `user` u ON u.id = d.owner_id\r\n  WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\r\n  SELECT 1 FROM tag_thing tt0\r\n  WHERE tt0.document_template_id = d.id\r\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\r\n  AND tt0.deleted_at IS NULL\r\n  )) UNION ALL (SELECT d.id, d.title\r\n  FROM document_template d\r\n  JOIN `user` u ON u.id = d.owner_id\r\n  WHERE d.private = 0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\r\n  SELECT 1 FROM tag_thing tt0\r\n  WHERE tt0.document_template_id = d.id\r\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\r\n  AND tt0.deleted_at IS NULL\r\n  )) ORDER BY title ASC LIMIT 10 OFFSET 0;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "(SELECT d.id, d.title FROM document_template d INNER JOIN `user` u ON u.id = d.owner_id INNER JOIN tag_thing tt ON tt.document_template_id = d.id AND tt.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204' AND tt.deleted_at IS NULL WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0) UNION ALL (SELECT d.id, d.title FROM document_template d INNER JOIN `user` u ON u.id = d.owner_id INNER JOIN tag_thing tt ON tt.document_template_id = d.id AND tt.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204' AND tt.deleted_at IS NULL WHERE d.private=0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0) ORDER BY title ASC LIMIT 10 OFFSET 0;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "44",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"44\", \"db_type\": \"mysql\", \"description\": \"该改写方法消除了UNION ALL结构，避免了重复扫描表和创建临时表的开销。核心策略是将两个分支的冲突条件（一个包含特定uuid列表且无视private，另一个排除该列表且要求private=0）用OR组合起来，集成到同一个查询中。同时保持非重复性过滤条件（如全文检索和标签过滤）在最外层执行一次，避免了冗余操作。\", \"create_table_statements\": [\"CREATE TABLE document_template (id VARCHAR(36) PRIMARY KEY, title VARCHAR(255) NOT NULL, owner_id VARCHAR(36) NOT NULL, private TINYINT(1) NOT NULL DEFAULT 0, deleted_at TIMESTAMP NULL DEFAULT NULL, FULLTEXT INDEX idx_title (title)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_owner_id ON document_template(owner_id);\", \"CREATE INDEX idx_deleted_at ON document_template(deleted_at);\", \"CREATE INDEX idx_private ON document_template(private);\", \"CREATE TABLE `user` (id VARCHAR(36) PRIMARY KEY, uuid VARCHAR(36) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_uuid ON `user`(uuid);\", \"CREATE TABLE tag_thing (document_template_id VARCHAR(36) NOT NULL, tag_id VARCHAR(36) NOT NULL, deleted_at TIMESTAMP NULL DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_document_template_id ON tag_thing(document_template_id);\", \"CREATE INDEX idx_tag_id ON tag_thing(tag_id);\", \"CREATE INDEX idx_deleted_at ON tag_thing(deleted_at);\"], \"sql\": \"(SELECT d.id, d.title\\r\\n  FROM document_template d\\r\\n  JOIN `user` u ON u.id = d.owner_id\\r\\n  WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\\r\\n  SELECT 1 FROM tag_thing tt0\\r\\n  WHERE tt0.document_template_id = d.id\\r\\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\\r\\n  AND tt0.deleted_at IS NULL\\r\\n  )) UNION ALL (SELECT d.id, d.title\\r\\n  FROM document_template d\\r\\n  JOIN `user` u ON u.id = d.owner_id\\r\\n  WHERE d.private = 0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\\r\\n  SELECT 1 FROM tag_thing tt0\\r\\n  WHERE tt0.document_template_id = d.id\\r\\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\\r\\n  AND tt0.deleted_at IS NULL\\r\\n  )) ORDER BY title ASC LIMIT 10 OFFSET 0;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\td\\t\\tfulltext\\tPRIMARY,idx_owner_id,idx_deleted_at,idx_title\\tidx_title\\t0\\tconst\\t1\\t18.14\\tUsing where; Ft_hints: rank > 0\\n1\\tPRIMARY\\tu\\t\\teq_ref\\tPRIMARY,idx_uuid\\tPRIMARY\\t146\\ttest_db.d.owner_id\\t1\\t5.0\\tUsing where\\n1\\tPRIMARY\\ttt0\\t\\tref\\tidx_document_template_id,idx_tag_id,idx_deleted_at\\tidx_document_template_id\\t146\\ttest_db.d.id\\t4\\t25.0\\tUsing where; FirstMatch(u)\\n3\\tUNION\\td\\t\\tfulltext\\tPRIMARY,idx_owner_id,idx_deleted_at,idx_private,idx_title\\tidx_title\\t0\\tconst\\t1\\t9.07\\tUsing where; Ft_hints: rank > 0\\n3\\tUNION\\tu\\t\\teq_ref\\tPRIMARY,idx_uuid\\tPRIMARY\\t146\\ttest_db.d.owner_id\\t1\\t50.0\\tUsing where\\n3\\tUNION\\ttt0\\t\\tref\\tidx_document_template_id,idx_tag_id,idx_deleted_at\\tidx_document_template_id\\t146\\ttest_db.d.id\\t4\\t25.0\\tUsing where; FirstMatch(u)\\n5\\tUNION RESULT\\t<union1,3>\\t\\tALL\\t\\t\\t\\t\\t\\t\\tUsing temporary; Using filesort\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"union_result\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"select_id\\\": 5,\\n  \\\"table_name\\\": \\\"<union1,3>\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"using_filesort\\\": true,\\n  \\\"query_specifications\\\": [\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"1.31\\\"\\n  },\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"d\\\",\\n  \\\"access_type\\\": \\\"fulltext\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_owner_id\\\",\\n  \\\"idx_deleted_at\\\",\\n  \\\"idx_title\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_title\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"title\\\"\\n  ],\\n  \\\"key_length\\\": \\\"0\\\",\\n  \\\"ref\\\": [\\n  \\\"const\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"18.14\\\",\\n  \\\"ft_hints\\\": \\\"rank > 0\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1.00\\\",\\n  \\\"eval_cost\\\": \\\"0.02\\\",\\n  \\\"prefix_cost\\\": \\\"1.10\\\",\\n  \\\"data_read_per_join\\\": \\\"239\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"title\\\",\\n  \\\"owner_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_uuid\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.owner_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"5.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.18\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.29\\\",\\n  \\\"data_read_per_join\\\": \\\"2\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"uuid\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`uuid` in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"tt0\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_document_template_id\\\",\\n  \\\"idx_tag_id\\\",\\n  \\\"idx_deleted_at\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_document_template_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"document_template_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 4,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"25.00\\\",\\n  \\\"first_match\\\": \\\"u\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.02\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.31\\\",\\n  \\\"data_read_per_join\\\": \\\"2\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"document_template_id\\\",\\n  \\\"tag_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\\\"\\n  }\\n  }\\n  ]\\n  }\\n  },\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"1.29\\\"\\n  },\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"d\\\",\\n  \\\"access_type\\\": \\\"fulltext\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_owner_id\\\",\\n  \\\"idx_deleted_at\\\",\\n  \\\"idx_private\\\",\\n  \\\"idx_title\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_title\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"title\\\"\\n  ],\\n  \\\"key_length\\\": \\\"0\\\",\\n  \\\"ref\\\": [\\n  \\\"const\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"9.07\\\",\\n  \\\"ft_hints\\\": \\\"rank > 0\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1.00\\\",\\n  \\\"eval_cost\\\": \\\"0.01\\\",\\n  \\\"prefix_cost\\\": \\\"1.10\\\",\\n  \\\"data_read_per_join\\\": \\\"119\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"title\\\",\\n  \\\"owner_id\\\",\\n  \\\"private\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`d`.`private` = 0) and (`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_uuid\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.owner_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"50.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.09\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.19\\\",\\n  \\\"data_read_per_join\\\": \\\"13\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"uuid\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`uuid` not in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"tt0\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_document_template_id\\\",\\n  \\\"idx_tag_id\\\",\\n  \\\"idx_deleted_at\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_document_template_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"document_template_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 4,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"25.00\\\",\\n  \\\"first_match\\\": \\\"u\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.08\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.30\\\",\\n  \\\"data_read_per_join\\\": \\\"13\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"document_template_id\\\",\\n  \\\"tag_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\\\"\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  ]\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将user.uuid过滤条件下推到EXISTS子查询内部，优化标签过滤的执行顺序。改写后数据库可先验证用户权限再执行标签匹配，减少不必要的tag_thing表扫描。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,将无输出JOIN转换为EXISTS半连接：1) 主查询JOIN user改为EXISTS验证 2) 移除EXISTS子查询中冗余JOIN user。通过一对一关系确保语义等价，消除重复JOIN操作，减少数据处理量和内存消耗\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"UNION消除优化,通过合并UNION ALL分支实现单次表扫描：将user.uuid的互斥条件整合为OR逻辑，消除重复扫描并保留所有过滤条件。预估减少50% I/O开销，避免临时表物化。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE document_template (id VARCHAR(36) PRIMARY KEY, title VARCHAR(255) NOT NULL, owner_id VARCHAR(36) NOT NULL, private TINYINT(1) NOT NULL DEFAULT 0, deleted_at TIMESTAMP NULL DEFAULT NULL, FULLTEXT INDEX idx_title (title)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_owner_id ON document_template(owner_id);\nCREATE INDEX idx_deleted_at ON document_template(deleted_at);\nCREATE INDEX idx_private ON document_template(private);\nCREATE TABLE `user` (id VARCHAR(36) PRIMARY KEY, uuid VARCHAR(36) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_uuid ON `user`(uuid);\nCREATE TABLE tag_thing (document_template_id VARCHAR(36) NOT NULL, tag_id VARCHAR(36) NOT NULL, deleted_at TIMESTAMP NULL DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_document_template_id ON tag_thing(document_template_id);\nCREATE INDEX idx_tag_id ON tag_thing(tag_id);\nCREATE INDEX idx_deleted_at ON tag_thing(deleted_at);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\td\t\tfulltext\tPRIMARY,idx_owner_id,idx_deleted_at,idx_title\tidx_title\t0\tconst\t1\t18.14\tUsing where; Ft_hints: rank > 0\n1\tPRIMARY\tu\t\teq_ref\tPRIMARY,idx_uuid\tPRIMARY\t146\ttest_db.d.owner_id\t1\t5.0\tUsing where\n1\tPRIMARY\ttt0\t\tref\tidx_document_template_id,idx_tag_id,idx_deleted_at\tidx_document_template_id\t146\ttest_db.d.id\t4\t25.0\tUsing where; FirstMatch(u)\n3\tUNION\td\t\tfulltext\tPRIMARY,idx_owner_id,idx_deleted_at,idx_private,idx_title\tidx_title\t0\tconst\t1\t9.07\tUsing where; Ft_hints: rank > 0\n3\tUNION\tu\t\teq_ref\tPRIMARY,idx_uuid\tPRIMARY\t146\ttest_db.d.owner_id\t1\t50.0\tUsing where\n3\tUNION\ttt0\t\tref\tidx_document_template_id,idx_tag_id,idx_deleted_at\tidx_document_template_id\t146\ttest_db.d.id\t4\t25.0\tUsing where; FirstMatch(u)\n5\tUNION RESULT\t<union1,3>\t\tALL\t\t\t\t\t\t\tUsing temporary; Using filesort\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"union_result\": {\n  \"using_temporary_table\": true,\n  \"select_id\": 5,\n  \"table_name\": \"<union1,3>\",\n  \"access_type\": \"ALL\",\n  \"using_filesort\": true,\n  \"query_specifications\": [\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"1.31\"\n  },\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"d\",\n  \"access_type\": \"fulltext\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_owner_id\",\n  \"idx_deleted_at\",\n  \"idx_title\"\n  ],\n  \"key\": \"idx_title\",\n  \"used_key_parts\": [\n  \"title\"\n  ],\n  \"key_length\": \"0\",\n  \"ref\": [\n  \"const\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"18.14\",\n  \"ft_hints\": \"rank > 0\",\n  \"cost_info\": {\n  \"read_cost\": \"1.00\",\n  \"eval_cost\": \"0.02\",\n  \"prefix_cost\": \"1.10\",\n  \"data_read_per_join\": \"239\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"title\",\n  \"owner_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_uuid\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.owner_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"5.00\",\n  \"cost_info\": {\n  \"read_cost\": \"0.18\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.29\",\n  \"data_read_per_join\": \"2\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"uuid\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`uuid` in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"tt0\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_document_template_id\",\n  \"idx_tag_id\",\n  \"idx_deleted_at\"\n  ],\n  \"key\": \"idx_document_template_id\",\n  \"used_key_parts\": [\n  \"document_template_id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.id\"\n  ],\n  \"rows_examined_per_scan\": 4,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"25.00\",\n  \"first_match\": \"u\",\n  \"cost_info\": {\n  \"read_cost\": \"0.02\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.31\",\n  \"data_read_per_join\": \"2\"\n  },\n  \"used_columns\": [\n  \"document_template_id\",\n  \"tag_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\"\n  }\n  }\n  ]\n  }\n  },\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"1.29\"\n  },\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"d\",\n  \"access_type\": \"fulltext\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_owner_id\",\n  \"idx_deleted_at\",\n  \"idx_private\",\n  \"idx_title\"\n  ],\n  \"key\": \"idx_title\",\n  \"used_key_parts\": [\n  \"title\"\n  ],\n  \"key_length\": \"0\",\n  \"ref\": [\n  \"const\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"9.07\",\n  \"ft_hints\": \"rank > 0\",\n  \"cost_info\": {\n  \"read_cost\": \"1.00\",\n  \"eval_cost\": \"0.01\",\n  \"prefix_cost\": \"1.10\",\n  \"data_read_per_join\": \"119\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"title\",\n  \"owner_id\",\n  \"private\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`d`.`private` = 0) and (`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_uuid\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.owner_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"50.00\",\n  \"cost_info\": {\n  \"read_cost\": \"0.09\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.19\",\n  \"data_read_per_join\": \"13\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"uuid\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`uuid` not in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"tt0\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_document_template_id\",\n  \"idx_tag_id\",\n  \"idx_deleted_at\"\n  ],\n  \"key\": \"idx_document_template_id\",\n  \"used_key_parts\": [\n  \"document_template_id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.id\"\n  ],\n  \"rows_examined_per_scan\": 4,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"25.00\",\n  \"first_match\": \"u\",\n  \"cost_info\": {\n  \"read_cost\": \"0.08\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.30\",\n  \"data_read_per_join\": \"13\"\n  },\n  \"used_columns\": [\n  \"document_template_id\",\n  \"tag_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\"\n  }\n  }\n  ]\n  }\n  }\n  ]\n  }\n  }\n}\n\n## Original SQL:\n(SELECT d.id, d.title\r\n  FROM document_template d\r\n  JOIN `user` u ON u.id = d.owner_id\r\n  WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\r\n  SELECT 1 FROM tag_thing tt0\r\n  WHERE tt0.document_template_id = d.id\r\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\r\n  AND tt0.deleted_at IS NULL\r\n  )) UNION ALL (SELECT d.id, d.title\r\n  FROM document_template d\r\n  JOIN `user` u ON u.id = d.owner_id\r\n  WHERE d.private = 0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\r\n  SELECT 1 FROM tag_thing tt0\r\n  WHERE tt0.document_template_id = d.id\r\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\r\n  AND tt0.deleted_at IS NULL\r\n  )) ORDER BY title ASC LIMIT 10 OFFSET 0;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "(SELECT d.id, d.title FROM document_template d INNER JOIN `user` u ON u.id = d.owner_id INNER JOIN tag_thing tt ON tt.document_template_id = d.id AND tt.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204' AND tt.deleted_at IS NULL WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0) UNION ALL (SELECT d.id, d.title FROM document_template d INNER JOIN `user` u ON u.id = d.owner_id INNER JOIN tag_thing tt ON tt.document_template_id = d.id AND tt.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204' AND tt.deleted_at IS NULL WHERE d.private=0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0) ORDER BY title ASC LIMIT 10 OFFSET 0;"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "44",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"44\", \"db_type\": \"mysql\", \"description\": \"该改写方法消除了UNION ALL结构，避免了重复扫描表和创建临时表的开销。核心策略是将两个分支的冲突条件（一个包含特定uuid列表且无视private，另一个排除该列表且要求private=0）用OR组合起来，集成到同一个查询中。同时保持非重复性过滤条件（如全文检索和标签过滤）在最外层执行一次，避免了冗余操作。\", \"create_table_statements\": [\"CREATE TABLE document_template (id VARCHAR(36) PRIMARY KEY, title VARCHAR(255) NOT NULL, owner_id VARCHAR(36) NOT NULL, private TINYINT(1) NOT NULL DEFAULT 0, deleted_at TIMESTAMP NULL DEFAULT NULL, FULLTEXT INDEX idx_title (title)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_owner_id ON document_template(owner_id);\", \"CREATE INDEX idx_deleted_at ON document_template(deleted_at);\", \"CREATE INDEX idx_private ON document_template(private);\", \"CREATE TABLE `user` (id VARCHAR(36) PRIMARY KEY, uuid VARCHAR(36) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_uuid ON `user`(uuid);\", \"CREATE TABLE tag_thing (document_template_id VARCHAR(36) NOT NULL, tag_id VARCHAR(36) NOT NULL, deleted_at TIMESTAMP NULL DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_document_template_id ON tag_thing(document_template_id);\", \"CREATE INDEX idx_tag_id ON tag_thing(tag_id);\", \"CREATE INDEX idx_deleted_at ON tag_thing(deleted_at);\"], \"sql\": \"(SELECT d.id, d.title\\r\\n  FROM document_template d\\r\\n  JOIN `user` u ON u.id = d.owner_id\\r\\n  WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\\r\\n  SELECT 1 FROM tag_thing tt0\\r\\n  WHERE tt0.document_template_id = d.id\\r\\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\\r\\n  AND tt0.deleted_at IS NULL\\r\\n  )) UNION ALL (SELECT d.id, d.title\\r\\n  FROM document_template d\\r\\n  JOIN `user` u ON u.id = d.owner_id\\r\\n  WHERE d.private = 0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\\r\\n  SELECT 1 FROM tag_thing tt0\\r\\n  WHERE tt0.document_template_id = d.id\\r\\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\\r\\n  AND tt0.deleted_at IS NULL\\r\\n  )) ORDER BY title ASC LIMIT 10 OFFSET 0;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\td\\t\\tfulltext\\tPRIMARY,idx_owner_id,idx_deleted_at,idx_title\\tidx_title\\t0\\tconst\\t1\\t18.14\\tUsing where; Ft_hints: rank > 0\\n1\\tPRIMARY\\tu\\t\\teq_ref\\tPRIMARY,idx_uuid\\tPRIMARY\\t146\\ttest_db.d.owner_id\\t1\\t5.0\\tUsing where\\n1\\tPRIMARY\\ttt0\\t\\tref\\tidx_document_template_id,idx_tag_id,idx_deleted_at\\tidx_document_template_id\\t146\\ttest_db.d.id\\t4\\t25.0\\tUsing where; FirstMatch(u)\\n3\\tUNION\\td\\t\\tfulltext\\tPRIMARY,idx_owner_id,idx_deleted_at,idx_private,idx_title\\tidx_title\\t0\\tconst\\t1\\t9.07\\tUsing where; Ft_hints: rank > 0\\n3\\tUNION\\tu\\t\\teq_ref\\tPRIMARY,idx_uuid\\tPRIMARY\\t146\\ttest_db.d.owner_id\\t1\\t50.0\\tUsing where\\n3\\tUNION\\ttt0\\t\\tref\\tidx_document_template_id,idx_tag_id,idx_deleted_at\\tidx_document_template_id\\t146\\ttest_db.d.id\\t4\\t25.0\\tUsing where; FirstMatch(u)\\n5\\tUNION RESULT\\t<union1,3>\\t\\tALL\\t\\t\\t\\t\\t\\t\\tUsing temporary; Using filesort\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"union_result\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"select_id\\\": 5,\\n  \\\"table_name\\\": \\\"<union1,3>\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"using_filesort\\\": true,\\n  \\\"query_specifications\\\": [\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"1.31\\\"\\n  },\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"d\\\",\\n  \\\"access_type\\\": \\\"fulltext\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_owner_id\\\",\\n  \\\"idx_deleted_at\\\",\\n  \\\"idx_title\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_title\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"title\\\"\\n  ],\\n  \\\"key_length\\\": \\\"0\\\",\\n  \\\"ref\\\": [\\n  \\\"const\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"18.14\\\",\\n  \\\"ft_hints\\\": \\\"rank > 0\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1.00\\\",\\n  \\\"eval_cost\\\": \\\"0.02\\\",\\n  \\\"prefix_cost\\\": \\\"1.10\\\",\\n  \\\"data_read_per_join\\\": \\\"239\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"title\\\",\\n  \\\"owner_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_uuid\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.owner_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"5.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.18\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.29\\\",\\n  \\\"data_read_per_join\\\": \\\"2\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"uuid\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`uuid` in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"tt0\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_document_template_id\\\",\\n  \\\"idx_tag_id\\\",\\n  \\\"idx_deleted_at\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_document_template_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"document_template_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 4,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"25.00\\\",\\n  \\\"first_match\\\": \\\"u\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.02\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.31\\\",\\n  \\\"data_read_per_join\\\": \\\"2\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"document_template_id\\\",\\n  \\\"tag_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\\\"\\n  }\\n  }\\n  ]\\n  }\\n  },\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"1.29\\\"\\n  },\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"d\\\",\\n  \\\"access_type\\\": \\\"fulltext\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_owner_id\\\",\\n  \\\"idx_deleted_at\\\",\\n  \\\"idx_private\\\",\\n  \\\"idx_title\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_title\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"title\\\"\\n  ],\\n  \\\"key_length\\\": \\\"0\\\",\\n  \\\"ref\\\": [\\n  \\\"const\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"9.07\\\",\\n  \\\"ft_hints\\\": \\\"rank > 0\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1.00\\\",\\n  \\\"eval_cost\\\": \\\"0.01\\\",\\n  \\\"prefix_cost\\\": \\\"1.10\\\",\\n  \\\"data_read_per_join\\\": \\\"119\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"title\\\",\\n  \\\"owner_id\\\",\\n  \\\"private\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`d`.`private` = 0) and (`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_uuid\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.owner_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"50.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.09\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.19\\\",\\n  \\\"data_read_per_join\\\": \\\"13\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"uuid\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`uuid` not in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"tt0\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_document_template_id\\\",\\n  \\\"idx_tag_id\\\",\\n  \\\"idx_deleted_at\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_document_template_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"document_template_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 4,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"25.00\\\",\\n  \\\"first_match\\\": \\\"u\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.08\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.30\\\",\\n  \\\"data_read_per_join\\\": \\\"13\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"document_template_id\\\",\\n  \\\"tag_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\\\"\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  ]\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将user.uuid过滤条件下推到EXISTS子查询内部，优化标签过滤的执行顺序。改写后数据库可先验证用户权限再执行标签匹配，减少不必要的tag_thing表扫描。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,将无输出JOIN转换为EXISTS半连接：1) 主查询JOIN user改为EXISTS验证 2) 移除EXISTS子查询中冗余JOIN user。通过一对一关系确保语义等价，消除重复JOIN操作，减少数据处理量和内存消耗\"}, {\"rule_id\": \"3\", \"difficulty_level\": \"3\", \"rationale\": \"UNION消除优化,通过合并UNION ALL分支实现单次表扫描：将user.uuid的互斥条件整合为OR逻辑，消除重复扫描并保留所有过滤条件。预估减少50% I/O开销，避免临时表物化。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE document_template (id VARCHAR(36) PRIMARY KEY, title VARCHAR(255) NOT NULL, owner_id VARCHAR(36) NOT NULL, private TINYINT(1) NOT NULL DEFAULT 0, deleted_at TIMESTAMP NULL DEFAULT NULL, FULLTEXT INDEX idx_title (title)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_owner_id ON document_template(owner_id);\nCREATE INDEX idx_deleted_at ON document_template(deleted_at);\nCREATE INDEX idx_private ON document_template(private);\nCREATE TABLE `user` (id VARCHAR(36) PRIMARY KEY, uuid VARCHAR(36) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_uuid ON `user`(uuid);\nCREATE TABLE tag_thing (document_template_id VARCHAR(36) NOT NULL, tag_id VARCHAR(36) NOT NULL, deleted_at TIMESTAMP NULL DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_document_template_id ON tag_thing(document_template_id);\nCREATE INDEX idx_tag_id ON tag_thing(tag_id);\nCREATE INDEX idx_deleted_at ON tag_thing(deleted_at);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\td\t\tfulltext\tPRIMARY,idx_owner_id,idx_deleted_at,idx_title\tidx_title\t0\tconst\t1\t18.14\tUsing where; Ft_hints: rank > 0\n1\tPRIMARY\tu\t\teq_ref\tPRIMARY,idx_uuid\tPRIMARY\t146\ttest_db.d.owner_id\t1\t5.0\tUsing where\n1\tPRIMARY\ttt0\t\tref\tidx_document_template_id,idx_tag_id,idx_deleted_at\tidx_document_template_id\t146\ttest_db.d.id\t4\t25.0\tUsing where; FirstMatch(u)\n3\tUNION\td\t\tfulltext\tPRIMARY,idx_owner_id,idx_deleted_at,idx_private,idx_title\tidx_title\t0\tconst\t1\t9.07\tUsing where; Ft_hints: rank > 0\n3\tUNION\tu\t\teq_ref\tPRIMARY,idx_uuid\tPRIMARY\t146\ttest_db.d.owner_id\t1\t50.0\tUsing where\n3\tUNION\ttt0\t\tref\tidx_document_template_id,idx_tag_id,idx_deleted_at\tidx_document_template_id\t146\ttest_db.d.id\t4\t25.0\tUsing where; FirstMatch(u)\n5\tUNION RESULT\t<union1,3>\t\tALL\t\t\t\t\t\t\tUsing temporary; Using filesort\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"union_result\": {\n  \"using_temporary_table\": true,\n  \"select_id\": 5,\n  \"table_name\": \"<union1,3>\",\n  \"access_type\": \"ALL\",\n  \"using_filesort\": true,\n  \"query_specifications\": [\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"1.31\"\n  },\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"d\",\n  \"access_type\": \"fulltext\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_owner_id\",\n  \"idx_deleted_at\",\n  \"idx_title\"\n  ],\n  \"key\": \"idx_title\",\n  \"used_key_parts\": [\n  \"title\"\n  ],\n  \"key_length\": \"0\",\n  \"ref\": [\n  \"const\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"18.14\",\n  \"ft_hints\": \"rank > 0\",\n  \"cost_info\": {\n  \"read_cost\": \"1.00\",\n  \"eval_cost\": \"0.02\",\n  \"prefix_cost\": \"1.10\",\n  \"data_read_per_join\": \"239\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"title\",\n  \"owner_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_uuid\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.owner_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"5.00\",\n  \"cost_info\": {\n  \"read_cost\": \"0.18\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.29\",\n  \"data_read_per_join\": \"2\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"uuid\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`uuid` in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"tt0\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_document_template_id\",\n  \"idx_tag_id\",\n  \"idx_deleted_at\"\n  ],\n  \"key\": \"idx_document_template_id\",\n  \"used_key_parts\": [\n  \"document_template_id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.id\"\n  ],\n  \"rows_examined_per_scan\": 4,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"25.00\",\n  \"first_match\": \"u\",\n  \"cost_info\": {\n  \"read_cost\": \"0.02\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.31\",\n  \"data_read_per_join\": \"2\"\n  },\n  \"used_columns\": [\n  \"document_template_id\",\n  \"tag_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\"\n  }\n  }\n  ]\n  }\n  },\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"1.29\"\n  },\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"d\",\n  \"access_type\": \"fulltext\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_owner_id\",\n  \"idx_deleted_at\",\n  \"idx_private\",\n  \"idx_title\"\n  ],\n  \"key\": \"idx_title\",\n  \"used_key_parts\": [\n  \"title\"\n  ],\n  \"key_length\": \"0\",\n  \"ref\": [\n  \"const\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"9.07\",\n  \"ft_hints\": \"rank > 0\",\n  \"cost_info\": {\n  \"read_cost\": \"1.00\",\n  \"eval_cost\": \"0.01\",\n  \"prefix_cost\": \"1.10\",\n  \"data_read_per_join\": \"119\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"title\",\n  \"owner_id\",\n  \"private\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`d`.`private` = 0) and (`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_uuid\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.owner_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"50.00\",\n  \"cost_info\": {\n  \"read_cost\": \"0.09\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.19\",\n  \"data_read_per_join\": \"13\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"uuid\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`uuid` not in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"tt0\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_document_template_id\",\n  \"idx_tag_id\",\n  \"idx_deleted_at\"\n  ],\n  \"key\": \"idx_document_template_id\",\n  \"used_key_parts\": [\n  \"document_template_id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.id\"\n  ],\n  \"rows_examined_per_scan\": 4,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"25.00\",\n  \"first_match\": \"u\",\n  \"cost_info\": {\n  \"read_cost\": \"0.08\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.30\",\n  \"data_read_per_join\": \"13\"\n  },\n  \"used_columns\": [\n  \"document_template_id\",\n  \"tag_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\"\n  }\n  }\n  ]\n  }\n  }\n  ]\n  }\n  }\n}\n\n## Original SQL:\n(SELECT d.id, d.title\r\n  FROM document_template d\r\n  JOIN `user` u ON u.id = d.owner_id\r\n  WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\r\n  SELECT 1 FROM tag_thing tt0\r\n  WHERE tt0.document_template_id = d.id\r\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\r\n  AND tt0.deleted_at IS NULL\r\n  )) UNION ALL (SELECT d.id, d.title\r\n  FROM document_template d\r\n  JOIN `user` u ON u.id = d.owner_id\r\n  WHERE d.private = 0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\r\n  SELECT 1 FROM tag_thing tt0\r\n  WHERE tt0.document_template_id = d.id\r\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\r\n  AND tt0.deleted_at IS NULL\r\n  )) ORDER BY title ASC LIMIT 10 OFFSET 0;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "(SELECT d.id, d.title FROM document_template d INNER JOIN `user` u ON u.id = d.owner_id INNER JOIN tag_thing tt ON tt.document_template_id = d.id AND tt.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204' AND tt.deleted_at IS NULL WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0) UNION ALL (SELECT d.id, d.title FROM document_template d INNER JOIN `user` u ON u.id = d.owner_id INNER JOIN tag_thing tt ON tt.document_template_id = d.id AND tt.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204' AND tt.deleted_at IS NULL WHERE d.private=0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0) ORDER BY title ASC LIMIT 10 OFFSET 0;"
                    }
                ],
                "rule_id": "3"
            },
            {
                "case_id": "45",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"45\", \"db_type\": \"postgresql\", \"description\": \"改写后的SQL直接将原始SQL中的WITH子句直接在句同为一层的查询中，移除了不必要的子查询结构（CTE），这是优化SQL编写方式的常用方法。在PostgreSQL处理用例，对于非递归的CTE，查询优化器通常能够直接优化内部逻辑，故改写可能带来可见提升效果不明显。\", \"create_table_statements\": [\"CREATE TABLE Student (s_id SERIAL PRIMARY KEY, s_name VARCHAR(100) NOT NULL, s_sex CHAR(1) NOT NULL);\", \"CREATE TABLE Score (id SERIAL PRIMARY KEY, s_id INTEGER NOT NULL, c_id INTEGER NOT NULL, s_score NUMERIC(5,2) NOT NULL, FOREIGN KEY (s_id) REFERENCES Student (s_id));\", \"CREATE INDEX idx_score_s_id ON Score(s_id);\", \"CREATE INDEX idx_score_s_score ON Score(s_score);\", \"CREATE INDEX idx_score_c_id ON Score(c_id);\"], \"sql\": \"WITH StudentStats AS (\\r\\n  SELECT \\r\\n  s.s_id,\\r\\n  s.s_name,\\r\\n  s.s_sex,\\r\\n  COUNT(DISTINCT sc.c_id) AS course_count,\\r\\n  AVG(sc.s_score) AS avg_score,\\r\\n  SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) AS excellent_course_count\\r\\n  FROM Student s\\r\\n  JOIN Score sc ON s.s_id = sc.s_id\\r\\n  GROUP BY s.s_id, s.s_name, s.s_sex\\r\\n  HAVING AVG(sc.s_score) > 80 AND SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) >= 2\\r\\n)\\r\\nSELECT \\r\\n  ss.s_id,\\r\\n  ss.s_name,\\r\\n  ss.s_sex,\\r\\n  ss.course_count,\\r\\n  ss.avg_score,\\r\\n  ss.excellent_course_count,\\r\\n  RANK() OVER (PARTITION BY ss.s_sex ORDER BY ss.avg_score DESC) AS gender_rank\\r\\nFROM StudentStats ss\\r\\nORDER BY ss.avg_score DESC;\", \"explain\": \"QUERY PLAN\\nSort  (cost=87015.43..87154.32 rows=55556 width=74)\\n  Sort Key: ss.avg_score DESC\\n  ->  WindowAgg  (cost=79055.04..80166.16 rows=55556 width=74)\\n  ->  Sort  (cost=79055.04..79193.93 rows=55556 width=66)\\n  Sort Key: ss.s_sex, ss.avg_score DESC\\n  ->  Subquery Scan on ss  (cost=3.35..72394.76 rows=55556 width=66)\\n  ->  GroupAggregate  (cost=3.35..72394.76 rows=55556 width=66)\\n  Group Key: s.s_id\\n  Filter: ((avg(sc.s_score) > '80'::numeric) AND (sum(CASE WHEN (sc.s_score > '90'::numeric) THEN 1 ELSE 0 END) >= 2))\\n  ->  Incremental Sort  (cost=3.35..57394.76 rows=500000 width=27)\\n  Sort Key: s.s_id, sc.c_id\\n  Presorted Key: s.s_id\\n  ->  Merge Join  (cost=3.27..34894.76 rows=500000 width=27)\\n  Merge Cond: (s.s_id = sc.s_id)\\n  ->  Index Scan using student_pkey on student s  (cost=0.42..16184.42 rows=500000 width=18)\\n  ->  Index Scan using idx_score_s_id on score sc  (cost=0.42..25147.43 rows=500000 width=13)\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 87015.43, 'Total Cost': 87154.32, 'Plan Rows': 55556, 'Plan Width': 74, 'Sort Key': ['ss.avg_score DESC'], 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 79055.04, 'Total Cost': 80166.16, 'Plan Rows': 55556, 'Plan Width': 74, 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 79055.04, 'Total Cost': 79193.93, 'Plan Rows': 55556, 'Plan Width': 66, 'Sort Key': ['ss.s_sex', 'ss.avg_score DESC'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'ss', 'Startup Cost': 3.35, 'Total Cost': 72394.76, 'Plan Rows': 55556, 'Plan Width': 66, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 3.35, 'Total Cost': 72394.76, 'Plan Rows': 55556, 'Plan Width': 66, 'Group Key': ['s.s_id'], 'Filter': \\\"((avg(sc.s_score) > '80'::numeric) AND (sum(CASE WHEN (sc.s_score > '90'::numeric) THEN 1 ELSE 0 END) >= 2))\\\", 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 3.35, 'Total Cost': 57394.76, 'Plan Rows': 500000, 'Plan Width': 27, 'Sort Key': ['s.s_id', 'sc.c_id'], 'Presorted Key': ['s.s_id'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 3.27, 'Total Cost': 34894.76, 'Plan Rows': 500000, 'Plan Width': 27, 'Inner Unique': False, 'Merge Cond': '(s.s_id = sc.s_id)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'student_pkey', 'Relation Name': 'student', 'Alias': 's', 'Startup Cost': 0.42, 'Total Cost': 16184.42, 'Plan Rows': 500000, 'Plan Width': 18}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_score_s_id', 'Relation Name': 'score', 'Alias': 'sc', 'Startup Cost': 0.42, 'Total Cost': 25147.43, 'Plan Rows': 500000, 'Plan Width': 13}]}]}]}]}]}]}]}}]\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"子查询折叠,通过折叠CTE，将原始SQL中的公共表表达式（StudentStats）与主查询合并，消除了中间结果集的物化开销，提高查询性能。在MySQL 5.7及以下版本效果显著，8.0+版本也能避免优化器选择物化策略的开销。\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE Student (s_id SERIAL PRIMARY KEY, s_name VARCHAR(100) NOT NULL, s_sex CHAR(1) NOT NULL);\nCREATE TABLE Score (id SERIAL PRIMARY KEY, s_id INTEGER NOT NULL, c_id INTEGER NOT NULL, s_score NUMERIC(5,2) NOT NULL, FOREIGN KEY (s_id) REFERENCES Student (s_id));\nCREATE INDEX idx_score_s_id ON Score(s_id);\nCREATE INDEX idx_score_s_score ON Score(s_score);\nCREATE INDEX idx_score_c_id ON Score(c_id);\n\n## Explain Output in JSON:\nQUERY PLAN\nSort  (cost=87015.43..87154.32 rows=55556 width=74)\n  Sort Key: ss.avg_score DESC\n  ->  WindowAgg  (cost=79055.04..80166.16 rows=55556 width=74)\n  ->  Sort  (cost=79055.04..79193.93 rows=55556 width=66)\n  Sort Key: ss.s_sex, ss.avg_score DESC\n  ->  Subquery Scan on ss  (cost=3.35..72394.76 rows=55556 width=66)\n  ->  GroupAggregate  (cost=3.35..72394.76 rows=55556 width=66)\n  Group Key: s.s_id\n  Filter: ((avg(sc.s_score) > '80'::numeric) AND (sum(CASE WHEN (sc.s_score > '90'::numeric) THEN 1 ELSE 0 END) >= 2))\n  ->  Incremental Sort  (cost=3.35..57394.76 rows=500000 width=27)\n  Sort Key: s.s_id, sc.c_id\n  Presorted Key: s.s_id\n  ->  Merge Join  (cost=3.27..34894.76 rows=500000 width=27)\n  Merge Cond: (s.s_id = sc.s_id)\n  ->  Index Scan using student_pkey on student s  (cost=0.42..16184.42 rows=500000 width=18)\n  ->  Index Scan using idx_score_s_id on score sc  (cost=0.42..25147.43 rows=500000 width=13)\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 87015.43, 'Total Cost': 87154.32, 'Plan Rows': 55556, 'Plan Width': 74, 'Sort Key': ['ss.avg_score DESC'], 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 79055.04, 'Total Cost': 80166.16, 'Plan Rows': 55556, 'Plan Width': 74, 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 79055.04, 'Total Cost': 79193.93, 'Plan Rows': 55556, 'Plan Width': 66, 'Sort Key': ['ss.s_sex', 'ss.avg_score DESC'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'ss', 'Startup Cost': 3.35, 'Total Cost': 72394.76, 'Plan Rows': 55556, 'Plan Width': 66, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 3.35, 'Total Cost': 72394.76, 'Plan Rows': 55556, 'Plan Width': 66, 'Group Key': ['s.s_id'], 'Filter': \"((avg(sc.s_score) > '80'::numeric) AND (sum(CASE WHEN (sc.s_score > '90'::numeric) THEN 1 ELSE 0 END) >= 2))\", 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 3.35, 'Total Cost': 57394.76, 'Plan Rows': 500000, 'Plan Width': 27, 'Sort Key': ['s.s_id', 'sc.c_id'], 'Presorted Key': ['s.s_id'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 3.27, 'Total Cost': 34894.76, 'Plan Rows': 500000, 'Plan Width': 27, 'Inner Unique': False, 'Merge Cond': '(s.s_id = sc.s_id)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'student_pkey', 'Relation Name': 'student', 'Alias': 's', 'Startup Cost': 0.42, 'Total Cost': 16184.42, 'Plan Rows': 500000, 'Plan Width': 18}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_score_s_id', 'Relation Name': 'score', 'Alias': 'sc', 'Startup Cost': 0.42, 'Total Cost': 25147.43, 'Plan Rows': 500000, 'Plan Width': 13}]}]}]}]}]}]}]}}]\n\n## Original SQL:\nWITH StudentStats AS (\r\n  SELECT \r\n  s.s_id,\r\n  s.s_name,\r\n  s.s_sex,\r\n  COUNT(DISTINCT sc.c_id) AS course_count,\r\n  AVG(sc.s_score) AS avg_score,\r\n  SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) AS excellent_course_count\r\n  FROM Student s\r\n  JOIN Score sc ON s.s_id = sc.s_id\r\n  GROUP BY s.s_id, s.s_name, s.s_sex\r\n  HAVING AVG(sc.s_score) > 80 AND SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) >= 2\r\n)\r\nSELECT \r\n  ss.s_id,\r\n  ss.s_name,\r\n  ss.s_sex,\r\n  ss.course_count,\r\n  ss.avg_score,\r\n  ss.excellent_course_count,\r\n  RANK() OVER (PARTITION BY ss.s_sex ORDER BY ss.avg_score DESC) AS gender_rank\r\nFROM StudentStats ss\r\nORDER BY ss.avg_score DESC;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT ss.s_id, ss.s_name, ss.s_sex, ss.course_count, ss.avg_score, ss.excellent_course_count, RANK() OVER (PARTITION BY ss.s_sex ORDER BY ss.avg_score DESC) AS gender_rank FROM (SELECT s.s_id, s.s_name, s.s_sex, COUNT(DISTINCT sc.c_id) AS course_count, AVG(sc.s_score) AS avg_score, COUNT(*) FILTER (WHERE sc.s_score > 90) AS excellent_course_count FROM Student s JOIN Score sc ON s.s_id = sc.s_id GROUP BY s.s_id, s.s_name, s.s_sex HAVING AVG(sc.s_score) > 80 AND COUNT(*) FILTER (WHERE sc.s_score > 90) >= 2) ss ORDER BY ss.avg_score DESC;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "46",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"46\", \"db_type\": \"mysql\", \"description\": \"此改写技术通过将外层过滤条件下推到子查询内部，减少子查询需要处理的数据规模，尤其对于需要聚合（group by）和窗口计算（row_number）的操作，避免对无效数据进行计算，从而提升整体性能。\", \"create_table_statements\": [\"CREATE TABLE users (user_id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) NOT NULL, status VARCHAR(50) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_users_status ON users(status);\", \"CREATE TABLE orders (order_id INT PRIMARY KEY AUTO_INCREMENT, user_id INT NOT NULL, order_date DATE NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_orders_user_id ON orders(user_id);\", \"CREATE INDEX idx_orders_order_date ON orders(order_date);\", \"CREATE INDEX idx_orders_user_id_order_date ON orders(user_id, order_date);\", \"CREATE TABLE order_items (order_item_id INT PRIMARY KEY AUTO_INCREMENT, order_id INT NOT NULL, product_id INT NOT NULL, quantity DECIMAL(10,2) NOT NULL, unit_price DECIMAL(10,2) NOT NULL, discount DECIMAL(5,2) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_order_items_order_id ON order_items(order_id);\", \"CREATE INDEX idx_order_items_product_id ON order_items(product_id);\", \"CREATE TABLE products (product_id INT PRIMARY KEY AUTO_INCREMENT, product_name VARCHAR(255) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\"], \"sql\": \"select /*QB_1*/ u.user_id,\\r\\n  u.username, COUNT(distinct o.order_id) as total_orders,\\r\\n  SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent,\\r\\n  AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value,\\r\\n  MAX(o.order_date) as last_order_date,\\r\\n  SQ_1758176107425.GROUP_CONCAT_ as top_products\\r\\nfrom users as u\\r\\ninner join orders as o\\r\\non u.user_id = o.user_id \\r\\nleft outer join order_items as oi\\r\\non o.order_id = oi.order_id \\r\\nleft outer join (\\r\\n  select /*SQ_1758176107425*/ oi2.user_id,\\r\\n  GROUP_CONCAT(distinct oi2.product_name order by oi2.product_name separator ', ') as GROUP_CONCAT_\\r\\n  from (\\r\\n  select /*QB_2*/ o3.user_id,\\r\\n  p.product_name,\\r\\n  row_number() over (partition by o3.user_id order by sum(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num\\r\\n  from order_items as oi2\\r\\n  inner join products as p\\r\\n  on oi2.product_id = p.product_id\\r\\n  inner join orders as o3\\r\\n  on o3.order_id = oi2.order_id\\r\\n  group by o3.user_id,\\r\\n  p.product_name\\r\\n  ) as oi2\\r\\n  where oi2.rank_num <= 3 \\r\\n  group by oi2.user_id \\r\\n  ) as SQ_1758176107425\\r\\non SQ_1758176107425.user_id = u.user_id\\r\\nwhere u.status = 'active'\\r\\n  and o.order_date >= DATE_SUB(CURRENT_DATE(),\\r\\n  interval '3' YEAR)\\r\\ngroup by u.user_id, u.username\\r\\nhaving COUNT(distinct o.order_id) > 0\\r\\norder by total_spent desc;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\to\\t\\tindex\\tidx_orders_user_id,idx_orders_order_date,idx_orders_user_id_order_date\\tidx_orders_user_id_order_date\\t7\\t\\t499550\\t50.0\\tUsing where; Using index; Using temporary; Using filesort\\n1\\tPRIMARY\\tu\\t\\teq_ref\\tPRIMARY,idx_users_status\\tPRIMARY\\t4\\ttest_db.o.user_id\\t1\\t50.0\\tUsing where\\n1\\tPRIMARY\\toi\\t\\tref\\tidx_order_items_order_id\\tidx_order_items_order_id\\t4\\ttest_db.o.order_id\\t5\\t100.0\\t\\n1\\tPRIMARY\\t<derived2>\\t\\tref\\t<auto_key0>\\t<auto_key0>\\t4\\ttest_db.o.user_id\\t10\\t100.0\\t\\n2\\tDERIVED\\t<derived3>\\t\\tALL\\t\\t\\t\\t\\t499070\\t33.33\\tUsing where; Using filesort\\n3\\tDERIVED\\toi2\\t\\tALL\\tidx_order_items_order_id,idx_order_items_product_id\\t\\t\\t\\t499070\\t100.0\\tUsing temporary; Using filesort\\n3\\tDERIVED\\tp\\t\\teq_ref\\tPRIMARY\\tPRIMARY\\t4\\ttest_db.oi2.product_id\\t1\\t100.0\\t\\n3\\tDERIVED\\to3\\t\\teq_ref\\tPRIMARY\\tPRIMARY\\t4\\ttest_db.oi2.order_id\\t1\\t100.0\\t\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"2701392.56\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_filesort\\\": true,\\n  \\\"grouping_operation\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": true,\\n  \\\"buffer_result\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"o\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_orders_user_id\\\",\\n  \\\"idx_orders_order_date\\\",\\n  \\\"idx_orders_user_id_order_date\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_orders_user_id_order_date\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"user_id\\\",\\n  \\\"order_date\\\"\\n  ],\\n  \\\"key_length\\\": \\\"7\\\",\\n  \\\"rows_examined_per_scan\\\": 499550,\\n  \\\"rows_produced_per_join\\\": 249775,\\n  \\\"filtered\\\": \\\"50.00\\\",\\n  \\\"using_index\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"25225.75\\\",\\n  \\\"eval_cost\\\": \\\"24977.50\\\",\\n  \\\"prefix_cost\\\": \\\"50203.25\\\",\\n  \\\"data_read_per_join\\\": \\\"3M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_id\\\",\\n  \\\"user_id\\\",\\n  \\\"order_date\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`o`.`order_date` >= <cache>((curdate() - interval '3' year)))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_users_status\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"user_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.o.user_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 124887,\\n  \\\"filtered\\\": \\\"50.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"205251.09\\\",\\n  \\\"eval_cost\\\": \\\"12488.72\\\",\\n  \\\"prefix_cost\\\": \\\"280431.84\\\",\\n  \\\"data_read_per_join\\\": \\\"72M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"user_id\\\",\\n  \\\"username\\\",\\n  \\\"status\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`status` = 'active')\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"oi\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_order_items_order_id\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_order_items_order_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"order_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.o.order_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 5,\\n  \\\"rows_produced_per_join\\\": 628820,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"157205.24\\\",\\n  \\\"eval_cost\\\": \\\"62882.10\\\",\\n  \\\"prefix_cost\\\": \\\"500519.18\\\",\\n  \\\"data_read_per_join\\\": \\\"19M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_item_id\\\",\\n  \\\"order_id\\\",\\n  \\\"quantity\\\",\\n  \\\"unit_price\\\",\\n  \\\"discount\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"SQ_1758176107425\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"<auto_key0>\\\"\\n  ],\\n  \\\"key\\\": \\\"<auto_key0>\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"user_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.o.user_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 10,\\n  \\\"rows_produced_per_join\\\": 6288209,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1572052.41\\\",\\n  \\\"eval_cost\\\": \\\"628820.97\\\",\\n  \\\"prefix_cost\\\": \\\"2701392.56\\\",\\n  \\\"data_read_per_join\\\": \\\"143M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"user_id\\\",\\n  \\\"GROUP_CONCAT_\\\"\\n  ],\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"222487.90\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n  \\\"using_filesort\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"166340.03\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"oi2\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 499070,\\n  \\\"rows_produced_per_join\\\": 166340,\\n  \\\"filtered\\\": \\\"33.33\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"39513.87\\\",\\n  \\\"eval_cost\\\": \\\"16634.00\\\",\\n  \\\"prefix_cost\\\": \\\"56147.88\\\",\\n  \\\"data_read_per_join\\\": \\\"164M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"user_id\\\",\\n  \\\"product_name\\\",\\n  \\\"rank_num\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`oi2`.`rank_num` <= 3)\\\",\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"898686.75\\\"\\n  },\\n  \\\"windowing\\\": {\\n  \\\"windows\\\": [\\n  {\\n  \\\"name\\\": \\\"<unnamed window>\\\",\\n  \\\"using_filesort\\\": true,\\n  \\\"filesort_key\\\": [\\n  \\\"`user_id`\\\",\\n  \\\"sum(((`quantity` * `unit_price`) * (1 - (`discount` / 100)))) desc\\\"\\n  ],\\n  \\\"functions\\\": [\\n  \\\"row_number\\\"\\n  ]\\n  }\\n  ],\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"499070.00\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": false,\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"oi2\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_order_items_order_id\\\",\\n  \\\"idx_order_items_product_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 499070,\\n  \\\"rows_produced_per_join\\\": 499070,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"360.75\\\",\\n  \\\"eval_cost\\\": \\\"49907.00\\\",\\n  \\\"prefix_cost\\\": \\\"50267.75\\\",\\n  \\\"data_read_per_join\\\": \\\"15M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_item_id\\\",\\n  \\\"order_id\\\",\\n  \\\"product_id\\\",\\n  \\\"quantity\\\",\\n  \\\"unit_price\\\",\\n  \\\"discount\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"p\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"product_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.oi2.product_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 499070,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"124767.50\\\",\\n  \\\"eval_cost\\\": \\\"49907.00\\\",\\n  \\\"prefix_cost\\\": \\\"224942.25\\\",\\n  \\\"data_read_per_join\\\": \\\"491M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"product_id\\\",\\n  \\\"product_name\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"o3\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"order_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.oi2.order_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 499070,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"124767.50\\\",\\n  \\\"eval_cost\\\": \\\"49907.00\\\",\\n  \\\"prefix_cost\\\": \\\"399616.75\\\",\\n  \\\"data_read_per_join\\\": \\\"7M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_id\\\",\\n  \\\"user_id\\\"\\n  ]\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推优化：1) 将高选择性条件'u.status=active'下推到窗口函数子查询中；2) 在子查询内添加JOIN users表过滤；3) 同步下推时间范围条件。避免对非活跃用户执行昂贵窗口计算，预计提升性能30-70%。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,在orders.order_date字段的条件中，检测到DATE类型与DATETIME类型比较导致的隐式转换风险。已通过CAST函数将日期值显式转换为DATETIME类型，消除潜在性能问题。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE users (user_id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) NOT NULL, status VARCHAR(50) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_users_status ON users(status);\nCREATE TABLE orders (order_id INT PRIMARY KEY AUTO_INCREMENT, user_id INT NOT NULL, order_date DATE NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_orders_user_id ON orders(user_id);\nCREATE INDEX idx_orders_order_date ON orders(order_date);\nCREATE INDEX idx_orders_user_id_order_date ON orders(user_id, order_date);\nCREATE TABLE order_items (order_item_id INT PRIMARY KEY AUTO_INCREMENT, order_id INT NOT NULL, product_id INT NOT NULL, quantity DECIMAL(10,2) NOT NULL, unit_price DECIMAL(10,2) NOT NULL, discount DECIMAL(5,2) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_order_items_order_id ON order_items(order_id);\nCREATE INDEX idx_order_items_product_id ON order_items(product_id);\nCREATE TABLE products (product_id INT PRIMARY KEY AUTO_INCREMENT, product_name VARCHAR(255) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\to\t\tindex\tidx_orders_user_id,idx_orders_order_date,idx_orders_user_id_order_date\tidx_orders_user_id_order_date\t7\t\t499550\t50.0\tUsing where; Using index; Using temporary; Using filesort\n1\tPRIMARY\tu\t\teq_ref\tPRIMARY,idx_users_status\tPRIMARY\t4\ttest_db.o.user_id\t1\t50.0\tUsing where\n1\tPRIMARY\toi\t\tref\tidx_order_items_order_id\tidx_order_items_order_id\t4\ttest_db.o.order_id\t5\t100.0\t\n1\tPRIMARY\t<derived2>\t\tref\t<auto_key0>\t<auto_key0>\t4\ttest_db.o.user_id\t10\t100.0\t\n2\tDERIVED\t<derived3>\t\tALL\t\t\t\t\t499070\t33.33\tUsing where; Using filesort\n3\tDERIVED\toi2\t\tALL\tidx_order_items_order_id,idx_order_items_product_id\t\t\t\t499070\t100.0\tUsing temporary; Using filesort\n3\tDERIVED\tp\t\teq_ref\tPRIMARY\tPRIMARY\t4\ttest_db.oi2.product_id\t1\t100.0\t\n3\tDERIVED\to3\t\teq_ref\tPRIMARY\tPRIMARY\t4\ttest_db.oi2.order_id\t1\t100.0\t\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"2701392.56\"\n  },\n  \"ordering_operation\": {\n  \"using_filesort\": true,\n  \"grouping_operation\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": true,\n  \"buffer_result\": {\n  \"using_temporary_table\": true,\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"o\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"idx_orders_user_id\",\n  \"idx_orders_order_date\",\n  \"idx_orders_user_id_order_date\"\n  ],\n  \"key\": \"idx_orders_user_id_order_date\",\n  \"used_key_parts\": [\n  \"user_id\",\n  \"order_date\"\n  ],\n  \"key_length\": \"7\",\n  \"rows_examined_per_scan\": 499550,\n  \"rows_produced_per_join\": 249775,\n  \"filtered\": \"50.00\",\n  \"using_index\": true,\n  \"cost_info\": {\n  \"read_cost\": \"25225.75\",\n  \"eval_cost\": \"24977.50\",\n  \"prefix_cost\": \"50203.25\",\n  \"data_read_per_join\": \"3M\"\n  },\n  \"used_columns\": [\n  \"order_id\",\n  \"user_id\",\n  \"order_date\"\n  ],\n  \"attached_condition\": \"(`test_db`.`o`.`order_date` >= <cache>((curdate() - interval '3' year)))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_users_status\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"user_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.o.user_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 124887,\n  \"filtered\": \"50.00\",\n  \"cost_info\": {\n  \"read_cost\": \"205251.09\",\n  \"eval_cost\": \"12488.72\",\n  \"prefix_cost\": \"280431.84\",\n  \"data_read_per_join\": \"72M\"\n  },\n  \"used_columns\": [\n  \"user_id\",\n  \"username\",\n  \"status\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`status` = 'active')\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"oi\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_order_items_order_id\"\n  ],\n  \"key\": \"idx_order_items_order_id\",\n  \"used_key_parts\": [\n  \"order_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.o.order_id\"\n  ],\n  \"rows_examined_per_scan\": 5,\n  \"rows_produced_per_join\": 628820,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"157205.24\",\n  \"eval_cost\": \"62882.10\",\n  \"prefix_cost\": \"500519.18\",\n  \"data_read_per_join\": \"19M\"\n  },\n  \"used_columns\": [\n  \"order_item_id\",\n  \"order_id\",\n  \"quantity\",\n  \"unit_price\",\n  \"discount\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"SQ_1758176107425\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"<auto_key0>\"\n  ],\n  \"key\": \"<auto_key0>\",\n  \"used_key_parts\": [\n  \"user_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.o.user_id\"\n  ],\n  \"rows_examined_per_scan\": 10,\n  \"rows_produced_per_join\": 6288209,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"1572052.41\",\n  \"eval_cost\": \"628820.97\",\n  \"prefix_cost\": \"2701392.56\",\n  \"data_read_per_join\": \"143M\"\n  },\n  \"used_columns\": [\n  \"user_id\",\n  \"GROUP_CONCAT_\"\n  ],\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"222487.90\"\n  },\n  \"grouping_operation\": {\n  \"using_filesort\": true,\n  \"cost_info\": {\n  \"sort_cost\": \"166340.03\"\n  },\n  \"table\": {\n  \"table_name\": \"oi2\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 499070,\n  \"rows_produced_per_join\": 166340,\n  \"filtered\": \"33.33\",\n  \"cost_info\": {\n  \"read_cost\": \"39513.87\",\n  \"eval_cost\": \"16634.00\",\n  \"prefix_cost\": \"56147.88\",\n  \"data_read_per_join\": \"164M\"\n  },\n  \"used_columns\": [\n  \"user_id\",\n  \"product_name\",\n  \"rank_num\"\n  ],\n  \"attached_condition\": \"(`oi2`.`rank_num` <= 3)\",\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"898686.75\"\n  },\n  \"windowing\": {\n  \"windows\": [\n  {\n  \"name\": \"<unnamed window>\",\n  \"using_filesort\": true,\n  \"filesort_key\": [\n  \"`user_id`\",\n  \"sum(((`quantity` * `unit_price`) * (1 - (`discount` / 100)))) desc\"\n  ],\n  \"functions\": [\n  \"row_number\"\n  ]\n  }\n  ],\n  \"cost_info\": {\n  \"sort_cost\": \"499070.00\"\n  },\n  \"grouping_operation\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": false,\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"oi2\",\n  \"access_type\": \"ALL\",\n  \"possible_keys\": [\n  \"idx_order_items_order_id\",\n  \"idx_order_items_product_id\"\n  ],\n  \"rows_examined_per_scan\": 499070,\n  \"rows_produced_per_join\": 499070,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"360.75\",\n  \"eval_cost\": \"49907.00\",\n  \"prefix_cost\": \"50267.75\",\n  \"data_read_per_join\": \"15M\"\n  },\n  \"used_columns\": [\n  \"order_item_id\",\n  \"order_id\",\n  \"product_id\",\n  \"quantity\",\n  \"unit_price\",\n  \"discount\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"p\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"product_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.oi2.product_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 499070,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"124767.50\",\n  \"eval_cost\": \"49907.00\",\n  \"prefix_cost\": \"224942.25\",\n  \"data_read_per_join\": \"491M\"\n  },\n  \"used_columns\": [\n  \"product_id\",\n  \"product_name\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"o3\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"order_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.oi2.order_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 499070,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"124767.50\",\n  \"eval_cost\": \"49907.00\",\n  \"prefix_cost\": \"399616.75\",\n  \"data_read_per_join\": \"7M\"\n  },\n  \"used_columns\": [\n  \"order_id\",\n  \"user_id\"\n  ]\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n}\n\n## Original SQL:\nselect /*QB_1*/ u.user_id,\r\n  u.username, COUNT(distinct o.order_id) as total_orders,\r\n  SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent,\r\n  AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value,\r\n  MAX(o.order_date) as last_order_date,\r\n  SQ_1758176107425.GROUP_CONCAT_ as top_products\r\nfrom users as u\r\ninner join orders as o\r\non u.user_id = o.user_id \r\nleft outer join order_items as oi\r\non o.order_id = oi.order_id \r\nleft outer join (\r\n  select /*SQ_1758176107425*/ oi2.user_id,\r\n  GROUP_CONCAT(distinct oi2.product_name order by oi2.product_name separator ', ') as GROUP_CONCAT_\r\n  from (\r\n  select /*QB_2*/ o3.user_id,\r\n  p.product_name,\r\n  row_number() over (partition by o3.user_id order by sum(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num\r\n  from order_items as oi2\r\n  inner join products as p\r\n  on oi2.product_id = p.product_id\r\n  inner join orders as o3\r\n  on o3.order_id = oi2.order_id\r\n  group by o3.user_id,\r\n  p.product_name\r\n  ) as oi2\r\n  where oi2.rank_num <= 3 \r\n  group by oi2.user_id \r\n  ) as SQ_1758176107425\r\non SQ_1758176107425.user_id = u.user_id\r\nwhere u.status = 'active'\r\n  and o.order_date >= DATE_SUB(CURRENT_DATE(),\r\n  interval '3' YEAR)\r\ngroup by u.user_id, u.username\r\nhaving COUNT(distinct o.order_id) > 0\r\norder by total_spent desc;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select u.user_id, u.username, COUNT(distinct o.order_id) as total_orders, SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent, AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value, MAX(o.order_date) as last_order_date, tp.top_products from users u inner join orders o on u.user_id = o.user_id and o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 YEAR) left join order_items oi on o.order_id = oi.order_id left join (select user_id, GROUP_CONCAT(distinct product_name order by product_name separator ', ') as top_products from (select o3.user_id, p.product_name, row_number() over (partition by o3.user_id order by SUM(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num from orders o3 inner join order_items oi2 on o3.order_id = oi2.order_id inner join products p on oi2.product_id = p.product_id where o3.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 YEAR) group by o3.user_id, p.product_name) ranked_products where rank_num <= 3 group by user_id) tp on tp.user_id = u.user_id where u.status = 'active' group by u.user_id, u.username having COUNT(distinct o.order_id) > 0 order by total_spent desc;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "46",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"46\", \"db_type\": \"mysql\", \"description\": \"此改写技术通过将外层过滤条件下推到子查询内部，减少子查询需要处理的数据规模，尤其对于需要聚合（group by）和窗口计算（row_number）的操作，避免对无效数据进行计算，从而提升整体性能。\", \"create_table_statements\": [\"CREATE TABLE users (user_id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) NOT NULL, status VARCHAR(50) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_users_status ON users(status);\", \"CREATE TABLE orders (order_id INT PRIMARY KEY AUTO_INCREMENT, user_id INT NOT NULL, order_date DATE NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_orders_user_id ON orders(user_id);\", \"CREATE INDEX idx_orders_order_date ON orders(order_date);\", \"CREATE INDEX idx_orders_user_id_order_date ON orders(user_id, order_date);\", \"CREATE TABLE order_items (order_item_id INT PRIMARY KEY AUTO_INCREMENT, order_id INT NOT NULL, product_id INT NOT NULL, quantity DECIMAL(10,2) NOT NULL, unit_price DECIMAL(10,2) NOT NULL, discount DECIMAL(5,2) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_order_items_order_id ON order_items(order_id);\", \"CREATE INDEX idx_order_items_product_id ON order_items(product_id);\", \"CREATE TABLE products (product_id INT PRIMARY KEY AUTO_INCREMENT, product_name VARCHAR(255) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\"], \"sql\": \"select /*QB_1*/ u.user_id,\\r\\n  u.username, COUNT(distinct o.order_id) as total_orders,\\r\\n  SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent,\\r\\n  AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value,\\r\\n  MAX(o.order_date) as last_order_date,\\r\\n  SQ_1758176107425.GROUP_CONCAT_ as top_products\\r\\nfrom users as u\\r\\ninner join orders as o\\r\\non u.user_id = o.user_id \\r\\nleft outer join order_items as oi\\r\\non o.order_id = oi.order_id \\r\\nleft outer join (\\r\\n  select /*SQ_1758176107425*/ oi2.user_id,\\r\\n  GROUP_CONCAT(distinct oi2.product_name order by oi2.product_name separator ', ') as GROUP_CONCAT_\\r\\n  from (\\r\\n  select /*QB_2*/ o3.user_id,\\r\\n  p.product_name,\\r\\n  row_number() over (partition by o3.user_id order by sum(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num\\r\\n  from order_items as oi2\\r\\n  inner join products as p\\r\\n  on oi2.product_id = p.product_id\\r\\n  inner join orders as o3\\r\\n  on o3.order_id = oi2.order_id\\r\\n  group by o3.user_id,\\r\\n  p.product_name\\r\\n  ) as oi2\\r\\n  where oi2.rank_num <= 3 \\r\\n  group by oi2.user_id \\r\\n  ) as SQ_1758176107425\\r\\non SQ_1758176107425.user_id = u.user_id\\r\\nwhere u.status = 'active'\\r\\n  and o.order_date >= DATE_SUB(CURRENT_DATE(),\\r\\n  interval '3' YEAR)\\r\\ngroup by u.user_id, u.username\\r\\nhaving COUNT(distinct o.order_id) > 0\\r\\norder by total_spent desc;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\to\\t\\tindex\\tidx_orders_user_id,idx_orders_order_date,idx_orders_user_id_order_date\\tidx_orders_user_id_order_date\\t7\\t\\t499550\\t50.0\\tUsing where; Using index; Using temporary; Using filesort\\n1\\tPRIMARY\\tu\\t\\teq_ref\\tPRIMARY,idx_users_status\\tPRIMARY\\t4\\ttest_db.o.user_id\\t1\\t50.0\\tUsing where\\n1\\tPRIMARY\\toi\\t\\tref\\tidx_order_items_order_id\\tidx_order_items_order_id\\t4\\ttest_db.o.order_id\\t5\\t100.0\\t\\n1\\tPRIMARY\\t<derived2>\\t\\tref\\t<auto_key0>\\t<auto_key0>\\t4\\ttest_db.o.user_id\\t10\\t100.0\\t\\n2\\tDERIVED\\t<derived3>\\t\\tALL\\t\\t\\t\\t\\t499070\\t33.33\\tUsing where; Using filesort\\n3\\tDERIVED\\toi2\\t\\tALL\\tidx_order_items_order_id,idx_order_items_product_id\\t\\t\\t\\t499070\\t100.0\\tUsing temporary; Using filesort\\n3\\tDERIVED\\tp\\t\\teq_ref\\tPRIMARY\\tPRIMARY\\t4\\ttest_db.oi2.product_id\\t1\\t100.0\\t\\n3\\tDERIVED\\to3\\t\\teq_ref\\tPRIMARY\\tPRIMARY\\t4\\ttest_db.oi2.order_id\\t1\\t100.0\\t\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"2701392.56\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_filesort\\\": true,\\n  \\\"grouping_operation\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": true,\\n  \\\"buffer_result\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"o\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_orders_user_id\\\",\\n  \\\"idx_orders_order_date\\\",\\n  \\\"idx_orders_user_id_order_date\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_orders_user_id_order_date\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"user_id\\\",\\n  \\\"order_date\\\"\\n  ],\\n  \\\"key_length\\\": \\\"7\\\",\\n  \\\"rows_examined_per_scan\\\": 499550,\\n  \\\"rows_produced_per_join\\\": 249775,\\n  \\\"filtered\\\": \\\"50.00\\\",\\n  \\\"using_index\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"25225.75\\\",\\n  \\\"eval_cost\\\": \\\"24977.50\\\",\\n  \\\"prefix_cost\\\": \\\"50203.25\\\",\\n  \\\"data_read_per_join\\\": \\\"3M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_id\\\",\\n  \\\"user_id\\\",\\n  \\\"order_date\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`o`.`order_date` >= <cache>((curdate() - interval '3' year)))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_users_status\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"user_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.o.user_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 124887,\\n  \\\"filtered\\\": \\\"50.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"205251.09\\\",\\n  \\\"eval_cost\\\": \\\"12488.72\\\",\\n  \\\"prefix_cost\\\": \\\"280431.84\\\",\\n  \\\"data_read_per_join\\\": \\\"72M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"user_id\\\",\\n  \\\"username\\\",\\n  \\\"status\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`status` = 'active')\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"oi\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_order_items_order_id\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_order_items_order_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"order_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.o.order_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 5,\\n  \\\"rows_produced_per_join\\\": 628820,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"157205.24\\\",\\n  \\\"eval_cost\\\": \\\"62882.10\\\",\\n  \\\"prefix_cost\\\": \\\"500519.18\\\",\\n  \\\"data_read_per_join\\\": \\\"19M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_item_id\\\",\\n  \\\"order_id\\\",\\n  \\\"quantity\\\",\\n  \\\"unit_price\\\",\\n  \\\"discount\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"SQ_1758176107425\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"<auto_key0>\\\"\\n  ],\\n  \\\"key\\\": \\\"<auto_key0>\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"user_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.o.user_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 10,\\n  \\\"rows_produced_per_join\\\": 6288209,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1572052.41\\\",\\n  \\\"eval_cost\\\": \\\"628820.97\\\",\\n  \\\"prefix_cost\\\": \\\"2701392.56\\\",\\n  \\\"data_read_per_join\\\": \\\"143M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"user_id\\\",\\n  \\\"GROUP_CONCAT_\\\"\\n  ],\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"222487.90\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n  \\\"using_filesort\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"166340.03\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"oi2\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 499070,\\n  \\\"rows_produced_per_join\\\": 166340,\\n  \\\"filtered\\\": \\\"33.33\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"39513.87\\\",\\n  \\\"eval_cost\\\": \\\"16634.00\\\",\\n  \\\"prefix_cost\\\": \\\"56147.88\\\",\\n  \\\"data_read_per_join\\\": \\\"164M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"user_id\\\",\\n  \\\"product_name\\\",\\n  \\\"rank_num\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`oi2`.`rank_num` <= 3)\\\",\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"898686.75\\\"\\n  },\\n  \\\"windowing\\\": {\\n  \\\"windows\\\": [\\n  {\\n  \\\"name\\\": \\\"<unnamed window>\\\",\\n  \\\"using_filesort\\\": true,\\n  \\\"filesort_key\\\": [\\n  \\\"`user_id`\\\",\\n  \\\"sum(((`quantity` * `unit_price`) * (1 - (`discount` / 100)))) desc\\\"\\n  ],\\n  \\\"functions\\\": [\\n  \\\"row_number\\\"\\n  ]\\n  }\\n  ],\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"499070.00\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": false,\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"oi2\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_order_items_order_id\\\",\\n  \\\"idx_order_items_product_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 499070,\\n  \\\"rows_produced_per_join\\\": 499070,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"360.75\\\",\\n  \\\"eval_cost\\\": \\\"49907.00\\\",\\n  \\\"prefix_cost\\\": \\\"50267.75\\\",\\n  \\\"data_read_per_join\\\": \\\"15M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_item_id\\\",\\n  \\\"order_id\\\",\\n  \\\"product_id\\\",\\n  \\\"quantity\\\",\\n  \\\"unit_price\\\",\\n  \\\"discount\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"p\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"product_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.oi2.product_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 499070,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"124767.50\\\",\\n  \\\"eval_cost\\\": \\\"49907.00\\\",\\n  \\\"prefix_cost\\\": \\\"224942.25\\\",\\n  \\\"data_read_per_join\\\": \\\"491M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"product_id\\\",\\n  \\\"product_name\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"o3\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"order_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.oi2.order_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 499070,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"124767.50\\\",\\n  \\\"eval_cost\\\": \\\"49907.00\\\",\\n  \\\"prefix_cost\\\": \\\"399616.75\\\",\\n  \\\"data_read_per_join\\\": \\\"7M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_id\\\",\\n  \\\"user_id\\\"\\n  ]\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推优化：1) 将高选择性条件'u.status=active'下推到窗口函数子查询中；2) 在子查询内添加JOIN users表过滤；3) 同步下推时间范围条件。避免对非活跃用户执行昂贵窗口计算，预计提升性能30-70%。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"隐式转换,在orders.order_date字段的条件中，检测到DATE类型与DATETIME类型比较导致的隐式转换风险。已通过CAST函数将日期值显式转换为DATETIME类型，消除潜在性能问题。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE users (user_id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) NOT NULL, status VARCHAR(50) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_users_status ON users(status);\nCREATE TABLE orders (order_id INT PRIMARY KEY AUTO_INCREMENT, user_id INT NOT NULL, order_date DATE NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_orders_user_id ON orders(user_id);\nCREATE INDEX idx_orders_order_date ON orders(order_date);\nCREATE INDEX idx_orders_user_id_order_date ON orders(user_id, order_date);\nCREATE TABLE order_items (order_item_id INT PRIMARY KEY AUTO_INCREMENT, order_id INT NOT NULL, product_id INT NOT NULL, quantity DECIMAL(10,2) NOT NULL, unit_price DECIMAL(10,2) NOT NULL, discount DECIMAL(5,2) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_order_items_order_id ON order_items(order_id);\nCREATE INDEX idx_order_items_product_id ON order_items(product_id);\nCREATE TABLE products (product_id INT PRIMARY KEY AUTO_INCREMENT, product_name VARCHAR(255) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\to\t\tindex\tidx_orders_user_id,idx_orders_order_date,idx_orders_user_id_order_date\tidx_orders_user_id_order_date\t7\t\t499550\t50.0\tUsing where; Using index; Using temporary; Using filesort\n1\tPRIMARY\tu\t\teq_ref\tPRIMARY,idx_users_status\tPRIMARY\t4\ttest_db.o.user_id\t1\t50.0\tUsing where\n1\tPRIMARY\toi\t\tref\tidx_order_items_order_id\tidx_order_items_order_id\t4\ttest_db.o.order_id\t5\t100.0\t\n1\tPRIMARY\t<derived2>\t\tref\t<auto_key0>\t<auto_key0>\t4\ttest_db.o.user_id\t10\t100.0\t\n2\tDERIVED\t<derived3>\t\tALL\t\t\t\t\t499070\t33.33\tUsing where; Using filesort\n3\tDERIVED\toi2\t\tALL\tidx_order_items_order_id,idx_order_items_product_id\t\t\t\t499070\t100.0\tUsing temporary; Using filesort\n3\tDERIVED\tp\t\teq_ref\tPRIMARY\tPRIMARY\t4\ttest_db.oi2.product_id\t1\t100.0\t\n3\tDERIVED\to3\t\teq_ref\tPRIMARY\tPRIMARY\t4\ttest_db.oi2.order_id\t1\t100.0\t\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"2701392.56\"\n  },\n  \"ordering_operation\": {\n  \"using_filesort\": true,\n  \"grouping_operation\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": true,\n  \"buffer_result\": {\n  \"using_temporary_table\": true,\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"o\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"idx_orders_user_id\",\n  \"idx_orders_order_date\",\n  \"idx_orders_user_id_order_date\"\n  ],\n  \"key\": \"idx_orders_user_id_order_date\",\n  \"used_key_parts\": [\n  \"user_id\",\n  \"order_date\"\n  ],\n  \"key_length\": \"7\",\n  \"rows_examined_per_scan\": 499550,\n  \"rows_produced_per_join\": 249775,\n  \"filtered\": \"50.00\",\n  \"using_index\": true,\n  \"cost_info\": {\n  \"read_cost\": \"25225.75\",\n  \"eval_cost\": \"24977.50\",\n  \"prefix_cost\": \"50203.25\",\n  \"data_read_per_join\": \"3M\"\n  },\n  \"used_columns\": [\n  \"order_id\",\n  \"user_id\",\n  \"order_date\"\n  ],\n  \"attached_condition\": \"(`test_db`.`o`.`order_date` >= <cache>((curdate() - interval '3' year)))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_users_status\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"user_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.o.user_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 124887,\n  \"filtered\": \"50.00\",\n  \"cost_info\": {\n  \"read_cost\": \"205251.09\",\n  \"eval_cost\": \"12488.72\",\n  \"prefix_cost\": \"280431.84\",\n  \"data_read_per_join\": \"72M\"\n  },\n  \"used_columns\": [\n  \"user_id\",\n  \"username\",\n  \"status\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`status` = 'active')\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"oi\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_order_items_order_id\"\n  ],\n  \"key\": \"idx_order_items_order_id\",\n  \"used_key_parts\": [\n  \"order_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.o.order_id\"\n  ],\n  \"rows_examined_per_scan\": 5,\n  \"rows_produced_per_join\": 628820,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"157205.24\",\n  \"eval_cost\": \"62882.10\",\n  \"prefix_cost\": \"500519.18\",\n  \"data_read_per_join\": \"19M\"\n  },\n  \"used_columns\": [\n  \"order_item_id\",\n  \"order_id\",\n  \"quantity\",\n  \"unit_price\",\n  \"discount\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"SQ_1758176107425\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"<auto_key0>\"\n  ],\n  \"key\": \"<auto_key0>\",\n  \"used_key_parts\": [\n  \"user_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.o.user_id\"\n  ],\n  \"rows_examined_per_scan\": 10,\n  \"rows_produced_per_join\": 6288209,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"1572052.41\",\n  \"eval_cost\": \"628820.97\",\n  \"prefix_cost\": \"2701392.56\",\n  \"data_read_per_join\": \"143M\"\n  },\n  \"used_columns\": [\n  \"user_id\",\n  \"GROUP_CONCAT_\"\n  ],\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"222487.90\"\n  },\n  \"grouping_operation\": {\n  \"using_filesort\": true,\n  \"cost_info\": {\n  \"sort_cost\": \"166340.03\"\n  },\n  \"table\": {\n  \"table_name\": \"oi2\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 499070,\n  \"rows_produced_per_join\": 166340,\n  \"filtered\": \"33.33\",\n  \"cost_info\": {\n  \"read_cost\": \"39513.87\",\n  \"eval_cost\": \"16634.00\",\n  \"prefix_cost\": \"56147.88\",\n  \"data_read_per_join\": \"164M\"\n  },\n  \"used_columns\": [\n  \"user_id\",\n  \"product_name\",\n  \"rank_num\"\n  ],\n  \"attached_condition\": \"(`oi2`.`rank_num` <= 3)\",\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"898686.75\"\n  },\n  \"windowing\": {\n  \"windows\": [\n  {\n  \"name\": \"<unnamed window>\",\n  \"using_filesort\": true,\n  \"filesort_key\": [\n  \"`user_id`\",\n  \"sum(((`quantity` * `unit_price`) * (1 - (`discount` / 100)))) desc\"\n  ],\n  \"functions\": [\n  \"row_number\"\n  ]\n  }\n  ],\n  \"cost_info\": {\n  \"sort_cost\": \"499070.00\"\n  },\n  \"grouping_operation\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": false,\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"oi2\",\n  \"access_type\": \"ALL\",\n  \"possible_keys\": [\n  \"idx_order_items_order_id\",\n  \"idx_order_items_product_id\"\n  ],\n  \"rows_examined_per_scan\": 499070,\n  \"rows_produced_per_join\": 499070,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"360.75\",\n  \"eval_cost\": \"49907.00\",\n  \"prefix_cost\": \"50267.75\",\n  \"data_read_per_join\": \"15M\"\n  },\n  \"used_columns\": [\n  \"order_item_id\",\n  \"order_id\",\n  \"product_id\",\n  \"quantity\",\n  \"unit_price\",\n  \"discount\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"p\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"product_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.oi2.product_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 499070,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"124767.50\",\n  \"eval_cost\": \"49907.00\",\n  \"prefix_cost\": \"224942.25\",\n  \"data_read_per_join\": \"491M\"\n  },\n  \"used_columns\": [\n  \"product_id\",\n  \"product_name\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"o3\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"order_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.oi2.order_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 499070,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"124767.50\",\n  \"eval_cost\": \"49907.00\",\n  \"prefix_cost\": \"399616.75\",\n  \"data_read_per_join\": \"7M\"\n  },\n  \"used_columns\": [\n  \"order_id\",\n  \"user_id\"\n  ]\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n}\n\n## Original SQL:\nselect /*QB_1*/ u.user_id,\r\n  u.username, COUNT(distinct o.order_id) as total_orders,\r\n  SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent,\r\n  AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value,\r\n  MAX(o.order_date) as last_order_date,\r\n  SQ_1758176107425.GROUP_CONCAT_ as top_products\r\nfrom users as u\r\ninner join orders as o\r\non u.user_id = o.user_id \r\nleft outer join order_items as oi\r\non o.order_id = oi.order_id \r\nleft outer join (\r\n  select /*SQ_1758176107425*/ oi2.user_id,\r\n  GROUP_CONCAT(distinct oi2.product_name order by oi2.product_name separator ', ') as GROUP_CONCAT_\r\n  from (\r\n  select /*QB_2*/ o3.user_id,\r\n  p.product_name,\r\n  row_number() over (partition by o3.user_id order by sum(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num\r\n  from order_items as oi2\r\n  inner join products as p\r\n  on oi2.product_id = p.product_id\r\n  inner join orders as o3\r\n  on o3.order_id = oi2.order_id\r\n  group by o3.user_id,\r\n  p.product_name\r\n  ) as oi2\r\n  where oi2.rank_num <= 3 \r\n  group by oi2.user_id \r\n  ) as SQ_1758176107425\r\non SQ_1758176107425.user_id = u.user_id\r\nwhere u.status = 'active'\r\n  and o.order_date >= DATE_SUB(CURRENT_DATE(),\r\n  interval '3' YEAR)\r\ngroup by u.user_id, u.username\r\nhaving COUNT(distinct o.order_id) > 0\r\norder by total_spent desc;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select u.user_id, u.username, COUNT(distinct o.order_id) as total_orders, SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent, AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value, MAX(o.order_date) as last_order_date, tp.top_products from users u inner join orders o on u.user_id = o.user_id and o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 YEAR) left join order_items oi on o.order_id = oi.order_id left join (select user_id, GROUP_CONCAT(distinct product_name order by product_name separator ', ') as top_products from (select o3.user_id, p.product_name, row_number() over (partition by o3.user_id order by SUM(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num from orders o3 inner join order_items oi2 on o3.order_id = oi2.order_id inner join products p on oi2.product_id = p.product_id where o3.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 YEAR) group by o3.user_id, p.product_name) ranked_products where rank_num <= 3 group by user_id) tp on tp.user_id = u.user_id where u.status = 'active' group by u.user_id, u.username having COUNT(distinct o.order_id) > 0 order by total_spent desc;"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "47",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"47\", \"db_type\": \"mysql\", \"description\": \"通过分析业务逻辑：avg_cust_rate子查询基于vehicle_type, booking_status, payment_method分组，而base表在JOIN时使用相同的字段组合匹配，因此不可能存在base记录在avg_cust_rate中找不到对应分组的情况。同时，WHERE条件要求字段差值的绝对值>=1，强制avg_cust_rate.avg_v必须有值，故LEFT JOIN时保留的NULL记录必然被WHERE过滤。改为INNER JOIN排除了这些无效记录，减少了中间结果集大小。\", \"create_table_statements\": [\"CREATE TABLE ride_bookings (id BIGINT PRIMARY KEY AUTO_INCREMENT, vehicle_type VARCHAR(50) NOT NULL, booking_status VARCHAR(50) NOT NULL, payment_method VARCHAR(50) NOT NULL, ride_distance NUMERIC(10,2) NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_grouping ON ride_bookings (vehicle_type, booking_status, payment_method);\", \"CREATE INDEX idx_ride_distance ON ride_bookings (ride_distance);\"], \"sql\": \"select * \\r\\nfrom (\\r\\nselect base.vehicle_type, base.booking_status, base.payment_method, base.ride_distance, coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0) as rate, \\r\\n row_number() over(partition by base.vehicle_type order by abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) desc ) as rank_num \\r\\nfrom ride_bookings base \\r\\nleft join (\\r\\n\\tselect vehicle_type, booking_status,payment_method,coalesce(avg(ride_distance), 0) as avg_v\\r\\n\\tfrom ride_bookings \\r\\n\\tgroup by vehicle_type, booking_status,payment_method\\r\\n) avg_cust_rate \\r\\non base.vehicle_type = avg_cust_rate.vehicle_type and base.booking_status = avg_cust_rate.booking_status and base.payment_method = avg_cust_rate.payment_method \\r\\nwhere abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) >= 1 \\r\\n) fn \\r\\nwhere rank_num <=5;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t4987160\\t33.33\\tUsing where\\n2\\tDERIVED\\tbase\\t\\tALL\\t\\t\\t\\t\\t498713\\t100.0\\tUsing temporary; Using filesort\\n2\\tDERIVED\\t<derived3>\\t\\tref\\t<auto_key0>\\t<auto_key0>\\t606\\ttest_db.base.vehicle_type,test_db.base.booking_status,test_db.base.payment_method\\t10\\t100.0\\tUsing where\\n3\\tDERIVED\\tride_bookings\\t\\tindex\\tidx_grouping\\tidx_grouping\\t606\\t\\t498713\\t100.0\\t\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"561058.00\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"fn\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 4987160,\\n  \\\"rows_produced_per_join\\\": 1662220,\\n  \\\"filtered\\\": \\\"33.33\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"394835.96\\\",\\n  \\\"eval_cost\\\": \\\"166222.04\\\",\\n  \\\"prefix_cost\\\": \\\"561058.00\\\",\\n  \\\"data_read_per_join\\\": \\\"1001M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\",\\n  \\\"ride_distance\\\",\\n  \\\"rate\\\",\\n  \\\"rank_num\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`fn`.`rank_num` <= 5)\\\",\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"6783026.30\\\"\\n  },\\n  \\\"windowing\\\": {\\n  \\\"windows\\\": [\\n  {\\n  \\\"name\\\": \\\"<unnamed window>\\\",\\n  \\\"using_filesort\\\": true,\\n  \\\"filesort_key\\\": [\\n  \\\"`vehicle_type`\\\",\\n  \\\"abs((coalesce(`ride_distance`,0) - coalesce(`avg_v`,0))) desc\\\"\\n  ],\\n  \\\"functions\\\": [\\n  \\\"row_number\\\"\\n  ]\\n  }\\n  ],\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"4987160.00\\\"\\n  },\\n  \\\"buffer_result\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"base\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 498713,\\n  \\\"rows_produced_per_join\\\": 498713,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"489.00\\\",\\n  \\\"eval_cost\\\": \\\"49871.30\\\",\\n  \\\"prefix_cost\\\": \\\"50360.30\\\",\\n  \\\"data_read_per_join\\\": \\\"296M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\",\\n  \\\"ride_distance\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"avg_cust_rate\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"<auto_key0>\\\"\\n  ],\\n  \\\"key\\\": \\\"<auto_key0>\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\"\\n  ],\\n  \\\"key_length\\\": \\\"606\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.base.vehicle_type\\\",\\n  \\\"test_db.base.booking_status\\\",\\n  \\\"test_db.base.payment_method\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 10,\\n  \\\"rows_produced_per_join\\\": 4987160,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1246790.00\\\",\\n  \\\"eval_cost\\\": \\\"498716.00\\\",\\n  \\\"prefix_cost\\\": \\\"1795866.30\\\",\\n  \\\"data_read_per_join\\\": \\\"2G\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\",\\n  \\\"avg_v\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"<if>(found_match(avg_cust_rate), (abs((coalesce(`test_db`.`base`.`ride_distance`,0) - coalesce(`avg_cust_rate`.`avg_v`,0))) >= 1), true)\\\",\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"50360.30\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n  \\\"using_filesort\\\": false,\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"ride_bookings\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_grouping\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_grouping\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\"\\n  ],\\n  \\\"key_length\\\": \\\"606\\\",\\n  \\\"rows_examined_per_scan\\\": 498713,\\n  \\\"rows_produced_per_join\\\": 498713,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"489.00\\\",\\n  \\\"eval_cost\\\": \\\"49871.30\\\",\\n  \\\"prefix_cost\\\": \\\"50360.30\\\",\\n  \\\"data_read_per_join\\\": \\\"296M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\",\\n  \\\"ride_distance\\\"\\n  ]\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,将LEFT JOIN优化为INNER JOIN。原始LEFT JOIN的右表子查询通过分组聚合确保左表所有记录都能匹配，WHERE条件和SELECT子句都依赖右表具体值。转换后语义不变但消除NULL处理开销，允许优化器更好地选择连接顺序。\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE ride_bookings (id BIGINT PRIMARY KEY AUTO_INCREMENT, vehicle_type VARCHAR(50) NOT NULL, booking_status VARCHAR(50) NOT NULL, payment_method VARCHAR(50) NOT NULL, ride_distance NUMERIC(10,2) NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_grouping ON ride_bookings (vehicle_type, booking_status, payment_method);\nCREATE INDEX idx_ride_distance ON ride_bookings (ride_distance);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t4987160\t33.33\tUsing where\n2\tDERIVED\tbase\t\tALL\t\t\t\t\t498713\t100.0\tUsing temporary; Using filesort\n2\tDERIVED\t<derived3>\t\tref\t<auto_key0>\t<auto_key0>\t606\ttest_db.base.vehicle_type,test_db.base.booking_status,test_db.base.payment_method\t10\t100.0\tUsing where\n3\tDERIVED\tride_bookings\t\tindex\tidx_grouping\tidx_grouping\t606\t\t498713\t100.0\t\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"561058.00\"\n  },\n  \"table\": {\n  \"table_name\": \"fn\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 4987160,\n  \"rows_produced_per_join\": 1662220,\n  \"filtered\": \"33.33\",\n  \"cost_info\": {\n  \"read_cost\": \"394835.96\",\n  \"eval_cost\": \"166222.04\",\n  \"prefix_cost\": \"561058.00\",\n  \"data_read_per_join\": \"1001M\"\n  },\n  \"used_columns\": [\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\",\n  \"ride_distance\",\n  \"rate\",\n  \"rank_num\"\n  ],\n  \"attached_condition\": \"(`fn`.`rank_num` <= 5)\",\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"6783026.30\"\n  },\n  \"windowing\": {\n  \"windows\": [\n  {\n  \"name\": \"<unnamed window>\",\n  \"using_filesort\": true,\n  \"filesort_key\": [\n  \"`vehicle_type`\",\n  \"abs((coalesce(`ride_distance`,0) - coalesce(`avg_v`,0))) desc\"\n  ],\n  \"functions\": [\n  \"row_number\"\n  ]\n  }\n  ],\n  \"cost_info\": {\n  \"sort_cost\": \"4987160.00\"\n  },\n  \"buffer_result\": {\n  \"using_temporary_table\": true,\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"base\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 498713,\n  \"rows_produced_per_join\": 498713,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"489.00\",\n  \"eval_cost\": \"49871.30\",\n  \"prefix_cost\": \"50360.30\",\n  \"data_read_per_join\": \"296M\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\",\n  \"ride_distance\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"avg_cust_rate\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"<auto_key0>\"\n  ],\n  \"key\": \"<auto_key0>\",\n  \"used_key_parts\": [\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\"\n  ],\n  \"key_length\": \"606\",\n  \"ref\": [\n  \"test_db.base.vehicle_type\",\n  \"test_db.base.booking_status\",\n  \"test_db.base.payment_method\"\n  ],\n  \"rows_examined_per_scan\": 10,\n  \"rows_produced_per_join\": 4987160,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"1246790.00\",\n  \"eval_cost\": \"498716.00\",\n  \"prefix_cost\": \"1795866.30\",\n  \"data_read_per_join\": \"2G\"\n  },\n  \"used_columns\": [\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\",\n  \"avg_v\"\n  ],\n  \"attached_condition\": \"<if>(found_match(avg_cust_rate), (abs((coalesce(`test_db`.`base`.`ride_distance`,0) - coalesce(`avg_cust_rate`.`avg_v`,0))) >= 1), true)\",\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"50360.30\"\n  },\n  \"grouping_operation\": {\n  \"using_filesort\": false,\n  \"table\": {\n  \"table_name\": \"ride_bookings\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"idx_grouping\"\n  ],\n  \"key\": \"idx_grouping\",\n  \"used_key_parts\": [\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\"\n  ],\n  \"key_length\": \"606\",\n  \"rows_examined_per_scan\": 498713,\n  \"rows_produced_per_join\": 498713,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"489.00\",\n  \"eval_cost\": \"49871.30\",\n  \"prefix_cost\": \"50360.30\",\n  \"data_read_per_join\": \"296M\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\",\n  \"ride_distance\"\n  ]\n  }\n  }\n  }\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n  }\n  }\n}\n\n## Original SQL:\nselect * \r\nfrom (\r\nselect base.vehicle_type, base.booking_status, base.payment_method, base.ride_distance, coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0) as rate, \r\n row_number() over(partition by base.vehicle_type order by abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) desc ) as rank_num \r\nfrom ride_bookings base \r\nleft join (\r\n\tselect vehicle_type, booking_status,payment_method,coalesce(avg(ride_distance), 0) as avg_v\r\n\tfrom ride_bookings \r\n\tgroup by vehicle_type, booking_status,payment_method\r\n) avg_cust_rate \r\non base.vehicle_type = avg_cust_rate.vehicle_type and base.booking_status = avg_cust_rate.booking_status and base.payment_method = avg_cust_rate.payment_method \r\nwhere abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) >= 1 \r\n) fn \r\nwhere rank_num <=5;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM (SELECT vehicle_type, booking_status, payment_method, ride_distance, rate, row_number() over(partition by vehicle_type order by abs(rate) desc) as rank_num FROM (SELECT vehicle_type, booking_status, payment_method, ride_distance, coalesce(ride_distance, 0) - coalesce(avg(ride_distance) over (partition by vehicle_type, booking_status, payment_method), 0) as rate FROM ride_bookings) t WHERE abs(rate) >= 1) fn WHERE rank_num <= 5;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "48",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"48\", \"db_type\": \"mysql\", \"description\": \"改写前的SQL对每个分组结果（每个customer_id）执行两个相关子查询，导致对每个成组的customer_id都要额外扫描两次表。改写后将子查询逻辑合并到主查询的聚合函数中，利用主查询的分组直接计算平均值和最大值，避免了N+1查询问题，大幅减少了重复扫描次数。\", \"create_table_statements\": [\"CREATE TABLE ride_bookings (booking_id INT PRIMARY KEY AUTO_INCREMENT, customer_id INT NOT NULL, booking_value DECIMAL(10,2) NOT NULL, driver_rating DECIMAL(3,2), booking_status VARCHAR(50) NOT NULL, booking_date DATETIME NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_customer_id ON ride_bookings(customer_id);\", \"CREATE INDEX idx_booking_status_date ON ride_bookings(booking_status, booking_date);\"], \"sql\": \"SELECT \\r\\n  rb.customer_id,\\r\\n  COUNT(DISTINCT rb.booking_id) AS total_bookings,\\r\\n  SUM(rb.booking_value) AS total_revenue,\\r\\n  (SELECT AVG(driver_rating) FROM ride_bookings WHERE customer_id = rb.customer_id) AS avg_driver_rating,\\r\\n  (SELECT MAX(booking_date) FROM ride_bookings WHERE customer_id = rb.customer_id) AS last_booking_date\\r\\nFROM \\r\\n  ride_bookings rb\\r\\nWHERE \\r\\n  rb.booking_status IN ('Completed', 'Cancelled', 'No Show')\\r\\n  AND rb.booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY)\\r\\nGROUP BY \\r\\n  rb.customer_id\\r\\nHAVING \\r\\n  total_bookings > 10\\r\\nORDER BY \\r\\n  total_revenue DESC,\\r\\n  avg_driver_rating ASC;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\trb\\t\\tindex\\tidx_customer_id,idx_booking_status_date\\tidx_customer_id\\t4\\t\\t498576\\t100.0\\tUsing where; Using temporary; Using filesort\\n3\\tDEPENDENT SUBQUERY\\tride_bookings\\t\\tref\\tidx_customer_id\\tidx_customer_id\\t4\\tfunc\\t25\\t100.0\\t\\n2\\tDEPENDENT SUBQUERY\\tride_bookings\\t\\tref\\tidx_customer_id\\tidx_customer_id\\t4\\tfunc\\t25\\t100.0\\t\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"50266.35\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": true,\\n  \\\"grouping_operation\\\": {\\n  \\\"using_filesort\\\": false,\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"rb\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_customer_id\\\",\\n  \\\"idx_booking_status_date\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_customer_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"customer_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"rows_examined_per_scan\\\": 498576,\\n  \\\"rows_produced_per_join\\\": 498576,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"408.75\\\",\\n  \\\"eval_cost\\\": \\\"49857.60\\\",\\n  \\\"prefix_cost\\\": \\\"50266.35\\\",\\n  \\\"data_read_per_join\\\": \\\"106M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"booking_id\\\",\\n  \\\"customer_id\\\",\\n  \\\"booking_value\\\",\\n  \\\"booking_status\\\",\\n  \\\"booking_date\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`rb`.`booking_status` in ('Completed','Cancelled','No Show')) and (`test_db`.`rb`.`booking_date` >= <cache>((curdate() - interval 180 day))))\\\"\\n  },\\n  \\\"select_list_subqueries\\\": [\\n  {\\n  \\\"dependent\\\": true,\\n  \\\"cacheable\\\": false,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"8.82\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"ride_bookings\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_customer_id\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_customer_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"customer_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"func\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 25,\\n  \\\"rows_produced_per_join\\\": 25,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"6.30\\\",\\n  \\\"eval_cost\\\": \\\"2.52\\\",\\n  \\\"prefix_cost\\\": \\\"8.82\\\",\\n  \\\"data_read_per_join\\\": \\\"5K\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"customer_id\\\",\\n  \\\"booking_date\\\"\\n  ]\\n  }\\n  }\\n  },\\n  {\\n  \\\"dependent\\\": true,\\n  \\\"cacheable\\\": false,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"8.82\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"ride_bookings\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_customer_id\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_customer_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"customer_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"func\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 25,\\n  \\\"rows_produced_per_join\\\": 25,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"6.30\\\",\\n  \\\"eval_cost\\\": \\\"2.52\\\",\\n  \\\"prefix_cost\\\": \\\"8.82\\\",\\n  \\\"data_read_per_join\\\": \\\"5K\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"customer_id\\\",\\n  \\\"driver_rating\\\"\\n  ]\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将外层WHERE的高选择性过滤条件下推到标量子查询中，显著减少子查询处理的数据量。原标量子查询未使用过滤条件，会全表扫描顾客所有历史记录；改写后仅扫描与主查询相同的时间范围和状态记录\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"子查询折叠,将两个相关子查询（计算平均司机评分和最后预订日期）合并到主查询分组聚合中，消除子查询重复执行。通过一次分组扫描同时计算所有指标，避免对每个customer_id执行两次子查询，大幅减少表扫描次数和计算开销\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE ride_bookings (booking_id INT PRIMARY KEY AUTO_INCREMENT, customer_id INT NOT NULL, booking_value DECIMAL(10,2) NOT NULL, driver_rating DECIMAL(3,2), booking_status VARCHAR(50) NOT NULL, booking_date DATETIME NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_customer_id ON ride_bookings(customer_id);\nCREATE INDEX idx_booking_status_date ON ride_bookings(booking_status, booking_date);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\trb\t\tindex\tidx_customer_id,idx_booking_status_date\tidx_customer_id\t4\t\t498576\t100.0\tUsing where; Using temporary; Using filesort\n3\tDEPENDENT SUBQUERY\tride_bookings\t\tref\tidx_customer_id\tidx_customer_id\t4\tfunc\t25\t100.0\t\n2\tDEPENDENT SUBQUERY\tride_bookings\t\tref\tidx_customer_id\tidx_customer_id\t4\tfunc\t25\t100.0\t\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"50266.35\"\n  },\n  \"ordering_operation\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": true,\n  \"grouping_operation\": {\n  \"using_filesort\": false,\n  \"table\": {\n  \"table_name\": \"rb\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"idx_customer_id\",\n  \"idx_booking_status_date\"\n  ],\n  \"key\": \"idx_customer_id\",\n  \"used_key_parts\": [\n  \"customer_id\"\n  ],\n  \"key_length\": \"4\",\n  \"rows_examined_per_scan\": 498576,\n  \"rows_produced_per_join\": 498576,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"408.75\",\n  \"eval_cost\": \"49857.60\",\n  \"prefix_cost\": \"50266.35\",\n  \"data_read_per_join\": \"106M\"\n  },\n  \"used_columns\": [\n  \"booking_id\",\n  \"customer_id\",\n  \"booking_value\",\n  \"booking_status\",\n  \"booking_date\"\n  ],\n  \"attached_condition\": \"((`test_db`.`rb`.`booking_status` in ('Completed','Cancelled','No Show')) and (`test_db`.`rb`.`booking_date` >= <cache>((curdate() - interval 180 day))))\"\n  },\n  \"select_list_subqueries\": [\n  {\n  \"dependent\": true,\n  \"cacheable\": false,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"8.82\"\n  },\n  \"table\": {\n  \"table_name\": \"ride_bookings\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_customer_id\"\n  ],\n  \"key\": \"idx_customer_id\",\n  \"used_key_parts\": [\n  \"customer_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"func\"\n  ],\n  \"rows_examined_per_scan\": 25,\n  \"rows_produced_per_join\": 25,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"6.30\",\n  \"eval_cost\": \"2.52\",\n  \"prefix_cost\": \"8.82\",\n  \"data_read_per_join\": \"5K\"\n  },\n  \"used_columns\": [\n  \"customer_id\",\n  \"booking_date\"\n  ]\n  }\n  }\n  },\n  {\n  \"dependent\": true,\n  \"cacheable\": false,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"8.82\"\n  },\n  \"table\": {\n  \"table_name\": \"ride_bookings\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_customer_id\"\n  ],\n  \"key\": \"idx_customer_id\",\n  \"used_key_parts\": [\n  \"customer_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"func\"\n  ],\n  \"rows_examined_per_scan\": 25,\n  \"rows_produced_per_join\": 25,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"6.30\",\n  \"eval_cost\": \"2.52\",\n  \"prefix_cost\": \"8.82\",\n  \"data_read_per_join\": \"5K\"\n  },\n  \"used_columns\": [\n  \"customer_id\",\n  \"driver_rating\"\n  ]\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n}\n\n## Original SQL:\nSELECT \r\n  rb.customer_id,\r\n  COUNT(DISTINCT rb.booking_id) AS total_bookings,\r\n  SUM(rb.booking_value) AS total_revenue,\r\n  (SELECT AVG(driver_rating) FROM ride_bookings WHERE customer_id = rb.customer_id) AS avg_driver_rating,\r\n  (SELECT MAX(booking_date) FROM ride_bookings WHERE customer_id = rb.customer_id) AS last_booking_date\r\nFROM \r\n  ride_bookings rb\r\nWHERE \r\n  rb.booking_status IN ('Completed', 'Cancelled', 'No Show')\r\n  AND rb.booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY)\r\nGROUP BY \r\n  rb.customer_id\r\nHAVING \r\n  total_bookings > 10\r\nORDER BY \r\n  total_revenue DESC,\r\n  avg_driver_rating ASC;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT t1.customer_id, t1.total_bookings, t1.total_revenue, t2.avg_driver_rating, t2.last_booking_date FROM (SELECT customer_id, COUNT(DISTINCT booking_id) AS total_bookings, SUM(booking_value) AS total_revenue FROM ride_bookings WHERE booking_status IN ('Completed', 'Cancelled', 'No Show') AND booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY) GROUP BY customer_id HAVING COUNT(DISTINCT booking_id) > 10) t1 LEFT JOIN (SELECT customer_id, AVG(driver_rating) AS avg_driver_rating, MAX(booking_date) AS last_booking_date FROM ride_bookings GROUP BY customer_id) t2 ON t1.customer_id = t2.customer_id ORDER BY t1.total_revenue DESC, t2.avg_driver_rating ASC;"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "48",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"48\", \"db_type\": \"mysql\", \"description\": \"改写前的SQL对每个分组结果（每个customer_id）执行两个相关子查询，导致对每个成组的customer_id都要额外扫描两次表。改写后将子查询逻辑合并到主查询的聚合函数中，利用主查询的分组直接计算平均值和最大值，避免了N+1查询问题，大幅减少了重复扫描次数。\", \"create_table_statements\": [\"CREATE TABLE ride_bookings (booking_id INT PRIMARY KEY AUTO_INCREMENT, customer_id INT NOT NULL, booking_value DECIMAL(10,2) NOT NULL, driver_rating DECIMAL(3,2), booking_status VARCHAR(50) NOT NULL, booking_date DATETIME NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_customer_id ON ride_bookings(customer_id);\", \"CREATE INDEX idx_booking_status_date ON ride_bookings(booking_status, booking_date);\"], \"sql\": \"SELECT \\r\\n  rb.customer_id,\\r\\n  COUNT(DISTINCT rb.booking_id) AS total_bookings,\\r\\n  SUM(rb.booking_value) AS total_revenue,\\r\\n  (SELECT AVG(driver_rating) FROM ride_bookings WHERE customer_id = rb.customer_id) AS avg_driver_rating,\\r\\n  (SELECT MAX(booking_date) FROM ride_bookings WHERE customer_id = rb.customer_id) AS last_booking_date\\r\\nFROM \\r\\n  ride_bookings rb\\r\\nWHERE \\r\\n  rb.booking_status IN ('Completed', 'Cancelled', 'No Show')\\r\\n  AND rb.booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY)\\r\\nGROUP BY \\r\\n  rb.customer_id\\r\\nHAVING \\r\\n  total_bookings > 10\\r\\nORDER BY \\r\\n  total_revenue DESC,\\r\\n  avg_driver_rating ASC;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\trb\\t\\tindex\\tidx_customer_id,idx_booking_status_date\\tidx_customer_id\\t4\\t\\t498576\\t100.0\\tUsing where; Using temporary; Using filesort\\n3\\tDEPENDENT SUBQUERY\\tride_bookings\\t\\tref\\tidx_customer_id\\tidx_customer_id\\t4\\tfunc\\t25\\t100.0\\t\\n2\\tDEPENDENT SUBQUERY\\tride_bookings\\t\\tref\\tidx_customer_id\\tidx_customer_id\\t4\\tfunc\\t25\\t100.0\\t\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"50266.35\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": true,\\n  \\\"grouping_operation\\\": {\\n  \\\"using_filesort\\\": false,\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"rb\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_customer_id\\\",\\n  \\\"idx_booking_status_date\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_customer_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"customer_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"rows_examined_per_scan\\\": 498576,\\n  \\\"rows_produced_per_join\\\": 498576,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"408.75\\\",\\n  \\\"eval_cost\\\": \\\"49857.60\\\",\\n  \\\"prefix_cost\\\": \\\"50266.35\\\",\\n  \\\"data_read_per_join\\\": \\\"106M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"booking_id\\\",\\n  \\\"customer_id\\\",\\n  \\\"booking_value\\\",\\n  \\\"booking_status\\\",\\n  \\\"booking_date\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`rb`.`booking_status` in ('Completed','Cancelled','No Show')) and (`test_db`.`rb`.`booking_date` >= <cache>((curdate() - interval 180 day))))\\\"\\n  },\\n  \\\"select_list_subqueries\\\": [\\n  {\\n  \\\"dependent\\\": true,\\n  \\\"cacheable\\\": false,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"8.82\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"ride_bookings\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_customer_id\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_customer_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"customer_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"func\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 25,\\n  \\\"rows_produced_per_join\\\": 25,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"6.30\\\",\\n  \\\"eval_cost\\\": \\\"2.52\\\",\\n  \\\"prefix_cost\\\": \\\"8.82\\\",\\n  \\\"data_read_per_join\\\": \\\"5K\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"customer_id\\\",\\n  \\\"booking_date\\\"\\n  ]\\n  }\\n  }\\n  },\\n  {\\n  \\\"dependent\\\": true,\\n  \\\"cacheable\\\": false,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"8.82\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"ride_bookings\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_customer_id\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_customer_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"customer_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"func\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 25,\\n  \\\"rows_produced_per_join\\\": 25,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"6.30\\\",\\n  \\\"eval_cost\\\": \\\"2.52\\\",\\n  \\\"prefix_cost\\\": \\\"8.82\\\",\\n  \\\"data_read_per_join\\\": \\\"5K\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"customer_id\\\",\\n  \\\"driver_rating\\\"\\n  ]\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n}\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,将外层WHERE的高选择性过滤条件下推到标量子查询中，显著减少子查询处理的数据量。原标量子查询未使用过滤条件，会全表扫描顾客所有历史记录；改写后仅扫描与主查询相同的时间范围和状态记录\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"子查询折叠,将两个相关子查询（计算平均司机评分和最后预订日期）合并到主查询分组聚合中，消除子查询重复执行。通过一次分组扫描同时计算所有指标，避免对每个customer_id执行两次子查询，大幅减少表扫描次数和计算开销\"}]}}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE ride_bookings (booking_id INT PRIMARY KEY AUTO_INCREMENT, customer_id INT NOT NULL, booking_value DECIMAL(10,2) NOT NULL, driver_rating DECIMAL(3,2), booking_status VARCHAR(50) NOT NULL, booking_date DATETIME NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_customer_id ON ride_bookings(customer_id);\nCREATE INDEX idx_booking_status_date ON ride_bookings(booking_status, booking_date);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\trb\t\tindex\tidx_customer_id,idx_booking_status_date\tidx_customer_id\t4\t\t498576\t100.0\tUsing where; Using temporary; Using filesort\n3\tDEPENDENT SUBQUERY\tride_bookings\t\tref\tidx_customer_id\tidx_customer_id\t4\tfunc\t25\t100.0\t\n2\tDEPENDENT SUBQUERY\tride_bookings\t\tref\tidx_customer_id\tidx_customer_id\t4\tfunc\t25\t100.0\t\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"50266.35\"\n  },\n  \"ordering_operation\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": true,\n  \"grouping_operation\": {\n  \"using_filesort\": false,\n  \"table\": {\n  \"table_name\": \"rb\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"idx_customer_id\",\n  \"idx_booking_status_date\"\n  ],\n  \"key\": \"idx_customer_id\",\n  \"used_key_parts\": [\n  \"customer_id\"\n  ],\n  \"key_length\": \"4\",\n  \"rows_examined_per_scan\": 498576,\n  \"rows_produced_per_join\": 498576,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"408.75\",\n  \"eval_cost\": \"49857.60\",\n  \"prefix_cost\": \"50266.35\",\n  \"data_read_per_join\": \"106M\"\n  },\n  \"used_columns\": [\n  \"booking_id\",\n  \"customer_id\",\n  \"booking_value\",\n  \"booking_status\",\n  \"booking_date\"\n  ],\n  \"attached_condition\": \"((`test_db`.`rb`.`booking_status` in ('Completed','Cancelled','No Show')) and (`test_db`.`rb`.`booking_date` >= <cache>((curdate() - interval 180 day))))\"\n  },\n  \"select_list_subqueries\": [\n  {\n  \"dependent\": true,\n  \"cacheable\": false,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"8.82\"\n  },\n  \"table\": {\n  \"table_name\": \"ride_bookings\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_customer_id\"\n  ],\n  \"key\": \"idx_customer_id\",\n  \"used_key_parts\": [\n  \"customer_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"func\"\n  ],\n  \"rows_examined_per_scan\": 25,\n  \"rows_produced_per_join\": 25,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"6.30\",\n  \"eval_cost\": \"2.52\",\n  \"prefix_cost\": \"8.82\",\n  \"data_read_per_join\": \"5K\"\n  },\n  \"used_columns\": [\n  \"customer_id\",\n  \"booking_date\"\n  ]\n  }\n  }\n  },\n  {\n  \"dependent\": true,\n  \"cacheable\": false,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"8.82\"\n  },\n  \"table\": {\n  \"table_name\": \"ride_bookings\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_customer_id\"\n  ],\n  \"key\": \"idx_customer_id\",\n  \"used_key_parts\": [\n  \"customer_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"func\"\n  ],\n  \"rows_examined_per_scan\": 25,\n  \"rows_produced_per_join\": 25,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"6.30\",\n  \"eval_cost\": \"2.52\",\n  \"prefix_cost\": \"8.82\",\n  \"data_read_per_join\": \"5K\"\n  },\n  \"used_columns\": [\n  \"customer_id\",\n  \"driver_rating\"\n  ]\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n}\n\n## Original SQL:\nSELECT \r\n  rb.customer_id,\r\n  COUNT(DISTINCT rb.booking_id) AS total_bookings,\r\n  SUM(rb.booking_value) AS total_revenue,\r\n  (SELECT AVG(driver_rating) FROM ride_bookings WHERE customer_id = rb.customer_id) AS avg_driver_rating,\r\n  (SELECT MAX(booking_date) FROM ride_bookings WHERE customer_id = rb.customer_id) AS last_booking_date\r\nFROM \r\n  ride_bookings rb\r\nWHERE \r\n  rb.booking_status IN ('Completed', 'Cancelled', 'No Show')\r\n  AND rb.booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY)\r\nGROUP BY \r\n  rb.customer_id\r\nHAVING \r\n  total_bookings > 10\r\nORDER BY \r\n  total_revenue DESC,\r\n  avg_driver_rating ASC;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT t1.customer_id, t1.total_bookings, t1.total_revenue, t2.avg_driver_rating, t2.last_booking_date FROM (SELECT customer_id, COUNT(DISTINCT booking_id) AS total_bookings, SUM(booking_value) AS total_revenue FROM ride_bookings WHERE booking_status IN ('Completed', 'Cancelled', 'No Show') AND booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY) GROUP BY customer_id HAVING COUNT(DISTINCT booking_id) > 10) t1 LEFT JOIN (SELECT customer_id, AVG(driver_rating) AS avg_driver_rating, MAX(booking_date) AS last_booking_date FROM ride_bookings GROUP BY customer_id) t2 ON t1.customer_id = t2.customer_id ORDER BY t1.total_revenue DESC, t2.avg_driver_rating ASC;"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "49",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"49\", \"db_type\": \"mysql\", \"description\": \"该SQL用于统计库存车辆数及首次入库数，涉及近20个表的LEFT JOIN。主要性能问题有：1. **投影冗余**：作为连接源的两个子查询（Derived Tables `mo` 和 `purchase`）输出了大量外部查询不需要的列（如`AUDIT_STATUS`、`NEW_HOUSE_ID`、`PURCHASE_ORDER_CODE`等）。这导致中间结果集（临时表）宽度过大，显著增加了内存消耗和I/O开销。2. **子查询效率低**：`mo`子查询内部嵌套了分组聚合和IN子查询，且未有效过滤数据。3. **谓词下推机会**：主表`t_mdm_dlr_car_store`的过滤条件`IS_ENABLE='1'`位于WHERE子句，虽然优化器通常处理，但在复杂宽表连接中，显式下推或精简数据源能获得更稳定的执行计划。\", \"create_table_statements\": [\"CREATE TABLE t_mdm_dlr_car_store (CAR_ID INT, SALES_PLAN_CODE VARCHAR(50), DLR_ID INT, CAR_STOCK_HOUSE_ID INT, CAR_SALE_HOUSE_ID INT, IS_ENABLE CHAR(1), FIRST_IN_HOSTSTOCK_DATE DATETIME, INDEX(CAR_ID), INDEX(SALES_PLAN_CODE));\", \"CREATE TABLE t_mdm_dlr_car (CAR_ID INT PRIMARY KEY, CAR_CONFIG_ID INT, OPTIONAL_PAG_ID INT, CAR_COLOR_ID INT, CAR_INCOLOR_ID INT);\", \"CREATE TABLE t_ve_bu_sale_order_d (SALE_PLAN_CODE VARCHAR(50), SALE_ORDER_ID INT, DELIVERY_FAC_HW_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE), INDEX(SALE_ORDER_ID));\", \"CREATE TABLE t_ve_bu_sale_order (SALE_ORDER_ID INT PRIMARY KEY);\", \"CREATE TABLE t_mdm_ve_car_config (CAR_CONFIG_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_bu_inv_apply_d (link_order_id INT, is_Enable CHAR(1), INDEX(link_order_id));\", \"CREATE TABLE t_ve_bu_movestock_order (MOVESTOCK_ORDER_CODE VARCHAR(50), CAR_ID INT, VIN VARCHAR(50), AUDIT_STATUS VARCHAR(20), NEW_HOUSE_ID INT, NEW_DLR_ID INT, INDEX(CAR_ID), INDEX(VIN));\", \"CREATE TABLE t_ve_bu_month_plan_d (SALES_PLAN_CODE VARCHAR(50), INSTORE_TIME DATETIME, INDEX(SALES_PLAN_CODE));\", \"CREATE TABLE t_usc_mdm_org_dlr (DLR_ID INT PRIMARY KEY, CITY_ID INT);\", \"CREATE TABLE T_USC_MDM_ORG_CITY (CITY_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_db_zb_stock (ZB_STOCK_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_db_car_stock_house (CAR_STOCK_HOUSE_ID INT PRIMARY KEY, CAR_HOUSE_CODE VARCHAR(50));\", \"CREATE TABLE t_mdm_ve_car_optionalpag (OPTIONAL_PAG_ID INT PRIMARY KEY);\", \"CREATE TABLE t_mdm_car_color (CAR_COLOR_ID INT PRIMARY KEY);\", \"CREATE TABLE t_mdm_car_incolor (CAR_INCOLOR_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_finance_wholesale_purchase_order (SALES_PLAN_CODE VARCHAR(50), WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), ORDER_STATUS VARCHAR(50), INDEX(SALES_PLAN_CODE));\", \"CREATE TABLE t_ve_bu_invoice_info_upload (WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), IS_ENABLE CHAR(1), INDEX(WHOLESALE_PURCHASE_ORDER_CODE));\", \"CREATE TABLE t_prc_mds_lookup_value (LOOKUP_VALUE_CODE VARCHAR(50), LOOKUP_TYPE_CODE VARCHAR(50), INDEX(LOOKUP_VALUE_CODE));\", \"CREATE TABLE t_ve_bu_purchase_order (PURCHASE_ORDER_CODE VARCHAR(50), SALE_PLAN_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE));\"], \"sql\": \"SELECT count(1) stockNum, COUNT(c.FIRST_IN_HOSTSTOCK_DATE ) hostStockNum -- , -- DATE_FORMAT( Max(mpd.INSTORE_TIME), '%Y-%m-%d %H%:%i:%s') maxStoreTime FROM t_mdm_dlr_car_store c LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID = SO.SALE_ORDER_ID LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID = car.CAR_CONFIG_ID LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id = iad.link_order_id and iad.is_Enable='1' LEFT JOIN (SELECT MOVESTOCK_ORDER_CODE,CAR_ID,AUDIT_STATUS,NEW_HOUSE_ID,NEW_DLR_ID from t_ve_bu_movestock_order WHERE MOVESTOCK_ORDER_CODE in ( SELECT max(MOVESTOCK_ORDER_CODE) from t_ve_bu_movestock_order GROUP BY VIN )) mo ON mo.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID = tumod.DLR_ID LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID = tumod.CITY_ID LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID = c.CAR_SALE_HOUSE_ID LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID = optionl.OPTIONAL_PAG_ID LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID = cols.CAR_COLOR_ID LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID = incol.CAR_INCOLOR_ID left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE = SOD.DELIVERY_FAC_HW_CODE left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE = c.SALES_PLAN_CODE left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE = tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE = '1' left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE = ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE = 'VE1414' left join (select max(PURCHASE_ORDER_CODE) PURCHASE_ORDER_CODE ,SALE_PLAN_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE ) purchase on purchase.SALE_PLAN_CODE =c.SALES_PLAN_CODE WHERE c.IS_ENABLE = '1'\", \"explain\": \"id\\tselect_type\\ttable\\ttype\\tkey\\trows\\tExtra\\n1\\tPRIMARY\\tc\\tALL\\tNULL\\t1000\\tUsing where\\n1\\tPRIMARY\\tCAR\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tSOD\\tref\\tSALE_PLAN_CODE\\t1\\tUsing index\\n1\\tPRIMARY\\tSO\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tcon\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tiad\\tref\\tlink_order_id\\t1\\tUsing where\\n1\\tPRIMARY\\t<derived2>\\tref\\t<auto_key0>\\t10\\tUsing where\\n1\\tPRIMARY\\tmpd\\tref\\tSALES_PLAN_CODE\\t1\\tUsing index\\n1\\tPRIMARY\\ttumod\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tCI\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\ttvdzs\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\ttvdcsh\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tSHd\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\toptionl\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tcols\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tincol\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\toge\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tord\\tref\\tSALES_PLAN_CODE\\t1\\tUsing index\\n1\\tPRIMARY\\ttvbiiu\\tref\\tWHOLESALE_PURCHASE_ORDER_CODE\\t1\\tUsing where\\n1\\tPRIMARY\\tv5\\tref\\tLOOKUP_VALUE_CODE\\t1\\tUsing where\\n1\\tPRIMARY\\t<derived4>\\tref\\t<auto_key0>\\t10\\tUsing where\\n2\\tDERIVED\\tt_ve_bu_movestock_order\\tALL\\tNULL\\t5000\\tUsing where\\n3\\tDEPENDENT SUBQUERY\\tt_ve_bu_movestock_order\\tindex\\tVIN\\t5000\\tUsing index\\n4\\tDERIVED\\tt_ve_bu_purchase_order\\tindex\\tSALE_PLAN_CODE\\t2000\\tUsing index\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推优化，裁剪了两个子查询中未被外部查询使用的列：1) 子查询mo只保留CAR_ID列，移除MOVESTOCK_ORDER_CODE、AUDIT_STATUS、NEW_HOUSE_ID、NEW_DLR_ID；2) 子查询purchase只保留SALE_PLAN_CODE列，移除max(PURCHASE_ORDER_CODE)。此优化减少子查询临时表的数据量，降低磁盘I/O和内存占用，提升查询性能。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推优化，将主表过滤条件c.IS_ENABLE='1'提前到派生表内执行，在复杂JOIN前减少数据处理量。改写后保持原语义但显著降低计算开销，特别适用于MySQL等弱优化器环境\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE t_mdm_dlr_car_store (CAR_ID INT, SALES_PLAN_CODE VARCHAR(50), DLR_ID INT, CAR_STOCK_HOUSE_ID INT, CAR_SALE_HOUSE_ID INT, IS_ENABLE CHAR(1), FIRST_IN_HOSTSTOCK_DATE DATETIME, INDEX(CAR_ID), INDEX(SALES_PLAN_CODE));\nCREATE TABLE t_mdm_dlr_car (CAR_ID INT PRIMARY KEY, CAR_CONFIG_ID INT, OPTIONAL_PAG_ID INT, CAR_COLOR_ID INT, CAR_INCOLOR_ID INT);\nCREATE TABLE t_ve_bu_sale_order_d (SALE_PLAN_CODE VARCHAR(50), SALE_ORDER_ID INT, DELIVERY_FAC_HW_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE), INDEX(SALE_ORDER_ID));\nCREATE TABLE t_ve_bu_sale_order (SALE_ORDER_ID INT PRIMARY KEY);\nCREATE TABLE t_mdm_ve_car_config (CAR_CONFIG_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_bu_inv_apply_d (link_order_id INT, is_Enable CHAR(1), INDEX(link_order_id));\nCREATE TABLE t_ve_bu_movestock_order (MOVESTOCK_ORDER_CODE VARCHAR(50), CAR_ID INT, VIN VARCHAR(50), AUDIT_STATUS VARCHAR(20), NEW_HOUSE_ID INT, NEW_DLR_ID INT, INDEX(CAR_ID), INDEX(VIN));\nCREATE TABLE t_ve_bu_month_plan_d (SALES_PLAN_CODE VARCHAR(50), INSTORE_TIME DATETIME, INDEX(SALES_PLAN_CODE));\nCREATE TABLE t_usc_mdm_org_dlr (DLR_ID INT PRIMARY KEY, CITY_ID INT);\nCREATE TABLE T_USC_MDM_ORG_CITY (CITY_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_db_zb_stock (ZB_STOCK_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_db_car_stock_house (CAR_STOCK_HOUSE_ID INT PRIMARY KEY, CAR_HOUSE_CODE VARCHAR(50));\nCREATE TABLE t_mdm_ve_car_optionalpag (OPTIONAL_PAG_ID INT PRIMARY KEY);\nCREATE TABLE t_mdm_car_color (CAR_COLOR_ID INT PRIMARY KEY);\nCREATE TABLE t_mdm_car_incolor (CAR_INCOLOR_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_finance_wholesale_purchase_order (SALES_PLAN_CODE VARCHAR(50), WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), ORDER_STATUS VARCHAR(50), INDEX(SALES_PLAN_CODE));\nCREATE TABLE t_ve_bu_invoice_info_upload (WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), IS_ENABLE CHAR(1), INDEX(WHOLESALE_PURCHASE_ORDER_CODE));\nCREATE TABLE t_prc_mds_lookup_value (LOOKUP_VALUE_CODE VARCHAR(50), LOOKUP_TYPE_CODE VARCHAR(50), INDEX(LOOKUP_VALUE_CODE));\nCREATE TABLE t_ve_bu_purchase_order (PURCHASE_ORDER_CODE VARCHAR(50), SALE_PLAN_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE));\n\n## Explain Output in JSON:\nid\tselect_type\ttable\ttype\tkey\trows\tExtra\n1\tPRIMARY\tc\tALL\tNULL\t1000\tUsing where\n1\tPRIMARY\tCAR\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tSOD\tref\tSALE_PLAN_CODE\t1\tUsing index\n1\tPRIMARY\tSO\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tcon\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tiad\tref\tlink_order_id\t1\tUsing where\n1\tPRIMARY\t<derived2>\tref\t<auto_key0>\t10\tUsing where\n1\tPRIMARY\tmpd\tref\tSALES_PLAN_CODE\t1\tUsing index\n1\tPRIMARY\ttumod\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tCI\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\ttvdzs\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\ttvdcsh\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tSHd\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\toptionl\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tcols\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tincol\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\toge\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tord\tref\tSALES_PLAN_CODE\t1\tUsing index\n1\tPRIMARY\ttvbiiu\tref\tWHOLESALE_PURCHASE_ORDER_CODE\t1\tUsing where\n1\tPRIMARY\tv5\tref\tLOOKUP_VALUE_CODE\t1\tUsing where\n1\tPRIMARY\t<derived4>\tref\t<auto_key0>\t10\tUsing where\n2\tDERIVED\tt_ve_bu_movestock_order\tALL\tNULL\t5000\tUsing where\n3\tDEPENDENT SUBQUERY\tt_ve_bu_movestock_order\tindex\tVIN\t5000\tUsing index\n4\tDERIVED\tt_ve_bu_purchase_order\tindex\tSALE_PLAN_CODE\t2000\tUsing index\n\n## Original SQL:\nSELECT count(1) stockNum, COUNT(c.FIRST_IN_HOSTSTOCK_DATE ) hostStockNum -- , -- DATE_FORMAT( Max(mpd.INSTORE_TIME), '%Y-%m-%d %H%:%i:%s') maxStoreTime FROM t_mdm_dlr_car_store c LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID = SO.SALE_ORDER_ID LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID = car.CAR_CONFIG_ID LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id = iad.link_order_id and iad.is_Enable='1' LEFT JOIN (SELECT MOVESTOCK_ORDER_CODE,CAR_ID,AUDIT_STATUS,NEW_HOUSE_ID,NEW_DLR_ID from t_ve_bu_movestock_order WHERE MOVESTOCK_ORDER_CODE in ( SELECT max(MOVESTOCK_ORDER_CODE) from t_ve_bu_movestock_order GROUP BY VIN )) mo ON mo.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID = tumod.DLR_ID LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID = tumod.CITY_ID LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID = c.CAR_SALE_HOUSE_ID LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID = optionl.OPTIONAL_PAG_ID LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID = cols.CAR_COLOR_ID LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID = incol.CAR_INCOLOR_ID left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE = SOD.DELIVERY_FAC_HW_CODE left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE = c.SALES_PLAN_CODE left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE = tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE = '1' left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE = ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE = 'VE1414' left join (select max(PURCHASE_ORDER_CODE) PURCHASE_ORDER_CODE ,SALE_PLAN_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE ) purchase on purchase.SALE_PLAN_CODE =c.SALES_PLAN_CODE WHERE c.IS_ENABLE = '1'\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT count(1) stockNum,COUNT(c.FIRST_IN_HOSTSTOCK_DATE) hostStockNum FROM t_mdm_dlr_car_store c LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID=c.CAR_ID LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE=c.SALES_PLAN_CODE LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID=SO.SALE_ORDER_ID LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID=car.CAR_CONFIG_ID LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id=iad.link_order_id and iad.is_Enable='1' LEFT JOIN(SELECT m.MOVESTOCK_ORDER_CODE,m.CAR_ID,m.AUDIT_STATUS,m.NEW_HOUSE_ID,m.NEW_DLR_ID FROM t_ve_bu_movestock_order m INNER JOIN(SELECT VIN,MAX(MOVESTOCK_ORDER_CODE) max_code FROM t_ve_bu_movestock_order GROUP BY VIN)mm ON m.VIN=mm.VIN AND m.MOVESTOCK_ORDER_CODE=mm.max_code)mo ON mo.CAR_ID=c.CAR_ID LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE=c.SALES_PLAN_CODE LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID=tumod.DLR_ID LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID=tumod.CITY_ID LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID=c.CAR_STOCK_HOUSE_ID LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID=c.CAR_STOCK_HOUSE_ID LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID=c.CAR_SALE_HOUSE_ID LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID=optionl.OPTIONAL_PAG_ID LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID=cols.CAR_COLOR_ID LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID=incol.CAR_INCOLOR_ID left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE=SOD.DELIVERY_FAC_HW_CODE left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE=c.SALES_PLAN_CODE left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE=tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE='1' left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE=ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE='VE1414' left join(select SALE_PLAN_CODE,MAX(PURCHASE_ORDER_CODE) PURCHASE_ORDER_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE)purchase on purchase.SALE_PLAN_CODE=c.SALES_PLAN_CODE WHERE c.IS_ENABLE='1'"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "49",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"49\", \"db_type\": \"mysql\", \"description\": \"该SQL用于统计库存车辆数及首次入库数，涉及近20个表的LEFT JOIN。主要性能问题有：1. **投影冗余**：作为连接源的两个子查询（Derived Tables `mo` 和 `purchase`）输出了大量外部查询不需要的列（如`AUDIT_STATUS`、`NEW_HOUSE_ID`、`PURCHASE_ORDER_CODE`等）。这导致中间结果集（临时表）宽度过大，显著增加了内存消耗和I/O开销。2. **子查询效率低**：`mo`子查询内部嵌套了分组聚合和IN子查询，且未有效过滤数据。3. **谓词下推机会**：主表`t_mdm_dlr_car_store`的过滤条件`IS_ENABLE='1'`位于WHERE子句，虽然优化器通常处理，但在复杂宽表连接中，显式下推或精简数据源能获得更稳定的执行计划。\", \"create_table_statements\": [\"CREATE TABLE t_mdm_dlr_car_store (CAR_ID INT, SALES_PLAN_CODE VARCHAR(50), DLR_ID INT, CAR_STOCK_HOUSE_ID INT, CAR_SALE_HOUSE_ID INT, IS_ENABLE CHAR(1), FIRST_IN_HOSTSTOCK_DATE DATETIME, INDEX(CAR_ID), INDEX(SALES_PLAN_CODE));\", \"CREATE TABLE t_mdm_dlr_car (CAR_ID INT PRIMARY KEY, CAR_CONFIG_ID INT, OPTIONAL_PAG_ID INT, CAR_COLOR_ID INT, CAR_INCOLOR_ID INT);\", \"CREATE TABLE t_ve_bu_sale_order_d (SALE_PLAN_CODE VARCHAR(50), SALE_ORDER_ID INT, DELIVERY_FAC_HW_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE), INDEX(SALE_ORDER_ID));\", \"CREATE TABLE t_ve_bu_sale_order (SALE_ORDER_ID INT PRIMARY KEY);\", \"CREATE TABLE t_mdm_ve_car_config (CAR_CONFIG_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_bu_inv_apply_d (link_order_id INT, is_Enable CHAR(1), INDEX(link_order_id));\", \"CREATE TABLE t_ve_bu_movestock_order (MOVESTOCK_ORDER_CODE VARCHAR(50), CAR_ID INT, VIN VARCHAR(50), AUDIT_STATUS VARCHAR(20), NEW_HOUSE_ID INT, NEW_DLR_ID INT, INDEX(CAR_ID), INDEX(VIN));\", \"CREATE TABLE t_ve_bu_month_plan_d (SALES_PLAN_CODE VARCHAR(50), INSTORE_TIME DATETIME, INDEX(SALES_PLAN_CODE));\", \"CREATE TABLE t_usc_mdm_org_dlr (DLR_ID INT PRIMARY KEY, CITY_ID INT);\", \"CREATE TABLE T_USC_MDM_ORG_CITY (CITY_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_db_zb_stock (ZB_STOCK_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_db_car_stock_house (CAR_STOCK_HOUSE_ID INT PRIMARY KEY, CAR_HOUSE_CODE VARCHAR(50));\", \"CREATE TABLE t_mdm_ve_car_optionalpag (OPTIONAL_PAG_ID INT PRIMARY KEY);\", \"CREATE TABLE t_mdm_car_color (CAR_COLOR_ID INT PRIMARY KEY);\", \"CREATE TABLE t_mdm_car_incolor (CAR_INCOLOR_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_finance_wholesale_purchase_order (SALES_PLAN_CODE VARCHAR(50), WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), ORDER_STATUS VARCHAR(50), INDEX(SALES_PLAN_CODE));\", \"CREATE TABLE t_ve_bu_invoice_info_upload (WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), IS_ENABLE CHAR(1), INDEX(WHOLESALE_PURCHASE_ORDER_CODE));\", \"CREATE TABLE t_prc_mds_lookup_value (LOOKUP_VALUE_CODE VARCHAR(50), LOOKUP_TYPE_CODE VARCHAR(50), INDEX(LOOKUP_VALUE_CODE));\", \"CREATE TABLE t_ve_bu_purchase_order (PURCHASE_ORDER_CODE VARCHAR(50), SALE_PLAN_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE));\"], \"sql\": \"SELECT count(1) stockNum, COUNT(c.FIRST_IN_HOSTSTOCK_DATE ) hostStockNum -- , -- DATE_FORMAT( Max(mpd.INSTORE_TIME), '%Y-%m-%d %H%:%i:%s') maxStoreTime FROM t_mdm_dlr_car_store c LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID = SO.SALE_ORDER_ID LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID = car.CAR_CONFIG_ID LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id = iad.link_order_id and iad.is_Enable='1' LEFT JOIN (SELECT MOVESTOCK_ORDER_CODE,CAR_ID,AUDIT_STATUS,NEW_HOUSE_ID,NEW_DLR_ID from t_ve_bu_movestock_order WHERE MOVESTOCK_ORDER_CODE in ( SELECT max(MOVESTOCK_ORDER_CODE) from t_ve_bu_movestock_order GROUP BY VIN )) mo ON mo.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID = tumod.DLR_ID LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID = tumod.CITY_ID LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID = c.CAR_SALE_HOUSE_ID LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID = optionl.OPTIONAL_PAG_ID LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID = cols.CAR_COLOR_ID LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID = incol.CAR_INCOLOR_ID left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE = SOD.DELIVERY_FAC_HW_CODE left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE = c.SALES_PLAN_CODE left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE = tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE = '1' left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE = ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE = 'VE1414' left join (select max(PURCHASE_ORDER_CODE) PURCHASE_ORDER_CODE ,SALE_PLAN_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE ) purchase on purchase.SALE_PLAN_CODE =c.SALES_PLAN_CODE WHERE c.IS_ENABLE = '1'\", \"explain\": \"id\\tselect_type\\ttable\\ttype\\tkey\\trows\\tExtra\\n1\\tPRIMARY\\tc\\tALL\\tNULL\\t1000\\tUsing where\\n1\\tPRIMARY\\tCAR\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tSOD\\tref\\tSALE_PLAN_CODE\\t1\\tUsing index\\n1\\tPRIMARY\\tSO\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tcon\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tiad\\tref\\tlink_order_id\\t1\\tUsing where\\n1\\tPRIMARY\\t<derived2>\\tref\\t<auto_key0>\\t10\\tUsing where\\n1\\tPRIMARY\\tmpd\\tref\\tSALES_PLAN_CODE\\t1\\tUsing index\\n1\\tPRIMARY\\ttumod\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tCI\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\ttvdzs\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\ttvdcsh\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tSHd\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\toptionl\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tcols\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tincol\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\toge\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tord\\tref\\tSALES_PLAN_CODE\\t1\\tUsing index\\n1\\tPRIMARY\\ttvbiiu\\tref\\tWHOLESALE_PURCHASE_ORDER_CODE\\t1\\tUsing where\\n1\\tPRIMARY\\tv5\\tref\\tLOOKUP_VALUE_CODE\\t1\\tUsing where\\n1\\tPRIMARY\\t<derived4>\\tref\\t<auto_key0>\\t10\\tUsing where\\n2\\tDERIVED\\tt_ve_bu_movestock_order\\tALL\\tNULL\\t5000\\tUsing where\\n3\\tDEPENDENT SUBQUERY\\tt_ve_bu_movestock_order\\tindex\\tVIN\\t5000\\tUsing index\\n4\\tDERIVED\\tt_ve_bu_purchase_order\\tindex\\tSALE_PLAN_CODE\\t2000\\tUsing index\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"投影下推,通过投影下推优化，裁剪了两个子查询中未被外部查询使用的列：1) 子查询mo只保留CAR_ID列，移除MOVESTOCK_ORDER_CODE、AUDIT_STATUS、NEW_HOUSE_ID、NEW_DLR_ID；2) 子查询purchase只保留SALE_PLAN_CODE列，移除max(PURCHASE_ORDER_CODE)。此优化减少子查询临时表的数据量，降低磁盘I/O和内存占用，提升查询性能。\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过谓词下推优化，将主表过滤条件c.IS_ENABLE='1'提前到派生表内执行，在复杂JOIN前减少数据处理量。改写后保持原语义但显著降低计算开销，特别适用于MySQL等弱优化器环境\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE t_mdm_dlr_car_store (CAR_ID INT, SALES_PLAN_CODE VARCHAR(50), DLR_ID INT, CAR_STOCK_HOUSE_ID INT, CAR_SALE_HOUSE_ID INT, IS_ENABLE CHAR(1), FIRST_IN_HOSTSTOCK_DATE DATETIME, INDEX(CAR_ID), INDEX(SALES_PLAN_CODE));\nCREATE TABLE t_mdm_dlr_car (CAR_ID INT PRIMARY KEY, CAR_CONFIG_ID INT, OPTIONAL_PAG_ID INT, CAR_COLOR_ID INT, CAR_INCOLOR_ID INT);\nCREATE TABLE t_ve_bu_sale_order_d (SALE_PLAN_CODE VARCHAR(50), SALE_ORDER_ID INT, DELIVERY_FAC_HW_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE), INDEX(SALE_ORDER_ID));\nCREATE TABLE t_ve_bu_sale_order (SALE_ORDER_ID INT PRIMARY KEY);\nCREATE TABLE t_mdm_ve_car_config (CAR_CONFIG_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_bu_inv_apply_d (link_order_id INT, is_Enable CHAR(1), INDEX(link_order_id));\nCREATE TABLE t_ve_bu_movestock_order (MOVESTOCK_ORDER_CODE VARCHAR(50), CAR_ID INT, VIN VARCHAR(50), AUDIT_STATUS VARCHAR(20), NEW_HOUSE_ID INT, NEW_DLR_ID INT, INDEX(CAR_ID), INDEX(VIN));\nCREATE TABLE t_ve_bu_month_plan_d (SALES_PLAN_CODE VARCHAR(50), INSTORE_TIME DATETIME, INDEX(SALES_PLAN_CODE));\nCREATE TABLE t_usc_mdm_org_dlr (DLR_ID INT PRIMARY KEY, CITY_ID INT);\nCREATE TABLE T_USC_MDM_ORG_CITY (CITY_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_db_zb_stock (ZB_STOCK_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_db_car_stock_house (CAR_STOCK_HOUSE_ID INT PRIMARY KEY, CAR_HOUSE_CODE VARCHAR(50));\nCREATE TABLE t_mdm_ve_car_optionalpag (OPTIONAL_PAG_ID INT PRIMARY KEY);\nCREATE TABLE t_mdm_car_color (CAR_COLOR_ID INT PRIMARY KEY);\nCREATE TABLE t_mdm_car_incolor (CAR_INCOLOR_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_finance_wholesale_purchase_order (SALES_PLAN_CODE VARCHAR(50), WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), ORDER_STATUS VARCHAR(50), INDEX(SALES_PLAN_CODE));\nCREATE TABLE t_ve_bu_invoice_info_upload (WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), IS_ENABLE CHAR(1), INDEX(WHOLESALE_PURCHASE_ORDER_CODE));\nCREATE TABLE t_prc_mds_lookup_value (LOOKUP_VALUE_CODE VARCHAR(50), LOOKUP_TYPE_CODE VARCHAR(50), INDEX(LOOKUP_VALUE_CODE));\nCREATE TABLE t_ve_bu_purchase_order (PURCHASE_ORDER_CODE VARCHAR(50), SALE_PLAN_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE));\n\n## Explain Output in JSON:\nid\tselect_type\ttable\ttype\tkey\trows\tExtra\n1\tPRIMARY\tc\tALL\tNULL\t1000\tUsing where\n1\tPRIMARY\tCAR\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tSOD\tref\tSALE_PLAN_CODE\t1\tUsing index\n1\tPRIMARY\tSO\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tcon\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tiad\tref\tlink_order_id\t1\tUsing where\n1\tPRIMARY\t<derived2>\tref\t<auto_key0>\t10\tUsing where\n1\tPRIMARY\tmpd\tref\tSALES_PLAN_CODE\t1\tUsing index\n1\tPRIMARY\ttumod\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tCI\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\ttvdzs\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\ttvdcsh\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tSHd\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\toptionl\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tcols\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tincol\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\toge\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tord\tref\tSALES_PLAN_CODE\t1\tUsing index\n1\tPRIMARY\ttvbiiu\tref\tWHOLESALE_PURCHASE_ORDER_CODE\t1\tUsing where\n1\tPRIMARY\tv5\tref\tLOOKUP_VALUE_CODE\t1\tUsing where\n1\tPRIMARY\t<derived4>\tref\t<auto_key0>\t10\tUsing where\n2\tDERIVED\tt_ve_bu_movestock_order\tALL\tNULL\t5000\tUsing where\n3\tDEPENDENT SUBQUERY\tt_ve_bu_movestock_order\tindex\tVIN\t5000\tUsing index\n4\tDERIVED\tt_ve_bu_purchase_order\tindex\tSALE_PLAN_CODE\t2000\tUsing index\n\n## Original SQL:\nSELECT count(1) stockNum, COUNT(c.FIRST_IN_HOSTSTOCK_DATE ) hostStockNum -- , -- DATE_FORMAT( Max(mpd.INSTORE_TIME), '%Y-%m-%d %H%:%i:%s') maxStoreTime FROM t_mdm_dlr_car_store c LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID = SO.SALE_ORDER_ID LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID = car.CAR_CONFIG_ID LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id = iad.link_order_id and iad.is_Enable='1' LEFT JOIN (SELECT MOVESTOCK_ORDER_CODE,CAR_ID,AUDIT_STATUS,NEW_HOUSE_ID,NEW_DLR_ID from t_ve_bu_movestock_order WHERE MOVESTOCK_ORDER_CODE in ( SELECT max(MOVESTOCK_ORDER_CODE) from t_ve_bu_movestock_order GROUP BY VIN )) mo ON mo.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID = tumod.DLR_ID LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID = tumod.CITY_ID LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID = c.CAR_SALE_HOUSE_ID LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID = optionl.OPTIONAL_PAG_ID LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID = cols.CAR_COLOR_ID LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID = incol.CAR_INCOLOR_ID left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE = SOD.DELIVERY_FAC_HW_CODE left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE = c.SALES_PLAN_CODE left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE = tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE = '1' left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE = ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE = 'VE1414' left join (select max(PURCHASE_ORDER_CODE) PURCHASE_ORDER_CODE ,SALE_PLAN_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE ) purchase on purchase.SALE_PLAN_CODE =c.SALES_PLAN_CODE WHERE c.IS_ENABLE = '1'\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT count(1) stockNum,COUNT(c.FIRST_IN_HOSTSTOCK_DATE) hostStockNum FROM t_mdm_dlr_car_store c LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID=c.CAR_ID LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE=c.SALES_PLAN_CODE LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID=SO.SALE_ORDER_ID LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID=car.CAR_CONFIG_ID LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id=iad.link_order_id and iad.is_Enable='1' LEFT JOIN(SELECT m.MOVESTOCK_ORDER_CODE,m.CAR_ID,m.AUDIT_STATUS,m.NEW_HOUSE_ID,m.NEW_DLR_ID FROM t_ve_bu_movestock_order m INNER JOIN(SELECT VIN,MAX(MOVESTOCK_ORDER_CODE) max_code FROM t_ve_bu_movestock_order GROUP BY VIN)mm ON m.VIN=mm.VIN AND m.MOVESTOCK_ORDER_CODE=mm.max_code)mo ON mo.CAR_ID=c.CAR_ID LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE=c.SALES_PLAN_CODE LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID=tumod.DLR_ID LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID=tumod.CITY_ID LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID=c.CAR_STOCK_HOUSE_ID LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID=c.CAR_STOCK_HOUSE_ID LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID=c.CAR_SALE_HOUSE_ID LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID=optionl.OPTIONAL_PAG_ID LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID=cols.CAR_COLOR_ID LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID=incol.CAR_INCOLOR_ID left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE=SOD.DELIVERY_FAC_HW_CODE left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE=c.SALES_PLAN_CODE left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE=tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE='1' left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE=ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE='VE1414' left join(select SALE_PLAN_CODE,MAX(PURCHASE_ORDER_CODE) PURCHASE_ORDER_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE)purchase on purchase.SALE_PLAN_CODE=c.SALES_PLAN_CODE WHERE c.IS_ENABLE='1'"
                    }
                ],
                "rule_id": "2"
            },
            {
                "case_id": "50",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"50\", \"db_type\": \"sqlserver\", \"description\": \"该SQL查询用于筛选特定的索赔记录（claim），逻辑上包含复杂的`OR`条件关联查询和用于去重的关联子查询。存在的主要性能瓶颈：1. **无输出的JOIN操作**：查询对`serie`表进行了两次LEFT JOIN（分别作为`serie`和`exchange_serie`），但在SELECT列表中并未请求这些表的任何字段，仅用于WHERE子句的过滤。这种写法增加了不必要的连接开销。2. **谓词未下推**：WHERE子句中包含跨表的`OR`逻辑 `(A AND B) OR (C AND D)`，这通常阻止优化器有效地利用索引进行过滤，导致优化器可能选择扫描整个`claim`表后再进行过滤，而不是先通过索引定位。3. **昂贵的关联子查询**：为了保留每个`claim_folder_id`下的最新记录，使用了关联子查询 `c.id = (SELECT MAX(...) ...)`，这会导致对每一行结果都执行一次子查询（N+1问题），在数据量大时性能急剧下降。\", \"create_table_statements\": [\"CREATE TABLE claim (id int PRIMARY KEY, sap_code nvarchar(4000), claim_folder_id int, repair_date datetime, claim_status_id int, is_e2e bit, serie_id int, exchange_serie_id int, serial_number nvarchar(4000), production_code nvarchar(4000), exchange_serial_number nvarchar(4000), exchange_production_code nvarchar(4000));\", \"CREATE TABLE serie (id int PRIMARY KEY, sap_code nvarchar(4000));\", \"CREATE INDEX idx_claim_folder ON claim(claim_folder_id);\", \"CREATE INDEX idx_claim_serial ON claim(serial_number);\", \"CREATE INDEX idx_serie_sap ON serie(sap_code);\"], \"sql\": \"SELECT c.id, \\r\\n   c.sap_code, \\r\\n   c.claim_folder_id, \\r\\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, \\r\\n   c.claim_status_id AS status, \\r\\n   c.is_e2e AS e2e \\r\\nFROM claim c \\r\\nLEFT JOIN serie \\r\\nON serie.id = c.serie_id \\r\\nLEFT JOIN serie exchange_serie \\r\\nON exchange_serie.id = c.exchange_serie_id \\r\\nWHERE ( ((serie.sap_code = @P0 \\r\\nOR serie.sap_code = CONCAT('4000', @P1)) \\r\\nAND c.serial_number = @P2 \\r\\nAND c.production_code = @P3) \\r\\nOR ((exchange_serie.sap_code = @P4 \\r\\nOR exchange_serie.sap_code = CONCAT('4000', @P5)) \\r\\nAND c.exchange_serial_number = @P6 \\r\\nAND c.exchange_production_code = @P7) ) \\r\\nAND (c.serial_number NOT IN (@P8) \\r\\nAND c.production_code NOT IN (@P9, @P10, @P11)) \\r\\nAND c.id = \\r\\n   (\\r\\n   SELECT MAX(c2.id) \\r\\n   FROM claim c2 \\r\\n   WHERE c2.claim_folder_id = c.claim_folder_id \\r\\n   OR (c.claim_folder_id IS NULL \\r\\n  AND c2.id = c.id)\\r\\n   ) \\r\\nORDER BY c.id DESC\\r\\n\\r\\n*/\\r\\n(@P0 nvarchar(4000),@P1 nvarchar(4000),@P2 nvarchar(4000),@P3 nvarchar(4000),@P4 nvarchar(4000),@P5 \\r\\nnvarchar(4000),@P6 nvarchar(4000),@P7 nvarchar(4000),@P8 nvarchar(4000),@P9 nvarchar(4000),@P10  \\r\\nnvarchar(4000),@P11 nvarchar(4000)) \\r\\n/* BEGIN ACTIVE SECTION (comment inserted by DPA) */  \\r\\nSELECT c.id,  \\r\\n   c.sap_code,  \\r\\n   c.claim_folder_id,  \\r\\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF,  \\r\\n   c.claim_status_id AS status,  \\r\\n   c.is_e2e AS e2e  \\r\\nFROM claim c  \\r\\nLEFT JOIN serie  \\r\\nON serie.id = c.serie_id  \\r\\nLEFT JOIN serie exchange_serie  \\r\\nON exchange_serie.id = c.exchange_serie_id  \\r\\nWHERE ( ((serie.sap_code = @P0  \\r\\nOR serie.sap_code = CONCAT('4000', @P1))  \\r\\nAND c.serial_number = @P2  \\r\\nAND c.production_code = @P3)  \\r\\nOR ((exchange_serie.sap_code = @P4  \\r\\nOR exchange_serie.sap_code = CONCAT('4000', @P5))  \\r\\nAND c.exchange_serial_number = @P6  \\r\\nAND c.exchange_production_code = @P7) )  \\r\\nAND (c.serial_number NOT IN (@P8)  \\r\\nAND c.production_code NOT IN (@P9, @P10, @P11))  \\r\\nAND c.id =  \\r\\n   ( \\r\\n   SELECT MAX(c2.id)  \\r\\n   FROM claim c2  \\r\\n   WHERE c2.claim_folder_id = c.claim_folder_id  \\r\\n   OR (c.claim_folder_id IS NULL  \\r\\n  AND c2.id = c.id) \\r\\n   )  \\r\\nORDER BY c.id DESC\", \"explain\": \"  |--Sort(ORDER BY:([c].[id] DESC))\\n       |--Filter(WHERE:([c].[id]=[Expr1009]))\\n            |--Nested Loops(Left Outer Join, WHERE:(... OR ...))\\n                 |--Nested Loops(Left Outer Join, WHERE:(...))\\n                 |    |--Table Scan(OBJECT:([claim] AS [c]), WHERE:([c].[serial_number] NOT IN (@P8) AND [c].[production_code] NOT IN (@P9, @P10, @P11)))\\n                 |    |--Index Seek(OBJECT:([serie] AS [serie]), SEEK:([serie].[id]=[c].[serie_id]))\\n                 |--Index Seek(OBJECT:([serie] AS [exchange_serie]), SEEK:([exchange_serie].[id]=[c].[exchange_serie_id]))\\n            |--Stream Aggregate(DEFINE:([Expr1009]=MAX([c2].[id])))\\n                 |--Index Seek(OBJECT:([claim] AS [c2]), SEEK:([c2].[claim_folder_id]=[c].[claim_folder_id]))\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过将serie和exchange_serie表的sap_code过滤条件下推到独立子查询，实现JOIN前的数据过滤。这符合rule0002谓词下推规则的多表JOIN优化场景，显著减少了连接表的数据量并保持了查询等价性\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,将无输出的LEFT JOIN子查询转化为EXISTS半连接，移除冗余数据加载。原JOIN仅用于验证serie记录是否存在，EXISTS子查询通过主键验证确保一对一关系，语义等价但减少JOIN操作开销。改写后执行路径更高效，特别在serie表较大时提升明显\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE claim (id int PRIMARY KEY, sap_code nvarchar(4000), claim_folder_id int, repair_date datetime, claim_status_id int, is_e2e bit, serie_id int, exchange_serie_id int, serial_number nvarchar(4000), production_code nvarchar(4000), exchange_serial_number nvarchar(4000), exchange_production_code nvarchar(4000));\nCREATE TABLE serie (id int PRIMARY KEY, sap_code nvarchar(4000));\nCREATE INDEX idx_claim_folder ON claim(claim_folder_id);\nCREATE INDEX idx_claim_serial ON claim(serial_number);\nCREATE INDEX idx_serie_sap ON serie(sap_code);\n\n## Explain Output in JSON:\n  |--Sort(ORDER BY:([c].[id] DESC))\n       |--Filter(WHERE:([c].[id]=[Expr1009]))\n            |--Nested Loops(Left Outer Join, WHERE:(... OR ...))\n                 |--Nested Loops(Left Outer Join, WHERE:(...))\n                 |    |--Table Scan(OBJECT:([claim] AS [c]), WHERE:([c].[serial_number] NOT IN (@P8) AND [c].[production_code] NOT IN (@P9, @P10, @P11)))\n                 |    |--Index Seek(OBJECT:([serie] AS [serie]), SEEK:([serie].[id]=[c].[serie_id]))\n                 |--Index Seek(OBJECT:([serie] AS [exchange_serie]), SEEK:([exchange_serie].[id]=[c].[exchange_serie_id]))\n            |--Stream Aggregate(DEFINE:([Expr1009]=MAX([c2].[id])))\n                 |--Index Seek(OBJECT:([claim] AS [c2]), SEEK:([c2].[claim_folder_id]=[c].[claim_folder_id]))\n\n## Original SQL:\nSELECT c.id, \r\n   c.sap_code, \r\n   c.claim_folder_id, \r\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, \r\n   c.claim_status_id AS status, \r\n   c.is_e2e AS e2e \r\nFROM claim c \r\nLEFT JOIN serie \r\nON serie.id = c.serie_id \r\nLEFT JOIN serie exchange_serie \r\nON exchange_serie.id = c.exchange_serie_id \r\nWHERE ( ((serie.sap_code = @P0 \r\nOR serie.sap_code = CONCAT('4000', @P1)) \r\nAND c.serial_number = @P2 \r\nAND c.production_code = @P3) \r\nOR ((exchange_serie.sap_code = @P4 \r\nOR exchange_serie.sap_code = CONCAT('4000', @P5)) \r\nAND c.exchange_serial_number = @P6 \r\nAND c.exchange_production_code = @P7) ) \r\nAND (c.serial_number NOT IN (@P8) \r\nAND c.production_code NOT IN (@P9, @P10, @P11)) \r\nAND c.id = \r\n   (\r\n   SELECT MAX(c2.id) \r\n   FROM claim c2 \r\n   WHERE c2.claim_folder_id = c.claim_folder_id \r\n   OR (c.claim_folder_id IS NULL \r\n  AND c2.id = c.id)\r\n   ) \r\nORDER BY c.id DESC\r\n\r\n*/\r\n(@P0 nvarchar(4000),@P1 nvarchar(4000),@P2 nvarchar(4000),@P3 nvarchar(4000),@P4 nvarchar(4000),@P5 \r\nnvarchar(4000),@P6 nvarchar(4000),@P7 nvarchar(4000),@P8 nvarchar(4000),@P9 nvarchar(4000),@P10  \r\nnvarchar(4000),@P11 nvarchar(4000)) \r\n/* BEGIN ACTIVE SECTION (comment inserted by DPA) */  \r\nSELECT c.id,  \r\n   c.sap_code,  \r\n   c.claim_folder_id,  \r\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF,  \r\n   c.claim_status_id AS status,  \r\n   c.is_e2e AS e2e  \r\nFROM claim c  \r\nLEFT JOIN serie  \r\nON serie.id = c.serie_id  \r\nLEFT JOIN serie exchange_serie  \r\nON exchange_serie.id = c.exchange_serie_id  \r\nWHERE ( ((serie.sap_code = @P0  \r\nOR serie.sap_code = CONCAT('4000', @P1))  \r\nAND c.serial_number = @P2  \r\nAND c.production_code = @P3)  \r\nOR ((exchange_serie.sap_code = @P4  \r\nOR exchange_serie.sap_code = CONCAT('4000', @P5))  \r\nAND c.exchange_serial_number = @P6  \r\nAND c.exchange_production_code = @P7) )  \r\nAND (c.serial_number NOT IN (@P8)  \r\nAND c.production_code NOT IN (@P9, @P10, @P11))  \r\nAND c.id =  \r\n   ( \r\n   SELECT MAX(c2.id)  \r\n   FROM claim c2  \r\n   WHERE c2.claim_folder_id = c.claim_folder_id  \r\n   OR (c.claim_folder_id IS NULL  \r\n  AND c2.id = c.id) \r\n   )  \r\nORDER BY c.id DESC\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH ranked_claims AS (SELECT c.*, ROW_NUMBER() OVER (PARTITION BY ISNULL(c.claim_folder_id, c.id) ORDER BY c.id DESC) AS rn FROM claim c WHERE c.serial_number NOT IN (@P8) AND c.production_code NOT IN (@P9, @P10, @P11)) SELECT rc.id, rc.sap_code, rc.claim_folder_id, DATEDIFF(day, rc.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, rc.claim_status_id AS status, rc.is_e2e AS e2e FROM ranked_claims rc LEFT JOIN serie ON serie.id = rc.serie_id LEFT JOIN serie exchange_serie ON exchange_serie.id = rc.exchange_serie_id WHERE rc.rn = 1 AND (((serie.sap_code = @P0 OR serie.sap_code = CONCAT('4000', @P1)) AND rc.serial_number = @P2 AND rc.production_code = @P3) OR ((exchange_serie.sap_code = @P4 OR exchange_serie.sap_code = CONCAT('4000', @P5)) AND rc.exchange_serial_number = @P6 AND rc.exchange_production_code = @P7)) ORDER BY rc.id DESC"
                    }
                ],
                "rule_id": "1"
            },
            {
                "case_id": "50",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"50\", \"db_type\": \"sqlserver\", \"description\": \"该SQL查询用于筛选特定的索赔记录（claim），逻辑上包含复杂的`OR`条件关联查询和用于去重的关联子查询。存在的主要性能瓶颈：1. **无输出的JOIN操作**：查询对`serie`表进行了两次LEFT JOIN（分别作为`serie`和`exchange_serie`），但在SELECT列表中并未请求这些表的任何字段，仅用于WHERE子句的过滤。这种写法增加了不必要的连接开销。2. **谓词未下推**：WHERE子句中包含跨表的`OR`逻辑 `(A AND B) OR (C AND D)`，这通常阻止优化器有效地利用索引进行过滤，导致优化器可能选择扫描整个`claim`表后再进行过滤，而不是先通过索引定位。3. **昂贵的关联子查询**：为了保留每个`claim_folder_id`下的最新记录，使用了关联子查询 `c.id = (SELECT MAX(...) ...)`，这会导致对每一行结果都执行一次子查询（N+1问题），在数据量大时性能急剧下降。\", \"create_table_statements\": [\"CREATE TABLE claim (id int PRIMARY KEY, sap_code nvarchar(4000), claim_folder_id int, repair_date datetime, claim_status_id int, is_e2e bit, serie_id int, exchange_serie_id int, serial_number nvarchar(4000), production_code nvarchar(4000), exchange_serial_number nvarchar(4000), exchange_production_code nvarchar(4000));\", \"CREATE TABLE serie (id int PRIMARY KEY, sap_code nvarchar(4000));\", \"CREATE INDEX idx_claim_folder ON claim(claim_folder_id);\", \"CREATE INDEX idx_claim_serial ON claim(serial_number);\", \"CREATE INDEX idx_serie_sap ON serie(sap_code);\"], \"sql\": \"SELECT c.id, \\r\\n   c.sap_code, \\r\\n   c.claim_folder_id, \\r\\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, \\r\\n   c.claim_status_id AS status, \\r\\n   c.is_e2e AS e2e \\r\\nFROM claim c \\r\\nLEFT JOIN serie \\r\\nON serie.id = c.serie_id \\r\\nLEFT JOIN serie exchange_serie \\r\\nON exchange_serie.id = c.exchange_serie_id \\r\\nWHERE ( ((serie.sap_code = @P0 \\r\\nOR serie.sap_code = CONCAT('4000', @P1)) \\r\\nAND c.serial_number = @P2 \\r\\nAND c.production_code = @P3) \\r\\nOR ((exchange_serie.sap_code = @P4 \\r\\nOR exchange_serie.sap_code = CONCAT('4000', @P5)) \\r\\nAND c.exchange_serial_number = @P6 \\r\\nAND c.exchange_production_code = @P7) ) \\r\\nAND (c.serial_number NOT IN (@P8) \\r\\nAND c.production_code NOT IN (@P9, @P10, @P11)) \\r\\nAND c.id = \\r\\n   (\\r\\n   SELECT MAX(c2.id) \\r\\n   FROM claim c2 \\r\\n   WHERE c2.claim_folder_id = c.claim_folder_id \\r\\n   OR (c.claim_folder_id IS NULL \\r\\n  AND c2.id = c.id)\\r\\n   ) \\r\\nORDER BY c.id DESC\\r\\n\\r\\n*/\\r\\n(@P0 nvarchar(4000),@P1 nvarchar(4000),@P2 nvarchar(4000),@P3 nvarchar(4000),@P4 nvarchar(4000),@P5 \\r\\nnvarchar(4000),@P6 nvarchar(4000),@P7 nvarchar(4000),@P8 nvarchar(4000),@P9 nvarchar(4000),@P10  \\r\\nnvarchar(4000),@P11 nvarchar(4000)) \\r\\n/* BEGIN ACTIVE SECTION (comment inserted by DPA) */  \\r\\nSELECT c.id,  \\r\\n   c.sap_code,  \\r\\n   c.claim_folder_id,  \\r\\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF,  \\r\\n   c.claim_status_id AS status,  \\r\\n   c.is_e2e AS e2e  \\r\\nFROM claim c  \\r\\nLEFT JOIN serie  \\r\\nON serie.id = c.serie_id  \\r\\nLEFT JOIN serie exchange_serie  \\r\\nON exchange_serie.id = c.exchange_serie_id  \\r\\nWHERE ( ((serie.sap_code = @P0  \\r\\nOR serie.sap_code = CONCAT('4000', @P1))  \\r\\nAND c.serial_number = @P2  \\r\\nAND c.production_code = @P3)  \\r\\nOR ((exchange_serie.sap_code = @P4  \\r\\nOR exchange_serie.sap_code = CONCAT('4000', @P5))  \\r\\nAND c.exchange_serial_number = @P6  \\r\\nAND c.exchange_production_code = @P7) )  \\r\\nAND (c.serial_number NOT IN (@P8)  \\r\\nAND c.production_code NOT IN (@P9, @P10, @P11))  \\r\\nAND c.id =  \\r\\n   ( \\r\\n   SELECT MAX(c2.id)  \\r\\n   FROM claim c2  \\r\\n   WHERE c2.claim_folder_id = c.claim_folder_id  \\r\\n   OR (c.claim_folder_id IS NULL  \\r\\n  AND c2.id = c.id) \\r\\n   )  \\r\\nORDER BY c.id DESC\", \"explain\": \"  |--Sort(ORDER BY:([c].[id] DESC))\\n       |--Filter(WHERE:([c].[id]=[Expr1009]))\\n            |--Nested Loops(Left Outer Join, WHERE:(... OR ...))\\n                 |--Nested Loops(Left Outer Join, WHERE:(...))\\n                 |    |--Table Scan(OBJECT:([claim] AS [c]), WHERE:([c].[serial_number] NOT IN (@P8) AND [c].[production_code] NOT IN (@P9, @P10, @P11)))\\n                 |    |--Index Seek(OBJECT:([serie] AS [serie]), SEEK:([serie].[id]=[c].[serie_id]))\\n                 |--Index Seek(OBJECT:([serie] AS [exchange_serie]), SEEK:([exchange_serie].[id]=[c].[exchange_serie_id]))\\n            |--Stream Aggregate(DEFINE:([Expr1009]=MAX([c2].[id])))\\n                 |--Index Seek(OBJECT:([claim] AS [c2]), SEEK:([c2].[claim_folder_id]=[c].[claim_folder_id]))\", \"expected\": {\"optimization_rules\": [{\"rule_id\": \"1\", \"difficulty_level\": \"3\", \"rationale\": \"谓词下推,通过将serie和exchange_serie表的sap_code过滤条件下推到独立子查询，实现JOIN前的数据过滤。这符合rule0002谓词下推规则的多表JOIN优化场景，显著减少了连接表的数据量并保持了查询等价性\"}, {\"rule_id\": \"2\", \"difficulty_level\": \"3\", \"rationale\": \"无输出JOIN转EXISTS / LEFT转INNER,将无输出的LEFT JOIN子查询转化为EXISTS半连接，移除冗余数据加载。原JOIN仅用于验证serie记录是否存在，EXISTS子查询通过主键验证确保一对一关系，语义等价但减少JOIN操作开销。改写后执行路径更高效，特别在serie表较大时提升明显\"}]}}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE claim (id int PRIMARY KEY, sap_code nvarchar(4000), claim_folder_id int, repair_date datetime, claim_status_id int, is_e2e bit, serie_id int, exchange_serie_id int, serial_number nvarchar(4000), production_code nvarchar(4000), exchange_serial_number nvarchar(4000), exchange_production_code nvarchar(4000));\nCREATE TABLE serie (id int PRIMARY KEY, sap_code nvarchar(4000));\nCREATE INDEX idx_claim_folder ON claim(claim_folder_id);\nCREATE INDEX idx_claim_serial ON claim(serial_number);\nCREATE INDEX idx_serie_sap ON serie(sap_code);\n\n## Explain Output in JSON:\n  |--Sort(ORDER BY:([c].[id] DESC))\n       |--Filter(WHERE:([c].[id]=[Expr1009]))\n            |--Nested Loops(Left Outer Join, WHERE:(... OR ...))\n                 |--Nested Loops(Left Outer Join, WHERE:(...))\n                 |    |--Table Scan(OBJECT:([claim] AS [c]), WHERE:([c].[serial_number] NOT IN (@P8) AND [c].[production_code] NOT IN (@P9, @P10, @P11)))\n                 |    |--Index Seek(OBJECT:([serie] AS [serie]), SEEK:([serie].[id]=[c].[serie_id]))\n                 |--Index Seek(OBJECT:([serie] AS [exchange_serie]), SEEK:([exchange_serie].[id]=[c].[exchange_serie_id]))\n            |--Stream Aggregate(DEFINE:([Expr1009]=MAX([c2].[id])))\n                 |--Index Seek(OBJECT:([claim] AS [c2]), SEEK:([c2].[claim_folder_id]=[c].[claim_folder_id]))\n\n## Original SQL:\nSELECT c.id, \r\n   c.sap_code, \r\n   c.claim_folder_id, \r\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, \r\n   c.claim_status_id AS status, \r\n   c.is_e2e AS e2e \r\nFROM claim c \r\nLEFT JOIN serie \r\nON serie.id = c.serie_id \r\nLEFT JOIN serie exchange_serie \r\nON exchange_serie.id = c.exchange_serie_id \r\nWHERE ( ((serie.sap_code = @P0 \r\nOR serie.sap_code = CONCAT('4000', @P1)) \r\nAND c.serial_number = @P2 \r\nAND c.production_code = @P3) \r\nOR ((exchange_serie.sap_code = @P4 \r\nOR exchange_serie.sap_code = CONCAT('4000', @P5)) \r\nAND c.exchange_serial_number = @P6 \r\nAND c.exchange_production_code = @P7) ) \r\nAND (c.serial_number NOT IN (@P8) \r\nAND c.production_code NOT IN (@P9, @P10, @P11)) \r\nAND c.id = \r\n   (\r\n   SELECT MAX(c2.id) \r\n   FROM claim c2 \r\n   WHERE c2.claim_folder_id = c.claim_folder_id \r\n   OR (c.claim_folder_id IS NULL \r\n  AND c2.id = c.id)\r\n   ) \r\nORDER BY c.id DESC\r\n\r\n*/\r\n(@P0 nvarchar(4000),@P1 nvarchar(4000),@P2 nvarchar(4000),@P3 nvarchar(4000),@P4 nvarchar(4000),@P5 \r\nnvarchar(4000),@P6 nvarchar(4000),@P7 nvarchar(4000),@P8 nvarchar(4000),@P9 nvarchar(4000),@P10  \r\nnvarchar(4000),@P11 nvarchar(4000)) \r\n/* BEGIN ACTIVE SECTION (comment inserted by DPA) */  \r\nSELECT c.id,  \r\n   c.sap_code,  \r\n   c.claim_folder_id,  \r\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF,  \r\n   c.claim_status_id AS status,  \r\n   c.is_e2e AS e2e  \r\nFROM claim c  \r\nLEFT JOIN serie  \r\nON serie.id = c.serie_id  \r\nLEFT JOIN serie exchange_serie  \r\nON exchange_serie.id = c.exchange_serie_id  \r\nWHERE ( ((serie.sap_code = @P0  \r\nOR serie.sap_code = CONCAT('4000', @P1))  \r\nAND c.serial_number = @P2  \r\nAND c.production_code = @P3)  \r\nOR ((exchange_serie.sap_code = @P4  \r\nOR exchange_serie.sap_code = CONCAT('4000', @P5))  \r\nAND c.exchange_serial_number = @P6  \r\nAND c.exchange_production_code = @P7) )  \r\nAND (c.serial_number NOT IN (@P8)  \r\nAND c.production_code NOT IN (@P9, @P10, @P11))  \r\nAND c.id =  \r\n   ( \r\n   SELECT MAX(c2.id)  \r\n   FROM claim c2  \r\n   WHERE c2.claim_folder_id = c.claim_folder_id  \r\n   OR (c.claim_folder_id IS NULL  \r\n  AND c2.id = c.id) \r\n   )  \r\nORDER BY c.id DESC\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH ranked_claims AS (SELECT c.*, ROW_NUMBER() OVER (PARTITION BY ISNULL(c.claim_folder_id, c.id) ORDER BY c.id DESC) AS rn FROM claim c WHERE c.serial_number NOT IN (@P8) AND c.production_code NOT IN (@P9, @P10, @P11)) SELECT rc.id, rc.sap_code, rc.claim_folder_id, DATEDIFF(day, rc.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, rc.claim_status_id AS status, rc.is_e2e AS e2e FROM ranked_claims rc LEFT JOIN serie ON serie.id = rc.serie_id LEFT JOIN serie exchange_serie ON exchange_serie.id = rc.exchange_serie_id WHERE rc.rn = 1 AND (((serie.sap_code = @P0 OR serie.sap_code = CONCAT('4000', @P1)) AND rc.serial_number = @P2 AND rc.production_code = @P3) OR ((exchange_serie.sap_code = @P4 OR exchange_serie.sap_code = CONCAT('4000', @P5)) AND rc.exchange_serial_number = @P6 AND rc.exchange_production_code = @P7)) ORDER BY rc.id DESC"
                    }
                ],
                "rule_id": "2"
            }
        ]
    },
    {
        "indicator_name": "syntax_error_detection.jsonl",
        "indicator_weight": 3,
        "evaluation_type": "hybrid",
        "case_pass_count": 43,
        "case_wrong_count": 7,
        "correct_rate": 0.86,
        "case_datas": [
            {
                "case_id": "1",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"1\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，子查询中存在多余的投影列，这些列在外层查询中没有被使用。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\"], \"sql\": \"SELECT student_name FROM students WHERE student_id IN ( SELECT student_id FROM ( SELECT student_id, gender FROM ( SELECT student_id, gender FROM ( SELECT student_id, gender FROM students ) AS inner_dt2 ) AS inner_dt1 ) AS outer_dt );\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.40\\\"}, \\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\"]}}, {\\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [\\\"test_db_case_1_1748591779.students.student_id\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"using_index\\\": true, \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"2.40\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\"]}}]}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"2.40\"}, \"nested_loop\": [{\"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"possible_keys\": [\"PRIMARY\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"student_name\"]}}, {\"table\": {\"table_name\": \"students\", \"access_type\": \"eq_ref\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"4\", \"ref\": [\"test_db_case_1_1748591779.students.student_id\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"using_index\": true, \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"2.40\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\"]}}]}}\n\n## Original SQL:\nSELECT student_name FROM students WHERE student_id IN ( SELECT student_id FROM ( SELECT student_id, gender FROM ( SELECT student_id, gender FROM ( SELECT student_id, gender FROM students ) AS inner_dt2 ) AS inner_dt1 ) AS outer_dt );\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_name FROM students;"
                    }
                ]
            },
            {
                "case_id": "2",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"2\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，其中外部的WHERE子句条件可以下推到最内层的子查询中。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\"], \"sql\": \"SELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM teachers WHERE teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!' ) AS inner_dt1 ) AS inner_dt2 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.40\\\"}, \\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"teacher_id\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_2_1749458126`.`students`.`teacher_id` is not null)\\\"}}, {\\\"table\\\": {\\\"table_name\\\": \\\"teachers\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"teacher_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [\\\"test_db_case_2_1749458126.students.teacher_id\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"2.40\\\", \\\"data_read_per_join\\\": \\\"208\\\"}, \\\"used_columns\\\": [\\\"teacher_id\\\", \\\"teacher_name\\\"], \\\"attached_condition\\\": \\\"((`test_db_case_2_1749458126`.`teachers`.`teacher_name` >= 'Dr. ') and (`test_db_case_2_1749458126`.`teachers`.`teacher_name` < 'Dr.!'))\\\"}}]}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"2.40\"}, \"nested_loop\": [{\"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"teacher_id\"], \"attached_condition\": \"(`test_db_case_2_1749458126`.`students`.`teacher_id` is not null)\"}}, {\"table\": {\"table_name\": \"teachers\", \"access_type\": \"eq_ref\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"teacher_id\"], \"key_length\": \"4\", \"ref\": [\"test_db_case_2_1749458126.students.teacher_id\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"2.40\", \"data_read_per_join\": \"208\"}, \"used_columns\": [\"teacher_id\", \"teacher_name\"], \"attached_condition\": \"((`test_db_case_2_1749458126`.`teachers`.`teacher_name` >= 'Dr. ') and (`test_db_case_2_1749458126`.`teachers`.`teacher_name` < 'Dr.!'))\"}}]}}\n\n## Original SQL:\nSELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name FROM teachers WHERE teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!' ) AS inner_dt1 ) AS inner_dt2 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT students.teacher_id, teachers.teacher_name FROM students JOIN teachers ON students.teacher_id = teachers.teacher_id WHERE teachers.teacher_name >= 'Dr. ' AND teachers.teacher_name < 'Dr.!'"
                    }
                ]
            },
            {
                "case_id": "3",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"3\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的JOIN语句，其中外部的WHERE子句条件可以下推到最内层的子查询中，同时存在可以投影下推的冗余列和可以进行LIKE前缀优化的条件。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, major VARCHAR(100), enroll_count INT );\", \"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE, enrollment_year INT );\", \"CREATE TABLE courses ( course_id INT AUTO_INCREMENT PRIMARY KEY, course_name VARCHAR(255) NOT NULL, course_credits INT, department_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department_id INT );\", \"CREATE TABLE departments ( department_id INT AUTO_INCREMENT PRIMARY KEY, department_name VARCHAR(100), location VARCHAR(100) );\"], \"sql\": \"SELECT initial_students.student_id, initial_students.student_name, final_courses.course_name, final_enrollments.enrollment_date, final_teachers.teacher_name FROM (SELECT student_id, student_name, major, enroll_count FROM students WHERE enroll_count > 5) AS initial_students JOIN (SELECT e.student_id, e.course_id, e.enrollment_date FROM enrollments e WHERE e.enrollment_year = 2024) AS final_enrollments ON initial_students.student_id = final_enrollments.student_id JOIN (SELECT course_id, course_name, department_id FROM courses WHERE course_credits >= 3) AS final_courses ON final_enrollments.course_id = final_courses.course_id LEFT JOIN (SELECT t.teacher_id, t.teacher_name FROM teachers t JOIN departments d ON t.department_id = d.department_id WHERE d.location = 'Building A') AS final_teachers ON final_courses.department_id = final_teachers.teacher_id WHERE initial_students.major = 'Physics' AND final_enrollments.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30' AND final_courses.course_name LIKE 'Advanced %';\", \"explain\": \"{\\\"query_block\\\": { \\\"select_id\\\": 1, \\\"cost_info\\\": { \\\"query_cost\\\": \\\"6.00\\\" }, \\\"nested_loop\\\": [ { \\\"table\\\": { \\\"table_name\\\": \\\"e\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"24\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"course_id\\\", \\\"enrollment_date\\\", \\\"enrollment_year\\\" ], \\\"attached_condition\\\": \\\"(((`test_db_case_5_1749718637`.`e`.`enrollment_year` = 2024) and (`test_db_case_5_1749718637`.`e`.`enrollment_date` between '2024-01-01' and '2024-06-30')) and (`test_db_case_5_1749718637`.`e`.`course_id` is not null))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"student_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.e.student_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"2.40\\\", \\\"data_read_per_join\\\": \\\"216\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"student_name\\\", \\\"major\\\", \\\"enroll_count\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_5_1749718637`.`students`.`major` = 'Physics') and (`test_db_case_5_1749718637`.`students`.`enroll_count` > 5))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"courses\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"course_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.e.course_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"3.60\\\", \\\"data_read_per_join\\\": \\\"272\\\" }, \\\"used_columns\\\": [ \\\"course_id\\\", \\\"course_name\\\", \\\"course_credits\\\", \\\"department_id\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_5_1749718637`.`courses`.`course_name` like 'Advanced %') and (`test_db_case_5_1749718637`.`courses`.`course_credits` >= 3))\\\" } }, { \\\"table\\\": { \\\"table_name\\\": \\\"t\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"teacher_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.courses.department_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"4.80\\\", \\\"data_read_per_join\\\": \\\"112\\\" }, \\\"used_columns\\\": [ \\\"teacher_id\\\", \\\"teacher_name\\\", \\\"department_id\\\" ] } }, { \\\"table\\\": { \\\"table_name\\\": \\\"d\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"department_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [ \\\"test_db_case_5_1749718637.t.department_id\\\" ], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"6.00\\\", \\\"data_read_per_join\\\": \\\"208\\\" }, \\\"used_columns\\\": [ \\\"department_id\\\", \\\"location\\\" ], \\\"attached_condition\\\": \\\"<if>(is_not_null_compl(t..d), (`test_db_case_5_1749718637`.`d`.`location` = 'Building A'), true)\\\" } } ] } }\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, major VARCHAR(100), enroll_count INT );\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE, enrollment_year INT );\nCREATE TABLE courses ( course_id INT AUTO_INCREMENT PRIMARY KEY, course_name VARCHAR(255) NOT NULL, course_credits INT, department_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department_id INT );\nCREATE TABLE departments ( department_id INT AUTO_INCREMENT PRIMARY KEY, department_name VARCHAR(100), location VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": { \"select_id\": 1, \"cost_info\": { \"query_cost\": \"6.00\" }, \"nested_loop\": [ { \"table\": { \"table_name\": \"e\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"24\" }, \"used_columns\": [ \"student_id\", \"course_id\", \"enrollment_date\", \"enrollment_year\" ], \"attached_condition\": \"(((`test_db_case_5_1749718637`.`e`.`enrollment_year` = 2024) and (`test_db_case_5_1749718637`.`e`.`enrollment_date` between '2024-01-01' and '2024-06-30')) and (`test_db_case_5_1749718637`.`e`.`course_id` is not null))\" } }, { \"table\": { \"table_name\": \"students\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"student_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.e.student_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"2.40\", \"data_read_per_join\": \"216\" }, \"used_columns\": [ \"student_id\", \"student_name\", \"major\", \"enroll_count\" ], \"attached_condition\": \"((`test_db_case_5_1749718637`.`students`.`major` = 'Physics') and (`test_db_case_5_1749718637`.`students`.`enroll_count` > 5))\" } }, { \"table\": { \"table_name\": \"courses\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"course_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.e.course_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"3.60\", \"data_read_per_join\": \"272\" }, \"used_columns\": [ \"course_id\", \"course_name\", \"course_credits\", \"department_id\" ], \"attached_condition\": \"((`test_db_case_5_1749718637`.`courses`.`course_name` like 'Advanced %') and (`test_db_case_5_1749718637`.`courses`.`course_credits` >= 3))\" } }, { \"table\": { \"table_name\": \"t\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"teacher_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.courses.department_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"4.80\", \"data_read_per_join\": \"112\" }, \"used_columns\": [ \"teacher_id\", \"teacher_name\", \"department_id\" ] } }, { \"table\": { \"table_name\": \"d\", \"access_type\": \"eq_ref\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"department_id\" ], \"key_length\": \"4\", \"ref\": [ \"test_db_case_5_1749718637.t.department_id\" ], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"6.00\", \"data_read_per_join\": \"208\" }, \"used_columns\": [ \"department_id\", \"location\" ], \"attached_condition\": \"<if>(is_not_null_compl(t..d), (`test_db_case_5_1749718637`.`d`.`location` = 'Building A'), true)\" } } ] } }\n\n## Original SQL:\nSELECT initial_students.student_id, initial_students.student_name, final_courses.course_name, final_enrollments.enrollment_date, final_teachers.teacher_name FROM (SELECT student_id, student_name, major, enroll_count FROM students WHERE enroll_count > 5) AS initial_students JOIN (SELECT e.student_id, e.course_id, e.enrollment_date FROM enrollments e WHERE e.enrollment_year = 2024) AS final_enrollments ON initial_students.student_id = final_enrollments.student_id JOIN (SELECT course_id, course_name, department_id FROM courses WHERE course_credits >= 3) AS final_courses ON final_enrollments.course_id = final_courses.course_id LEFT JOIN (SELECT t.teacher_id, t.teacher_name FROM teachers t JOIN departments d ON t.department_id = d.department_id WHERE d.location = 'Building A') AS final_teachers ON final_courses.department_id = final_teachers.teacher_id WHERE initial_students.major = 'Physics' AND final_enrollments.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30' AND final_courses.course_name LIKE 'Advanced %';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT s.student_id, s.student_name, c.course_name, e.enrollment_date, t.teacher_name FROM enrollments e INNER JOIN students s ON e.student_id = s.student_id AND s.major = 'Physics' AND s.enroll_count > 5 INNER JOIN courses c ON e.course_id = c.course_id AND c.course_credits >= 3 AND c.course_name LIKE 'Advanced %' LEFT JOIN teachers t ON c.department_id = t.teacher_id AND EXISTS (SELECT 1 FROM departments WHERE department_id = t.department_id AND location = 'Building A') WHERE e.enrollment_year = 2024 AND e.enrollment_date BETWEEN '2024-01-01' AND '2024-06-30'"
                    }
                ]
            },
            {
                "case_id": "4",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"4\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，子查询中存在多余的投影列，同时内层子查询有ORDER BY和LIMIT，但最外层查询仍可进行投影下推。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\"], \"sql\": \"SELECT s.student_id, s.student_name, s.date_of_birth FROM students s JOIN ( SELECT student_id, gender FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM students ORDER BY student_id DESC ) AS inner_dt3 ) AS inner_dt2 ORDER BY student_id DESC LIMIT 1 ) AS inner_dt1 ) dt ON s.student_id = dt.student_id WHERE dt.gender = 'MALE'\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"message\\\": \\\"no matching row in const table\\\", \\\"table\\\": {\\\"materialized_from_subquery\\\": {\\\"using_temporary_table\\\": true, \\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 3, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"ordering_operation\\\": {\\\"using_filesort\\\": false, \\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"index\\\", \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"gender\\\", \\\"date_of_birth\\\"]}}}}}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, gender ENUM('Male', 'Female', 'Other'), date_of_birth DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"message\": \"no matching row in const table\", \"table\": {\"materialized_from_subquery\": {\"using_temporary_table\": true, \"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 3, \"cost_info\": {\"query_cost\": \"1.20\"}, \"ordering_operation\": {\"using_filesort\": false, \"table\": {\"table_name\": \"students\", \"access_type\": \"index\", \"key\": \"PRIMARY\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"gender\", \"date_of_birth\"]}}}}}}}\n\n## Original SQL:\nSELECT s.student_id, s.student_name, s.date_of_birth FROM students s JOIN ( SELECT student_id, gender FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM ( SELECT student_id, gender, date_of_birth FROM students ORDER BY student_id DESC ) AS inner_dt3 ) AS inner_dt2 ORDER BY student_id DESC LIMIT 1 ) AS inner_dt1 ) dt ON s.student_id = dt.student_id WHERE dt.gender = 'MALE'\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id, student_name, date_of_birth FROM students WHERE gender = 'Male' ORDER BY student_id DESC LIMIT 1"
                    }
                ]
            },
            {
                "case_id": "5",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"5\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的JOIN语句，其中外部的WHERE子句条件可以下推到最内层的子查询中，同时存在可以投影下推的冗余列和可以进行LIKE前缀优化的条件。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\", \"CREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\"], \"sql\": \"SELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM teachers ) AS inner_dt1 ) AS inner_dt2 ) AS inner_dt3 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id WHERE outer_dt.teacher_name LIKE 'Dr. %';\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.40\\\"},\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"students\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"teacher_id\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"teachers\\\",\\\"access_type\\\": \\\"eq_ref\\\",\\\"possible_keys\\\": [\\\"PRIMARY\\\"],\\\"key\\\": \\\"PRIMARY\\\",\\\"used_key_parts\\\": [\\\"teacher_id\\\"],\\\"key_length\\\": \\\"4\\\",\\\"ref\\\": [\\\"test_db_case_5_1749537373.students.teacher_id\\\"],\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"208\\\"},\\\"used_columns\\\": [\\\"teacher_id\\\",\\\"teacher_name\\\",\\\"department\\\"],\\\"attached_condition\\\": \\\"(`test_db_case_5_1749537373`.`teachers`.`teacher_name` LIKE 'Dr. %')\\\"}}]}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) NOT NULL, teacher_id INT );\nCREATE TABLE teachers ( teacher_id INT AUTO_INCREMENT PRIMARY KEY, teacher_name VARCHAR(100) NOT NULL, department VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"2.40\"},\"nested_loop\": [{\"table\": {\"table_name\": \"students\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"teacher_id\"]}},{\"table\": {\"table_name\": \"teachers\",\"access_type\": \"eq_ref\",\"possible_keys\": [\"PRIMARY\"],\"key\": \"PRIMARY\",\"used_key_parts\": [\"teacher_id\"],\"key_length\": \"4\",\"ref\": [\"test_db_case_5_1749537373.students.teacher_id\"],\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"208\"},\"used_columns\": [\"teacher_id\",\"teacher_name\",\"department\"],\"attached_condition\": \"(`test_db_case_5_1749537373`.`teachers`.`teacher_name` LIKE 'Dr. %')\"}}]}}}\n\n## Original SQL:\nSELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM ( SELECT teacher_id, teacher_name, department FROM teachers ) AS inner_dt1 ) AS inner_dt2 ) AS inner_dt3 ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id WHERE outer_dt.teacher_name LIKE 'Dr. %';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT t.teacher_id, t.teacher_name FROM students JOIN teachers t ON students.teacher_id = t.teacher_id WHERE t.teacher_name LIKE 'Dr. %'"
                    }
                ]
            },
            {
                "case_id": "6",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"6\", \"db_type\": \"mysql\", \"description\": \"一个简单的SELECT语句，其中WHERE子句对字段使用了函数，导致隐式转换。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT student_id, CONCAT(\\\"id_\\\", student_id) as student_id2 FROM enrollments WHERE CONCAT(\\\"id_\\\", student_id) >= \\\"id_1000\\\" LIMIT 10;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"enrollments\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"24\\\"}, \\\"used_columns\\\": [\\\"student_id\\\"], \\\"attached_condition\\\": \\\"(concat('id_',`test_db_case_6_1748591779`.`enrollments`.`student_id`) >= 'id_1000')\\\"}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"enrollments\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"24\"}, \"used_columns\": [\"student_id\"], \"attached_condition\": \"(concat('id_',`test_db_case_6_1748591779`.`enrollments`.`student_id`) >= 'id_1000')\"}}}\n\n## Original SQL:\nSELECT student_id, CONCAT(\"id_\", student_id) as student_id2 FROM enrollments WHERE CONCAT(\"id_\", student_id) >= \"id_1000\" LIMIT 10;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id, CONCAT(\"id_\", student_id) as student_id2 FROM enrollments WHERE student_id >= 1000 LIMIT 10;"
                    }
                ]
            },
            {
                "case_id": "7",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"7\", \"db_type\": \"mysql\", \"description\": \"一个包含COUNT标量子查询的SELECT语句，可以将其改写为IN子查询以利用SEMI JOIN特性。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) );\", \"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT * FROM students WHERE NOT ( SELECT count(*) FROM enrollments WHERE students.student_id = enrollments.student_id AND enrollment_id > 1000 ) > 0;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\"], \\\"attached_condition\\\": \\\"((/* select#2 */ select count(0) from `test_db_case_7_1748591779`.`enrollments` where ((`test_db_case_7_1748591779`.`students`.`student_id` = `test_db_case_7_1748591779`.`enrollments`.`student_id`) and (`test_db_case_7_1748591779`.`enrollment_id` > 1000))) <= 0)\\\", \\\"attached_subqueries\\\": [{\\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.41\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"enrollments\\\", \\\"access_type\\\": \\\"range\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"enrollment_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.21\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.41\\\", \\\"data_read_per_join\\\": \\\"24\\\"}, \\\"used_columns\\\": [\\\"enrollment_id\\\", \\\"student_id\\\"], \\\"attached_condition\\\": \\\"((`test_db_case_7_1748591779`.`students`.`student_id` = `test_db_case_7_1748591779`.`enrollments`.`student_id`) and (`test_db_case_7_1748591779`.`enrollment_id` > 1000))\\\"}}}]}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) );\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"student_name\"], \"attached_condition\": \"((/* select#2 */ select count(0) from `test_db_case_7_1748591779`.`enrollments` where ((`test_db_case_7_1748591779`.`students`.`student_id` = `test_db_case_7_1748591779`.`enrollments`.`student_id`) and (`test_db_case_7_1748591779`.`enrollment_id` > 1000))) <= 0)\", \"attached_subqueries\": [{\"dependent\": true, \"cacheable\": false, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.41\"}, \"table\": {\"table_name\": \"enrollments\", \"access_type\": \"range\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"enrollment_id\"], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.21\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.41\", \"data_read_per_join\": \"24\"}, \"used_columns\": [\"enrollment_id\", \"student_id\"], \"attached_condition\": \"((`test_db_case_7_1748591779`.`students`.`student_id` = `test_db_case_7_1748591779`.`enrollments`.`student_id`) and (`test_db_case_7_1748591779`.`enrollment_id` > 1000))\"}}}]}}\n\n## Original SQL:\nSELECT * FROM students WHERE NOT ( SELECT count(*) FROM enrollments WHERE students.student_id = enrollments.student_id AND enrollment_id > 1000 ) > 0;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM students WHERE NOT EXISTS (SELECT 1 FROM enrollments WHERE students.student_id = enrollments.student_id AND enrollment_id > 1000)"
                    }
                ]
            },
            {
                "case_id": "8",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"8\", \"db_type\": \"mysql\", \"description\": \"一个包含HAVING子句的SELECT语句，其中HAVING条件不依赖聚合函数，可以下推到WHERE子句。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE enrollment_date > '1993-11-26' OR enrollment_date < '1991-11-26' GROUP BY student_id HAVING student_id = 1999\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.20\\\"},\\\"grouping_operation\\\": {\\\"using_temporary_table\\\": true,\\\"using_filesort\\\": true,\\\"cost_info\\\": {\\\"sort_cost\\\": \\\"1.00\\\"},\\\"table\\\": {\\\"table_name\\\": \\\"enrollments\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"24\\\"},\\\"used_columns\\\": [\\\"enrollment_id\\\",\\\"student_id\\\",\\\"enrollment_date\\\"],\\\"attached_condition\\\": \\\"((`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` > '1993-11-26') or (`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` < '1991-11-26'))\\\"}}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"2.20\"},\"grouping_operation\": {\"using_temporary_table\": true,\"using_filesort\": true,\"cost_info\": {\"sort_cost\": \"1.00\"},\"table\": {\"table_name\": \"enrollments\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"24\"},\"used_columns\": [\"enrollment_id\",\"student_id\",\"enrollment_date\"],\"attached_condition\": \"((`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` > '1993-11-26') or (`test_db_case_8_1749537373`.`enrollments`.`enrollment_date` < '1991-11-26'))\"}}}}\n\n## Original SQL:\nSELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE enrollment_date > '1993-11-26' OR enrollment_date < '1991-11-26' GROUP BY student_id HAVING student_id = 1999\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE student_id = 1999 AND (enrollment_date > '1993-11-26' OR enrollment_date < '1991-11-26') GROUP BY student_id"
                    }
                ]
            },
            {
                "case_id": "9",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"9\", \"db_type\": \"mysql\", \"description\": \"一个包含多层嵌套子查询的SELECT语句，最内层的GROUP BY子句是不必要的，可以被消除。\", \"difficulty_level\": \"2\", \"sql\": \"SELECT student_id FROM students s WHERE EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id) AND s.gender = 'Female' AND s.date_of_birth <= CAST('2000-01-01' AS DATE) AND s.student_name != '张凯' GROUP BY student_id LIMIT 10;\", \"create_table_statements\": [\"CREATE TABLE students (student_id INT PRIMARY KEY, student_name VARCHAR(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL, gender VARCHAR(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci, date_of_birth DATE) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\", \"CREATE TABLE enrollments (enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, enrollment_date DATE, FOREIGN KEY (student_id) REFERENCES students(student_id)) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\"], \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"grouping_operation\\\": {\\\"using_filesort\\\": false, \\\"table\\\": {\\\"table_name\\\": \\\"s\\\", \\\"access_type\\\": \\\"index\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"1K\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\", \\\"gender\\\", \\\"date_of_birth\\\"], \\\"attached_condition\\\": \\\"(exists(/* select#2 */ select 1 from `test_db_case_9_1749465373`.`enrollments` `e` where (`test_db_case_9_1749465373`.`e`.`student_id` = `test_db_case_9_1749465373`.`s`.`student_id`)) and (`test_db_case_9_1749465373`.`s`.`gender` = 'Female') and (`test_db_case_9_1749465373`.`s`.`date_of_birth` <= <cache>(cast('2000-01-01' as date))) and (`test_db_case_9_1749465373`.`s`.`student_name` <> '张凯'))\\\", \\\"attached_subqueries\\\": [{\\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"e\\\", \\\"access_type\\\": \\\"ref\\\", \\\"possible_keys\\\": [\\\"student_id\\\"], \\\"key\\\": \\\"student_id\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"5\\\", \\\"ref\\\": [\\\"test_db_case_9_1749465373.s.student_id\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"using_index\\\": true, \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"24\\\"}, \\\"used_columns\\\": [\\\"student_id\\\"]}}}]}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students (student_id INT PRIMARY KEY, student_name VARCHAR(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL, gender VARCHAR(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci, date_of_birth DATE) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\nCREATE TABLE enrollments (enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, enrollment_date DATE, FOREIGN KEY (student_id) REFERENCES students(student_id)) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"1.20\"}, \"grouping_operation\": {\"using_filesort\": false, \"table\": {\"table_name\": \"s\", \"access_type\": \"index\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"1K\"}, \"used_columns\": [\"student_id\", \"student_name\", \"gender\", \"date_of_birth\"], \"attached_condition\": \"(exists(/* select#2 */ select 1 from `test_db_case_9_1749465373`.`enrollments` `e` where (`test_db_case_9_1749465373`.`e`.`student_id` = `test_db_case_9_1749465373`.`s`.`student_id`)) and (`test_db_case_9_1749465373`.`s`.`gender` = 'Female') and (`test_db_case_9_1749465373`.`s`.`date_of_birth` <= <cache>(cast('2000-01-01' as date))) and (`test_db_case_9_1749465373`.`s`.`student_name` <> '张凯'))\", \"attached_subqueries\": [{\"dependent\": true, \"cacheable\": false, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"e\", \"access_type\": \"ref\", \"possible_keys\": [\"student_id\"], \"key\": \"student_id\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"5\", \"ref\": [\"test_db_case_9_1749465373.s.student_id\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"using_index\": true, \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"24\"}, \"used_columns\": [\"student_id\"]}}}]}}}\n\n## Original SQL:\nSELECT student_id FROM students s WHERE EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id) AND s.gender = 'Female' AND s.date_of_birth <= CAST('2000-01-01' AS DATE) AND s.student_name != '张凯' GROUP BY student_id LIMIT 10;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_id FROM students s WHERE EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id) AND s.gender = 'Female' AND s.date_of_birth <= '2000-01-01' AND s.student_name != '张凯' LIMIT 10;"
                    }
                ]
            },
            {
                "case_id": "10",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"10\", \"db_type\": \"mysql\", \"description\": \"一个包含非关联子查询的SELECT语句，可以将子查询转换为关联子查询。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) );\", \"CREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT );\"], \"sql\": \"SELECT * FROM students WHERE student_id IN ( SELECT student_id FROM enrollments AS inner_dt );\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"4.80\\\"}, \\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"<subquery2>\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"materialized_from_subquery\\\": {\\\"using_temporary_table\\\": true, \\\"query_block\\\": {\\\"table\\\": {\\\"table_name\\\": \\\"inner_dt\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"16\\\"}, \\\"used_columns\\\": [\\\"student_id\\\"]}}}}}, {\\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"student_id\\\"], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [\\\"<subquery2>.student_id\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"4.80\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\"]}}]}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100) );\nCREATE TABLE enrollments ( enrollment_id INT AUTO_INCREMENT PRIMARY KEY, student_id INT NOT NULL, course_id INT );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"4.80\"}, \"nested_loop\": [{\"table\": {\"table_name\": \"<subquery2>\", \"access_type\": \"ALL\", \"materialized_from_subquery\": {\"using_temporary_table\": true, \"query_block\": {\"table\": {\"table_name\": \"inner_dt\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"16\"}, \"used_columns\": [\"student_id\"]}}}}}, {\"table\": {\"table_name\": \"students\", \"access_type\": \"eq_ref\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"student_id\"], \"key_length\": \"4\", \"ref\": [\"<subquery2>.student_id\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"4.80\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"student_name\"]}}]}}\n\n## Original SQL:\nSELECT * FROM students WHERE student_id IN ( SELECT student_id FROM enrollments AS inner_dt );\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT s.* FROM students s WHERE EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id);"
                    }
                ]
            },
            {
                "case_id": "11",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"11\", \"db_type\": \"mysql\", \"description\": \"一个包含多个ROW_NUMBER()窗口函数和过滤条件的SELECT语句\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), date_of_birth DATE );\"], \"sql\": \"SELECT T1.student_name, T1.date_of_birth FROM students AS T1 WHERE (SELECT COUNT(*) FROM students AS T2 WHERE T2.student_name <= T1.student_name) <= 3 AND (SELECT COUNT(*) FROM students AS T3 WHERE T3.date_of_birth <= T1.date_of_birth) <= 2 ORDER BY T1.student_name, T1.date_of_birth;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"2.20\\\"}, \\\"ordering_operation\\\": {\\\"using_filesort\\\": true, \\\"cost_info\\\": {\\\"sort_cost\\\": \\\"1.00\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"T1\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\", \\\"date_of_birth\\\"], \\\"attached_condition\\\": \\\"(((/* select#2 */ select count(0) from `test_db_case_11_1748591779`.`students` `T2` where (`test_db_case_11_1748591779`.`T2`.`student_name` <= `test_db_case_11_1748591779`.`T1`.`student_name`)) <= 3) and ((/* select#3 */ select count(0) from `test_db_case_11_1748591779`.`students` `T3` where (`test_db_case_11_1748591779`.`T3`.`date_of_birth` <= `test_db_case_11_1748591779`.`T1`.`date_of_birth`)) <= 2))\\\", \\\"attached_subqueries\\\": [{\\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": {\\\"select_id\\\": 3, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"T3\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"date_of_birth\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_11_1748591779`.`T3`.`date_of_birth` <= `test_db_case_11_1748591779`.`T1`.`date_of_birth`)\\\"}}}, {\\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"T2\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"student_name\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_11_1748591779`.`T2`.`student_name` <= `test_db_case_11_1748591779`.`T1`.`student_name`)\\\"}}}]}}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), date_of_birth DATE );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"2.20\"}, \"ordering_operation\": {\"using_filesort\": true, \"cost_info\": {\"sort_cost\": \"1.00\"}, \"table\": {\"table_name\": \"T1\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_id\", \"student_name\", \"date_of_birth\"], \"attached_condition\": \"(((/* select#2 */ select count(0) from `test_db_case_11_1748591779`.`students` `T2` where (`test_db_case_11_1748591779`.`T2`.`student_name` <= `test_db_case_11_1748591779`.`T1`.`student_name`)) <= 3) and ((/* select#3 */ select count(0) from `test_db_case_11_1748591779`.`students` `T3` where (`test_db_case_11_1748591779`.`T3`.`date_of_birth` <= `test_db_case_11_1748591779`.`T1`.`date_of_birth`)) <= 2))\", \"attached_subqueries\": [{\"dependent\": true, \"cacheable\": false, \"query_block\": {\"select_id\": 3, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"T3\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"date_of_birth\"], \"attached_condition\": \"(`test_db_case_11_1748591779`.`T3`.`date_of_birth` <= `test_db_case_11_1748591779`.`T1`.`date_of_birth`)\"}}}, {\"dependent\": true, \"cacheable\": false, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"T2\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"student_name\"], \"attached_condition\": \"(`test_db_case_11_1748591779`.`T2`.`student_name` <= `test_db_case_11_1748591779`.`T1`.`student_name`)\"}}}]}}}}\n\n## Original SQL:\nSELECT T1.student_name, T1.date_of_birth FROM students AS T1 WHERE (SELECT COUNT(*) FROM students AS T2 WHERE T2.student_name <= T1.student_name) <= 3 AND (SELECT COUNT(*) FROM students AS T3 WHERE T3.date_of_birth <= T1.date_of_birth) <= 2 ORDER BY T1.student_name, T1.date_of_birth;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT student_name, date_of_birth FROM (SELECT student_name, date_of_birth, COUNT(*) OVER (ORDER BY student_name RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as name_count, COUNT(*) OVER (ORDER BY date_of_birth RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as dob_count FROM students) t WHERE name_count <= 3 AND dob_count <= 2 ORDER BY student_name, date_of_birth;"
                    }
                ]
            },
            {
                "case_id": "12",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"12\", \"db_type\": \"mysql\", \"description\": \"一个包含UNION的SELECT语句，其中WHERE子句包含LIKE前缀匹配，可以改写为范围查询。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), major VARCHAR(100) );\"], \"sql\": \"SELECT * FROM students WHERE student_name LIKE 'John%' UNION SELECT * FROM students WHERE student_name LIKE 'Jane%';\", \"explain\": \"{\\\"query_block\\\": {\\\"union_result\\\": {\\\"using_temporary_table\\\": true, \\\"table_name\\\": \\\"<union1,2>\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"query_specifications\\\": [{\\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"208\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\", \\\"major\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_12_1748591779`.`students`.`student_name` like 'John%')\\\"}}}, {\\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"208\\\"}, \\\"used_columns\\\": [\\\"student_id\\\", \\\"student_name\\\", \\\"major\\\"], \\\"attached_condition\\\": \\\"(`test_db_case_12_1748591779`.`students`.`student_name` like 'Jane%')\\\"}}}]}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( student_id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), major VARCHAR(100) );\n\n## Explain Output in JSON:\n{\"query_block\": {\"union_result\": {\"using_temporary_table\": true, \"table_name\": \"<union1,2>\", \"access_type\": \"ALL\", \"query_specifications\": [{\"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"208\"}, \"used_columns\": [\"student_id\", \"student_name\", \"major\"], \"attached_condition\": \"(`test_db_case_12_1748591779`.`students`.`student_name` like 'John%')\"}}}, {\"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"208\"}, \"used_columns\": [\"student_id\", \"student_name\", \"major\"], \"attached_condition\": \"(`test_db_case_12_1748591779`.`students`.`student_name` like 'Jane%')\"}}}]}}}\n\n## Original SQL:\nSELECT * FROM students WHERE student_name LIKE 'John%' UNION SELECT * FROM students WHERE student_name LIKE 'Jane%';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM students WHERE student_name LIKE 'John%' OR student_name LIKE 'Jane%';"
                    }
                ]
            },
            {
                "case_id": "13",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"13\", \"db_type\": \"mysql\", \"description\": \"一个包含UNION的SELECT语句，外部查询包含LIMIT子句，可以下推到UNION的各个分支中。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(100), reg_date DATE );\", \"CREATE TABLE articles ( id INT PRIMARY KEY, title VARCHAR(255), publish_time DATETIME );\"], \"sql\": \"SELECT * FROM (  (SELECT name FROM users ORDER BY reg_date DESC)  UNION  (SELECT title FROM articles ORDER BY publish_time DESC) ) AS mixed  ORDER BY name LIMIT 5;\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"15.00\\\"}, \\\"ordering_operation\\\": {\\\"using_filesort\\\": true, \\\"cost_info\\\": {\\\"sort_cost\\\": \\\"4.00\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"mixed\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 4, \\\"rows_produced_per_join\\\": 4, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"10.20\\\", \\\"eval_cost\\\": \\\"0.80\\\", \\\"prefix_cost\\\": \\\"11.00\\\", \\\"data_read_per_join\\\": \\\"1K\\\"}, \\\"used_columns\\\": [\\\"name\\\"], \\\"materialized_from_subquery\\\": {\\\"using_temporary_table\\\": true, \\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"union_result\\\": {\\\"using_temporary_table\\\": true, \\\"table_name\\\": \\\"<union2,3>\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"query_specifications\\\": [{\\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 2, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"users\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\"}, \\\"used_columns\\\": [\\\"name\\\", \\\"reg_date\\\"]}}}, {\\\"dependent\\\": false, \\\"cacheable\\\": true, \\\"query_block\\\": {\\\"select_id\\\": 3, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"}, \\\"table\\\": {\\\"table_name\\\": \\\"articles\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"272\\\"}, \\\"used_columns\\\": [\\\"title\\\", \\\"publish_time\\\"]}}}]}}}}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(100), reg_date DATE );\nCREATE TABLE articles ( id INT PRIMARY KEY, title VARCHAR(255), publish_time DATETIME );\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"15.00\"}, \"ordering_operation\": {\"using_filesort\": true, \"cost_info\": {\"sort_cost\": \"4.00\"}, \"table\": {\"table_name\": \"mixed\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 4, \"rows_produced_per_join\": 4, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"10.20\", \"eval_cost\": \"0.80\", \"prefix_cost\": \"11.00\", \"data_read_per_join\": \"1K\"}, \"used_columns\": [\"name\"], \"materialized_from_subquery\": {\"using_temporary_table\": true, \"dependent\": false, \"cacheable\": true, \"query_block\": {\"union_result\": {\"using_temporary_table\": true, \"table_name\": \"<union2,3>\", \"access_type\": \"ALL\", \"query_specifications\": [{\"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 2, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"users\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\"}, \"used_columns\": [\"name\", \"reg_date\"]}}}, {\"dependent\": false, \"cacheable\": true, \"query_block\": {\"select_id\": 3, \"cost_info\": {\"query_cost\": \"1.20\"}, \"table\": {\"table_name\": \"articles\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"272\"}, \"used_columns\": [\"title\", \"publish_time\"]}}}]}}}}}}\n\n## Original SQL:\nSELECT * FROM (  (SELECT name FROM users ORDER BY reg_date DESC)  UNION  (SELECT title FROM articles ORDER BY publish_time DESC) ) AS mixed  ORDER BY name LIMIT 5;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM ((SELECT name FROM users) UNION (SELECT title FROM articles)) AS mixed ORDER BY name LIMIT 5;"
                    }
                ]
            },
            {
                "case_id": "14",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"14\", \"db_type\": \"mysql\", \"description\": \"一个包含IN子查询的SELECT语句，子查询明确只返回一行，因此可以转换为标量子查询。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE students ( id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), score INT );\"], \"sql\": \"SELECT * FROM students WHERE id IN ( SELECT MAX(id) FROM students );\", \"explain\": \"{\\\"query_block\\\": { \\\"select_id\\\": 1, \\\"cost_info\\\": { \\\"query_cost\\\": \\\"1.20\\\" }, \\\"table\\\": { \\\"table_name\\\": \\\"students\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.00\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.20\\\", \\\"data_read_per_join\\\": \\\"112\\\" }, \\\"used_columns\\\": [ \\\"id\\\", \\\"student_name\\\", \\\"score\\\" ], \\\"attached_condition\\\": \\\"<in_optimizer>(`test_db_case_14_1749536504`.`students`.`id`,<exists>(/* select#2 */ select max(`test_db_case_14_1749536504`.`students`.`id`) from `test_db_case_14_1749536504`.`students` having (<cache>(`test_db_case_14_1749536504`.`students`.`id`) = <ref_null_helper>(max(`test_db_case_14_1749536504`.`students`.`id`)))))\\\", \\\"attached_subqueries\\\": [ { \\\"dependent\\\": true, \\\"cacheable\\\": false, \\\"query_block\\\": { \\\"select_id\\\": 2, \\\"message\\\": \\\"No matching min/max row\\\" } } ] } } }\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE students ( id INT AUTO_INCREMENT PRIMARY KEY, student_name VARCHAR(100), score INT );\n\n## Explain Output in JSON:\n{\"query_block\": { \"select_id\": 1, \"cost_info\": { \"query_cost\": \"1.20\" }, \"table\": { \"table_name\": \"students\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.00\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.20\", \"data_read_per_join\": \"112\" }, \"used_columns\": [ \"id\", \"student_name\", \"score\" ], \"attached_condition\": \"<in_optimizer>(`test_db_case_14_1749536504`.`students`.`id`,<exists>(/* select#2 */ select max(`test_db_case_14_1749536504`.`students`.`id`) from `test_db_case_14_1749536504`.`students` having (<cache>(`test_db_case_14_1749536504`.`students`.`id`) = <ref_null_helper>(max(`test_db_case_14_1749536504`.`students`.`id`)))))\", \"attached_subqueries\": [ { \"dependent\": true, \"cacheable\": false, \"query_block\": { \"select_id\": 2, \"message\": \"No matching min/max row\" } } ] } } }\n\n## Original SQL:\nSELECT * FROM students WHERE id IN ( SELECT MAX(id) FROM students );\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM students ORDER BY id DESC LIMIT 1;"
                    }
                ]
            },
            {
                "case_id": "15",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"15\", \"db_type\": \"mysql\", \"description\": \"一个包含嵌套子查询的COUNT语句，其中外部的WHERE子句条件可以下推到内层的子查询中，并且子查询中存在可以投影下推的冗余列。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE enrollments ( student_id INT PRIMARY KEY, course_id INT, enrollment_date DATE );\"], \"sql\": \"SELECT COUNT(*) FROM ( SELECT student_id, enrollment_date FROM enrollments WHERE student_id < 1000 ) AS dt WHERE enrollment_date >= '2023-01-01';\", \"explain\": \"{\\\"query_block\\\": { \\\"select_id\\\": 1, \\\"cost_info\\\": { \\\"query_cost\\\": \\\"1.41\\\" }, \\\"table\\\": { \\\"table_name\\\": \\\"enrollments\\\", \\\"access_type\\\": \\\"range\\\", \\\"possible_keys\\\": [ \\\"PRIMARY\\\" ], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [ \\\"student_id\\\" ], \\\"key_length\\\": \\\"4\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": { \\\"read_cost\\\": \\\"1.21\\\", \\\"eval_cost\\\": \\\"0.20\\\", \\\"prefix_cost\\\": \\\"1.41\\\", \\\"data_read_per_join\\\": \\\"16\\\" }, \\\"used_columns\\\": [ \\\"student_id\\\", \\\"enrollment_date\\\" ], \\\"attached_condition\\\": \\\"((`test_db_case_15_1749719333`.`enrollments`.`enrollment_date` >= '2023-01-01') and (`test_db_case_15_1749719333`.`enrollments`.`student_id` < 1000))\\\" } } }\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE enrollments ( student_id INT PRIMARY KEY, course_id INT, enrollment_date DATE );\n\n## Explain Output in JSON:\n{\"query_block\": { \"select_id\": 1, \"cost_info\": { \"query_cost\": \"1.41\" }, \"table\": { \"table_name\": \"enrollments\", \"access_type\": \"range\", \"possible_keys\": [ \"PRIMARY\" ], \"key\": \"PRIMARY\", \"used_key_parts\": [ \"student_id\" ], \"key_length\": \"4\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": { \"read_cost\": \"1.21\", \"eval_cost\": \"0.20\", \"prefix_cost\": \"1.41\", \"data_read_per_join\": \"16\" }, \"used_columns\": [ \"student_id\", \"enrollment_date\" ], \"attached_condition\": \"((`test_db_case_15_1749719333`.`enrollments`.`enrollment_date` >= '2023-01-01') and (`test_db_case_15_1749719333`.`enrollments`.`student_id` < 1000))\" } } }\n\n## Original SQL:\nSELECT COUNT(*) FROM ( SELECT student_id, enrollment_date FROM enrollments WHERE student_id < 1000 ) AS dt WHERE enrollment_date >= '2023-01-01';\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT COUNT(*) FROM enrollments WHERE student_id < 1000 AND enrollment_date >= '2023-01-01';"
                    }
                ]
            },
            {
                "case_id": "16",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"16\", \"db_type\": \"mysql\", \"description\": \"一个简单的LEFT JOIN查询，明确引用了主表中的列，可能存在可消除的外连接。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;\"], \"sql\": \"SELECT o.o_custkey FROM orders o LEFT JOIN customer ON c_custkey=o_custkey\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"},\\\"table\\\": {\\\"table_name\\\": \\\"o\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"O_CUSTKEY\\\",\\\"O_ORDERKEY\\\",\\\"O_ORDERSTATUS\\\",\\\"O_TOTALPRICE\\\",\\\"O_ORDERDATE\\\",\\\"O_ORDERPRIORITY\\\",\\\"O_CLERK\\\",\\\"O_SHIPPRIORITY\\\",\\\"O_COMMENT\\\"]}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"1.20\"},\"table\": {\"table_name\": \"o\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"O_CUSTKEY\",\"O_ORDERKEY\",\"O_ORDERSTATUS\",\"O_TOTALPRICE\",\"O_ORDERDATE\",\"O_ORDERPRIORITY\",\"O_CLERK\",\"O_SHIPPRIORITY\",\"O_COMMENT\"]}}}\n\n## Original SQL:\nSELECT o.o_custkey FROM orders o LEFT JOIN customer ON c_custkey=o_custkey\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT o.o_custkey FROM orders o"
                    }
                ]
            },
            {
                "case_id": "17",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"17\", \"db_type\": \"mysql\", \"description\": \"一个包含LEFT JOIN的SELECT语句，连接条件为不等值连接，难以进行外连接消除。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\"], \"sql\": \"SELECT c.* FROM customer c LEFT JOIN orders o ON c.c_custkey > o.o_custkey\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"},\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"c\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"C_CUSTKEY\\\",\\\"C_NAME\\\",\\\"C_ADDRESS\\\",\\\"C_NATIONKEY\\\",\\\"C_PHONE\\\",\\\"C_ACCTBAL\\\",\\\"C_MKTSEGMENT\\\",\\\"C_COMMENT\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"o\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"O_CUSTKEY\\\",\\\"O_ORDERKEY\\\",\\\"O_ORDERSTATUS\\\",\\\"O_TOTALPRICE\\\",\\\"O_ORDERDATE\\\",\\\"O_ORDERPRIORITY\\\",\\\"O_CLERK\\\",\\\"O_SHIPPRIORITY\\\",\\\"O_COMMENT\\\"],\\\"attached_condition\\\": \\\"(`c`.`C_CUSTKEY` > `o`.`O_CUSTKEY`)\\\"}}]}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"1.20\"},\"nested_loop\": [{\"table\": {\"table_name\": \"c\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"C_CUSTKEY\",\"C_NAME\",\"C_ADDRESS\",\"C_NATIONKEY\",\"C_PHONE\",\"C_ACCTBAL\",\"C_MKTSEGMENT\",\"C_COMMENT\"]}},{\"table\": {\"table_name\": \"o\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"O_CUSTKEY\",\"O_ORDERKEY\",\"O_ORDERSTATUS\",\"O_TOTALPRICE\",\"O_ORDERDATE\",\"O_ORDERPRIORITY\",\"O_CLERK\",\"O_SHIPPRIORITY\",\"O_COMMENT\"],\"attached_condition\": \"(`c`.`C_CUSTKEY` > `o`.`O_CUSTKEY`)\"}}]}}}\n\n## Original SQL:\nSELECT c.* FROM customer c LEFT JOIN orders o ON c.c_custkey > o.o_custkey\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT c.* FROM customer c LEFT JOIN orders o ON c.C_CUSTKEY = o.O_CUSTKEY"
                    }
                ]
            },
            {
                "case_id": "18",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"18\", \"db_type\": \"mysql\", \"description\": \"一个包含LEFT JOIN的SELECT语句，连接条件为不等值连接，难以进行外连接消除，且使用了表别名。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\"], \"sql\": \"SELECT c.* FROM customer AS c LEFT JOIN orders AS o ON c.c_custkey > o.o_custkey\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"},\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"c\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"C_CUSTKEY\\\",\\\"C_NAME\\\",\\\"C_ADDRESS\\\",\\\"C_NATIONKEY\\\",\\\"C_PHONE\\\",\\\"C_ACCTBAL\\\",\\\"C_MKTSEGMENT\\\",\\\"C_COMMENT\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"o\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"O_CUSTKEY\\\",\\\"O_ORDERKEY\\\",\\\"O_ORDERSTATUS\\\",\\\"O_TOTALPRICE\\\",\\\"O_ORDERDATE\\\",\\\"O_ORDERPRIORITY\\\",\\\"O_CLERK\\\",\\\"O_SHIPPRIORITY\\\",\\\"O_COMMENT\\\"],\\\"attached_condition\\\": \\\"(`c`.`C_CUSTKEY` > `o`.`O_CUSTKEY`)\\\"}}]}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"1.20\"},\"nested_loop\": [{\"table\": {\"table_name\": \"c\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"C_CUSTKEY\",\"C_NAME\",\"C_ADDRESS\",\"C_NATIONKEY\",\"C_PHONE\",\"C_ACCTBAL\",\"C_MKTSEGMENT\",\"C_COMMENT\"]}},{\"table\": {\"table_name\": \"o\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"O_CUSTKEY\",\"O_ORDERKEY\",\"O_ORDERSTATUS\",\"O_TOTALPRICE\",\"O_ORDERDATE\",\"O_ORDERPRIORITY\",\"O_CLERK\",\"O_SHIPPRIORITY\",\"O_COMMENT\"],\"attached_condition\": \"(`c`.`C_CUSTKEY` > `o`.`O_CUSTKEY`)\"}}]}}}\n\n## Original SQL:\nSELECT c.* FROM customer AS c LEFT JOIN orders AS o ON c.c_custkey > o.o_custkey\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT c.* FROM customer AS c LEFT JOIN orders AS o ON c.c_custkey = o.o_custkey"
                    }
                ]
            },
            {
                "case_id": "19",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"19\", \"db_type\": \"mysql\", \"description\": \"一个包含INNER JOIN和DISTINCT的SELECT语句，可能存在不必要的DISTINCT，且包含排序操作。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE PatientRecords (PatientID INT PRIMARY KEY,Name VARCHAR(255),Age INT);CREATE TABLE DoctorSchedules (DoctorID INT PRIMARY KEY,ScheduleDate DATE,PatientID INT);CREATE TABLE MedicalDevices (DeviceID INT PRIMARY KEY,DeviceName VARCHAR(255),PatientID INT);CREATE TABLE TreatmentHistory (TreatmentID INT PRIMARY KEY,PatientID INT,TreatmentDate DATE);\"], \"sql\": \"SELECT DISTINCT PatientRecords.PatientID, PatientRecords.Name, TreatmentHistory.TreatmentDate FROM PatientRecords INNER JOIN TreatmentHistory ON PatientRecords.PatientID = TreatmentHistory.PatientID ORDER BY TreatmentHistory.TreatmentDate DESC\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1,\\\"cost_info\\\": {\\\"query_cost\\\": \\\"1.20\\\"},\\\"duplicates_removal\\\": {\\\"using_temporary_table\\\": true,\\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"PatientRecords\\\",\\\"access_type\\\": \\\"ALL\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"1.20\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"PatientID\\\",\\\"Name\\\",\\\"Age\\\"]}},{\\\"table\\\": {\\\"table_name\\\": \\\"TreatmentHistory\\\",\\\"access_type\\\": \\\"ref\\\",\\\"rows_examined_per_scan\\\": 1,\\\"rows_produced_per_join\\\": 1,\\\"filtered\\\": \\\"100.00\\\",\\\"cost_info\\\": {\\\"read_cost\\\": \\\"1.00\\\",\\\"eval_cost\\\": \\\"0.20\\\",\\\"prefix_cost\\\": \\\"2.40\\\",\\\"data_read_per_join\\\": \\\"112\\\"},\\\"used_columns\\\": [\\\"TreatmentID\\\",\\\"PatientID\\\",\\\"TreatmentDate\\\"],\\\"attached_condition\\\": \\\"(`PatientRecords`.`PatientID` = `TreatmentHistory`.`PatientID`)\\\"}}]}}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE PatientRecords (PatientID INT PRIMARY KEY,Name VARCHAR(255),Age INT);CREATE TABLE DoctorSchedules (DoctorID INT PRIMARY KEY,ScheduleDate DATE,PatientID INT);CREATE TABLE MedicalDevices (DeviceID INT PRIMARY KEY,DeviceName VARCHAR(255),PatientID INT);CREATE TABLE TreatmentHistory (TreatmentID INT PRIMARY KEY,PatientID INT,TreatmentDate DATE);\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1,\"cost_info\": {\"query_cost\": \"1.20\"},\"duplicates_removal\": {\"using_temporary_table\": true,\"nested_loop\": [{\"table\": {\"table_name\": \"PatientRecords\",\"access_type\": \"ALL\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"1.20\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"PatientID\",\"Name\",\"Age\"]}},{\"table\": {\"table_name\": \"TreatmentHistory\",\"access_type\": \"ref\",\"rows_examined_per_scan\": 1,\"rows_produced_per_join\": 1,\"filtered\": \"100.00\",\"cost_info\": {\"read_cost\": \"1.00\",\"eval_cost\": \"0.20\",\"prefix_cost\": \"2.40\",\"data_read_per_join\": \"112\"},\"used_columns\": [\"TreatmentID\",\"PatientID\",\"TreatmentDate\"],\"attached_condition\": \"(`PatientRecords`.`PatientID` = `TreatmentHistory`.`PatientID`)\"}}]}}}\n\n## Original SQL:\nSELECT DISTINCT PatientRecords.PatientID, PatientRecords.Name, TreatmentHistory.TreatmentDate FROM PatientRecords INNER JOIN TreatmentHistory ON PatientRecords.PatientID = TreatmentHistory.PatientID ORDER BY TreatmentHistory.TreatmentDate DESC\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT PatientRecords.PatientID, PatientRecords.Name, TreatmentHistory.TreatmentDate FROM PatientRecords INNER JOIN TreatmentHistory ON PatientRecords.PatientID = TreatmentHistory.PatientID ORDER BY TreatmentHistory.TreatmentDate DESC"
                    }
                ]
            },
            {
                "case_id": "20",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"20\", \"db_type\": \"mysql\", \"description\": \"一个简单的LEFT JOIN查询，可能存在可消除的外连接，且未引用被连接表中的任何列。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\"], \"sql\": \"SELECT o_custkey FROM orders LEFT JOIN customer ON c_custkey=o_custkey\", \"explain\": \"{\\\"query_block\\\": {\\\"select_id\\\": 1, \\\"cost_info\\\": {\\\"query_cost\\\": \\\"0.70\\\"}, \\\"nested_loop\\\": [{\\\"table\\\": {\\\"table_name\\\": \\\"orders\\\", \\\"access_type\\\": \\\"ALL\\\", \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"cost_info\\\": {\\\"read_cost\\\": \\\"0.25\\\", \\\"eval_cost\\\": \\\"0.10\\\", \\\"prefix_cost\\\": \\\"0.35\\\", \\\"data_read_per_join\\\": \\\"472\\\"}, \\\"used_columns\\\": [\\\"O_CUSTKEY\\\"]}}, {\\\"table\\\": {\\\"table_name\\\": \\\"customer\\\", \\\"access_type\\\": \\\"eq_ref\\\", \\\"possible_keys\\\": [\\\"PRIMARY\\\"], \\\"key\\\": \\\"PRIMARY\\\", \\\"used_key_parts\\\": [\\\"C_CUSTKEY\\\"], \\\"key_length\\\": \\\"4\\\", \\\"ref\\\": [\\\"test_db_case_10_1749728367.orders.O_CUSTKEY\\\"], \\\"rows_examined_per_scan\\\": 1, \\\"rows_produced_per_join\\\": 1, \\\"filtered\\\": \\\"100.00\\\", \\\"using_index\\\": true, \\\"cost_info\\\": {\\\"read_cost\\\": \\\"0.25\\\", \\\"eval_cost\\\": \\\"0.10\\\", \\\"prefix_cost\\\": \\\"0.70\\\", \\\"data_read_per_join\\\": \\\"848\\\"}, \\\"used_columns\\\": [\\\"C_CUSTKEY\\\"]}}]}}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE `customer` (`C_CUSTKEY` int NOT NULL,`C_NAME` varchar(25) NOT NULL,`C_ADDRESS` varchar(40) NOT NULL,`C_NATIONKEY` int NOT NULL,`C_PHONE` char(15) NOT NULL,`C_ACCTBAL` decimal(15,2) NOT NULL,`C_MKTSEGMENT` char(10) NOT NULL,`C_COMMENT` varchar(117) NOT NULL,PRIMARY KEY `PK_IDX1614428511` (`C_CUSTKEY`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;CREATE TABLE `orders` (`O_ORDERKEY` int NOT NULL,`O_CUSTKEY` int NOT NULL,`O_ORDERSTATUS` char(1) NOT NULL,`O_TOTALPRICE` decimal(15,2) NOT NULL,`O_ORDERDATE` date NOT NULL,`O_ORDERPRIORITY` char(15) NOT NULL,`O_CLERK` char(15) NOT NULL,`O_SHIPPRIORITY` int NOT NULL,`O_COMMENT` varchar(79) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n## Explain Output in JSON:\n{\"query_block\": {\"select_id\": 1, \"cost_info\": {\"query_cost\": \"0.70\"}, \"nested_loop\": [{\"table\": {\"table_name\": \"orders\", \"access_type\": \"ALL\", \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"cost_info\": {\"read_cost\": \"0.25\", \"eval_cost\": \"0.10\", \"prefix_cost\": \"0.35\", \"data_read_per_join\": \"472\"}, \"used_columns\": [\"O_CUSTKEY\"]}}, {\"table\": {\"table_name\": \"customer\", \"access_type\": \"eq_ref\", \"possible_keys\": [\"PRIMARY\"], \"key\": \"PRIMARY\", \"used_key_parts\": [\"C_CUSTKEY\"], \"key_length\": \"4\", \"ref\": [\"test_db_case_10_1749728367.orders.O_CUSTKEY\"], \"rows_examined_per_scan\": 1, \"rows_produced_per_join\": 1, \"filtered\": \"100.00\", \"using_index\": true, \"cost_info\": {\"read_cost\": \"0.25\", \"eval_cost\": \"0.10\", \"prefix_cost\": \"0.70\", \"data_read_per_join\": \"848\"}, \"used_columns\": [\"C_CUSTKEY\"]}}]}}\n\n## Original SQL:\nSELECT o_custkey FROM orders LEFT JOIN customer ON c_custkey=o_custkey\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT o_custkey FROM orders"
                    }
                ]
            },
            {
                "case_id": "21",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"21\", \"db_type\": \"oracle\", \"description\": \"本次改写的核心技术是将score_model_factor表的JOIN转换为EXISTS子查询。原SQL中,虽然JOIN了score_model_factor表,但SELECT子句中并未使用该表的任何列(仅用于过滤),这正是JOIN转EXISTS优化的典型场景。改写后,通过EXISTS(SELECT 1 FROM score_model_factor f WHERE f.model_factor_id = t.model_factor_id)实现了相同的语义:只有当SCORE_RATING_RECORD_DETAIL.model_factor_id在score_model_factor表中存在时,该行才被保留。EXISTS的优势在于:(1)利用主键索引快速验证;(2)找到第一条匹配记录即返回TRUE,无需扫描所有匹配行;(3)不需要传递score_model_factor的列数据,减少内存和网络开销。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE SEQUENCE score_rating_record_seq; CREATE TABLE SCORE_RATING_RECORD (score_rating_record_id NUMBER PRIMARY KEY, rpt_dt DATE NOT NULL); CREATE OR REPLACE TRIGGER score_rating_record_bi BEFORE INSERT ON SCORE_RATING_RECORD FOR EACH ROW BEGIN IF :NEW.score_rating_record_id IS NULL THEN SELECT score_rating_record_seq.NEXTVAL INTO :NEW.score_rating_record_id FROM DUAL; END IF; END;\", \"CREATE SEQUENCE score_rating_region_record_seq; CREATE TABLE score_rating_region_record (score_rating_region_record_id NUMBER PRIMARY KEY, score_rating_record_id NUMBER NOT NULL, region_cd VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER score_rating_region_record_bi BEFORE INSERT ON score_rating_region_record FOR EACH ROW BEGIN IF :NEW.score_rating_region_record_id IS NULL THEN SELECT score_rating_region_record_seq.NEXTVAL INTO :NEW.score_rating_region_record_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_srr_score_rating_record_id ON score_rating_region_record(score_rating_record_id);\", \"CREATE INDEX idx_srr_region_cd ON score_rating_region_record(region_cd);\", \"CREATE SEQUENCE score_rating_record_detail_seq; CREATE TABLE SCORE_RATING_RECORD_DETAIL (score_rating_record_detail_id NUMBER PRIMARY KEY, score_rating_region_record_id NUMBER NOT NULL, model_factor_id NUMBER NOT NULL, factor_cd VARCHAR2(50) NOT NULL, factor_value NUMBER(18,4), option_init VARCHAR2(100)); CREATE OR REPLACE TRIGGER score_rating_record_detail_bi BEFORE INSERT ON SCORE_RATING_RECORD_DETAIL FOR EACH ROW BEGIN IF :NEW.score_rating_record_detail_id IS NULL THEN SELECT score_rating_record_detail_seq.NEXTVAL INTO :NEW.score_rating_record_detail_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_srrd_region_record_id ON SCORE_RATING_RECORD_DETAIL(score_rating_region_record_id);\", \"CREATE INDEX idx_srrd_model_factor_id ON SCORE_RATING_RECORD_DETAIL(model_factor_id);\", \"CREATE INDEX idx_srrd_factor_cd ON SCORE_RATING_RECORD_DETAIL(factor_cd);\", \"CREATE SEQUENCE score_model_factor_seq; CREATE TABLE score_model_factor (model_factor_id NUMBER PRIMARY KEY, factor_name VARCHAR2(100), factor_desc VARCHAR2(500)); CREATE OR REPLACE TRIGGER score_model_factor_bi BEFORE INSERT ON score_model_factor FOR EACH ROW BEGIN IF :NEW.model_factor_id IS NULL THEN SELECT score_model_factor_seq.NEXTVAL INTO :NEW.model_factor_id FROM DUAL; END IF; END;\"], \"sql\": \"select a.rpt_dt,s.region_cd , t.factor_cd,t.factor_value,t.option_init from SCORE_RATING_RECORD a\\njoin score_rating_region_record s on a.score_rating_record_id =s.score_rating_record_id\\njoin SCORE_RATING_RECORD_DETAIL t on s.score_rating_region_record_id =t.score_rating_region_record_id\\njoin score_model_factor f on f.model_factor_id =t.model_factor_id\\nwhere a.score_rating_record_id =1951215209649586177\\norder by s.region_cd , t.factor_cd;\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t109\\t50\\t2650\\t37698709\\t108\\n1\\t  SORT ORDER BY \\t109\\t50\\t2650\\t37698709\\t108\\n2\\t  HASH JOIN  \\t108\\t50\\t2650\\t817426\\t108\\n3\\t   NESTED LOOPS  \\t108\\t50\\t2650\\t817426\\t108\\n4\\t  NESTED LOOPS  \\t108\\t100\\t2650\\t817426\\t108\\n5\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n6\\t   NESTED LOOPS  \\t6\\t1\\t34\\t45189\\t6\\n7\\t  TABLE ACCESS BY INDEX ROWID SCORE_RATING_RECORD\\t3\\t1\\t18\\t22584\\t3\\n8\\t  INDEX UNIQUE SCAN SYS_C008302\\t2\\t1\\t\\t15293\\t2\\n9\\t  TABLE ACCESS BY INDEX ROWID BATCHED SCORE_RATING_REGION_RECORD\\t3\\t1\\t16\\t22604\\t3\\n10\\t  INDEX RANGE SCAN IDX_SRR_SCORE_RATING_RECORD_ID\\t2\\t1\\t\\t15293\\t2\\n11\\t  INDEX RANGE SCAN IDX_SRRD_REGION_RECORD_ID\\t2\\t100\\t\\t35093\\t2\\n12\\t  TABLE ACCESS BY INDEX ROWID SCORE_RATING_RECORD_DETAIL\\t102\\t100\\t1900\\t772237\\t102\\n13\\t   TABLE ACCESS FULL SCORE_RATING_RECORD_DETAIL\\t102\\t100\\t1900\\t772237\\t102\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE score_rating_record_seq; CREATE TABLE SCORE_RATING_RECORD (score_rating_record_id NUMBER PRIMARY KEY, rpt_dt DATE NOT NULL); CREATE OR REPLACE TRIGGER score_rating_record_bi BEFORE INSERT ON SCORE_RATING_RECORD FOR EACH ROW BEGIN IF :NEW.score_rating_record_id IS NULL THEN SELECT score_rating_record_seq.NEXTVAL INTO :NEW.score_rating_record_id FROM DUAL; END IF; END;\nCREATE SEQUENCE score_rating_region_record_seq; CREATE TABLE score_rating_region_record (score_rating_region_record_id NUMBER PRIMARY KEY, score_rating_record_id NUMBER NOT NULL, region_cd VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER score_rating_region_record_bi BEFORE INSERT ON score_rating_region_record FOR EACH ROW BEGIN IF :NEW.score_rating_region_record_id IS NULL THEN SELECT score_rating_region_record_seq.NEXTVAL INTO :NEW.score_rating_region_record_id FROM DUAL; END IF; END;\nCREATE INDEX idx_srr_score_rating_record_id ON score_rating_region_record(score_rating_record_id);\nCREATE INDEX idx_srr_region_cd ON score_rating_region_record(region_cd);\nCREATE SEQUENCE score_rating_record_detail_seq; CREATE TABLE SCORE_RATING_RECORD_DETAIL (score_rating_record_detail_id NUMBER PRIMARY KEY, score_rating_region_record_id NUMBER NOT NULL, model_factor_id NUMBER NOT NULL, factor_cd VARCHAR2(50) NOT NULL, factor_value NUMBER(18,4), option_init VARCHAR2(100)); CREATE OR REPLACE TRIGGER score_rating_record_detail_bi BEFORE INSERT ON SCORE_RATING_RECORD_DETAIL FOR EACH ROW BEGIN IF :NEW.score_rating_record_detail_id IS NULL THEN SELECT score_rating_record_detail_seq.NEXTVAL INTO :NEW.score_rating_record_detail_id FROM DUAL; END IF; END;\nCREATE INDEX idx_srrd_region_record_id ON SCORE_RATING_RECORD_DETAIL(score_rating_region_record_id);\nCREATE INDEX idx_srrd_model_factor_id ON SCORE_RATING_RECORD_DETAIL(model_factor_id);\nCREATE INDEX idx_srrd_factor_cd ON SCORE_RATING_RECORD_DETAIL(factor_cd);\nCREATE SEQUENCE score_model_factor_seq; CREATE TABLE score_model_factor (model_factor_id NUMBER PRIMARY KEY, factor_name VARCHAR2(100), factor_desc VARCHAR2(500)); CREATE OR REPLACE TRIGGER score_model_factor_bi BEFORE INSERT ON score_model_factor FOR EACH ROW BEGIN IF :NEW.model_factor_id IS NULL THEN SELECT score_model_factor_seq.NEXTVAL INTO :NEW.model_factor_id FROM DUAL; END IF; END;\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t109\t50\t2650\t37698709\t108\n1\t  SORT ORDER BY \t109\t50\t2650\t37698709\t108\n2\t  HASH JOIN  \t108\t50\t2650\t817426\t108\n3\t   NESTED LOOPS  \t108\t50\t2650\t817426\t108\n4\t  NESTED LOOPS  \t108\t100\t2650\t817426\t108\n5\t  STATISTICS COLLECTOR  \t\t\t\t\t\n6\t   NESTED LOOPS  \t6\t1\t34\t45189\t6\n7\t  TABLE ACCESS BY INDEX ROWID SCORE_RATING_RECORD\t3\t1\t18\t22584\t3\n8\t  INDEX UNIQUE SCAN SYS_C008302\t2\t1\t\t15293\t2\n9\t  TABLE ACCESS BY INDEX ROWID BATCHED SCORE_RATING_REGION_RECORD\t3\t1\t16\t22604\t3\n10\t  INDEX RANGE SCAN IDX_SRR_SCORE_RATING_RECORD_ID\t2\t1\t\t15293\t2\n11\t  INDEX RANGE SCAN IDX_SRRD_REGION_RECORD_ID\t2\t100\t\t35093\t2\n12\t  TABLE ACCESS BY INDEX ROWID SCORE_RATING_RECORD_DETAIL\t102\t100\t1900\t772237\t102\n13\t   TABLE ACCESS FULL SCORE_RATING_RECORD_DETAIL\t102\t100\t1900\t772237\t102\n\n## Original SQL:\nselect a.rpt_dt,s.region_cd , t.factor_cd,t.factor_value,t.option_init from SCORE_RATING_RECORD a\njoin score_rating_region_record s on a.score_rating_record_id =s.score_rating_record_id\njoin SCORE_RATING_RECORD_DETAIL t on s.score_rating_region_record_id =t.score_rating_region_record_id\njoin score_model_factor f on f.model_factor_id =t.model_factor_id\nwhere a.score_rating_record_id =1951215209649586177\norder by s.region_cd , t.factor_cd;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select a.rpt_dt,s.region_cd,t.factor_cd,t.factor_value,t.option_init from SCORE_RATING_RECORD a join score_rating_region_record s on a.score_rating_record_id=s.score_rating_record_id join SCORE_RATING_RECORD_DETAIL t on s.score_rating_region_record_id=t.score_rating_region_record_id where a.score_rating_record_id=1951215209649586177 order by s.region_cd,t.factor_cd"
                    }
                ]
            },
            {
                "case_id": "22",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"22\", \"db_type\": \"oracle\", \"description\": \"此次改写主要采用了谓词下推技术，试图通过提前过滤减少数据量。同时移除了内层不必要的ORDER BY操作（因为最外层使用ROWNUM限制结果集），理论上可以节省排序成本。还优化了日期比较条件，使其更加精确。然而，由于过滤条件位置调整不当，导致了SQL语义发生变化。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE SEQUENCE SYS_READ_HIS_LOG_SEQ; CREATE TABLE SYS_READ_HIS_LOG (PKID NUMBER PRIMARY KEY, FD_MODEL_ID NUMBER, FD_MODEL_NAME VARCHAR2(200), FD_READ_TIME TIMESTAMP); CREATE OR REPLACE TRIGGER SYS_READ_HIS_LOG_BI BEFORE INSERT ON SYS_READ_HIS_LOG FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT SYS_READ_HIS_LOG_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_sys_read_model_name ON SYS_READ_HIS_LOG(FD_MODEL_NAME);\", \"CREATE INDEX idx_sys_read_model_id ON SYS_READ_HIS_LOG(FD_MODEL_ID);\", \"CREATE INDEX idx_sys_read_time ON SYS_READ_HIS_LOG(FD_READ_TIME);\", \"CREATE SEQUENCE MANUAL_FILE_SEQ; CREATE TABLE MANUAL_FILE (FD_ID NUMBER PRIMARY KEY, FD_FILE_ID NUMBER); CREATE OR REPLACE TRIGGER MANUAL_FILE_BI BEFORE INSERT ON MANUAL_FILE FOR EACH ROW BEGIN IF :NEW.FD_ID IS NULL THEN SELECT MANUAL_FILE_SEQ.NEXTVAL INTO :NEW.FD_ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_manual_file_id ON MANUAL_FILE(FD_FILE_ID);\", \"CREATE SEQUENCE MANUAL_FILE_BASIC_INFO_SEQ; CREATE TABLE MANUAL_FILE_BASIC_INFO (PKID NUMBER PRIMARY KEY, FD_FILE_NAME VARCHAR2(200), FD_NO VARCHAR2(100), MANUAL_ID NUMBER, IS_DELETED VARCHAR2(1) DEFAULT '0'); CREATE OR REPLACE TRIGGER MANUAL_FILE_BASIC_INFO_BI BEFORE INSERT ON MANUAL_FILE_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT MANUAL_FILE_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mfbi_manual_id ON MANUAL_FILE_BASIC_INFO(MANUAL_ID);\", \"CREATE INDEX idx_mfbi_is_deleted ON MANUAL_FILE_BASIC_INFO(IS_DELETED);\", \"CREATE SEQUENCE XMAIR_MANUAL_BASIC_INFO_SEQ; CREATE TABLE XMAIR_MANUAL_BASIC_INFO (PKID NUMBER PRIMARY KEY, TYPE_ID NUMBER); CREATE OR REPLACE TRIGGER XMAIR_MANUAL_BASIC_INFO_BI BEFORE INSERT ON XMAIR_MANUAL_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT XMAIR_MANUAL_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_xmbi_type_id ON XMAIR_MANUAL_BASIC_INFO(TYPE_ID);\"], \"sql\": \"SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (\\n  SELECT  max(FD_MODEL_ID) FD_MODEL_ID,sum(countNumber) sumNumber ,max(FD_FILE_ID) FD_FILE_ID FROM (\\n  SELECT FD_MODEL_ID,count(1) countNumber from\\n  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL\\n  <if test=\\\"startDate != null and startDate != ''\\\">\\n   and FD_READ_TIME >= to_date(#{startDate},'yyyy-mm-dd')\\n  </if>\\n  <if test=\\\"endDate != null and endDate != ''\\\">\\n   and FD_READ_TIME &lt;= to_date(#{endDate},'yyyy-mm-dd')\\n  </if>\\n  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID\\n  GROUP BY FD_FILE_ID order by  sumNumber desc ) w\\n  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi\\n  ON mfbi.PKID = w.FD_FILE_ID\\n  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID\\n  <where>\\n   mfbi.IS_DELETED = '0'\\n   <if test=\\\" typeIdsByMfId != null  and typeIdsByMfId.size>0\\\">\\n  and  xmbi.TYPE_ID in\\n  <foreach collection=\\\"typeIdsByMfId\\\" item=\\\"typeId\\\" open=\\\"(\\\" separator=\\\",\\\" close=\\\")\\\">\\n  #{typeId}\\n  </foreach>\\n   </if>\\n   and rownum <![CDATA[ <= ]]> 10\\n  </where>\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t101\\t10\\t670\\t32701838\\t100\\n1\\t  COUNT STOPKEY \\t\\t\\t\\t\\t\\n2\\t  NESTED LOOPS  \\t101\\t10\\t670\\t32701838\\t100\\n3\\t   NESTED LOOPS  \\t101\\t20\\t670\\t32701838\\t100\\n4\\t  VIEW  \\t61\\t1000\\t26000\\t32373380\\t60\\n5\\t  SORT ORDER BY \\t3030\\t1000\\t29000\\t1618668956\\t2986\\n6\\t   HASH GROUP BY \\t3030\\t1000\\t29000\\t1618668956\\t2986\\n7\\t  VIEW  \\t3028\\t1000\\t29000\\t1544033810\\t2986\\n8\\t  HASH JOIN OUTER \\t3028\\t1000\\t33000\\t1544033810\\t2986\\n9\\t   NESTED LOOPS OUTER \\t3028\\t1000\\t33000\\t1544033810\\t2986\\n10\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n11\\t  VIEW  VW_GBF_8\\t2497\\t1000\\t26000\\t1259582159\\t2463\\n12\\t   HASH GROUP BY \\t2497\\t1000\\t46000\\t1259582159\\t2463\\n13\\t  TABLE ACCESS FULL SYS_READ_HIS_LOG\\t2472\\t1000000\\t46000000\\t324705404\\t2463\\n14\\t  TABLE ACCESS BY INDEX ROWID MANUAL_FILE\\t528\\t1\\t7\\t183701651\\t523\\n15\\t  INDEX UNIQUE SCAN SYS_C008302\\t\\t\\t\\t\\t\\n16\\t   TABLE ACCESS FULL MANUAL_FILE\\t528\\t1000000\\t7000000\\t183701651\\t523\\n17\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n18\\t   TABLE ACCESS BY INDEX ROWID MANUAL_FILE_BASIC_INFO\\t2\\t1\\t41\\t16423\\t2\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE SYS_READ_HIS_LOG_SEQ; CREATE TABLE SYS_READ_HIS_LOG (PKID NUMBER PRIMARY KEY, FD_MODEL_ID NUMBER, FD_MODEL_NAME VARCHAR2(200), FD_READ_TIME TIMESTAMP); CREATE OR REPLACE TRIGGER SYS_READ_HIS_LOG_BI BEFORE INSERT ON SYS_READ_HIS_LOG FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT SYS_READ_HIS_LOG_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_sys_read_model_name ON SYS_READ_HIS_LOG(FD_MODEL_NAME);\nCREATE INDEX idx_sys_read_model_id ON SYS_READ_HIS_LOG(FD_MODEL_ID);\nCREATE INDEX idx_sys_read_time ON SYS_READ_HIS_LOG(FD_READ_TIME);\nCREATE SEQUENCE MANUAL_FILE_SEQ; CREATE TABLE MANUAL_FILE (FD_ID NUMBER PRIMARY KEY, FD_FILE_ID NUMBER); CREATE OR REPLACE TRIGGER MANUAL_FILE_BI BEFORE INSERT ON MANUAL_FILE FOR EACH ROW BEGIN IF :NEW.FD_ID IS NULL THEN SELECT MANUAL_FILE_SEQ.NEXTVAL INTO :NEW.FD_ID FROM DUAL; END IF; END;\nCREATE INDEX idx_manual_file_id ON MANUAL_FILE(FD_FILE_ID);\nCREATE SEQUENCE MANUAL_FILE_BASIC_INFO_SEQ; CREATE TABLE MANUAL_FILE_BASIC_INFO (PKID NUMBER PRIMARY KEY, FD_FILE_NAME VARCHAR2(200), FD_NO VARCHAR2(100), MANUAL_ID NUMBER, IS_DELETED VARCHAR2(1) DEFAULT '0'); CREATE OR REPLACE TRIGGER MANUAL_FILE_BASIC_INFO_BI BEFORE INSERT ON MANUAL_FILE_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT MANUAL_FILE_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_mfbi_manual_id ON MANUAL_FILE_BASIC_INFO(MANUAL_ID);\nCREATE INDEX idx_mfbi_is_deleted ON MANUAL_FILE_BASIC_INFO(IS_DELETED);\nCREATE SEQUENCE XMAIR_MANUAL_BASIC_INFO_SEQ; CREATE TABLE XMAIR_MANUAL_BASIC_INFO (PKID NUMBER PRIMARY KEY, TYPE_ID NUMBER); CREATE OR REPLACE TRIGGER XMAIR_MANUAL_BASIC_INFO_BI BEFORE INSERT ON XMAIR_MANUAL_BASIC_INFO FOR EACH ROW BEGIN IF :NEW.PKID IS NULL THEN SELECT XMAIR_MANUAL_BASIC_INFO_SEQ.NEXTVAL INTO :NEW.PKID FROM DUAL; END IF; END;\nCREATE INDEX idx_xmbi_type_id ON XMAIR_MANUAL_BASIC_INFO(TYPE_ID);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t101\t10\t670\t32701838\t100\n1\t  COUNT STOPKEY \t\t\t\t\t\n2\t  NESTED LOOPS  \t101\t10\t670\t32701838\t100\n3\t   NESTED LOOPS  \t101\t20\t670\t32701838\t100\n4\t  VIEW  \t61\t1000\t26000\t32373380\t60\n5\t  SORT ORDER BY \t3030\t1000\t29000\t1618668956\t2986\n6\t   HASH GROUP BY \t3030\t1000\t29000\t1618668956\t2986\n7\t  VIEW  \t3028\t1000\t29000\t1544033810\t2986\n8\t  HASH JOIN OUTER \t3028\t1000\t33000\t1544033810\t2986\n9\t   NESTED LOOPS OUTER \t3028\t1000\t33000\t1544033810\t2986\n10\t  STATISTICS COLLECTOR  \t\t\t\t\t\n11\t  VIEW  VW_GBF_8\t2497\t1000\t26000\t1259582159\t2463\n12\t   HASH GROUP BY \t2497\t1000\t46000\t1259582159\t2463\n13\t  TABLE ACCESS FULL SYS_READ_HIS_LOG\t2472\t1000000\t46000000\t324705404\t2463\n14\t  TABLE ACCESS BY INDEX ROWID MANUAL_FILE\t528\t1\t7\t183701651\t523\n15\t  INDEX UNIQUE SCAN SYS_C008302\t\t\t\t\t\n16\t   TABLE ACCESS FULL MANUAL_FILE\t528\t1000000\t7000000\t183701651\t523\n17\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n18\t   TABLE ACCESS BY INDEX ROWID MANUAL_FILE_BASIC_INFO\t2\t1\t41\t16423\t2\n\n## Original SQL:\nSELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (\n  SELECT  max(FD_MODEL_ID) FD_MODEL_ID,sum(countNumber) sumNumber ,max(FD_FILE_ID) FD_FILE_ID FROM (\n  SELECT FD_MODEL_ID,count(1) countNumber from\n  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL\n  <if test=\"startDate != null and startDate != ''\">\n   and FD_READ_TIME >= to_date(#{startDate},'yyyy-mm-dd')\n  </if>\n  <if test=\"endDate != null and endDate != ''\">\n   and FD_READ_TIME &lt;= to_date(#{endDate},'yyyy-mm-dd')\n  </if>\n  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID\n  GROUP BY FD_FILE_ID order by  sumNumber desc ) w\n  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi\n  ON mfbi.PKID = w.FD_FILE_ID\n  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID\n  <where>\n   mfbi.IS_DELETED = '0'\n   <if test=\" typeIdsByMfId != null  and typeIdsByMfId.size>0\">\n  and  xmbi.TYPE_ID in\n  <foreach collection=\"typeIdsByMfId\" item=\"typeId\" open=\"(\" separator=\",\" close=\")\">\n  #{typeId}\n  </foreach>\n   </if>\n   and rownum <![CDATA[ <= ]]> 10\n  </where>\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO,w.sumNumber countNumber FROM (SELECT FD_FILE_ID,sumNumber FROM (SELECT mf.FD_FILE_ID,SUM(cnt) sumNumber FROM (SELECT FD_MODEL_ID,COUNT(*) cnt FROM SYS_READ_HIS_LOG WHERE FD_MODEL_NAME='com.xmair.core.entity.DO.XmairManualFileNew' AND FD_MODEL_ID IS NOT NULL GROUP BY FD_MODEL_ID) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID=t.FD_MODEL_ID GROUP BY mf.FD_FILE_ID ORDER BY sumNumber DESC) WHERE ROWNUM<=10) w LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi ON mfbi.PKID=w.FD_FILE_ID LEFT JOIN XMAIR_MANUAL_BASIC_INFO xmbi ON xmbi.PKID=mfbi.MANUAL_ID WHERE mfbi.IS_DELETED='0'"
                    }
                ]
            },
            {
                "case_id": "23",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"23\", \"db_type\": \"oracle\", \"description\": \"此次改写将子查询内部的'LEFT JOIN mrtrecordinfo B ON A.ID = B.ID'改为'INNER JOIN'。改写的理论基础是：由于外层查询使用了WHERE A.ID IN (SELECT bid FROM ...)条件，而bid来源于B.ID，这意味着只有B.ID存在的记录才会被选中。因此LEFT JOIN产生的NULL行在后续过滤中会被完全排除，使用INNER JOIN语义上等价且理论上可减少NULL处理开销。然而实际测试显示，Oracle优化器在处理原始LEFT JOIN时已经识别出这种模式并进行了等价优化，导致手动改写未产生实质性能提升。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE SEQUENCE mrtopration_seq; CREATE TABLE mrtopration (ID NUMBER PRIMARY KEY, PRAMARYID NUMBER, OPERCODE VARCHAR2(50), OPERNAME VARCHAR2(100), OPERDEPT VARCHAR2(100), OPERDATE DATE NOT NULL, MARK VARCHAR2(500), MARK2 VARCHAR2(500), MARK3 VARCHAR2(500), MARK4 VARCHAR2(500), OPERTYPE VARCHAR2(50), NEXTOPERTYPE VARCHAR2(50), PREOPERTYPE VARCHAR2(50), VALID NUMBER(1), CONFIRMUSER VARCHAR2(100), CONFIRMDEPT VARCHAR2(100), VERSIONNUMBER NUMBER); CREATE OR REPLACE TRIGGER mrtopration_bi BEFORE INSERT ON mrtopration FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtopration_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mrtopration_operdate ON mrtopration(OPERDATE);\", \"CREATE INDEX idx_mrtopration_opercode ON mrtopration(OPERCODE);\", \"CREATE SEQUENCE mrtrecordinfo_seq; CREATE TABLE mrtrecordinfo (ID NUMBER PRIMARY KEY, IN_TIMES NUMBER, NAME VARCHAR2(100), IN_DATE DATE, OUT_DATE DATE, OUT_DEPT VARCHAR2(100), RECORD_STATE VARCHAR2(50)); CREATE OR REPLACE TRIGGER mrtrecordinfo_bi BEFORE INSERT ON mrtrecordinfo FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtrecordinfo_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\", \"CREATE INDEX idx_mrtrecordinfo_indate ON mrtrecordinfo(IN_DATE);\", \"CREATE TABLE mrtrecordregresses (RECODE_NO NUMBER NOT NULL, OPER_DATE DATE NOT NULL, OPERID VARCHAR2(50) NOT NULL, BACKREASON VARCHAR2(500), CONSTRAINT pk_mrtrecordregresses PRIMARY KEY (RECODE_NO, OPER_DATE, OPERID));\"], \"sql\": \"SELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID WHERE A.ID IN (SELECT bid FROM (SELECT B.ID AS bid, B.IN_DATE AS inDate, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID WHERE B.ID LIKE :\\\"SYS_B_0\\\" || :1 || :\\\" SYS_B_1\\\" GROUP BY B.ID, B.IN_DATE) WHERE rn BETWEEN :2 + :\\\"SYS_B_2\\\" AND :3 + :4 ) ORDER BY A.OPERDATE DESC\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t3725\\t10\\t1950\\t907708019\\t3700\\n1\\t  SORT ORDER BY \\t3725\\t10\\t1950\\t907708019\\t3700\\n2\\t  HASH JOIN OUTER \\t3724\\t10\\t1950\\t870837954\\t3700\\n3\\t   NESTED LOOPS OUTER \\t3724\\t10\\t1950\\t870837954\\t3700\\n4\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n5\\t  HASH JOIN OUTER \\t3714\\t10\\t1560\\t870747739\\t3690\\n6\\t   NESTED LOOPS OUTER \\t3714\\t10\\t1560\\t870747739\\t3690\\n7\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n8\\t  HASH JOIN  \\t3694\\t10\\t1110\\t870583611\\t3670\\n9\\t   NESTED LOOPS  \\t3694\\t10\\t1110\\t870583611\\t3670\\n10\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n11\\t  VIEW  VW_NSO_1\\t3673\\t10\\t40\\t833547416\\t3650\\n12\\t   HASH UNIQUE \\t\\t10\\t150\\t\\t\\n13\\t  VIEW  \\t3673\\t10\\t150\\t833547416\\t3650\\n14\\t  WINDOW NOSORT STOPKEY \\t3673\\t50000\\t750000\\t833547416\\t3650\\n15\\t   SORT GROUP BY \\t3673\\t50000\\t750000\\t833547416\\t3650\\n16\\t  HASH JOIN SEMI \\t3413\\t50000\\t750000\\t757426652\\t3392\\n17\\t  TABLE ACCESS FULL MRTRECORDINFO\\t2081\\t50000\\t550000\\t407379316\\t2070\\n18\\t  INDEX FAST FULL SCAN SYS_C008302\\t514\\t1000000\\t4000000\\t133352700\\t510\\n19\\t  TABLE ACCESS BY INDEX ROWID MRTOPRATION\\t2\\t1\\t107\\t16613\\t2\\n20\\t  INDEX UNIQUE SCAN SYS_C008302\\t1\\t1\\t\\t9021\\t1\\n21\\t   TABLE ACCESS FULL MRTOPRATION\\t2\\t1\\t107\\t16613\\t2\\n22\\t  TABLE ACCESS BY INDEX ROWID MRTRECORDINFO\\t2\\t1\\t45\\t16413\\t2\\n23\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n24\\t   TABLE ACCESS FULL MRTRECORDINFO\\t2\\t1\\t45\\t16413\\t2\\n25\\t  TABLE ACCESS BY INDEX ROWID MRTRECORDREGRESSES\\t1\\t1\\t39\\t9021\\t1\\n26\\t  INDEX UNIQUE SCAN PK_MRTRECORDREGRESSES\\t1\\t1\\t\\t9021\\t1\\n27\\t   TABLE ACCESS FULL MRTRECORDREGRESSES\\t1\\t1\\t39\\t9021\\t1\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE mrtopration_seq; CREATE TABLE mrtopration (ID NUMBER PRIMARY KEY, PRAMARYID NUMBER, OPERCODE VARCHAR2(50), OPERNAME VARCHAR2(100), OPERDEPT VARCHAR2(100), OPERDATE DATE NOT NULL, MARK VARCHAR2(500), MARK2 VARCHAR2(500), MARK3 VARCHAR2(500), MARK4 VARCHAR2(500), OPERTYPE VARCHAR2(50), NEXTOPERTYPE VARCHAR2(50), PREOPERTYPE VARCHAR2(50), VALID NUMBER(1), CONFIRMUSER VARCHAR2(100), CONFIRMDEPT VARCHAR2(100), VERSIONNUMBER NUMBER); CREATE OR REPLACE TRIGGER mrtopration_bi BEFORE INSERT ON mrtopration FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtopration_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\nCREATE INDEX idx_mrtopration_operdate ON mrtopration(OPERDATE);\nCREATE INDEX idx_mrtopration_opercode ON mrtopration(OPERCODE);\nCREATE SEQUENCE mrtrecordinfo_seq; CREATE TABLE mrtrecordinfo (ID NUMBER PRIMARY KEY, IN_TIMES NUMBER, NAME VARCHAR2(100), IN_DATE DATE, OUT_DATE DATE, OUT_DEPT VARCHAR2(100), RECORD_STATE VARCHAR2(50)); CREATE OR REPLACE TRIGGER mrtrecordinfo_bi BEFORE INSERT ON mrtrecordinfo FOR EACH ROW BEGIN IF :NEW.ID IS NULL THEN SELECT mrtrecordinfo_seq.NEXTVAL INTO :NEW.ID FROM DUAL; END IF; END;\nCREATE INDEX idx_mrtrecordinfo_indate ON mrtrecordinfo(IN_DATE);\nCREATE TABLE mrtrecordregresses (RECODE_NO NUMBER NOT NULL, OPER_DATE DATE NOT NULL, OPERID VARCHAR2(50) NOT NULL, BACKREASON VARCHAR2(500), CONSTRAINT pk_mrtrecordregresses PRIMARY KEY (RECODE_NO, OPER_DATE, OPERID));\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t3725\t10\t1950\t907708019\t3700\n1\t  SORT ORDER BY \t3725\t10\t1950\t907708019\t3700\n2\t  HASH JOIN OUTER \t3724\t10\t1950\t870837954\t3700\n3\t   NESTED LOOPS OUTER \t3724\t10\t1950\t870837954\t3700\n4\t  STATISTICS COLLECTOR  \t\t\t\t\t\n5\t  HASH JOIN OUTER \t3714\t10\t1560\t870747739\t3690\n6\t   NESTED LOOPS OUTER \t3714\t10\t1560\t870747739\t3690\n7\t  STATISTICS COLLECTOR  \t\t\t\t\t\n8\t  HASH JOIN  \t3694\t10\t1110\t870583611\t3670\n9\t   NESTED LOOPS  \t3694\t10\t1110\t870583611\t3670\n10\t  STATISTICS COLLECTOR  \t\t\t\t\t\n11\t  VIEW  VW_NSO_1\t3673\t10\t40\t833547416\t3650\n12\t   HASH UNIQUE \t\t10\t150\t\t\n13\t  VIEW  \t3673\t10\t150\t833547416\t3650\n14\t  WINDOW NOSORT STOPKEY \t3673\t50000\t750000\t833547416\t3650\n15\t   SORT GROUP BY \t3673\t50000\t750000\t833547416\t3650\n16\t  HASH JOIN SEMI \t3413\t50000\t750000\t757426652\t3392\n17\t  TABLE ACCESS FULL MRTRECORDINFO\t2081\t50000\t550000\t407379316\t2070\n18\t  INDEX FAST FULL SCAN SYS_C008302\t514\t1000000\t4000000\t133352700\t510\n19\t  TABLE ACCESS BY INDEX ROWID MRTOPRATION\t2\t1\t107\t16613\t2\n20\t  INDEX UNIQUE SCAN SYS_C008302\t1\t1\t\t9021\t1\n21\t   TABLE ACCESS FULL MRTOPRATION\t2\t1\t107\t16613\t2\n22\t  TABLE ACCESS BY INDEX ROWID MRTRECORDINFO\t2\t1\t45\t16413\t2\n23\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n24\t   TABLE ACCESS FULL MRTRECORDINFO\t2\t1\t45\t16413\t2\n25\t  TABLE ACCESS BY INDEX ROWID MRTRECORDREGRESSES\t1\t1\t39\t9021\t1\n26\t  INDEX UNIQUE SCAN PK_MRTRECORDREGRESSES\t1\t1\t\t9021\t1\n27\t   TABLE ACCESS FULL MRTRECORDREGRESSES\t1\t1\t39\t9021\t1\n\n## Original SQL:\nSELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID WHERE A.ID IN (SELECT bid FROM (SELECT B.ID AS bid, B.IN_DATE AS inDate, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID WHERE B.ID LIKE :\"SYS_B_0\" || :1 || :\" SYS_B_1\" GROUP BY B.ID, B.IN_DATE) WHERE rn BETWEEN :2 + :\"SYS_B_2\" AND :3 + :4 ) ORDER BY A.OPERDATE DESC\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState FROM mrtopration A LEFT JOIN mrtrecordinfo B ON A.ID = B.ID LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID WHERE A.ID IN (SELECT B.ID FROM (SELECT B.ID, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn FROM mrtrecordinfo B WHERE B.ID LIKE :\"SYS_B_0\" || :1 || :\" SYS_B_1\") WHERE rn BETWEEN :2 + :\"SYS_B_2\" AND :3 + :4) ORDER BY A.OPERDATE DESC"
                    }
                ]
            },
            {
                "case_id": "24",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"24\", \"db_type\": \"oracle\", \"description\": \"这是一种经典的UNION ALL消除优化技术。当UNION ALL的多个分支查询相同的表，且仅在SELECT列表的计算逻辑或WHERE条件的常量值上有差异时，可以通过CASE表达式将不同的计算逻辑统一到一个SELECT语句中。改写的核心是将'metric_name IN (集合1) 返回round(VALUE,2)'和'metric_name IN (集合2) 返回round(VALUE*10,2)'两个分支，合并为'metric_name IN (集合1+集合2) 返回CASE WHEN...END'。这样WHERE条件从两次分别过滤变为一次过滤更大的集合，SELECT列表使用CASE根据metric_name动态选择计算方式。这种改写在保证逻辑等价的前提下，显著减少了I/O操作。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE SEQUENCE gv_session_seq; CREATE TABLE gv$session (session_id NUMBER PRIMARY KEY, inst_id NUMBER NOT NULL, TYPE VARCHAR2(20) NOT NULL, status VARCHAR2(20)); CREATE OR REPLACE TRIGGER gv_session_bi BEFORE INSERT ON gv$session FOR EACH ROW BEGIN IF :NEW.session_id IS NULL THEN SELECT gv_session_seq.NEXTVAL INTO :NEW.session_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_gv_session_inst_id ON gv$session(inst_id);\", \"CREATE INDEX idx_gv_session_type_status ON gv$session(TYPE, status);\", \"CREATE SEQUENCE gv_sysmetric_seq; CREATE TABLE gv$sysmetric (metric_id NUMBER PRIMARY KEY, inst_id NUMBER NOT NULL, end_time TIMESTAMP NOT NULL, metric_name VARCHAR2(100) NOT NULL, VALUE NUMBER(20,2), intsize_csec NUMBER); CREATE OR REPLACE TRIGGER gv_sysmetric_bi BEFORE INSERT ON gv$sysmetric FOR EACH ROW BEGIN IF :NEW.metric_id IS NULL THEN SELECT gv_sysmetric_seq.NEXTVAL INTO :NEW.metric_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_gv_sysmetric_inst_id ON gv$sysmetric(inst_id);\", \"CREATE INDEX idx_gv_sysmetric_intsize ON gv$sysmetric(intsize_csec);\", \"CREATE INDEX idx_gv_sysmetric_metric_name ON gv$sysmetric(metric_name);\"], \"sql\": \"SELECT\\n  c.inst_id,\\n  m.end_time AS checktime,\\n  c.conn,\\n  c.activeconn,\\n  m.sqlthroughput,\\n  m.sqlavgtime,\\n  m.user_commits,\\n  m.user_rollbacks,\\n  m.user_commits + m.user_rollbacks AS transactioncount,\\n  m.transactionavgtime\\nFROM\\n  (\\n  WITH\\n   t1 AS (\\n  SELECT\\n  inst_id,\\n  COUNT(*) conn\\n  FROM\\n  gv$session\\n  WHERE\\n  TYPE = 'USER'\\n  GROUP BY\\n  inst_id\\n   ),\\n   t2 AS (\\n  SELECT\\n  inst_id,\\n  COUNT(*) activeconn\\n  FROM\\n  gv$session\\n  WHERE\\n  TYPE = 'USER'\\n  AND status = 'ACTIVE'\\n  GROUP BY\\n  inst_id\\n   )\\n  SELECT\\n   t1.inst_id,\\n   t1.conn,\\n   t2.activeconn\\n  FROM\\n   t1,\\n   t2\\n  WHERE\\n   t1.inst_id = t2.inst_id\\n  ) c,\\n  (\\n  SELECT\\n   *\\n  FROM\\n   (\\n  SELECT\\n  inst_id,\\n  end_time,\\n  metric_name,\\n  round(VALUE, 2) VALUE\\n  FROM\\n  gv$sysmetric\\n  WHERE\\n  round(intsize_csec / 100, 0) = 60\\n  AND metric_name IN (\\n   'Executions Per Sec',\\n   'User Commits Per Sec',\\n   'User Rollbacks Per Sec'\\n  )\\n  UNION ALL\\n  SELECT\\n  inst_id,\\n  end_time,\\n  metric_name,\\n  round(VALUE * 10, 2) VALUE\\n  FROM\\n  gv$sysmetric\\n  WHERE\\n  round(intsize_csec / 100, 0) = 60\\n  AND metric_name IN (\\n   'SQL Service Response Time',\\n   'Response Time Per Txn'\\n  )\\n   ) PIVOT (\\n  AVG(VALUE) FOR metric_name IN (\\n  'Executions Per Sec' sqlthroughput,\\n  'SQL Service Response Time' sqlavgtime,\\n  'User Commits Per Sec' user_commits,\\n  'User Rollbacks Per Sec' user_rollbacks,\\n  'Response Time Per Txn' transactionavgtime\\n  )\\n   )\\n  ) m\\nWHERE\\n  c.inst_id = m.inst_id\\nORDER BY\\n  inst_id\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t6390\\t10000\\t1100000\\t2369214804\\t6326\\n1\\t  MERGE JOIN  \\t6390\\t10000\\t1100000\\t2369214804\\t6326\\n2\\t  MERGE JOIN  \\t5337\\t10000\\t950000\\t1861270817\\t5287\\n3\\t   SORT JOIN \\t4278\\t10000\\t800000\\t1093774272\\t4248\\n4\\t  VIEW  \\t4278\\t10000\\t800000\\t1093774272\\t4248\\n5\\t  HASH GROUP BY PIVOT \\t4278\\t10000\\t780000\\t1093774272\\t4248\\n6\\t   VIEW  \\t4092\\t10000\\t780000\\t1048013114\\t4064\\n7\\t  UNION-ALL  \\t\\t\\t\\t\\t\\n8\\t  TABLE ACCESS FULL GV$SYSMETRIC\\t2047\\t6000\\t246000\\t554616557\\t2032\\n9\\t  TABLE ACCESS FULL GV$SYSMETRIC\\t2045\\t4000\\t164000\\t493396557\\t2032\\n10\\t   SORT JOIN \\t1060\\t4\\t60\\t767496545\\t1039\\n11\\t  VIEW  \\t1059\\t4\\t60\\t730627615\\t1039\\n12\\t  HASH GROUP BY \\t1059\\t4\\t32\\t730627615\\t1039\\n13\\t   TABLE ACCESS FULL GV$SESSION\\t1046\\t500000\\t4000000\\t267282237\\t1039\\n14\\t  SORT JOIN \\t1053\\t4\\t60\\t507943987\\t1039\\n15\\t   VIEW  \\t1052\\t4\\t60\\t471075058\\t1039\\n16\\t  HASH GROUP BY \\t1052\\t4\\t60\\t471075058\\t1039\\n17\\t  TABLE ACCESS FULL GV$SESSION\\t1047\\t166667\\t2500005\\t303948903\\t1039\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE gv_session_seq; CREATE TABLE gv$session (session_id NUMBER PRIMARY KEY, inst_id NUMBER NOT NULL, TYPE VARCHAR2(20) NOT NULL, status VARCHAR2(20)); CREATE OR REPLACE TRIGGER gv_session_bi BEFORE INSERT ON gv$session FOR EACH ROW BEGIN IF :NEW.session_id IS NULL THEN SELECT gv_session_seq.NEXTVAL INTO :NEW.session_id FROM DUAL; END IF; END;\nCREATE INDEX idx_gv_session_inst_id ON gv$session(inst_id);\nCREATE INDEX idx_gv_session_type_status ON gv$session(TYPE, status);\nCREATE SEQUENCE gv_sysmetric_seq; CREATE TABLE gv$sysmetric (metric_id NUMBER PRIMARY KEY, inst_id NUMBER NOT NULL, end_time TIMESTAMP NOT NULL, metric_name VARCHAR2(100) NOT NULL, VALUE NUMBER(20,2), intsize_csec NUMBER); CREATE OR REPLACE TRIGGER gv_sysmetric_bi BEFORE INSERT ON gv$sysmetric FOR EACH ROW BEGIN IF :NEW.metric_id IS NULL THEN SELECT gv_sysmetric_seq.NEXTVAL INTO :NEW.metric_id FROM DUAL; END IF; END;\nCREATE INDEX idx_gv_sysmetric_inst_id ON gv$sysmetric(inst_id);\nCREATE INDEX idx_gv_sysmetric_intsize ON gv$sysmetric(intsize_csec);\nCREATE INDEX idx_gv_sysmetric_metric_name ON gv$sysmetric(metric_name);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t6390\t10000\t1100000\t2369214804\t6326\n1\t  MERGE JOIN  \t6390\t10000\t1100000\t2369214804\t6326\n2\t  MERGE JOIN  \t5337\t10000\t950000\t1861270817\t5287\n3\t   SORT JOIN \t4278\t10000\t800000\t1093774272\t4248\n4\t  VIEW  \t4278\t10000\t800000\t1093774272\t4248\n5\t  HASH GROUP BY PIVOT \t4278\t10000\t780000\t1093774272\t4248\n6\t   VIEW  \t4092\t10000\t780000\t1048013114\t4064\n7\t  UNION-ALL  \t\t\t\t\t\n8\t  TABLE ACCESS FULL GV$SYSMETRIC\t2047\t6000\t246000\t554616557\t2032\n9\t  TABLE ACCESS FULL GV$SYSMETRIC\t2045\t4000\t164000\t493396557\t2032\n10\t   SORT JOIN \t1060\t4\t60\t767496545\t1039\n11\t  VIEW  \t1059\t4\t60\t730627615\t1039\n12\t  HASH GROUP BY \t1059\t4\t32\t730627615\t1039\n13\t   TABLE ACCESS FULL GV$SESSION\t1046\t500000\t4000000\t267282237\t1039\n14\t  SORT JOIN \t1053\t4\t60\t507943987\t1039\n15\t   VIEW  \t1052\t4\t60\t471075058\t1039\n16\t  HASH GROUP BY \t1052\t4\t60\t471075058\t1039\n17\t  TABLE ACCESS FULL GV$SESSION\t1047\t166667\t2500005\t303948903\t1039\n\n## Original SQL:\nSELECT\n  c.inst_id,\n  m.end_time AS checktime,\n  c.conn,\n  c.activeconn,\n  m.sqlthroughput,\n  m.sqlavgtime,\n  m.user_commits,\n  m.user_rollbacks,\n  m.user_commits + m.user_rollbacks AS transactioncount,\n  m.transactionavgtime\nFROM\n  (\n  WITH\n   t1 AS (\n  SELECT\n  inst_id,\n  COUNT(*) conn\n  FROM\n  gv$session\n  WHERE\n  TYPE = 'USER'\n  GROUP BY\n  inst_id\n   ),\n   t2 AS (\n  SELECT\n  inst_id,\n  COUNT(*) activeconn\n  FROM\n  gv$session\n  WHERE\n  TYPE = 'USER'\n  AND status = 'ACTIVE'\n  GROUP BY\n  inst_id\n   )\n  SELECT\n   t1.inst_id,\n   t1.conn,\n   t2.activeconn\n  FROM\n   t1,\n   t2\n  WHERE\n   t1.inst_id = t2.inst_id\n  ) c,\n  (\n  SELECT\n   *\n  FROM\n   (\n  SELECT\n  inst_id,\n  end_time,\n  metric_name,\n  round(VALUE, 2) VALUE\n  FROM\n  gv$sysmetric\n  WHERE\n  round(intsize_csec / 100, 0) = 60\n  AND metric_name IN (\n   'Executions Per Sec',\n   'User Commits Per Sec',\n   'User Rollbacks Per Sec'\n  )\n  UNION ALL\n  SELECT\n  inst_id,\n  end_time,\n  metric_name,\n  round(VALUE * 10, 2) VALUE\n  FROM\n  gv$sysmetric\n  WHERE\n  round(intsize_csec / 100, 0) = 60\n  AND metric_name IN (\n   'SQL Service Response Time',\n   'Response Time Per Txn'\n  )\n   ) PIVOT (\n  AVG(VALUE) FOR metric_name IN (\n  'Executions Per Sec' sqlthroughput,\n  'SQL Service Response Time' sqlavgtime,\n  'User Commits Per Sec' user_commits,\n  'User Rollbacks Per Sec' user_rollbacks,\n  'Response Time Per Txn' transactionavgtime\n  )\n   )\n  ) m\nWHERE\n  c.inst_id = m.inst_id\nORDER BY\n  inst_id\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT c.inst_id, m.end_time AS checktime, c.conn, c.activeconn, m.sqlthroughput, m.sqlavgtime, m.user_commits, m.user_rollbacks, m.user_commits + m.user_rollbacks AS transactioncount, m.transactionavgtime FROM (SELECT inst_id, SUM(CASE WHEN TYPE = 'USER' THEN 1 ELSE 0 END) conn, SUM(CASE WHEN TYPE = 'USER' AND status = 'ACTIVE' THEN 1 ELSE 0 END) activeconn FROM gv$session WHERE TYPE = 'USER' GROUP BY inst_id) c INNER JOIN (SELECT * FROM (SELECT inst_id, end_time, metric_name, CASE WHEN metric_name IN ('Executions Per Sec', 'User Commits Per Sec', 'User Rollbacks Per Sec') THEN round(VALUE, 2) ELSE round(VALUE * 10, 2) END VALUE FROM gv$sysmetric WHERE intsize_csec >= 5950 AND intsize_csec <= 6049 AND metric_name IN ('Executions Per Sec', 'User Commits Per Sec', 'User Rollbacks Per Sec', 'SQL Service Response Time', 'Response Time Per Txn')) PIVOT (AVG(VALUE) FOR metric_name IN ('Executions Per Sec' sqlthroughput, 'SQL Service Response Time' sqlavgtime, 'User Commits Per Sec' user_commits, 'User Rollbacks Per Sec' user_rollbacks, 'Response Time Per Txn' transactionavgtime))) m ON c.inst_id = m.inst_id ORDER BY inst_id"
                    }
                ]
            },
            {
                "case_id": "25",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"25\", \"db_type\": \"mysql\", \"description\": \"在LEFT JOIN场景中，当WHERE子句包含对右表（被LEFT JOIN的表）的条件时，这些条件实际上会将LEFT JOIN转化为INNER JOIN的效果（因为NULL行会被WHERE过滤掉）。但如果将这些条件移到ON子句中，就能：1）保持真正的LEFT JOIN语义；2）在连接阶段就减少需要处理的数据；3）让优化器有更多优化空间。本次改写正是基于这一原理，将对表B的tenant_id和bo_name过滤从WHERE移到ON子句。同时清理了冗余的'A.tenant_id = 1065587309019136'重复条件（改写前WHERE子句中出现了多次）\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE acctg_trans_detail (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, gl_account_id BIGINT NOT NULL, master_voucher_id BIGINT, base_posted_dr DECIMAL(20,2) DEFAULT 0, base_posted_cr DECIMAL(20,2) DEFAULT 0, voucher_status_enum VARCHAR(50), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_tenant_id ON acctg_trans_detail(tenant_id);\", \"CREATE INDEX idx_master_voucher_id ON acctg_trans_detail(master_voucher_id);\", \"CREATE INDEX idx_tenant_gl_account ON acctg_trans_detail(tenant_id, gl_account_id);\", \"CREATE INDEX idx_voucher_status ON acctg_trans_detail(voucher_status_enum);\", \"CREATE TABLE acctg_trans (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, acctg_period VARCHAR(20), bo_name VARCHAR(100), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_tenant_id ON acctg_trans(tenant_id);\", \"CREATE INDEX idx_tenant_id_acctg_period ON acctg_trans(tenant_id, id, acctg_period);\", \"CREATE INDEX idx_bo_name ON acctg_trans(bo_name);\", \"CREATE TABLE gl_account_balance (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, gl_account_id BIGINT NOT NULL, acctg_period VARCHAR(20) NOT NULL, base_posted_dr DECIMAL(20,2) DEFAULT 0, base_posted_cr DECIMAL(20,2) DEFAULT 0, created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_tenant_id ON gl_account_balance(tenant_id);\", \"CREATE INDEX idx_gl_account_period ON gl_account_balance(gl_account_id, acctg_period, tenant_id);\", \"CREATE INDEX idx_acctg_period ON gl_account_balance(acctg_period);\", \"CREATE TABLE gl_account (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, code VARCHAR(50) NOT NULL, name VARCHAR(200), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_tenant_id ON gl_account(tenant_id);\", \"CREATE INDEX idx_tenant_code ON gl_account(tenant_id, code);\"], \"sql\": \"SELECT acctg.tenant_id, acctg.gl_account_id, ac.code, acctg.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg LEFT JOIN gl_account_balance A ON (A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id) AND A.tenant_id = 1065587309019136 LEFT JOIN gl_account ac ON (ac.id = acctg.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (acctg.base_posted_dr1 != ifnull(A.base_posted_dr, 0) OR acctg.base_posted_cr1 != ifnull(A.base_posted_cr, 0)) UNION SELECT A.tenant_id, A.gl_account_id, ac.code, A.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM gl_account_balance A LEFT JOIN (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id LEFT JOIN gl_account ac ON (ac.id = A.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND A.acctg_period NOT LIKE '%00' AND (A.base_posted_dr != ifnull(acctg.base_posted_dr1, 0) OR A.base_posted_cr != ifnull(acctg.base_posted_cr1, 0))) AND A.tenant_id = 1065587309019136 LIMIT 50001;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t13821\\t100.0\\t\\n1\\tPRIMARY\\tA\\t\\tref\\tidx_tenant_id,idx_gl_account_period,idx_acctg_period\\tidx_gl_account_period\\t98\\tacctg.gl_account_id,acctg.acctg_period,const\\t70\\t100.0\\tUsing where\\n1\\tPRIMARY\\tac\\t\\teq_ref\\tPRIMARY,idx_tenant_id,idx_tenant_code\\tPRIMARY\\t8\\tacctg.gl_account_id\\t1\\t100.0\\tUsing where\\n2\\tDERIVED\\tA\\t\\tref\\tidx_tenant_id,idx_tenant_gl_account,idx_voucher_status\\tidx_tenant_id\\t8\\tconst\\t497420\\t55.57\\tUsing where; Using temporary\\n2\\tDERIVED\\tB\\t\\teq_ref\\tPRIMARY,idx_tenant_id,idx_tenant_id_acctg_period\\tPRIMARY\\t8\\ttest_db.A.master_voucher_id\\t1\\t5.0\\tUsing where\\n3\\tUNION\\tA\\t\\tref\\tidx_tenant_id\\tidx_tenant_id\\t8\\tconst\\t497472\\t88.89\\tUsing where\\n3\\tUNION\\t<derived4>\\t\\tref\\t<auto_key0>\\t<auto_key0>\\t99\\tconst,test_db.A.gl_account_id,test_db.A.acctg_period\\t10\\t100.0\\tUsing where\\n3\\tUNION\\tac\\t\\teq_ref\\tPRIMARY,idx_tenant_id,idx_tenant_code\\tPRIMARY\\t8\\ttest_db.A.gl_account_id\\t1\\t100.0\\tUsing where\\n4\\tDERIVED\\tA\\t\\tref\\tidx_tenant_id,idx_tenant_gl_account,idx_voucher_status\\tidx_tenant_id\\t8\\tconst\\t497420\\t55.57\\tUsing where; Using temporary\\n4\\tDERIVED\\tB\\t\\teq_ref\\tPRIMARY,idx_tenant_id,idx_tenant_id_acctg_period\\tPRIMARY\\t8\\ttest_db.A.master_voucher_id\\t1\\t5.0\\tUsing where\\n5\\tUNION RESULT\\t<union1,3>\\t\\tALL\\t\\t\\t\\t\\t\\t\\tUsing temporary\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"union_result\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"select_id\\\": 5,\\n   \\\"table_name\\\": \\\"<union1,3>\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"query_specifications\\\": [\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n   \\\"select_id\\\": 1,\\n   \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"869134.39\\\"\\n   },\\n   \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"acctg\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"rows_examined_per_scan\\\": 13821,\\n   \\\"rows_produced_per_join\\\": 13821,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"175.26\\\",\\n  \\\"eval_cost\\\": \\\"1382.10\\\",\\n  \\\"prefix_cost\\\": \\\"1557.36\\\",\\n  \\\"data_read_per_join\\\": \\\"1M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"base_posted_dr1\\\",\\n  \\\"base_posted_cr1\\\"\\n   ],\\n   \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"364233.56\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"using_filesort\\\": false,\\n   \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"A\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_gl_account\\\",\\n  \\\"idx_voucher_status\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_tenant_id\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"tenant_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 497420,\\n   \\\"rows_produced_per_join\\\": 276421,\\n   \\\"filtered\\\": \\\"55.57\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"12601.85\\\",\\n  \\\"eval_cost\\\": \\\"27642.10\\\",\\n  \\\"prefix_cost\\\": \\\"62343.85\\\",\\n  \\\"data_read_per_join\\\": \\\"69M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"master_voucher_id\\\",\\n  \\\"base_posted_dr\\\",\\n  \\\"base_posted_cr\\\",\\n  \\\"voucher_status_enum\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`A`.`voucher_status_enum` is null) or (`test_db`.`A`.`voucher_status_enum` <> 'CANCELLED'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"B\\\",\\n   \\\"access_type\\\": \\\"eq_ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_id_acctg_period\\\"\\n   ],\\n   \\\"key\\\": \\\"PRIMARY\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"test_db.A.master_voucher_id\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 1,\\n   \\\"rows_produced_per_join\\\": 13821,\\n   \\\"filtered\\\": \\\"5.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"274247.61\\\",\\n  \\\"eval_cost\\\": \\\"1382.11\\\",\\n  \\\"prefix_cost\\\": \\\"364233.56\\\",\\n  \\\"data_read_per_join\\\": \\\"6M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"bo_name\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(<if>(found_match(B), ((`test_db`.`B`.`bo_name` is null) or (`test_db`.`B`.`bo_name` <> 'DraftAcctgTrans')), true) and <if>(is_not_null_compl(B), (`test_db`.`B`.`tenant_id` = 1065587309019136), true))\\\"\\n  }\\n  }\\n   ]\\n  }\\n  }\\n   }\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"A\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_gl_account_period\\\",\\n  \\\"idx_acctg_period\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_gl_account_period\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"tenant_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"98\\\",\\n   \\\"ref\\\": [\\n  \\\"acctg.gl_account_id\\\",\\n  \\\"acctg.acctg_period\\\",\\n  \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 70,\\n   \\\"rows_produced_per_join\\\": 980681,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"658345.61\\\",\\n  \\\"eval_cost\\\": \\\"98068.18\\\",\\n  \\\"prefix_cost\\\": \\\"757971.16\\\",\\n  \\\"data_read_per_join\\\": \\\"127M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"base_posted_dr\\\",\\n  \\\"base_posted_cr\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(<if>(found_match(A), ((`acctg`.`base_posted_dr1` <> ifnull(`test_db`.`A`.`base_posted_dr`,0)) or (`acctg`.`base_posted_cr1` <> ifnull(`test_db`.`A`.`base_posted_cr`,0))), true) and <if>(is_not_null_compl(A), (`acctg`.`tenant_id` = 1065587309019136), true))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"ac\\\",\\n   \\\"access_type\\\": \\\"eq_ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_code\\\"\\n   ],\\n   \\\"key\\\": \\\"PRIMARY\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"acctg.gl_account_id\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 1,\\n   \\\"rows_produced_per_join\\\": 980681,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"13095.05\\\",\\n  \\\"eval_cost\\\": \\\"98068.18\\\",\\n  \\\"prefix_cost\\\": \\\"869134.39\\\",\\n  \\\"data_read_per_join\\\": \\\"965M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"code\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"<if>(is_not_null_compl(ac), (`test_db`.`ac`.`tenant_id` = 1065587309019136), true)\\\"\\n  }\\n  }\\n   ]\\n  }\\n  },\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n   \\\"select_id\\\": 3,\\n   \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"2469300.89\\\"\\n   },\\n   \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"A\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"idx_tenant_id\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_tenant_id\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"tenant_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 497472,\\n   \\\"rows_produced_per_join\\\": 442202,\\n   \\\"filtered\\\": \\\"88.89\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"10520.84\\\",\\n  \\\"eval_cost\\\": \\\"44220.29\\\",\\n  \\\"prefix_cost\\\": \\\"60268.04\\\",\\n  \\\"data_read_per_join\\\": \\\"57M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"base_posted_dr\\\",\\n  \\\"base_posted_cr\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(not((`test_db`.`A`.`acctg_period` like '%00')))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"acctg\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"<auto_key0>\\\"\\n   ],\\n   \\\"key\\\": \\\"<auto_key0>\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\"\\n   ],\\n   \\\"key_length\\\": \\\"99\\\",\\n   \\\"ref\\\": [\\n  \\\"const\\\",\\n  \\\"test_db.A.gl_account_id\\\",\\n  \\\"test_db.A.acctg_period\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 10,\\n   \\\"rows_produced_per_join\\\": 4422348,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1105587.12\\\",\\n  \\\"eval_cost\\\": \\\"442234.85\\\",\\n  \\\"prefix_cost\\\": \\\"1608090.01\\\",\\n  \\\"data_read_per_join\\\": \\\"607M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"base_posted_dr1\\\",\\n  \\\"base_posted_cr1\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"<if>(found_match(acctg), ((`test_db`.`A`.`base_posted_dr` <> ifnull(`acctg`.`base_posted_dr1`,0)) or (`test_db`.`A`.`base_posted_cr` <> ifnull(`acctg`.`base_posted_cr1`,0))), true)\\\",\\n   \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 4,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"364233.56\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"using_filesort\\\": false,\\n   \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"A\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_gl_account\\\",\\n  \\\"idx_voucher_status\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_tenant_id\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"tenant_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 497420,\\n   \\\"rows_produced_per_join\\\": 276421,\\n   \\\"filtered\\\": \\\"55.57\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"12601.85\\\",\\n  \\\"eval_cost\\\": \\\"27642.10\\\",\\n  \\\"prefix_cost\\\": \\\"62343.85\\\",\\n  \\\"data_read_per_join\\\": \\\"69M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"gl_account_id\\\",\\n  \\\"master_voucher_id\\\",\\n  \\\"base_posted_dr\\\",\\n  \\\"base_posted_cr\\\",\\n  \\\"voucher_status_enum\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`A`.`voucher_status_enum` is null) or (`test_db`.`A`.`voucher_status_enum` <> 'CANCELLED'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"B\\\",\\n   \\\"access_type\\\": \\\"eq_ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_id_acctg_period\\\"\\n   ],\\n   \\\"key\\\": \\\"PRIMARY\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"test_db.A.master_voucher_id\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 1,\\n   \\\"rows_produced_per_join\\\": 13821,\\n   \\\"filtered\\\": \\\"5.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"274247.61\\\",\\n  \\\"eval_cost\\\": \\\"1382.11\\\",\\n  \\\"prefix_cost\\\": \\\"364233.56\\\",\\n  \\\"data_read_per_join\\\": \\\"6M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"acctg_period\\\",\\n  \\\"bo_name\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(<if>(found_match(B), ((`test_db`.`B`.`bo_name` is null) or (`test_db`.`B`.`bo_name` <> 'DraftAcctgTrans')), true) and <if>(is_not_null_compl(B), (`test_db`.`B`.`tenant_id` = 1065587309019136), true))\\\"\\n  }\\n  }\\n   ]\\n  }\\n  }\\n   }\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"ac\\\",\\n   \\\"access_type\\\": \\\"eq_ref\\\",\\n   \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_tenant_id\\\",\\n  \\\"idx_tenant_code\\\"\\n   ],\\n   \\\"key\\\": \\\"PRIMARY\\\",\\n   \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"8\\\",\\n   \\\"ref\\\": [\\n  \\\"test_db.A.gl_account_id\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 1,\\n   \\\"rows_produced_per_join\\\": 4422348,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"418976.04\\\",\\n  \\\"eval_cost\\\": \\\"442234.85\\\",\\n  \\\"prefix_cost\\\": \\\"2469300.89\\\",\\n  \\\"data_read_per_join\\\": \\\"4G\\\"\\n   },\\n   \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"tenant_id\\\",\\n  \\\"code\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"<if>(is_not_null_compl(ac), (`test_db`.`ac`.`tenant_id` = 1065587309019136), true)\\\"\\n  }\\n  }\\n   ]\\n  }\\n  }\\n   ]\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE acctg_trans_detail (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, gl_account_id BIGINT NOT NULL, master_voucher_id BIGINT, base_posted_dr DECIMAL(20,2) DEFAULT 0, base_posted_cr DECIMAL(20,2) DEFAULT 0, voucher_status_enum VARCHAR(50), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_tenant_id ON acctg_trans_detail(tenant_id);\nCREATE INDEX idx_master_voucher_id ON acctg_trans_detail(master_voucher_id);\nCREATE INDEX idx_tenant_gl_account ON acctg_trans_detail(tenant_id, gl_account_id);\nCREATE INDEX idx_voucher_status ON acctg_trans_detail(voucher_status_enum);\nCREATE TABLE acctg_trans (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, acctg_period VARCHAR(20), bo_name VARCHAR(100), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_tenant_id ON acctg_trans(tenant_id);\nCREATE INDEX idx_tenant_id_acctg_period ON acctg_trans(tenant_id, id, acctg_period);\nCREATE INDEX idx_bo_name ON acctg_trans(bo_name);\nCREATE TABLE gl_account_balance (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, gl_account_id BIGINT NOT NULL, acctg_period VARCHAR(20) NOT NULL, base_posted_dr DECIMAL(20,2) DEFAULT 0, base_posted_cr DECIMAL(20,2) DEFAULT 0, created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_tenant_id ON gl_account_balance(tenant_id);\nCREATE INDEX idx_gl_account_period ON gl_account_balance(gl_account_id, acctg_period, tenant_id);\nCREATE INDEX idx_acctg_period ON gl_account_balance(acctg_period);\nCREATE TABLE gl_account (id BIGINT PRIMARY KEY AUTO_INCREMENT, tenant_id BIGINT NOT NULL, code VARCHAR(50) NOT NULL, name VARCHAR(200), created_time DATETIME DEFAULT CURRENT_TIMESTAMP, updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_tenant_id ON gl_account(tenant_id);\nCREATE INDEX idx_tenant_code ON gl_account(tenant_id, code);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t13821\t100.0\t\n1\tPRIMARY\tA\t\tref\tidx_tenant_id,idx_gl_account_period,idx_acctg_period\tidx_gl_account_period\t98\tacctg.gl_account_id,acctg.acctg_period,const\t70\t100.0\tUsing where\n1\tPRIMARY\tac\t\teq_ref\tPRIMARY,idx_tenant_id,idx_tenant_code\tPRIMARY\t8\tacctg.gl_account_id\t1\t100.0\tUsing where\n2\tDERIVED\tA\t\tref\tidx_tenant_id,idx_tenant_gl_account,idx_voucher_status\tidx_tenant_id\t8\tconst\t497420\t55.57\tUsing where; Using temporary\n2\tDERIVED\tB\t\teq_ref\tPRIMARY,idx_tenant_id,idx_tenant_id_acctg_period\tPRIMARY\t8\ttest_db.A.master_voucher_id\t1\t5.0\tUsing where\n3\tUNION\tA\t\tref\tidx_tenant_id\tidx_tenant_id\t8\tconst\t497472\t88.89\tUsing where\n3\tUNION\t<derived4>\t\tref\t<auto_key0>\t<auto_key0>\t99\tconst,test_db.A.gl_account_id,test_db.A.acctg_period\t10\t100.0\tUsing where\n3\tUNION\tac\t\teq_ref\tPRIMARY,idx_tenant_id,idx_tenant_code\tPRIMARY\t8\ttest_db.A.gl_account_id\t1\t100.0\tUsing where\n4\tDERIVED\tA\t\tref\tidx_tenant_id,idx_tenant_gl_account,idx_voucher_status\tidx_tenant_id\t8\tconst\t497420\t55.57\tUsing where; Using temporary\n4\tDERIVED\tB\t\teq_ref\tPRIMARY,idx_tenant_id,idx_tenant_id_acctg_period\tPRIMARY\t8\ttest_db.A.master_voucher_id\t1\t5.0\tUsing where\n5\tUNION RESULT\t<union1,3>\t\tALL\t\t\t\t\t\t\tUsing temporary\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"union_result\": {\n   \"using_temporary_table\": true,\n   \"select_id\": 5,\n   \"table_name\": \"<union1,3>\",\n   \"access_type\": \"ALL\",\n   \"query_specifications\": [\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n   \"select_id\": 1,\n   \"cost_info\": {\n  \"query_cost\": \"869134.39\"\n   },\n   \"nested_loop\": [\n  {\n  \"table\": {\n   \"table_name\": \"acctg\",\n   \"access_type\": \"ALL\",\n   \"rows_examined_per_scan\": 13821,\n   \"rows_produced_per_join\": 13821,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"175.26\",\n  \"eval_cost\": \"1382.10\",\n  \"prefix_cost\": \"1557.36\",\n  \"data_read_per_join\": \"1M\"\n   },\n   \"used_columns\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"base_posted_dr1\",\n  \"base_posted_cr1\"\n   ],\n   \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n   \"query_cost\": \"364233.56\"\n  },\n  \"grouping_operation\": {\n   \"using_temporary_table\": true,\n   \"using_filesort\": false,\n   \"nested_loop\": [\n  {\n  \"table\": {\n   \"table_name\": \"A\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"idx_tenant_id\",\n  \"idx_tenant_gl_account\",\n  \"idx_voucher_status\"\n   ],\n   \"key\": \"idx_tenant_id\",\n   \"used_key_parts\": [\n  \"tenant_id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"const\"\n   ],\n   \"rows_examined_per_scan\": 497420,\n   \"rows_produced_per_join\": 276421,\n   \"filtered\": \"55.57\",\n   \"cost_info\": {\n  \"read_cost\": \"12601.85\",\n  \"eval_cost\": \"27642.10\",\n  \"prefix_cost\": \"62343.85\",\n  \"data_read_per_join\": \"69M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"master_voucher_id\",\n  \"base_posted_dr\",\n  \"base_posted_cr\",\n  \"voucher_status_enum\"\n   ],\n   \"attached_condition\": \"((`test_db`.`A`.`voucher_status_enum` is null) or (`test_db`.`A`.`voucher_status_enum` <> 'CANCELLED'))\"\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"B\",\n   \"access_type\": \"eq_ref\",\n   \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_tenant_id\",\n  \"idx_tenant_id_acctg_period\"\n   ],\n   \"key\": \"PRIMARY\",\n   \"used_key_parts\": [\n  \"id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"test_db.A.master_voucher_id\"\n   ],\n   \"rows_examined_per_scan\": 1,\n   \"rows_produced_per_join\": 13821,\n   \"filtered\": \"5.00\",\n   \"cost_info\": {\n  \"read_cost\": \"274247.61\",\n  \"eval_cost\": \"1382.11\",\n  \"prefix_cost\": \"364233.56\",\n  \"data_read_per_join\": \"6M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"acctg_period\",\n  \"bo_name\"\n   ],\n   \"attached_condition\": \"(<if>(found_match(B), ((`test_db`.`B`.`bo_name` is null) or (`test_db`.`B`.`bo_name` <> 'DraftAcctgTrans')), true) and <if>(is_not_null_compl(B), (`test_db`.`B`.`tenant_id` = 1065587309019136), true))\"\n  }\n  }\n   ]\n  }\n  }\n   }\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"A\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"idx_tenant_id\",\n  \"idx_gl_account_period\",\n  \"idx_acctg_period\"\n   ],\n   \"key\": \"idx_gl_account_period\",\n   \"used_key_parts\": [\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"tenant_id\"\n   ],\n   \"key_length\": \"98\",\n   \"ref\": [\n  \"acctg.gl_account_id\",\n  \"acctg.acctg_period\",\n  \"const\"\n   ],\n   \"rows_examined_per_scan\": 70,\n   \"rows_produced_per_join\": 980681,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"658345.61\",\n  \"eval_cost\": \"98068.18\",\n  \"prefix_cost\": \"757971.16\",\n  \"data_read_per_join\": \"127M\"\n   },\n   \"used_columns\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"base_posted_dr\",\n  \"base_posted_cr\"\n   ],\n   \"attached_condition\": \"(<if>(found_match(A), ((`acctg`.`base_posted_dr1` <> ifnull(`test_db`.`A`.`base_posted_dr`,0)) or (`acctg`.`base_posted_cr1` <> ifnull(`test_db`.`A`.`base_posted_cr`,0))), true) and <if>(is_not_null_compl(A), (`acctg`.`tenant_id` = 1065587309019136), true))\"\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"ac\",\n   \"access_type\": \"eq_ref\",\n   \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_tenant_id\",\n  \"idx_tenant_code\"\n   ],\n   \"key\": \"PRIMARY\",\n   \"used_key_parts\": [\n  \"id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"acctg.gl_account_id\"\n   ],\n   \"rows_examined_per_scan\": 1,\n   \"rows_produced_per_join\": 980681,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"13095.05\",\n  \"eval_cost\": \"98068.18\",\n  \"prefix_cost\": \"869134.39\",\n  \"data_read_per_join\": \"965M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"code\"\n   ],\n   \"attached_condition\": \"<if>(is_not_null_compl(ac), (`test_db`.`ac`.`tenant_id` = 1065587309019136), true)\"\n  }\n  }\n   ]\n  }\n  },\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n   \"select_id\": 3,\n   \"cost_info\": {\n  \"query_cost\": \"2469300.89\"\n   },\n   \"nested_loop\": [\n  {\n  \"table\": {\n   \"table_name\": \"A\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"idx_tenant_id\"\n   ],\n   \"key\": \"idx_tenant_id\",\n   \"used_key_parts\": [\n  \"tenant_id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"const\"\n   ],\n   \"rows_examined_per_scan\": 497472,\n   \"rows_produced_per_join\": 442202,\n   \"filtered\": \"88.89\",\n   \"cost_info\": {\n  \"read_cost\": \"10520.84\",\n  \"eval_cost\": \"44220.29\",\n  \"prefix_cost\": \"60268.04\",\n  \"data_read_per_join\": \"57M\"\n   },\n   \"used_columns\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"base_posted_dr\",\n  \"base_posted_cr\"\n   ],\n   \"attached_condition\": \"(not((`test_db`.`A`.`acctg_period` like '%00')))\"\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"acctg\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"<auto_key0>\"\n   ],\n   \"key\": \"<auto_key0>\",\n   \"used_key_parts\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\"\n   ],\n   \"key_length\": \"99\",\n   \"ref\": [\n  \"const\",\n  \"test_db.A.gl_account_id\",\n  \"test_db.A.acctg_period\"\n   ],\n   \"rows_examined_per_scan\": 10,\n   \"rows_produced_per_join\": 4422348,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"1105587.12\",\n  \"eval_cost\": \"442234.85\",\n  \"prefix_cost\": \"1608090.01\",\n  \"data_read_per_join\": \"607M\"\n   },\n   \"used_columns\": [\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"acctg_period\",\n  \"base_posted_dr1\",\n  \"base_posted_cr1\"\n   ],\n   \"attached_condition\": \"<if>(found_match(acctg), ((`test_db`.`A`.`base_posted_dr` <> ifnull(`acctg`.`base_posted_dr1`,0)) or (`test_db`.`A`.`base_posted_cr` <> ifnull(`acctg`.`base_posted_cr1`,0))), true)\",\n   \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 4,\n  \"cost_info\": {\n   \"query_cost\": \"364233.56\"\n  },\n  \"grouping_operation\": {\n   \"using_temporary_table\": true,\n   \"using_filesort\": false,\n   \"nested_loop\": [\n  {\n  \"table\": {\n   \"table_name\": \"A\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n  \"idx_tenant_id\",\n  \"idx_tenant_gl_account\",\n  \"idx_voucher_status\"\n   ],\n   \"key\": \"idx_tenant_id\",\n   \"used_key_parts\": [\n  \"tenant_id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"const\"\n   ],\n   \"rows_examined_per_scan\": 497420,\n   \"rows_produced_per_join\": 276421,\n   \"filtered\": \"55.57\",\n   \"cost_info\": {\n  \"read_cost\": \"12601.85\",\n  \"eval_cost\": \"27642.10\",\n  \"prefix_cost\": \"62343.85\",\n  \"data_read_per_join\": \"69M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"gl_account_id\",\n  \"master_voucher_id\",\n  \"base_posted_dr\",\n  \"base_posted_cr\",\n  \"voucher_status_enum\"\n   ],\n   \"attached_condition\": \"((`test_db`.`A`.`voucher_status_enum` is null) or (`test_db`.`A`.`voucher_status_enum` <> 'CANCELLED'))\"\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"B\",\n   \"access_type\": \"eq_ref\",\n   \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_tenant_id\",\n  \"idx_tenant_id_acctg_period\"\n   ],\n   \"key\": \"PRIMARY\",\n   \"used_key_parts\": [\n  \"id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"test_db.A.master_voucher_id\"\n   ],\n   \"rows_examined_per_scan\": 1,\n   \"rows_produced_per_join\": 13821,\n   \"filtered\": \"5.00\",\n   \"cost_info\": {\n  \"read_cost\": \"274247.61\",\n  \"eval_cost\": \"1382.11\",\n  \"prefix_cost\": \"364233.56\",\n  \"data_read_per_join\": \"6M\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"acctg_period\",\n  \"bo_name\"\n   ],\n   \"attached_condition\": \"(<if>(found_match(B), ((`test_db`.`B`.`bo_name` is null) or (`test_db`.`B`.`bo_name` <> 'DraftAcctgTrans')), true) and <if>(is_not_null_compl(B), (`test_db`.`B`.`tenant_id` = 1065587309019136), true))\"\n  }\n  }\n   ]\n  }\n  }\n   }\n  }\n  },\n  {\n  \"table\": {\n   \"table_name\": \"ac\",\n   \"access_type\": \"eq_ref\",\n   \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_tenant_id\",\n  \"idx_tenant_code\"\n   ],\n   \"key\": \"PRIMARY\",\n   \"used_key_parts\": [\n  \"id\"\n   ],\n   \"key_length\": \"8\",\n   \"ref\": [\n  \"test_db.A.gl_account_id\"\n   ],\n   \"rows_examined_per_scan\": 1,\n   \"rows_produced_per_join\": 4422348,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n  \"read_cost\": \"418976.04\",\n  \"eval_cost\": \"442234.85\",\n  \"prefix_cost\": \"2469300.89\",\n  \"data_read_per_join\": \"4G\"\n   },\n   \"used_columns\": [\n  \"id\",\n  \"tenant_id\",\n  \"code\"\n   ],\n   \"attached_condition\": \"<if>(is_not_null_compl(ac), (`test_db`.`ac`.`tenant_id` = 1065587309019136), true)\"\n  }\n  }\n   ]\n  }\n  }\n   ]\n  }\n  }\n}\n\n## Original SQL:\nSELECT acctg.tenant_id, acctg.gl_account_id, ac.code, acctg.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg LEFT JOIN gl_account_balance A ON (A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id) AND A.tenant_id = 1065587309019136 LEFT JOIN gl_account ac ON (ac.id = acctg.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (acctg.base_posted_dr1 != ifnull(A.base_posted_dr, 0) OR acctg.base_posted_cr1 != ifnull(A.base_posted_cr, 0)) UNION SELECT A.tenant_id, A.gl_account_id, ac.code, A.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM gl_account_balance A LEFT JOIN (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id LEFT JOIN gl_account ac ON (ac.id = A.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND A.acctg_period NOT LIKE '%00' AND (A.base_posted_dr != ifnull(acctg.base_posted_dr1, 0) OR A.base_posted_cr != ifnull(acctg.base_posted_cr1, 0))) AND A.tenant_id = 1065587309019136 LIMIT 50001;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH trans_summary AS (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, SUM(A.base_posted_dr) AS base_posted_dr1, SUM(A.base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id WHERE A.tenant_id = 1065587309019136 AND (A.voucher_status_enum IS NULL OR A.voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans') GROUP BY A.tenant_id, A.gl_account_id, B.acctg_period) SELECT acctg.tenant_id, acctg.gl_account_id, ac.code, acctg.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM trans_summary acctg LEFT JOIN gl_account_balance A ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = 1065587309019136 LEFT JOIN gl_account ac ON ac.id = acctg.gl_account_id AND ac.tenant_id = 1065587309019136 WHERE acctg.base_posted_dr1 != IFNULL(A.base_posted_dr, 0) OR acctg.base_posted_cr1 != IFNULL(A.base_posted_cr, 0) UNION ALL SELECT A.tenant_id, A.gl_account_id, ac.code, A.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM gl_account_balance A LEFT JOIN trans_summary acctg ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id LEFT JOIN gl_account ac ON ac.id = A.gl_account_id AND ac.tenant_id = 1065587309019136 WHERE A.tenant_id = 1065587309019136 AND A.acctg_period NOT LIKE '%00' AND (A.base_posted_dr != IFNULL(acctg.base_posted_dr1, 0) OR A.base_posted_cr != IFNULL(acctg.base_posted_cr1, 0)) LIMIT 50001"
                    }
                ]
            },
            {
                "case_id": "26",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"26\", \"db_type\": \"postgresql\", \"description\": \"本次改写采用了CTE常量提取模式，将时间计算逻辑（fun_addmonth、to_char等）从连接条件中提取到CTE中，理论上可以避免在循环中重复计算这些函数。同时将COALESCE改写为显式OR条件，希望优化器能更好地理解谓词逻辑。然而，这种改写忽略了LIMIT 1对执行计划的影响：在只需要返回1行的场景下，原SQL的\\\"惰性计算\\\"策略更优，因为常量函数只会被调用极少次数。CTE的物化成本和额外的扫描开销在这种场景下无法被节省的计算成本所抵消。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE dwd_csi_ac02 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aae140 VARCHAR(10), aac008 VARCHAR(5), aac031 VARCHAR(5), aac030 NUMERIC(8,0), aae041 NUMERIC(6,0), aae042 NUMERIC(6,0));\", \"CREATE INDEX idx_dwd_csi_ac02_aac001 ON dwd_csi_ac02(aac001);\", \"CREATE INDEX idx_dwd_csi_ac02_composite ON dwd_csi_ac02(aae140, aac008, aac031, aac030, aae041, aae042);\", \"CREATE TABLE dwd_hrss_ac99 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aac147 VARCHAR(100));\", \"CREATE INDEX idx_dwd_hrss_ac99_aac001 ON dwd_hrss_ac99(aac001);\", \"CREATE INDEX idx_dwd_hrss_ac99_aac147 ON dwd_hrss_ac99(aac147);\"], \"sql\": \"select\\n\\t'lxzdqdwjf5nys',\\n\\t'连续在当前单位参保5年以上',\\n\\tc.aac147,\\n\\t'是',\\n\\t'连续在当前单位参保5年以上'\\nfrom\\n\\tdwd_csi_ac02 a,\\n\\t(\\n\\tselect\\n\\t\\t(fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)|| '31')::numeric aac030,\\n\\t\\t fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)::numeric aae041,\\n\\t\\tto_char(current_timestamp, 'yyyymm')::numeric aae042) b,\\n\\tdwd_hrss_ac99 c\\nwhere a.aac001::varchar = c.aac001::varchar\\n\\tand a.aae140 = '110'\\n\\tand a.aac008 = '1'\\n\\tand a.aac031 = '1'\\n\\tand a.aac030 <= b.aac030\\n\\tand a.aae041 <= b.aae041\\n\\tand coalesce(a.aae042, 999912) >= b.aae042\\n\\tand c.aac147 is not null limit 1\", \"explain\": \"QUERY PLAN\\nLimit  (cost=0.42..3.47 rows=1 width=166)\\n  ->  Nested Loop  (cost=0.42..45289.49 rows=14886 width=166)\\n  ->  Nested Loop  (cost=0.00..35441.33 rows=16590 width=19)\\n  Join Filter: ((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\\n  ->  Result  (cost=0.00..0.54 rows=1 width=96)\\n  ->  Seq Scan on dwd_csi_ac02 a  (cost=0.00..27602.00 rows=447931 width=40)\\n  Filter: (((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\\n  ->  Index Scan using idx_dwd_hrss_ac99_aac001 on dwd_hrss_ac99 c  (cost=0.42..0.58 rows=1 width=57)\\n  Index Cond: ((aac001)::text = (a.aac001)::text)\\n  Filter: (aac147 IS NOT NULL)\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Limit', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 3.47, 'Plan Rows': 1, 'Plan Width': 166, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.42, 'Total Cost': 45289.49, 'Plan Rows': 14886, 'Plan Width': 166, 'Inner Unique': False, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.0, 'Total Cost': 35441.33, 'Plan Rows': 16590, 'Plan Width': 19, 'Inner Unique': False, 'Join Filter': \\\"((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\\\", 'Plans': [{'Node Type': 'Result', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.0, 'Total Cost': 0.54, 'Plan Rows': 1, 'Plan Width': 96}, {'Node Type': 'Seq Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'dwd_csi_ac02', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 27602.0, 'Plan Rows': 447931, 'Plan Width': 40, 'Filter': \\\"(((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\\\"}]}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_dwd_hrss_ac99_aac001', 'Relation Name': 'dwd_hrss_ac99', 'Alias': 'c', 'Startup Cost': 0.42, 'Total Cost': 0.58, 'Plan Rows': 1, 'Plan Width': 57, 'Index Cond': '((aac001)::text = (a.aac001)::text)', 'Filter': '(aac147 IS NOT NULL)'}]}]}}]\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE dwd_csi_ac02 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aae140 VARCHAR(10), aac008 VARCHAR(5), aac031 VARCHAR(5), aac030 NUMERIC(8,0), aae041 NUMERIC(6,0), aae042 NUMERIC(6,0));\nCREATE INDEX idx_dwd_csi_ac02_aac001 ON dwd_csi_ac02(aac001);\nCREATE INDEX idx_dwd_csi_ac02_composite ON dwd_csi_ac02(aae140, aac008, aac031, aac030, aae041, aae042);\nCREATE TABLE dwd_hrss_ac99 (id SERIAL PRIMARY KEY, aac001 VARCHAR(50), aac147 VARCHAR(100));\nCREATE INDEX idx_dwd_hrss_ac99_aac001 ON dwd_hrss_ac99(aac001);\nCREATE INDEX idx_dwd_hrss_ac99_aac147 ON dwd_hrss_ac99(aac147);\n\n## Explain Output in JSON:\nQUERY PLAN\nLimit  (cost=0.42..3.47 rows=1 width=166)\n  ->  Nested Loop  (cost=0.42..45289.49 rows=14886 width=166)\n  ->  Nested Loop  (cost=0.00..35441.33 rows=16590 width=19)\n  Join Filter: ((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\n  ->  Result  (cost=0.00..0.54 rows=1 width=96)\n  ->  Seq Scan on dwd_csi_ac02 a  (cost=0.00..27602.00 rows=447931 width=40)\n  Filter: (((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\n  ->  Index Scan using idx_dwd_hrss_ac99_aac001 on dwd_hrss_ac99 c  (cost=0.42..0.58 rows=1 width=57)\n  Index Cond: ((aac001)::text = (a.aac001)::text)\n  Filter: (aac147 IS NOT NULL)\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Limit', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 3.47, 'Plan Rows': 1, 'Plan Width': 166, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.42, 'Total Cost': 45289.49, 'Plan Rows': 14886, 'Plan Width': 166, 'Inner Unique': False, 'Plans': [{'Node Type': 'Nested Loop', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 0.0, 'Total Cost': 35441.33, 'Plan Rows': 16590, 'Plan Width': 19, 'Inner Unique': False, 'Join Filter': \"((a.aac030 <= ((((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::text || '31'::text))::numeric)) AND (a.aae041 <= ((fun_addmonth((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::character varying, '-61'::integer))::numeric)) AND (COALESCE(a.aae042, '999912'::numeric) >= ((to_char(CURRENT_TIMESTAMP, 'yyyymm'::text))::numeric)))\", 'Plans': [{'Node Type': 'Result', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.0, 'Total Cost': 0.54, 'Plan Rows': 1, 'Plan Width': 96}, {'Node Type': 'Seq Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'dwd_csi_ac02', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 27602.0, 'Plan Rows': 447931, 'Plan Width': 40, 'Filter': \"(((aae140)::text = '110'::text) AND ((aac008)::text = '1'::text) AND ((aac031)::text = '1'::text))\"}]}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_dwd_hrss_ac99_aac001', 'Relation Name': 'dwd_hrss_ac99', 'Alias': 'c', 'Startup Cost': 0.42, 'Total Cost': 0.58, 'Plan Rows': 1, 'Plan Width': 57, 'Index Cond': '((aac001)::text = (a.aac001)::text)', 'Filter': '(aac147 IS NOT NULL)'}]}]}}]\n\n## Original SQL:\nselect\n\t'lxzdqdwjf5nys',\n\t'连续在当前单位参保5年以上',\n\tc.aac147,\n\t'是',\n\t'连续在当前单位参保5年以上'\nfrom\n\tdwd_csi_ac02 a,\n\t(\n\tselect\n\t\t(fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)|| '31')::numeric aac030,\n\t\t fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)::numeric aae041,\n\t\tto_char(current_timestamp, 'yyyymm')::numeric aae042) b,\n\tdwd_hrss_ac99 c\nwhere a.aac001::varchar = c.aac001::varchar\n\tand a.aae140 = '110'\n\tand a.aac008 = '1'\n\tand a.aac031 = '1'\n\tand a.aac030 <= b.aac030\n\tand a.aae041 <= b.aae041\n\tand coalesce(a.aae042, 999912) >= b.aae042\n\tand c.aac147 is not null limit 1\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select 'lxzdqdwjf5nys','连续在当前单位参保5年以上',c.aac147,'是','连续在当前单位参保5年以上' from dwd_csi_ac02 a inner join dwd_hrss_ac99 c on a.aac001=c.aac001 where a.aae140='110' and a.aac008='1' and a.aac031='1' and a.aac030<=(fun_addmonth(to_char(current_timestamp,'yyyymm')::varchar,-61)||'31')::numeric and a.aae041<=fun_addmonth(to_char(current_timestamp,'yyyymm')::varchar,-61)::numeric and coalesce(a.aae042,999912)>=to_char(current_timestamp,'yyyymm')::numeric and c.aac147 is not null limit 1"
                    }
                ]
            },
            {
                "case_id": "27",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"27\", \"db_type\": \"postgresql\", \"description\": \"该改写试图用经典的'MAX+自连接'模式替代窗口函数来获取每个分组的最新记录。理论上，当窗口函数需要处理大量数据时，GROUP BY聚合可能更高效。然而，本次改写犯了两个严重错误：1) 在CTE定义和子查询中使用了SELECT指定列而非SELECT *，导致结果集缺少字段；2) 没有充分验证结果集的完整性。正确的改写应该保持与原SQL完全相同的输出列，只改变获取数据的方法。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE cash_transaction (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL, balance DECIMAL(15,2) NOT NULL DEFAULT 0, created_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, cash_type INTEGER NOT NULL);\", \"CREATE INDEX idx_cash_transaction_member_num ON cash_transaction(member_num);\", \"CREATE INDEX idx_cash_transaction_cash_type ON cash_transaction(cash_type);\", \"CREATE INDEX idx_cash_transaction_composite ON cash_transaction(member_num, cash_type, id DESC);\", \"CREATE TABLE cash (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL UNIQUE, credit_available DECIMAL(15,2) NOT NULL DEFAULT 0);\", \"CREATE INDEX idx_cash_member_num ON cash(member_num);\"], \"sql\": \"with temp as(\\n select * from (\\n select ROW_NUMBER() OVER (PARTITION BY member_num ORDER BY id desc)a,\\n member_num,balance,created_on\\n from cash_transaction where cash_type=2 )a\\n where a=1 and balance<>0)\\n select * from temp a \\n full outer join\\n ( select * from  cash where  credit_available<>0)b\\n on a.member_num=b.member_num\\n where a.balance<>b.credit_available\\n or a.member_num is null\\n or b.member_num is null\", \"explain\": \"QUERY PLAN\\nHash Full Join  (cost=100581.31..137547.65 rows=835137 width=58)\\n  Hash Cond: ((cash.member_num)::text = (a.member_num)::text)\\n  Filter: ((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))\\n  ->  Seq Scan on cash  (cost=0.00..19747.00 rows=859467 width=26)\\n  Filter: (credit_available <> '0'::numeric)\\n  ->  Hash  (cost=100546.39..100546.39 rows=2793 width=32)\\n  ->  Subquery Scan on a  (cost=0.42..100546.39 rows=2793 width=32)\\n  Filter: ((a.balance <> '0'::numeric) AND (a.a = 1))\\n  ->  WindowAgg  (cost=0.42..90052.89 rows=699567 width=40)\\n  Run Condition: (row_number() OVER (?) <= 1)\\n  ->  Index Scan using idx_cash_transaction_composite on cash_transaction  (cost=0.42..77810.47 rows=699567 width=32)\\n  Index Cond: (cash_type = 2)\\nJIT:\\n  Functions: 25\\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Hash Join', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Full', 'Startup Cost': 100581.31, 'Total Cost': 137547.65, 'Plan Rows': 835137, 'Plan Width': 58, 'Inner Unique': False, 'Hash Cond': '((cash.member_num)::text = (a.member_num)::text)', 'Filter': '((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'cash', 'Alias': 'cash', 'Startup Cost': 0.0, 'Total Cost': 19747.0, 'Plan Rows': 859467, 'Plan Width': 26, 'Filter': \\\"(credit_available <> '0'::numeric)\\\"}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 100546.39, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'a', 'Startup Cost': 0.42, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Filter': \\\"((a.balance <> '0'::numeric) AND (a.a = 1))\\\", 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 90052.89, 'Plan Rows': 699567, 'Plan Width': 40, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_cash_transaction_composite', 'Relation Name': 'cash_transaction', 'Alias': 'cash_transaction', 'Startup Cost': 0.42, 'Total Cost': 77810.47, 'Plan Rows': 699567, 'Plan Width': 32, 'Index Cond': '(cash_type = 2)'}]}]}]}]}, 'JIT': {'Functions': 25, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE cash_transaction (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL, balance DECIMAL(15,2) NOT NULL DEFAULT 0, created_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, cash_type INTEGER NOT NULL);\nCREATE INDEX idx_cash_transaction_member_num ON cash_transaction(member_num);\nCREATE INDEX idx_cash_transaction_cash_type ON cash_transaction(cash_type);\nCREATE INDEX idx_cash_transaction_composite ON cash_transaction(member_num, cash_type, id DESC);\nCREATE TABLE cash (id BIGSERIAL PRIMARY KEY, member_num VARCHAR(50) NOT NULL UNIQUE, credit_available DECIMAL(15,2) NOT NULL DEFAULT 0);\nCREATE INDEX idx_cash_member_num ON cash(member_num);\n\n## Explain Output in JSON:\nQUERY PLAN\nHash Full Join  (cost=100581.31..137547.65 rows=835137 width=58)\n  Hash Cond: ((cash.member_num)::text = (a.member_num)::text)\n  Filter: ((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))\n  ->  Seq Scan on cash  (cost=0.00..19747.00 rows=859467 width=26)\n  Filter: (credit_available <> '0'::numeric)\n  ->  Hash  (cost=100546.39..100546.39 rows=2793 width=32)\n  ->  Subquery Scan on a  (cost=0.42..100546.39 rows=2793 width=32)\n  Filter: ((a.balance <> '0'::numeric) AND (a.a = 1))\n  ->  WindowAgg  (cost=0.42..90052.89 rows=699567 width=40)\n  Run Condition: (row_number() OVER (?) <= 1)\n  ->  Index Scan using idx_cash_transaction_composite on cash_transaction  (cost=0.42..77810.47 rows=699567 width=32)\n  Index Cond: (cash_type = 2)\nJIT:\n  Functions: 25\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Hash Join', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Full', 'Startup Cost': 100581.31, 'Total Cost': 137547.65, 'Plan Rows': 835137, 'Plan Width': 58, 'Inner Unique': False, 'Hash Cond': '((cash.member_num)::text = (a.member_num)::text)', 'Filter': '((a.balance <> cash.credit_available) OR (a.member_num IS NULL) OR (cash.member_num IS NULL))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'cash', 'Alias': 'cash', 'Startup Cost': 0.0, 'Total Cost': 19747.0, 'Plan Rows': 859467, 'Plan Width': 26, 'Filter': \"(credit_available <> '0'::numeric)\"}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 100546.39, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'a', 'Startup Cost': 0.42, 'Total Cost': 100546.39, 'Plan Rows': 2793, 'Plan Width': 32, 'Filter': \"((a.balance <> '0'::numeric) AND (a.a = 1))\", 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 0.42, 'Total Cost': 90052.89, 'Plan Rows': 699567, 'Plan Width': 40, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_cash_transaction_composite', 'Relation Name': 'cash_transaction', 'Alias': 'cash_transaction', 'Startup Cost': 0.42, 'Total Cost': 77810.47, 'Plan Rows': 699567, 'Plan Width': 32, 'Index Cond': '(cash_type = 2)'}]}]}]}]}, 'JIT': {'Functions': 25, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\n\n## Original SQL:\nwith temp as(\n select * from (\n select ROW_NUMBER() OVER (PARTITION BY member_num ORDER BY id desc)a,\n member_num,balance,created_on\n from cash_transaction where cash_type=2 )a\n where a=1 and balance<>0)\n select * from temp a \n full outer join\n ( select * from  cash where  credit_available<>0)b\n on a.member_num=b.member_num\n where a.balance<>b.credit_available\n or a.member_num is null\n or b.member_num is null\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select * from (select distinct on (member_num) member_num,balance,created_on from cash_transaction where cash_type=2 and balance<>0 order by member_num,id desc) a full outer join (select * from cash where credit_available<>0) b on a.member_num=b.member_num where a.balance is distinct from b.credit_available or a.member_num is null or b.member_num is null"
                    }
                ]
            },
            {
                "case_id": "28",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"28\", \"db_type\": \"oracle\", \"description\": \"本次改写主要做了两方面优化：1) 消除了子查询中计算但从未使用的first_tran_date字段，减少了一次min()聚合操作；2) 将onhold_accounts这个内联视图展开，直接在主查询中JOIN audit_header和audit_detail表，并将过滤条件移到WHERE子句中。这种改写理论上可以给优化器更多的优化空间，但由于原SQL结构已经较为优化，实际收益有限。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE SEQUENCE accounts_seq; CREATE TABLE accounts (acc_account_no VARCHAR2(50), acc_subacc_no VARCHAR2(50), acc_incep_date DATE NOT NULL, acc_act_code VARCHAR2(20), acc_gact_type VARCHAR2(10), PRIMARY KEY (acc_account_no, acc_subacc_no)); CREATE OR REPLACE TRIGGER accounts_bi BEFORE INSERT ON accounts FOR EACH ROW BEGIN NULL; END;\", \"CREATE INDEX idx_accounts_act_code ON accounts(acc_act_code);\", \"CREATE INDEX idx_accounts_gact_type ON accounts(acc_gact_type);\", \"CREATE INDEX idx_accounts_incep_date ON accounts(acc_incep_date);\", \"CREATE SEQUENCE account_headers_seq; CREATE TABLE account_headers (acch_account_no VARCHAR2(50) PRIMARY KEY, acch_title VARCHAR2(200), acch_brn_code VARCHAR2(20)); CREATE OR REPLACE TRIGGER account_headers_bi BEFORE INSERT ON account_headers FOR EACH ROW BEGIN NULL; END;\", \"CREATE INDEX idx_acch_account_no ON account_headers(acch_account_no);\", \"CREATE SEQUENCE account_types_seq; CREATE TABLE account_types (act_code VARCHAR2(20) PRIMARY KEY, act_long_name VARCHAR2(100)); CREATE OR REPLACE TRIGGER account_types_bi BEFORE INSERT ON account_types FOR EACH ROW BEGIN NULL; END;\", \"CREATE SEQUENCE transactions_seq; CREATE TABLE transactions (tran_seqno NUMBER PRIMARY KEY, tran_account_no VARCHAR2(50) NOT NULL, tran_subacc_no VARCHAR2(50) NOT NULL, tran_date DATE NOT NULL, tran_amount_cr NUMBER(18,2), tran_trans_code VARCHAR2(20), tran_pay_method VARCHAR2(10), tran_create_by VARCHAR2(50)); CREATE OR REPLACE TRIGGER transactions_bi BEFORE INSERT ON transactions FOR EACH ROW BEGIN IF :NEW.tran_seqno IS NULL THEN SELECT transactions_seq.NEXTVAL INTO :NEW.tran_seqno FROM DUAL; END IF; END;\", \"CREATE INDEX idx_trans_account_subacc ON transactions(tran_account_no, tran_subacc_no);\", \"CREATE INDEX idx_trans_date ON transactions(tran_date);\", \"CREATE INDEX idx_trans_trans_code ON transactions(tran_trans_code);\", \"CREATE INDEX idx_trans_pay_method ON transactions(tran_pay_method);\", \"CREATE SEQUENCE audit_header_seq; CREATE TABLE audit_header (audh_seqno NUMBER PRIMARY KEY, audh_key1 VARCHAR2(50), audh_key2 VARCHAR2(50), audh_date DATE, audh_table_prefix VARCHAR2(20), audh_change_type VARCHAR2(10)); CREATE OR REPLACE TRIGGER audit_header_bi BEFORE INSERT ON audit_header FOR EACH ROW BEGIN IF :NEW.audh_seqno IS NULL THEN SELECT audit_header_seq.NEXTVAL INTO :NEW.audh_seqno FROM DUAL; END IF; END;\", \"CREATE INDEX idx_audh_keys ON audit_header(audh_key1, audh_key2);\", \"CREATE INDEX idx_audh_table_prefix ON audit_header(audh_table_prefix);\", \"CREATE INDEX idx_audh_change_type ON audit_header(audh_change_type);\", \"CREATE SEQUENCE audit_detail_seq; CREATE TABLE audit_detail (audd_id NUMBER PRIMARY KEY, audd_audh_seqno NUMBER NOT NULL, audd_col_sufix VARCHAR2(50), audd_old_value VARCHAR2(200), audd_new_value VARCHAR2(200)); CREATE OR REPLACE TRIGGER audit_detail_bi BEFORE INSERT ON audit_detail FOR EACH ROW BEGIN IF :NEW.audd_id IS NULL THEN SELECT audit_detail_seq.NEXTVAL INTO :NEW.audd_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_audd_audh_seqno ON audit_detail(audd_audh_seqno);\", \"CREATE INDEX idx_audd_col_sufix ON audit_detail(audd_col_sufix);\", \"CREATE SEQUENCE account_links_seq; CREATE TABLE ACCOUNT_LINKS (accl_id NUMBER PRIMARY KEY, accl_account_no VARCHAR2(50) NOT NULL, accl_subacc_no VARCHAR2(50) NOT NULL, accl_holder_pos NUMBER, accl_cust_seqno NUMBER); CREATE OR REPLACE TRIGGER account_links_bi BEFORE INSERT ON ACCOUNT_LINKS FOR EACH ROW BEGIN IF :NEW.accl_id IS NULL THEN SELECT account_links_seq.NEXTVAL INTO :NEW.accl_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_accl_account_subacc ON ACCOUNT_LINKS(accl_account_no, accl_subacc_no);\", \"CREATE INDEX idx_accl_holder_pos ON ACCOUNT_LINKS(accl_holder_pos);\", \"CREATE SEQUENCE account_holding_tax_seq; CREATE TABLE SUMMIT.ACCOUNT_HOLDING_TAX (acctax_id NUMBER PRIMARY KEY, ACCTAX_ACCOUNT_NO VARCHAR2(50) NOT NULL, ACCTAX_SUBACC_NO VARCHAR2(50) NOT NULL, ACCTAX_CUST_SEQNO NUMBER, ACCTAX_EFF_DATE_FROM DATE); CREATE OR REPLACE TRIGGER account_holding_tax_bi BEFORE INSERT ON SUMMIT.ACCOUNT_HOLDING_TAX FOR EACH ROW BEGIN IF :NEW.acctax_id IS NULL THEN SELECT account_holding_tax_seq.NEXTVAL INTO :NEW.acctax_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_acctax_composite ON SUMMIT.ACCOUNT_HOLDING_TAX(ACCTAX_ACCOUNT_NO, ACCTAX_SUBACC_NO, ACCTAX_CUST_SEQNO);\"], \"sql\": \"SELECT DISTINCT acc_account_no, \\n  acc_subacc_no, \\n  acch_title,\\n  to_char(acc_incep_date,'DD/MM/YYYY') acc_incep_date,\\n  htax.ACCTAX_EFF_DATE_FROM,\\n  to_char(onhold_accounts.audh_date, 'DD-MON-YYYY') approved_date,\\n  act_long_name, \\n  tran_amount_cr,\\n  tran_create_by,\\n  CASE WHEN (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) < 0 THEN 0 ELSE\\n   (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) END time_on_approved,\\n  acch_brn_code\\n  FROM\\n  (\\n   (\\n  SELECT accounts.acc_account_no,\\n   acch_title, \\n   accounts.acc_subacc_no,\\n   acc_incep_date,\\n   act_long_name,\\n   tran_amount_cr,\\n   transactions.tran_create_by,\\n   first_tran_date,\\n   acch_brn_code\\n  FROM accounts \\n  JOIN account_headers ON account_headers.acch_account_no = accounts.acc_account_no\\n  JOIN account_types ON acc_act_code = act_code\\n  JOIN \\n   (\\n  SELECT tran_account_no, tran_subacc_no, min(tran_seqno) first_tran_seq, min(tran_date) first_tran_date\\n  FROM transactions\\n  WHERE tran_amount_cr IS NOT NULL\\n  AND tran_trans_code IN ('RIC','RSAV')\\n  AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE\\n  AND tran_pay_method not in ('C','CQ')   --Exclude cash and cheque receipts as those accounts will already have the passbook.\\n  GROUP BY tran_account_no, tran_subacc_no\\n   ) first_trans\\n   ON tran_account_no = acc_account_no AND tran_subacc_no = acc_subacc_no\\n  JOIN transactions ON tran_seqno = first_trans.first_tran_seq\\n  WHERE acc_gact_type IN ('S', 'IC') \\n   AND acc_incep_date BETWEEN IN_INCEP_FROM_DATE and IN_INCEP_TO_DATE\\n   ) opened_accounts\\n   JOIN\\n   (\\n  SELECT audh_key1, audh_key2, audh_date, audd_old_value, audd_new_value\\n  FROM audit_header\\n  JOIN audit_detail\\n   ON audh_seqno = audd_audh_seqno\\n  WHERE audh_table_prefix = 'ACC'\\n   AND audd_col_sufix = 'PROCESS_STATUS'\\n   AND audh_change_type  = 'I'\\n   AND audd_old_value IS NULL \\n   AND audd_new_value = 1\\n   ) onhold_accounts\\n  ON opened_accounts.acc_account_no = onhold_accounts.audh_key1\\n   AND opened_accounts.acc_subacc_no = onhold_accounts.audh_key2\\n   JOIN ACCOUNT_LINKS al ON al.accl_account_no = opened_accounts.ACC_ACCOUNT_NO and al.accl_subacc_no = opened_accounts.ACC_SUBACC_NO and al.accl_holder_pos = 1\\n   JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax \\n  ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO\\n   AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO\\n   AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO\\n  )\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t1320\\t1\\t264\\t333735386\\t1311\\n1\\t  HASH UNIQUE \\t1320\\t1\\t264\\t333735386\\t1311\\n2\\t  HASH JOIN  \\t1319\\t1\\t264\\t296866817\\t1311\\n3\\t   NESTED LOOPS  \\t1319\\t1\\t264\\t296866817\\t1311\\n4\\t  NESTED LOOPS  \\t1319\\t1\\t264\\t296866817\\t1311\\n5\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n6\\t   NESTED LOOPS  \\t1317\\t1\\t249\\t296850384\\t1309\\n7\\t  HASH JOIN  \\t1294\\t1\\t236\\t296676455\\t1286\\n8\\t  NESTED LOOPS  \\t1294\\t1\\t236\\t296676455\\t1286\\n9\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n10\\t  HASH JOIN  \\t1291\\t1\\t206\\t296653810\\t1283\\n11\\t  NESTED LOOPS  \\t1291\\t1\\t206\\t296653810\\t1283\\n12\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n13\\t  HASH JOIN  \\t1289\\t1\\t180\\t296638517\\t1281\\n14\\t  NESTED LOOPS  \\t1289\\t1\\t180\\t296638517\\t1281\\n15\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n16\\t  HASH JOIN  \\t1287\\t1\\t132\\t296622185\\t1279\\n17\\t  NESTED LOOPS  \\t1287\\t1\\t132\\t296622185\\t1279\\n18\\t   STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n19\\t  NESTED LOOPS  \\t1283\\t4\\t328\\t296586099\\t1275\\n20\\t  HASH JOIN  \\t1278\\t4\\t208\\t296542487\\t1270\\n21\\t   NESTED LOOPS  \\t1278\\t4\\t208\\t296542487\\t1270\\n22\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n23\\t  TABLE ACCESS FULL AUDIT_DETAIL\\t1270\\t4\\t84\\t296476515\\t1262\\n24\\t  TABLE ACCESS BY INDEX ROWID AUDIT_HEADER\\t2\\t1\\t31\\t16493\\t2\\n25\\t  INDEX UNIQUE SCAN SYS_C008309\\t1\\t1\\t\\t9021\\t1\\n26\\t   TABLE ACCESS FULL AUDIT_HEADER\\t2\\t1\\t31\\t16493\\t2\\n27\\t  TABLE ACCESS BY INDEX ROWID ACCOUNTS\\t2\\t1\\t30\\t16548\\t2\\n28\\t   INDEX UNIQUE SCAN SYS_C008302\\t1\\t1\\t\\t9021\\t1\\n29\\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_TYPES\\t1\\t1\\t50\\t9021\\t1\\n30\\t  INDEX UNIQUE SCAN SYS_C008304\\t1\\t1\\t\\t9021\\t1\\n31\\t  TABLE ACCESS FULL ACCOUNT_TYPES\\t1\\t1\\t50\\t9021\\t1\\n32\\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_HEADERS\\t2\\t1\\t48\\t16333\\t2\\n33\\t  INDEX UNIQUE SCAN SYS_C008303\\t1\\t1\\t\\t9021\\t1\\n34\\t  TABLE ACCESS FULL ACCOUNT_HEADERS\\t2\\t1\\t48\\t16333\\t2\\n35\\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_LINKS\\t2\\t1\\t26\\t15293\\t2\\n36\\t  INDEX RANGE SCAN IDX_ACCL_ACCOUNT_SUBACC\\t2\\t10\\t\\t15293\\t2\\n37\\t  TABLE ACCESS FULL ACCOUNT_LINKS\\t2\\t1\\t26\\t15293\\t2\\n38\\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_HOLDING_TAX\\t3\\t1\\t30\\t22644\\t3\\n39\\t  INDEX RANGE SCAN IDX_ACCTAX_COMPOSITE\\t2\\t1\\t\\t15293\\t2\\n40\\t  TABLE ACCESS FULL ACCOUNT_HOLDING_TAX\\t3\\t1\\t30\\t22644\\t3\\n41\\t  VIEW PUSHED PREDICATE  \\t23\\t1\\t13\\t173930\\t23\\n42\\t  FILTER  \\t\\t\\t\\t\\t\\n43\\t   SORT AGGREGATE \\t\\t1\\t40\\t\\t\\n44\\t  TABLE ACCESS BY INDEX ROWID BATCHED TRANSACTIONS\\t23\\t1\\t40\\t173930\\t23\\n45\\t  INDEX RANGE SCAN IDX_TRANS_ACCOUNT_SUBACC\\t3\\t20\\t\\t25364\\t3\\n46\\t  INDEX UNIQUE SCAN SYS_C008308\\t1\\t1\\t\\t9021\\t1\\n47\\t  TABLE ACCESS BY INDEX ROWID TRANSACTIONS\\t2\\t1\\t15\\t16433\\t2\\n48\\t   TABLE ACCESS FULL TRANSACTIONS\\t2\\t1\\t15\\t16433\\t2\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE accounts_seq; CREATE TABLE accounts (acc_account_no VARCHAR2(50), acc_subacc_no VARCHAR2(50), acc_incep_date DATE NOT NULL, acc_act_code VARCHAR2(20), acc_gact_type VARCHAR2(10), PRIMARY KEY (acc_account_no, acc_subacc_no)); CREATE OR REPLACE TRIGGER accounts_bi BEFORE INSERT ON accounts FOR EACH ROW BEGIN NULL; END;\nCREATE INDEX idx_accounts_act_code ON accounts(acc_act_code);\nCREATE INDEX idx_accounts_gact_type ON accounts(acc_gact_type);\nCREATE INDEX idx_accounts_incep_date ON accounts(acc_incep_date);\nCREATE SEQUENCE account_headers_seq; CREATE TABLE account_headers (acch_account_no VARCHAR2(50) PRIMARY KEY, acch_title VARCHAR2(200), acch_brn_code VARCHAR2(20)); CREATE OR REPLACE TRIGGER account_headers_bi BEFORE INSERT ON account_headers FOR EACH ROW BEGIN NULL; END;\nCREATE INDEX idx_acch_account_no ON account_headers(acch_account_no);\nCREATE SEQUENCE account_types_seq; CREATE TABLE account_types (act_code VARCHAR2(20) PRIMARY KEY, act_long_name VARCHAR2(100)); CREATE OR REPLACE TRIGGER account_types_bi BEFORE INSERT ON account_types FOR EACH ROW BEGIN NULL; END;\nCREATE SEQUENCE transactions_seq; CREATE TABLE transactions (tran_seqno NUMBER PRIMARY KEY, tran_account_no VARCHAR2(50) NOT NULL, tran_subacc_no VARCHAR2(50) NOT NULL, tran_date DATE NOT NULL, tran_amount_cr NUMBER(18,2), tran_trans_code VARCHAR2(20), tran_pay_method VARCHAR2(10), tran_create_by VARCHAR2(50)); CREATE OR REPLACE TRIGGER transactions_bi BEFORE INSERT ON transactions FOR EACH ROW BEGIN IF :NEW.tran_seqno IS NULL THEN SELECT transactions_seq.NEXTVAL INTO :NEW.tran_seqno FROM DUAL; END IF; END;\nCREATE INDEX idx_trans_account_subacc ON transactions(tran_account_no, tran_subacc_no);\nCREATE INDEX idx_trans_date ON transactions(tran_date);\nCREATE INDEX idx_trans_trans_code ON transactions(tran_trans_code);\nCREATE INDEX idx_trans_pay_method ON transactions(tran_pay_method);\nCREATE SEQUENCE audit_header_seq; CREATE TABLE audit_header (audh_seqno NUMBER PRIMARY KEY, audh_key1 VARCHAR2(50), audh_key2 VARCHAR2(50), audh_date DATE, audh_table_prefix VARCHAR2(20), audh_change_type VARCHAR2(10)); CREATE OR REPLACE TRIGGER audit_header_bi BEFORE INSERT ON audit_header FOR EACH ROW BEGIN IF :NEW.audh_seqno IS NULL THEN SELECT audit_header_seq.NEXTVAL INTO :NEW.audh_seqno FROM DUAL; END IF; END;\nCREATE INDEX idx_audh_keys ON audit_header(audh_key1, audh_key2);\nCREATE INDEX idx_audh_table_prefix ON audit_header(audh_table_prefix);\nCREATE INDEX idx_audh_change_type ON audit_header(audh_change_type);\nCREATE SEQUENCE audit_detail_seq; CREATE TABLE audit_detail (audd_id NUMBER PRIMARY KEY, audd_audh_seqno NUMBER NOT NULL, audd_col_sufix VARCHAR2(50), audd_old_value VARCHAR2(200), audd_new_value VARCHAR2(200)); CREATE OR REPLACE TRIGGER audit_detail_bi BEFORE INSERT ON audit_detail FOR EACH ROW BEGIN IF :NEW.audd_id IS NULL THEN SELECT audit_detail_seq.NEXTVAL INTO :NEW.audd_id FROM DUAL; END IF; END;\nCREATE INDEX idx_audd_audh_seqno ON audit_detail(audd_audh_seqno);\nCREATE INDEX idx_audd_col_sufix ON audit_detail(audd_col_sufix);\nCREATE SEQUENCE account_links_seq; CREATE TABLE ACCOUNT_LINKS (accl_id NUMBER PRIMARY KEY, accl_account_no VARCHAR2(50) NOT NULL, accl_subacc_no VARCHAR2(50) NOT NULL, accl_holder_pos NUMBER, accl_cust_seqno NUMBER); CREATE OR REPLACE TRIGGER account_links_bi BEFORE INSERT ON ACCOUNT_LINKS FOR EACH ROW BEGIN IF :NEW.accl_id IS NULL THEN SELECT account_links_seq.NEXTVAL INTO :NEW.accl_id FROM DUAL; END IF; END;\nCREATE INDEX idx_accl_account_subacc ON ACCOUNT_LINKS(accl_account_no, accl_subacc_no);\nCREATE INDEX idx_accl_holder_pos ON ACCOUNT_LINKS(accl_holder_pos);\nCREATE SEQUENCE account_holding_tax_seq; CREATE TABLE SUMMIT.ACCOUNT_HOLDING_TAX (acctax_id NUMBER PRIMARY KEY, ACCTAX_ACCOUNT_NO VARCHAR2(50) NOT NULL, ACCTAX_SUBACC_NO VARCHAR2(50) NOT NULL, ACCTAX_CUST_SEQNO NUMBER, ACCTAX_EFF_DATE_FROM DATE); CREATE OR REPLACE TRIGGER account_holding_tax_bi BEFORE INSERT ON SUMMIT.ACCOUNT_HOLDING_TAX FOR EACH ROW BEGIN IF :NEW.acctax_id IS NULL THEN SELECT account_holding_tax_seq.NEXTVAL INTO :NEW.acctax_id FROM DUAL; END IF; END;\nCREATE INDEX idx_acctax_composite ON SUMMIT.ACCOUNT_HOLDING_TAX(ACCTAX_ACCOUNT_NO, ACCTAX_SUBACC_NO, ACCTAX_CUST_SEQNO);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t1320\t1\t264\t333735386\t1311\n1\t  HASH UNIQUE \t1320\t1\t264\t333735386\t1311\n2\t  HASH JOIN  \t1319\t1\t264\t296866817\t1311\n3\t   NESTED LOOPS  \t1319\t1\t264\t296866817\t1311\n4\t  NESTED LOOPS  \t1319\t1\t264\t296866817\t1311\n5\t  STATISTICS COLLECTOR  \t\t\t\t\t\n6\t   NESTED LOOPS  \t1317\t1\t249\t296850384\t1309\n7\t  HASH JOIN  \t1294\t1\t236\t296676455\t1286\n8\t  NESTED LOOPS  \t1294\t1\t236\t296676455\t1286\n9\t   STATISTICS COLLECTOR  \t\t\t\t\t\n10\t  HASH JOIN  \t1291\t1\t206\t296653810\t1283\n11\t  NESTED LOOPS  \t1291\t1\t206\t296653810\t1283\n12\t   STATISTICS COLLECTOR  \t\t\t\t\t\n13\t  HASH JOIN  \t1289\t1\t180\t296638517\t1281\n14\t  NESTED LOOPS  \t1289\t1\t180\t296638517\t1281\n15\t   STATISTICS COLLECTOR  \t\t\t\t\t\n16\t  HASH JOIN  \t1287\t1\t132\t296622185\t1279\n17\t  NESTED LOOPS  \t1287\t1\t132\t296622185\t1279\n18\t   STATISTICS COLLECTOR  \t\t\t\t\t\n19\t  NESTED LOOPS  \t1283\t4\t328\t296586099\t1275\n20\t  HASH JOIN  \t1278\t4\t208\t296542487\t1270\n21\t   NESTED LOOPS  \t1278\t4\t208\t296542487\t1270\n22\t  STATISTICS COLLECTOR  \t\t\t\t\t\n23\t  TABLE ACCESS FULL AUDIT_DETAIL\t1270\t4\t84\t296476515\t1262\n24\t  TABLE ACCESS BY INDEX ROWID AUDIT_HEADER\t2\t1\t31\t16493\t2\n25\t  INDEX UNIQUE SCAN SYS_C008309\t1\t1\t\t9021\t1\n26\t   TABLE ACCESS FULL AUDIT_HEADER\t2\t1\t31\t16493\t2\n27\t  TABLE ACCESS BY INDEX ROWID ACCOUNTS\t2\t1\t30\t16548\t2\n28\t   INDEX UNIQUE SCAN SYS_C008302\t1\t1\t\t9021\t1\n29\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_TYPES\t1\t1\t50\t9021\t1\n30\t  INDEX UNIQUE SCAN SYS_C008304\t1\t1\t\t9021\t1\n31\t  TABLE ACCESS FULL ACCOUNT_TYPES\t1\t1\t50\t9021\t1\n32\t   TABLE ACCESS BY INDEX ROWID ACCOUNT_HEADERS\t2\t1\t48\t16333\t2\n33\t  INDEX UNIQUE SCAN SYS_C008303\t1\t1\t\t9021\t1\n34\t  TABLE ACCESS FULL ACCOUNT_HEADERS\t2\t1\t48\t16333\t2\n35\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_LINKS\t2\t1\t26\t15293\t2\n36\t  INDEX RANGE SCAN IDX_ACCL_ACCOUNT_SUBACC\t2\t10\t\t15293\t2\n37\t  TABLE ACCESS FULL ACCOUNT_LINKS\t2\t1\t26\t15293\t2\n38\t   TABLE ACCESS BY INDEX ROWID BATCHED ACCOUNT_HOLDING_TAX\t3\t1\t30\t22644\t3\n39\t  INDEX RANGE SCAN IDX_ACCTAX_COMPOSITE\t2\t1\t\t15293\t2\n40\t  TABLE ACCESS FULL ACCOUNT_HOLDING_TAX\t3\t1\t30\t22644\t3\n41\t  VIEW PUSHED PREDICATE  \t23\t1\t13\t173930\t23\n42\t  FILTER  \t\t\t\t\t\n43\t   SORT AGGREGATE \t\t1\t40\t\t\n44\t  TABLE ACCESS BY INDEX ROWID BATCHED TRANSACTIONS\t23\t1\t40\t173930\t23\n45\t  INDEX RANGE SCAN IDX_TRANS_ACCOUNT_SUBACC\t3\t20\t\t25364\t3\n46\t  INDEX UNIQUE SCAN SYS_C008308\t1\t1\t\t9021\t1\n47\t  TABLE ACCESS BY INDEX ROWID TRANSACTIONS\t2\t1\t15\t16433\t2\n48\t   TABLE ACCESS FULL TRANSACTIONS\t2\t1\t15\t16433\t2\n\n## Original SQL:\nSELECT DISTINCT acc_account_no, \n  acc_subacc_no, \n  acch_title,\n  to_char(acc_incep_date,'DD/MM/YYYY') acc_incep_date,\n  htax.ACCTAX_EFF_DATE_FROM,\n  to_char(onhold_accounts.audh_date, 'DD-MON-YYYY') approved_date,\n  act_long_name, \n  tran_amount_cr,\n  tran_create_by,\n  CASE WHEN (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) < 0 THEN 0 ELSE\n   (trunc(acc_incep_date) - trunc(onhold_accounts.audh_date)) END time_on_approved,\n  acch_brn_code\n  FROM\n  (\n   (\n  SELECT accounts.acc_account_no,\n   acch_title, \n   accounts.acc_subacc_no,\n   acc_incep_date,\n   act_long_name,\n   tran_amount_cr,\n   transactions.tran_create_by,\n   first_tran_date,\n   acch_brn_code\n  FROM accounts \n  JOIN account_headers ON account_headers.acch_account_no = accounts.acc_account_no\n  JOIN account_types ON acc_act_code = act_code\n  JOIN \n   (\n  SELECT tran_account_no, tran_subacc_no, min(tran_seqno) first_tran_seq, min(tran_date) first_tran_date\n  FROM transactions\n  WHERE tran_amount_cr IS NOT NULL\n  AND tran_trans_code IN ('RIC','RSAV')\n  AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE\n  AND tran_pay_method not in ('C','CQ')   --Exclude cash and cheque receipts as those accounts will already have the passbook.\n  GROUP BY tran_account_no, tran_subacc_no\n   ) first_trans\n   ON tran_account_no = acc_account_no AND tran_subacc_no = acc_subacc_no\n  JOIN transactions ON tran_seqno = first_trans.first_tran_seq\n  WHERE acc_gact_type IN ('S', 'IC') \n   AND acc_incep_date BETWEEN IN_INCEP_FROM_DATE and IN_INCEP_TO_DATE\n   ) opened_accounts\n   JOIN\n   (\n  SELECT audh_key1, audh_key2, audh_date, audd_old_value, audd_new_value\n  FROM audit_header\n  JOIN audit_detail\n   ON audh_seqno = audd_audh_seqno\n  WHERE audh_table_prefix = 'ACC'\n   AND audd_col_sufix = 'PROCESS_STATUS'\n   AND audh_change_type  = 'I'\n   AND audd_old_value IS NULL \n   AND audd_new_value = 1\n   ) onhold_accounts\n  ON opened_accounts.acc_account_no = onhold_accounts.audh_key1\n   AND opened_accounts.acc_subacc_no = onhold_accounts.audh_key2\n   JOIN ACCOUNT_LINKS al ON al.accl_account_no = opened_accounts.ACC_ACCOUNT_NO and al.accl_subacc_no = opened_accounts.ACC_SUBACC_NO and al.accl_holder_pos = 1\n   JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax \n  ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO\n   AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO\n   AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO\n  )\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT DISTINCT a.acc_account_no, a.acc_subacc_no, ah.acch_title, TO_CHAR(a.acc_incep_date,'DD/MM/YYYY') acc_incep_date, htax.ACCTAX_EFF_DATE_FROM, TO_CHAR(ad.audh_date, 'DD-MON-YYYY') approved_date, at.act_long_name, t.tran_amount_cr, t.tran_create_by, CASE WHEN (TRUNC(a.acc_incep_date) - TRUNC(ad.audh_date)) < 0 THEN 0 ELSE (TRUNC(a.acc_incep_date) - TRUNC(ad.audh_date)) END time_on_approved, ah.acch_brn_code FROM accounts a INNER JOIN account_headers ah ON ah.acch_account_no = a.acc_account_no INNER JOIN account_types at ON a.acc_act_code = at.act_code INNER JOIN (SELECT tran_account_no, tran_subacc_no, MIN(tran_seqno) first_tran_seq FROM transactions WHERE tran_amount_cr IS NOT NULL AND tran_trans_code IN ('RIC','RSAV') AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE AND tran_pay_method NOT IN ('C','CQ') GROUP BY tran_account_no, tran_subacc_no) ft ON ft.tran_account_no = a.acc_account_no AND ft.tran_subacc_no = a.acc_subacc_no INNER JOIN transactions t ON t.tran_seqno = ft.first_tran_seq INNER JOIN audit_header ad ON ad.audh_key1 = a.acc_account_no AND ad.audh_key2 = a.acc_subacc_no AND ad.audh_table_prefix = 'ACC' AND ad.audh_change_type = 'I' INNER JOIN audit_detail audd ON ad.audh_seqno = audd.audd_audh_seqno AND audd.audd_col_sufix = 'PROCESS_STATUS' AND audd.audd_old_value IS NULL AND audd.audd_new_value = 1 INNER JOIN ACCOUNT_LINKS al ON al.accl_account_no = a.acc_account_no AND al.accl_subacc_no = a.acc_subacc_no AND al.accl_holder_pos = 1 INNER JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO WHERE a.acc_gact_type IN ('S', 'IC') AND a.acc_incep_date BETWEEN IN_INCEP_FROM_DATE AND IN_INCEP_TO_DATE;"
                    }
                ]
            },
            {
                "case_id": "29",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"29\", \"db_type\": \"oracle\", \"description\": \"改写试图通过三个方向优化：1）谓词优化：将SUBSTR函数改为LIKE谓词以便索引扫描；将HAVING COUNT(DECODE())改为简单的WHERE过滤；2）投影裁剪：对于COUNT(*)查询，将SELECT所有列改为SELECT 1，减少数据传输；3）数据预过滤：在连接前通过内联视图过滤数据。理论上这些都是常见的优化技术，但在本案例中，HAVING到WHERE的转换导致优化器基数估算失准，反而产生了更差的执行计划。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE SEQUENCE jobinfo_his_seq; CREATE TABLE jobinfo_his (id NUMBER PRIMARY KEY, jobid VARCHAR2(50) NOT NULL, tellercode VARCHAR2(50), jobname VARCHAR2(100), jobstatus VARCHAR2(10), jobstartpersname VARCHAR2(100), jobpriorpersname VARCHAR2(100), jobtype VARCHAR2(50), createtime DATE NOT NULL, tranname VARCHAR2(100), issucc VARCHAR2(1), tranprop VARCHAR2(100), trandata VARCHAR2(4000), jbjg VARCHAR2(100), jbgy VARCHAR2(100), ldlcid VARCHAR2(50)); CREATE OR REPLACE TRIGGER jobinfo_his_bi BEFORE INSERT ON jobinfo_his FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT jobinfo_his_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_jobinfo_his_jobid ON jobinfo_his(jobid);\", \"CREATE INDEX idx_jobinfo_his_status ON jobinfo_his(jobstatus);\", \"CREATE INDEX idx_jobinfo_his_createtime ON jobinfo_his(createtime);\", \"CREATE INDEX idx_jobinfo_his_composite ON jobinfo_his(jobid, jobstatus, createtime);\", \"CREATE SEQUENCE businodeinst_seq; CREATE TABLE businodeinst (id NUMBER PRIMARY KEY, nodeinstid VARCHAR2(50) NOT NULL, flowinstid VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER businodeinst_bi BEFORE INSERT ON businodeinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT businodeinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_businodeinst_nodeinstid ON businodeinst(nodeinstid);\", \"CREATE INDEX idx_businodeinst_flowinstid ON businodeinst(flowinstid);\", \"CREATE SEQUENCE busiflowinst_seq; CREATE TABLE busiflowinst (id NUMBER PRIMARY KEY, flowinstid VARCHAR2(50) NOT NULL, status VARCHAR2(10)); CREATE OR REPLACE TRIGGER busiflowinst_bi BEFORE INSERT ON busiflowinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT busiflowinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_busiflowinst_flowinstid ON busiflowinst(flowinstid);\", \"CREATE INDEX idx_busiflowinst_composite ON busiflowinst(flowinstid, status);\"], \"sql\": \"select\\n  count(*)\\nfrom\\n  (\\n  select\\n   tt.jobid,\\n   tt.tellercode,\\n   tt.jobname,\\n   tt.jobstatus,\\n   tt.jobstartpersname,\\n   tt.jobpriorpersname,\\n   tt.jobtype,\\n   tt.createtime,\\n   tt.tranname,\\n   tt.issucc,\\n   tt.tranprop,\\n   tt.trandata,\\n   tt.jbjg,\\n   tt.jbgy,\\n   tt.ldlcid\\n  from\\n   (\\n  select\\n  t3.jobid,\\n  t3.tellercode,\\n  t3.jobname,\\n  t3.jobstatus,\\n  t3.jobstartpersname,\\n  t3.jobpriorpersname,\\n  t3.jobtype,\\n  t3.createtime,\\n  t3.tranname,\\n  t3.issucc,\\n  t3.tranprop,\\n  t3.trandata,\\n  t3.jbjg,\\n  t3.jbgy,\\n  t3.ldlcid,\\n  row_number() over (\\n   partition by\\n  t3.jobid\\n   order by\\n  t3.createtime desc\\n  ) as rn\\n  from\\n  jobinfo_his t3\\n  where\\n  exists (\\n   select\\n  t2.jobid\\n   from\\n  jobinfo_his t2\\n   where\\n  t2.jobid = t3.jobid\\n  and exists (\\n  select\\n   t1.jobid\\n  from\\n   jobinfo_his t1\\n  where\\n   t1.jobid = t2.jobid\\n   and t1.jobstatus = 'O'\\n   and substr(jobid, 0, 1) = 'A'\\n  )\\n   group by\\n  t2.jobid\\n   having\\n  count(decode(t2.jobstatus, 'N', 1, null)) = 0\\n  )\\n   ) tt\\n  where\\n   tt.rn = 1\\n  union all\\n  select\\n   t.jobid,\\n   t.tellercode,\\n   t.jobname,\\n   t.jobstatus,\\n   t.jobstartpersname,\\n   t.jobpriorpersname,\\n   t.jobtype,\\n   t.createtime,\\n   t.tranname,\\n   t.issucc,\\n   t.tranprop,\\n   t.trandata,\\n   t.jbjg,\\n   t.jbgy,\\n   t.ldlcid\\n  from\\n   jobinfo_his t,\\n   businodeinst t1,\\n   busiflowinst t2\\n  where\\n   t.jobid = t1.nodeinstid\\n   and t1.flowinstid = t2.flowinstid\\n   and t2.status = '1'\\n   and t.jobstatus = 'O'\\n  )\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t11679\\t1\\t\\t1903461107\\t11627\\n1\\t  SORT AGGREGATE \\t\\t1\\t\\t\\t\\n2\\t  VIEW  \\t11679\\t343333\\t\\t1903461107\\t11627\\n3\\t   UNION-ALL  \\t\\t\\t\\t\\t\\n4\\t  VIEW  \\t4181\\t10000\\t130000\\t837889750\\t4158\\n5\\t  WINDOW SORT PUSHED RANK \\t4181\\t10000\\t290000\\t837889750\\t4158\\n6\\t   NESTED LOOPS  \\t4180\\t10000\\t290000\\t795034459\\t4158\\n7\\t  VIEW  VW_NSO_1\\t3611\\t500\\t5500\\t785488019\\t3590\\n8\\t  HASH GROUP BY \\t3611\\t500\\t12000\\t785488019\\t3590\\n9\\t   HASH JOIN RIGHT SEMI \\t3609\\t64600\\t1550400\\t702111454\\t3590\\n10\\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1807\\t3333\\t39996\\t433839085\\t1795\\n11\\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1800\\t1000000\\t12000000\\t167172419\\t1795\\n12\\t  INDEX RANGE SCAN IDX_JOBINFO_HIS_COMPOSITE\\t2\\t20\\t360\\t19093\\t2\\n13\\t  HASH JOIN  \\t7498\\t333333\\t16666650\\t1065571358\\t7469\\n14\\t  INDEX FAST FULL SCAN IDX_BUSIFLOWINST_COMPOSITE\\t957\\t500000\\t7500000\\t194989133\\t952\\n15\\t  HASH JOIN  \\t5157\\t333333\\t11666655\\t713706795\\t5138\\n16\\t   NESTED LOOPS  \\t5157\\t333333\\t11666655\\t713706795\\t5138\\n17\\t  NESTED LOOPS  \\t\\t\\t\\t\\t\\n18\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n19\\t   INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\\t1801\\t333333\\t3999996\\t217172419\\t1795\\n20\\t  INDEX RANGE SCAN IDX_BUSINODEINST_NODEINSTID\\t\\t\\t\\t\\t\\n21\\t  TABLE ACCESS BY INDEX ROWID BUSINODEINST\\t1316\\t1\\t23\\t224396555\\t1310\\n22\\t   TABLE ACCESS FULL BUSINODEINST\\t1316\\t1000000\\t23000000\\t224396555\\t1310\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE jobinfo_his_seq; CREATE TABLE jobinfo_his (id NUMBER PRIMARY KEY, jobid VARCHAR2(50) NOT NULL, tellercode VARCHAR2(50), jobname VARCHAR2(100), jobstatus VARCHAR2(10), jobstartpersname VARCHAR2(100), jobpriorpersname VARCHAR2(100), jobtype VARCHAR2(50), createtime DATE NOT NULL, tranname VARCHAR2(100), issucc VARCHAR2(1), tranprop VARCHAR2(100), trandata VARCHAR2(4000), jbjg VARCHAR2(100), jbgy VARCHAR2(100), ldlcid VARCHAR2(50)); CREATE OR REPLACE TRIGGER jobinfo_his_bi BEFORE INSERT ON jobinfo_his FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT jobinfo_his_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_jobinfo_his_jobid ON jobinfo_his(jobid);\nCREATE INDEX idx_jobinfo_his_status ON jobinfo_his(jobstatus);\nCREATE INDEX idx_jobinfo_his_createtime ON jobinfo_his(createtime);\nCREATE INDEX idx_jobinfo_his_composite ON jobinfo_his(jobid, jobstatus, createtime);\nCREATE SEQUENCE businodeinst_seq; CREATE TABLE businodeinst (id NUMBER PRIMARY KEY, nodeinstid VARCHAR2(50) NOT NULL, flowinstid VARCHAR2(50) NOT NULL); CREATE OR REPLACE TRIGGER businodeinst_bi BEFORE INSERT ON businodeinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT businodeinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_businodeinst_nodeinstid ON businodeinst(nodeinstid);\nCREATE INDEX idx_businodeinst_flowinstid ON businodeinst(flowinstid);\nCREATE SEQUENCE busiflowinst_seq; CREATE TABLE busiflowinst (id NUMBER PRIMARY KEY, flowinstid VARCHAR2(50) NOT NULL, status VARCHAR2(10)); CREATE OR REPLACE TRIGGER busiflowinst_bi BEFORE INSERT ON busiflowinst FOR EACH ROW BEGIN IF :NEW.id IS NULL THEN SELECT busiflowinst_seq.NEXTVAL INTO :NEW.id FROM DUAL; END IF; END;\nCREATE INDEX idx_busiflowinst_flowinstid ON busiflowinst(flowinstid);\nCREATE INDEX idx_busiflowinst_composite ON busiflowinst(flowinstid, status);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t11679\t1\t\t1903461107\t11627\n1\t  SORT AGGREGATE \t\t1\t\t\t\n2\t  VIEW  \t11679\t343333\t\t1903461107\t11627\n3\t   UNION-ALL  \t\t\t\t\t\n4\t  VIEW  \t4181\t10000\t130000\t837889750\t4158\n5\t  WINDOW SORT PUSHED RANK \t4181\t10000\t290000\t837889750\t4158\n6\t   NESTED LOOPS  \t4180\t10000\t290000\t795034459\t4158\n7\t  VIEW  VW_NSO_1\t3611\t500\t5500\t785488019\t3590\n8\t  HASH GROUP BY \t3611\t500\t12000\t785488019\t3590\n9\t   HASH JOIN RIGHT SEMI \t3609\t64600\t1550400\t702111454\t3590\n10\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1807\t3333\t39996\t433839085\t1795\n11\t  INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1800\t1000000\t12000000\t167172419\t1795\n12\t  INDEX RANGE SCAN IDX_JOBINFO_HIS_COMPOSITE\t2\t20\t360\t19093\t2\n13\t  HASH JOIN  \t7498\t333333\t16666650\t1065571358\t7469\n14\t  INDEX FAST FULL SCAN IDX_BUSIFLOWINST_COMPOSITE\t957\t500000\t7500000\t194989133\t952\n15\t  HASH JOIN  \t5157\t333333\t11666655\t713706795\t5138\n16\t   NESTED LOOPS  \t5157\t333333\t11666655\t713706795\t5138\n17\t  NESTED LOOPS  \t\t\t\t\t\n18\t  STATISTICS COLLECTOR  \t\t\t\t\t\n19\t   INDEX FAST FULL SCAN IDX_JOBINFO_HIS_COMPOSITE\t1801\t333333\t3999996\t217172419\t1795\n20\t  INDEX RANGE SCAN IDX_BUSINODEINST_NODEINSTID\t\t\t\t\t\n21\t  TABLE ACCESS BY INDEX ROWID BUSINODEINST\t1316\t1\t23\t224396555\t1310\n22\t   TABLE ACCESS FULL BUSINODEINST\t1316\t1000000\t23000000\t224396555\t1310\n\n## Original SQL:\nselect\n  count(*)\nfrom\n  (\n  select\n   tt.jobid,\n   tt.tellercode,\n   tt.jobname,\n   tt.jobstatus,\n   tt.jobstartpersname,\n   tt.jobpriorpersname,\n   tt.jobtype,\n   tt.createtime,\n   tt.tranname,\n   tt.issucc,\n   tt.tranprop,\n   tt.trandata,\n   tt.jbjg,\n   tt.jbgy,\n   tt.ldlcid\n  from\n   (\n  select\n  t3.jobid,\n  t3.tellercode,\n  t3.jobname,\n  t3.jobstatus,\n  t3.jobstartpersname,\n  t3.jobpriorpersname,\n  t3.jobtype,\n  t3.createtime,\n  t3.tranname,\n  t3.issucc,\n  t3.tranprop,\n  t3.trandata,\n  t3.jbjg,\n  t3.jbgy,\n  t3.ldlcid,\n  row_number() over (\n   partition by\n  t3.jobid\n   order by\n  t3.createtime desc\n  ) as rn\n  from\n  jobinfo_his t3\n  where\n  exists (\n   select\n  t2.jobid\n   from\n  jobinfo_his t2\n   where\n  t2.jobid = t3.jobid\n  and exists (\n  select\n   t1.jobid\n  from\n   jobinfo_his t1\n  where\n   t1.jobid = t2.jobid\n   and t1.jobstatus = 'O'\n   and substr(jobid, 0, 1) = 'A'\n  )\n   group by\n  t2.jobid\n   having\n  count(decode(t2.jobstatus, 'N', 1, null)) = 0\n  )\n   ) tt\n  where\n   tt.rn = 1\n  union all\n  select\n   t.jobid,\n   t.tellercode,\n   t.jobname,\n   t.jobstatus,\n   t.jobstartpersname,\n   t.jobpriorpersname,\n   t.jobtype,\n   t.createtime,\n   t.tranname,\n   t.issucc,\n   t.tranprop,\n   t.trandata,\n   t.jbjg,\n   t.jbgy,\n   t.ldlcid\n  from\n   jobinfo_his t,\n   businodeinst t1,\n   busiflowinst t2\n  where\n   t.jobid = t1.nodeinstid\n   and t1.flowinstid = t2.flowinstid\n   and t2.status = '1'\n   and t.jobstatus = 'O'\n  )\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select count(*) from (select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid from (select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid, row_number() over (partition by t.jobid order by t.createtime desc) as rn from jobinfo_his t where t.jobid like 'A%' and exists (select 1 from jobinfo_his where jobid = t.jobid and jobstatus = 'O') and not exists (select 1 from jobinfo_his where jobid = t.jobid and jobstatus = 'N')) where rn = 1 union all select t.jobid, t.tellercode, t.jobname, t.jobstatus, t.jobstartpersname, t.jobpriorpersname, t.jobtype, t.createtime, t.tranname, t.issucc, t.tranprop, t.trandata, t.jbjg, t.jbgy, t.ldlcid from jobinfo_his t inner join businodeinst t1 on t.jobid = t1.nodeinstid inner join busiflowinst t2 on t1.flowinstid = t2.flowinstid where t2.status = '1' and t.jobstatus = 'O')"
                    }
                ]
            },
            {
                "case_id": "30",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"30\", \"db_type\": \"oracle\", \"description\": \"此改写的核心是将原SQL中针对nortran表的7个独立子查询(n1-n7)和1个去重子查询(z)通过CTE的GROUP BY + MAX + CASE WHEN技术合并。原SQL中每个子查询都有WHERE条件过滤不同的nortran_aufd_code，改写后通过CASE WHEN在单次扫描中同时提取所有需要的字段值，然后用MAX聚合选择每个transaction的值。这种行列转换技术将EAV(Entity-Attribute-Value)模型的多行数据透视为宽表的单行数据。同时，将nobtran的过滤条件前置，减少JOIN时的数据量。这种改写方式在OLAP场景中常用于优化维度属性的多次JOIN。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE SEQUENCE nobtran_seq; CREATE TABLE nobtran (nobtran_id NUMBER PRIMARY KEY, nobtran_transaction_no NUMBER NOT NULL, nobtran_acat_code VARCHAR2(20), nobtran_effective_date DATE, nobtran_trans_status_ind VARCHAR2(1), nobtran_pidm NUMBER NOT NULL, nobtran_apply_ind VARCHAR2(1) DEFAULT 'N'); CREATE OR REPLACE TRIGGER nobtran_bi BEFORE INSERT ON nobtran FOR EACH ROW BEGIN IF :NEW.nobtran_id IS NULL THEN SELECT nobtran_seq.NEXTVAL INTO :NEW.nobtran_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nobtran_acat_code ON nobtran(nobtran_acat_code);\", \"CREATE INDEX idx_nobtran_pidm ON nobtran(nobtran_pidm);\", \"CREATE INDEX idx_nobtran_transaction_no ON nobtran(nobtran_transaction_no);\", \"CREATE INDEX idx_nobtran_status ON nobtran(nobtran_trans_status_ind);\", \"CREATE INDEX idx_nobtran_apply_ind ON nobtran(nobtran_apply_ind);\", \"CREATE SEQUENCE spriden_seq; CREATE TABLE spriden (spriden_pidm NUMBER PRIMARY KEY, spriden_id VARCHAR2(50) NOT NULL, spriden_last_name VARCHAR2(100) NOT NULL, spriden_first_name VARCHAR2(100), spriden_change_ind VARCHAR2(1)); CREATE OR REPLACE TRIGGER spriden_bi BEFORE INSERT ON spriden FOR EACH ROW BEGIN IF :NEW.spriden_pidm IS NULL THEN SELECT spriden_seq.NEXTVAL INTO :NEW.spriden_pidm FROM DUAL; END IF; END;\", \"CREATE INDEX idx_spriden_change_ind ON spriden(spriden_change_ind);\", \"CREATE SEQUENCE norrout_seq; CREATE TABLE norrout (norrout_id NUMBER PRIMARY KEY, norrout_transaction_no NUMBER NOT NULL, norrout_queue_status_ind VARCHAR2(1), norrout_level_no NUMBER); CREATE OR REPLACE TRIGGER norrout_bi BEFORE INSERT ON norrout FOR EACH ROW BEGIN IF :NEW.norrout_id IS NULL THEN SELECT norrout_seq.NEXTVAL INTO :NEW.norrout_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_norrout_transaction_no ON norrout(norrout_transaction_no);\", \"CREATE INDEX idx_norrout_level_no ON norrout(norrout_level_no);\", \"CREATE INDEX idx_norrout_queue_status ON norrout(norrout_queue_status_ind);\", \"CREATE SEQUENCE pebempl_seq; CREATE TABLE pebempl (pebempl_pidm NUMBER PRIMARY KEY, pebempl_ecls_code VARCHAR2(10) NOT NULL, pebempl_current_hire_date DATE); CREATE OR REPLACE TRIGGER pebempl_bi BEFORE INSERT ON pebempl FOR EACH ROW BEGIN IF :NEW.pebempl_pidm IS NULL THEN SELECT pebempl_seq.NEXTVAL INTO :NEW.pebempl_pidm FROM DUAL; END IF; END;\", \"CREATE INDEX idx_pebempl_ecls_code ON pebempl(pebempl_ecls_code);\", \"CREATE SEQUENCE nortran_seq; CREATE TABLE nortran (nortran_id NUMBER PRIMARY KEY, nortran_transaction_no NUMBER NOT NULL, nortran_apty_code VARCHAR2(20), nortran_aufd_code VARCHAR2(50) NOT NULL, nortran_value VARCHAR2(200), nortran_posn VARCHAR2(50)); CREATE OR REPLACE TRIGGER nortran_bi BEFORE INSERT ON nortran FOR EACH ROW BEGIN IF :NEW.nortran_id IS NULL THEN SELECT nortran_seq.NEXTVAL INTO :NEW.nortran_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nortran_transaction_no ON nortran(nortran_transaction_no);\", \"CREATE INDEX idx_nortran_aufd_code ON nortran(nortran_aufd_code);\", \"CREATE INDEX idx_nortran_apty_code ON nortran(nortran_apty_code);\", \"CREATE SEQUENCE nortern_seq; CREATE TABLE nortern (nortern_id NUMBER PRIMARY KEY, nortern_transaction_no NUMBER NOT NULL, nortern_effective_date DATE, nortern_earn_code VARCHAR2(20), nortern_hrs NUMBER(10,2), nortern_special_rate NUMBER(15,2)); CREATE OR REPLACE TRIGGER nortern_bi BEFORE INSERT ON nortern FOR EACH ROW BEGIN IF :NEW.nortern_id IS NULL THEN SELECT nortern_seq.NEXTVAL INTO :NEW.nortern_id FROM DUAL; END IF; END;\", \"CREATE INDEX idx_nortern_transaction_no ON nortern(nortern_transaction_no);\"], \"sql\": \"select s.spriden_id EID,\\n  s.spriden_last_name ||', '||s.spriden_first_name \\\"NAME\\\",\\n  b.nobtran_transaction_no \\\"TRANS NO.\\\",\\n  z.nortran_posn \\\"POSN NO\\\",\\n  b.nobtran_effective_date \\\"QUERY DATE\\\", \\n  b.nobtran_acat_code \\\"ACAT CODE\\\",\\n  n1.nortran_value \\\"CURRENT HIRE DATE\\\",\\n  n2.nortran_value \\\"BEGIN PERSONNEL DATE\\\",\\n  n3.nortran_value \\\"SALARY GROUP\\\",\\n  n4.nortran_value \\\"APPOINTMENT PERCENT\\\",\\n  n5.nortran_value \\\"ANNUAL SALARY\\\",\\n  t1.nortern_effective_date \\\"PAY DATA EFFECTIVE DATE\\\",\\n  t1.nortern_earn_code \\\"PAY DATA EARNINGS\\\",\\n  t1.nortern_hrs \\\"PAY DATA HOURS\\\",\\n  t1.nortern_special_rate \\\"PAY DATA SPECIAL RATE\\\",\\n  n6.nortran_value \\\"END JOB EFFECTIVE DATE\\\",\\n  n7.nortran_value \\\"END PERSONNEL DATE\\\"\\n   ,case b.nobtran_trans_status_ind\\n   when 'A' then 'Approved'\\n   when 'C' then 'Completed'\\n   when 'V' then 'Voided' \\n   when 'D' then 'Disapproved'\\n   when 'R' then 'Return for Correction'\\n   when 'P' then 'Pending'\\n   when 'W' then 'Waiting'\\n   when 'T' then 'Partially Completed'\\n   when 'N' then 'Cancelled'\\n   when 'U' then 'Superuser Update'\\n  end trans_status   \\n  ,case r.norrout_queue_status_ind\\n   when 'A' then 'Approved by that Approver'\\n   when 'D' then 'Disapproved'\\n   when 'F' then 'FYI'\\n   when 'I' then 'In Queue'\\n   when 'K' then 'Acknowledged'\\n   when 'L' then 'Applied by Applier'\\n   when 'M' then 'More Information'\\n   when 'O' then 'Overridden'\\n   when 'P' then 'Pending Action by Approver/Applier '\\n   when 'Q' then 'Removed from Queue'\\n   when 'R' then 'Return for Correction'\\n  end queue_status\\n  ,r.norrout_level_no\\n  \\n\\n  from nobtran b,spriden s, norrout r, pebempl pp, /*nbrjobs nbr,*/\\n  (select nc.nortran_transaction_no,nc.nortran_apty_code,nc.nortran_aufd_code,nc.nortran_value\\n  from nortran nc\\n   where nc.nortran_aufd_code = 'PEBEMPL_CURRENT_HIRE_DATE'\\n  ) n1, /* Current Hire Date */\\n  (select nb.nortran_transaction_no,nb.nortran_apty_code,nb.nortran_aufd_code,nb.nortran_value\\n  from nortran nb\\n   where nb.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' \\n  ) n2,  /*Begin Personnnel Date*/ \\n  (select ns.nortran_transaction_no,ns.nortran_apty_code,ns.nortran_aufd_code,ns.nortran_value\\n  from nortran ns\\n   where ns.nortran_aufd_code = 'NBRJOBS_SGRP_CODE'\\n   ) n3, /* Salary Group */\\n  (select na.nortran_transaction_no,na.nortran_apty_code,na.nortran_aufd_code,na.nortran_value\\n  from nortran na\\n   where na.nortran_aufd_code = 'NBRJOBS_APPT_PCT'\\n  ) n4, /*Appointment Percent*/ \\n  (select nu.nortran_transaction_no,nu.nortran_apty_code,nu.nortran_aufd_code,nu.nortran_value\\n  from nortran nu\\n   where nu.nortran_aufd_code = 'NBRJOBS_ANN_SALARY'\\n  ) n5, /*Annual Salary*/\\n  (select nj.nortran_transaction_no,nj.nortran_apty_code,nj.nortran_aufd_code,nj.nortran_value\\n  from nortran nj\\n   where nj.nortran_aufd_code = 'NBRJOBS_EFFECTIVE_DATE'  \\n  and nj.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n6,  /*End Job Effective Date*/\\n  (select np.nortran_transaction_no,np.nortran_apty_code,np.nortran_aufd_code,np.nortran_value\\n  from nortran np\\n   where np.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE'  \\n  and np.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n7,  /*End Personnel Date*/\\n\\n  (select t.nortern_transaction_no,t.nortern_effective_date,t.nortern_earn_code,\\n   t.nortern_hrs, t.nortern_special_rate\\n  from nortern t) t1 \\n\\n   ,(select unique zz.nortran_transaction_no,zz.nortran_posn\\n  from nortran zz\\n   where zz.nortran_posn is not null\\n  ) z\\n\\n where b.nobtran_acat_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') /*employee*/\\n  /*waiting,completed,partially completedc,ancelled,supperuser update */\\n  /* and nobtran_trans_status_ind in ('W','C','T','U') */\\n   and b.nobtran_pidm = s.spriden_pidm\\n   and s.spriden_change_ind is null\\n   \\n   and b.nobtran_transaction_no = t1.nortern_transaction_no(+) /*Pay Data*/\\n   \\n   and b.nobtran_transaction_no = n1.nortran_transaction_no(+) /*Current Hire Date*/\\n   \\n   and b.nobtran_transaction_no = n2.nortran_transaction_no(+) /*Begin Personnnel Date*/\\n   \\n   and b.nobtran_transaction_no = n3.nortran_transaction_no(+) /*Salary Group*/\\n   \\n   and b.nobtran_transaction_no = n4.nortran_transaction_no(+) /*Appointment Percent*/\\n   \\n   and b.nobtran_transaction_no = n5.nortran_transaction_no(+) /*Annual Salary*/\\n   \\n   and b.nobtran_transaction_no = n6.nortran_transaction_no(+) /*End Job Effective Date*/\\n   \\n   and b.nobtran_transaction_no = n7.nortran_transaction_no(+) /*End Personnel Date*/\\n   \\n   and nobtran_transaction_no = r.norrout_transaction_no(+)\\n   --get all queue status\\n   /*and r.norrout_queue_status_ind = 'A'*/\\n   and r.norrout_level_no = 90 /* Pending HR approval Queue */\\n   -- not applied yet\\n   and b.nobtran_apply_ind = 'N' /*Applied ePAFs will not be listed*/\\n   --HR does not care about voided ePAFs\\n   and nobtran_trans_status_ind <> 'V'\\n   --get posn\\n   and b.nobtran_transaction_no = z.nortran_transaction_no\\n   and r.norrout_queue_status_ind <> 'A'\\n  -- exclude student\\n   and s.spriden_pidm = pp.pebempl_pidm\\n   and pp.pebempl_ecls_code not in ('RE','FW','GS','MW')\\n\\n   order by 3\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t68442\\t220696\\t81657520\\t10388402242\\t68160\\n1\\t  MERGE JOIN OUTER \\t68442\\t220696\\t81657520\\t10388402242\\t68160\\n2\\t  MERGE JOIN  \\t61068\\t220696\\t77243600\\t9073000336\\t60822\\n3\\t   MERGE JOIN OUTER \\t59624\\t1072825\\t366906150\\t8593654179\\t59391\\n4\\t  MERGE JOIN  \\t55673\\t1000048\\t302014496\\t8042006798\\t55455\\n5\\t  MERGE JOIN OUTER \\t40155\\t875042\\t236261340\\t5632420040\\t40002\\n6\\t   MERGE JOIN OUTER \\t36204\\t815681\\t187606630\\t5082114259\\t36066\\n7\\t  MERGE JOIN OUTER \\t32442\\t760347\\t149028012\\t4563228883\\t32318\\n8\\t  MERGE JOIN OUTER \\t28680\\t708767\\t114820254\\t4044718907\\t28570\\n9\\t   MERGE JOIN OUTER \\t24918\\t660686\\t84567808\\t3526558831\\t24822\\n10\\t  MERGE JOIN OUTER \\t21156\\t615866\\t57891404\\t3008724855\\t21074\\n11\\t  SORT JOIN \\t17394\\t574088\\t34445280\\t2491195079\\t17326\\n12\\t   HASH JOIN  \\t9138\\t574088\\t34445280\\t1827947896\\t9088\\n13\\t  HASH JOIN  \\t4697\\t656100\\t23619600\\t973767459\\t4671\\n14\\t  TABLE ACCESS FULL PEBEMPL\\t794\\t656100\\t3936600\\t362530962\\t784\\n15\\t  TABLE ACCESS FULL SPRIDEN\\t1351\\t1000000\\t30000000\\t285272492\\t1343\\n16\\t  TABLE ACCESS FULL NOBTRAN\\t1454\\t875000\\t21000000\\t548613482\\t1439\\n17\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n18\\t   TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n19\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n20\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n21\\t   SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n22\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n23\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n24\\t   TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n25\\t  SORT JOIN \\t3762\\t166667\\t5666678\\t513351976\\t3748\\n26\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t5666678\\t322092341\\t2236\\n27\\t   SORT JOIN \\t3951\\t166667\\t6666680\\t544369681\\t3936\\n28\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t6666680\\t350105675\\t2236\\n29\\t  SORT JOIN \\t15518\\t1000000\\t32000000\\t2409581958\\t15453\\n30\\t   VIEW  \\t6805\\t1000000\\t32000000\\t1336011571\\t6769\\n31\\t  HASH UNIQUE \\t6805\\t1000000\\t12000000\\t1336011571\\t6769\\n32\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t1000000\\t12000000\\t328759001\\t2236\\n33\\t  SORT JOIN \\t3951\\t166667\\t6666680\\t544369681\\t3936\\n34\\t  TABLE ACCESS FULL NORTRAN\\t2245\\t166667\\t6666680\\t350105675\\t2236\\n35\\t   SORT JOIN \\t1444\\t180000\\t1440000\\t479346156\\t1431\\n36\\t  TABLE ACCESS FULL NORROUT\\t792\\t180000\\t1440000\\t290580962\\t784\\n37\\t  SORT JOIN \\t7374\\t1000000\\t20000000\\t1315401906\\t7338\\n38\\t   TABLE ACCESS FULL NORTERN\\t1304\\t1000000\\t20000000\\t284040483\\t1296\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SEQUENCE nobtran_seq; CREATE TABLE nobtran (nobtran_id NUMBER PRIMARY KEY, nobtran_transaction_no NUMBER NOT NULL, nobtran_acat_code VARCHAR2(20), nobtran_effective_date DATE, nobtran_trans_status_ind VARCHAR2(1), nobtran_pidm NUMBER NOT NULL, nobtran_apply_ind VARCHAR2(1) DEFAULT 'N'); CREATE OR REPLACE TRIGGER nobtran_bi BEFORE INSERT ON nobtran FOR EACH ROW BEGIN IF :NEW.nobtran_id IS NULL THEN SELECT nobtran_seq.NEXTVAL INTO :NEW.nobtran_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nobtran_acat_code ON nobtran(nobtran_acat_code);\nCREATE INDEX idx_nobtran_pidm ON nobtran(nobtran_pidm);\nCREATE INDEX idx_nobtran_transaction_no ON nobtran(nobtran_transaction_no);\nCREATE INDEX idx_nobtran_status ON nobtran(nobtran_trans_status_ind);\nCREATE INDEX idx_nobtran_apply_ind ON nobtran(nobtran_apply_ind);\nCREATE SEQUENCE spriden_seq; CREATE TABLE spriden (spriden_pidm NUMBER PRIMARY KEY, spriden_id VARCHAR2(50) NOT NULL, spriden_last_name VARCHAR2(100) NOT NULL, spriden_first_name VARCHAR2(100), spriden_change_ind VARCHAR2(1)); CREATE OR REPLACE TRIGGER spriden_bi BEFORE INSERT ON spriden FOR EACH ROW BEGIN IF :NEW.spriden_pidm IS NULL THEN SELECT spriden_seq.NEXTVAL INTO :NEW.spriden_pidm FROM DUAL; END IF; END;\nCREATE INDEX idx_spriden_change_ind ON spriden(spriden_change_ind);\nCREATE SEQUENCE norrout_seq; CREATE TABLE norrout (norrout_id NUMBER PRIMARY KEY, norrout_transaction_no NUMBER NOT NULL, norrout_queue_status_ind VARCHAR2(1), norrout_level_no NUMBER); CREATE OR REPLACE TRIGGER norrout_bi BEFORE INSERT ON norrout FOR EACH ROW BEGIN IF :NEW.norrout_id IS NULL THEN SELECT norrout_seq.NEXTVAL INTO :NEW.norrout_id FROM DUAL; END IF; END;\nCREATE INDEX idx_norrout_transaction_no ON norrout(norrout_transaction_no);\nCREATE INDEX idx_norrout_level_no ON norrout(norrout_level_no);\nCREATE INDEX idx_norrout_queue_status ON norrout(norrout_queue_status_ind);\nCREATE SEQUENCE pebempl_seq; CREATE TABLE pebempl (pebempl_pidm NUMBER PRIMARY KEY, pebempl_ecls_code VARCHAR2(10) NOT NULL, pebempl_current_hire_date DATE); CREATE OR REPLACE TRIGGER pebempl_bi BEFORE INSERT ON pebempl FOR EACH ROW BEGIN IF :NEW.pebempl_pidm IS NULL THEN SELECT pebempl_seq.NEXTVAL INTO :NEW.pebempl_pidm FROM DUAL; END IF; END;\nCREATE INDEX idx_pebempl_ecls_code ON pebempl(pebempl_ecls_code);\nCREATE SEQUENCE nortran_seq; CREATE TABLE nortran (nortran_id NUMBER PRIMARY KEY, nortran_transaction_no NUMBER NOT NULL, nortran_apty_code VARCHAR2(20), nortran_aufd_code VARCHAR2(50) NOT NULL, nortran_value VARCHAR2(200), nortran_posn VARCHAR2(50)); CREATE OR REPLACE TRIGGER nortran_bi BEFORE INSERT ON nortran FOR EACH ROW BEGIN IF :NEW.nortran_id IS NULL THEN SELECT nortran_seq.NEXTVAL INTO :NEW.nortran_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nortran_transaction_no ON nortran(nortran_transaction_no);\nCREATE INDEX idx_nortran_aufd_code ON nortran(nortran_aufd_code);\nCREATE INDEX idx_nortran_apty_code ON nortran(nortran_apty_code);\nCREATE SEQUENCE nortern_seq; CREATE TABLE nortern (nortern_id NUMBER PRIMARY KEY, nortern_transaction_no NUMBER NOT NULL, nortern_effective_date DATE, nortern_earn_code VARCHAR2(20), nortern_hrs NUMBER(10,2), nortern_special_rate NUMBER(15,2)); CREATE OR REPLACE TRIGGER nortern_bi BEFORE INSERT ON nortern FOR EACH ROW BEGIN IF :NEW.nortern_id IS NULL THEN SELECT nortern_seq.NEXTVAL INTO :NEW.nortern_id FROM DUAL; END IF; END;\nCREATE INDEX idx_nortern_transaction_no ON nortern(nortern_transaction_no);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t68442\t220696\t81657520\t10388402242\t68160\n1\t  MERGE JOIN OUTER \t68442\t220696\t81657520\t10388402242\t68160\n2\t  MERGE JOIN  \t61068\t220696\t77243600\t9073000336\t60822\n3\t   MERGE JOIN OUTER \t59624\t1072825\t366906150\t8593654179\t59391\n4\t  MERGE JOIN  \t55673\t1000048\t302014496\t8042006798\t55455\n5\t  MERGE JOIN OUTER \t40155\t875042\t236261340\t5632420040\t40002\n6\t   MERGE JOIN OUTER \t36204\t815681\t187606630\t5082114259\t36066\n7\t  MERGE JOIN OUTER \t32442\t760347\t149028012\t4563228883\t32318\n8\t  MERGE JOIN OUTER \t28680\t708767\t114820254\t4044718907\t28570\n9\t   MERGE JOIN OUTER \t24918\t660686\t84567808\t3526558831\t24822\n10\t  MERGE JOIN OUTER \t21156\t615866\t57891404\t3008724855\t21074\n11\t  SORT JOIN \t17394\t574088\t34445280\t2491195079\t17326\n12\t   HASH JOIN  \t9138\t574088\t34445280\t1827947896\t9088\n13\t  HASH JOIN  \t4697\t656100\t23619600\t973767459\t4671\n14\t  TABLE ACCESS FULL PEBEMPL\t794\t656100\t3936600\t362530962\t784\n15\t  TABLE ACCESS FULL SPRIDEN\t1351\t1000000\t30000000\t285272492\t1343\n16\t  TABLE ACCESS FULL NOBTRAN\t1454\t875000\t21000000\t548613482\t1439\n17\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n18\t   TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n19\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n20\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n21\t   SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n22\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n23\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n24\t   TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n25\t  SORT JOIN \t3762\t166667\t5666678\t513351976\t3748\n26\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t5666678\t322092341\t2236\n27\t   SORT JOIN \t3951\t166667\t6666680\t544369681\t3936\n28\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t6666680\t350105675\t2236\n29\t  SORT JOIN \t15518\t1000000\t32000000\t2409581958\t15453\n30\t   VIEW  \t6805\t1000000\t32000000\t1336011571\t6769\n31\t  HASH UNIQUE \t6805\t1000000\t12000000\t1336011571\t6769\n32\t  TABLE ACCESS FULL NORTRAN\t2245\t1000000\t12000000\t328759001\t2236\n33\t  SORT JOIN \t3951\t166667\t6666680\t544369681\t3936\n34\t  TABLE ACCESS FULL NORTRAN\t2245\t166667\t6666680\t350105675\t2236\n35\t   SORT JOIN \t1444\t180000\t1440000\t479346156\t1431\n36\t  TABLE ACCESS FULL NORROUT\t792\t180000\t1440000\t290580962\t784\n37\t  SORT JOIN \t7374\t1000000\t20000000\t1315401906\t7338\n38\t   TABLE ACCESS FULL NORTERN\t1304\t1000000\t20000000\t284040483\t1296\n\n## Original SQL:\nselect s.spriden_id EID,\n  s.spriden_last_name ||', '||s.spriden_first_name \"NAME\",\n  b.nobtran_transaction_no \"TRANS NO.\",\n  z.nortran_posn \"POSN NO\",\n  b.nobtran_effective_date \"QUERY DATE\", \n  b.nobtran_acat_code \"ACAT CODE\",\n  n1.nortran_value \"CURRENT HIRE DATE\",\n  n2.nortran_value \"BEGIN PERSONNEL DATE\",\n  n3.nortran_value \"SALARY GROUP\",\n  n4.nortran_value \"APPOINTMENT PERCENT\",\n  n5.nortran_value \"ANNUAL SALARY\",\n  t1.nortern_effective_date \"PAY DATA EFFECTIVE DATE\",\n  t1.nortern_earn_code \"PAY DATA EARNINGS\",\n  t1.nortern_hrs \"PAY DATA HOURS\",\n  t1.nortern_special_rate \"PAY DATA SPECIAL RATE\",\n  n6.nortran_value \"END JOB EFFECTIVE DATE\",\n  n7.nortran_value \"END PERSONNEL DATE\"\n   ,case b.nobtran_trans_status_ind\n   when 'A' then 'Approved'\n   when 'C' then 'Completed'\n   when 'V' then 'Voided' \n   when 'D' then 'Disapproved'\n   when 'R' then 'Return for Correction'\n   when 'P' then 'Pending'\n   when 'W' then 'Waiting'\n   when 'T' then 'Partially Completed'\n   when 'N' then 'Cancelled'\n   when 'U' then 'Superuser Update'\n  end trans_status   \n  ,case r.norrout_queue_status_ind\n   when 'A' then 'Approved by that Approver'\n   when 'D' then 'Disapproved'\n   when 'F' then 'FYI'\n   when 'I' then 'In Queue'\n   when 'K' then 'Acknowledged'\n   when 'L' then 'Applied by Applier'\n   when 'M' then 'More Information'\n   when 'O' then 'Overridden'\n   when 'P' then 'Pending Action by Approver/Applier '\n   when 'Q' then 'Removed from Queue'\n   when 'R' then 'Return for Correction'\n  end queue_status\n  ,r.norrout_level_no\n  \n\n  from nobtran b,spriden s, norrout r, pebempl pp, /*nbrjobs nbr,*/\n  (select nc.nortran_transaction_no,nc.nortran_apty_code,nc.nortran_aufd_code,nc.nortran_value\n  from nortran nc\n   where nc.nortran_aufd_code = 'PEBEMPL_CURRENT_HIRE_DATE'\n  ) n1, /* Current Hire Date */\n  (select nb.nortran_transaction_no,nb.nortran_apty_code,nb.nortran_aufd_code,nb.nortran_value\n  from nortran nb\n   where nb.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' \n  ) n2,  /*Begin Personnnel Date*/ \n  (select ns.nortran_transaction_no,ns.nortran_apty_code,ns.nortran_aufd_code,ns.nortran_value\n  from nortran ns\n   where ns.nortran_aufd_code = 'NBRJOBS_SGRP_CODE'\n   ) n3, /* Salary Group */\n  (select na.nortran_transaction_no,na.nortran_apty_code,na.nortran_aufd_code,na.nortran_value\n  from nortran na\n   where na.nortran_aufd_code = 'NBRJOBS_APPT_PCT'\n  ) n4, /*Appointment Percent*/ \n  (select nu.nortran_transaction_no,nu.nortran_apty_code,nu.nortran_aufd_code,nu.nortran_value\n  from nortran nu\n   where nu.nortran_aufd_code = 'NBRJOBS_ANN_SALARY'\n  ) n5, /*Annual Salary*/\n  (select nj.nortran_transaction_no,nj.nortran_apty_code,nj.nortran_aufd_code,nj.nortran_value\n  from nortran nj\n   where nj.nortran_aufd_code = 'NBRJOBS_EFFECTIVE_DATE'  \n  and nj.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n6,  /*End Job Effective Date*/\n  (select np.nortran_transaction_no,np.nortran_apty_code,np.nortran_aufd_code,np.nortran_value\n  from nortran np\n   where np.nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE'  \n  and np.nortran_apty_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')) n7,  /*End Personnel Date*/\n\n  (select t.nortern_transaction_no,t.nortern_effective_date,t.nortern_earn_code,\n   t.nortern_hrs, t.nortern_special_rate\n  from nortern t) t1 \n\n   ,(select unique zz.nortran_transaction_no,zz.nortran_posn\n  from nortran zz\n   where zz.nortran_posn is not null\n  ) z\n\n where b.nobtran_acat_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') /*employee*/\n  /*waiting,completed,partially completedc,ancelled,supperuser update */\n  /* and nobtran_trans_status_ind in ('W','C','T','U') */\n   and b.nobtran_pidm = s.spriden_pidm\n   and s.spriden_change_ind is null\n   \n   and b.nobtran_transaction_no = t1.nortern_transaction_no(+) /*Pay Data*/\n   \n   and b.nobtran_transaction_no = n1.nortran_transaction_no(+) /*Current Hire Date*/\n   \n   and b.nobtran_transaction_no = n2.nortran_transaction_no(+) /*Begin Personnnel Date*/\n   \n   and b.nobtran_transaction_no = n3.nortran_transaction_no(+) /*Salary Group*/\n   \n   and b.nobtran_transaction_no = n4.nortran_transaction_no(+) /*Appointment Percent*/\n   \n   and b.nobtran_transaction_no = n5.nortran_transaction_no(+) /*Annual Salary*/\n   \n   and b.nobtran_transaction_no = n6.nortran_transaction_no(+) /*End Job Effective Date*/\n   \n   and b.nobtran_transaction_no = n7.nortran_transaction_no(+) /*End Personnel Date*/\n   \n   and nobtran_transaction_no = r.norrout_transaction_no(+)\n   --get all queue status\n   /*and r.norrout_queue_status_ind = 'A'*/\n   and r.norrout_level_no = 90 /* Pending HR approval Queue */\n   -- not applied yet\n   and b.nobtran_apply_ind = 'N' /*Applied ePAFs will not be listed*/\n   --HR does not care about voided ePAFs\n   and nobtran_trans_status_ind <> 'V'\n   --get posn\n   and b.nobtran_transaction_no = z.nortran_transaction_no\n   and r.norrout_queue_status_ind <> 'A'\n  -- exclude student\n   and s.spriden_pidm = pp.pebempl_pidm\n   and pp.pebempl_ecls_code not in ('RE','FW','GS','MW')\n\n   order by 3\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH nt AS (SELECT nortran_transaction_no, MAX(CASE WHEN nortran_aufd_code='PEBEMPL_CURRENT_HIRE_DATE' THEN nortran_value END) n1_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_PERS_CHG_DATE' THEN nortran_value END) n2_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_SGRP_CODE' THEN nortran_value END) n3_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_APPT_PCT' THEN nortran_value END) n4_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_ANN_SALARY' THEN nortran_value END) n5_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_EFFECTIVE_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) n6_val, MAX(CASE WHEN nortran_aufd_code='NBRJOBS_PERS_CHG_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) n7_val, MAX(CASE WHEN nortran_posn IS NOT NULL THEN nortran_posn END) z_posn FROM nortran GROUP BY nortran_transaction_no) SELECT s.spriden_id EID, s.spriden_last_name||', '||s.spriden_first_name \"NAME\", b.nobtran_transaction_no \"TRANS NO.\", nt.z_posn \"POSN NO\", b.nobtran_effective_date \"QUERY DATE\", b.nobtran_acat_code \"ACAT CODE\", nt.n1_val \"CURRENT HIRE DATE\", nt.n2_val \"BEGIN PERSONNEL DATE\", nt.n3_val \"SALARY GROUP\", nt.n4_val \"APPOINTMENT PERCENT\", nt.n5_val \"ANNUAL SALARY\", t1.nortern_effective_date \"PAY DATA EFFECTIVE DATE\", t1.nortern_earn_code \"PAY DATA EARNINGS\", t1.nortern_hrs \"PAY DATA HOURS\", t1.nortern_special_rate \"PAY DATA SPECIAL RATE\", nt.n6_val \"END JOB EFFECTIVE DATE\", nt.n7_val \"END PERSONNEL DATE\", CASE b.nobtran_trans_status_ind WHEN 'A' THEN 'Approved' WHEN 'C' THEN 'Completed' WHEN 'V' THEN 'Voided' WHEN 'D' THEN 'Disapproved' WHEN 'R' THEN 'Return for Correction' WHEN 'P' THEN 'Pending' WHEN 'W' THEN 'Waiting' WHEN 'T' THEN 'Partially Completed' WHEN 'N' THEN 'Cancelled' WHEN 'U' THEN 'Superuser Update' END trans_status, CASE r.norrout_queue_status_ind WHEN 'A' THEN 'Approved by that Approver' WHEN 'D' THEN 'Disapproved' WHEN 'F' THEN 'FYI' WHEN 'I' THEN 'In Queue' WHEN 'K' THEN 'Acknowledged' WHEN 'L' THEN 'Applied by Applier' WHEN 'M' THEN 'More Information' WHEN 'O' THEN 'Overridden' WHEN 'P' THEN 'Pending Action by Approver/Applier' WHEN 'Q' THEN 'Removed from Queue' WHEN 'R' THEN 'Return for Correction' END queue_status, r.norrout_level_no FROM nobtran b INNER JOIN spriden s ON b.nobtran_pidm=s.spriden_pidm AND s.spriden_change_ind IS NULL INNER JOIN pebempl pp ON s.spriden_pidm=pp.pebempl_pidm AND pp.pebempl_ecls_code NOT IN ('RE','FW','GS','MW') INNER JOIN nt ON b.nobtran_transaction_no=nt.nortran_transaction_no LEFT OUTER JOIN nortern t1 ON b.nobtran_transaction_no=t1.nortern_transaction_no LEFT OUTER JOIN norrout r ON b.nobtran_transaction_no=r.norrout_transaction_no AND r.norrout_level_no=90 WHERE b.nobtran_acat_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') AND b.nobtran_apply_ind='N' AND b.nobtran_trans_status_ind<>'V' AND (r.norrout_queue_status_ind IS NULL OR r.norrout_queue_status_ind<>'A') ORDER BY 3"
                    }
                ]
            },
            {
                "case_id": "31",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"31\", \"db_type\": \"oracle\", \"description\": \"本次改写是一个纯语法层面的变更，仅将派生表（子查询）的别名从't'改为't2'，并相应更新外层SELECT语句中的列引用（t.age→t2.age等）。这种改写不改变SQL的语义、执行逻辑或数据访问路径，对数据库优化器来说两个查询完全等价。从性能优化角度看，这不是一个有效的改写方案，因为它不涉及任何能够提升性能的技术手段，如索引利用、连接顺序调整、谓词下推、子查询展开等。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE SAPR3.BSIS (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BUZEI VARCHAR2(3) NOT NULL, HKONT VARCHAR2(10), DMBTR NUMBER(15,2), WAERS VARCHAR2(3), MONAT VARCHAR2(2), BLDAT VARCHAR2(8), CONSTRAINT pk_bsis PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR, BUZEI));\", \"CREATE INDEX idx_bsis_query ON SAPR3.BSIS(GJAHR, BUKRS, HKONT, MANDT, BUZEI, WAERS, MONAT, BLDAT);\", \"CREATE INDEX idx_bsis_join ON SAPR3.BSIS(BELNR, GJAHR, BUKRS);\", \"CREATE TABLE SAPR3.BKPF (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BLDAT VARCHAR2(8), CONSTRAINT pk_bkpf PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR));\"], \"sql\": \"SELECT\\n  t.age,\\n  CASE \\n  WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days'\\n  WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days'\\n  ELSE 'Above 7 Days'\\n  END AS age_bucket,\\n  t.amount_local,\\n  t.hkont AS gl_account,\\n  t.bukrs AS company_code\\nFROM (\\n  SELECT \\n  b.BUKRS,\\n  b.HKONT,\\n  b.DMBTR AS amount_local,\\n  (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age\\n  FROM (\\n  SELECT /*+ FIRST_ROWS(30) */\\n   BELNR, GJAHR, BUKRS, HKONT, DMBTR\\n  FROM SAPR3.BSIS\\n  WHERE GJAHR = '2025'\\n  AND BUKRS = '0100'\\n  AND HKONT = '0000895200'\\n  AND MANDT = '500'\\n  AND BUZEI = '002'\\n  AND WAERS = 'INR'\\n  AND MONAT = '01'\\n  AND BLDAT = '20240401'\\n  ) b\\n  JOIN SAPR3.BKPF k\\n   ON b.BELNR = k.BELNR\\n  AND b.GJAHR = k.GJAHR\\n  AND b.BUKRS = k.BUKRS\\n) t\\nORDER BY t.age;\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT  \\t4225\\t1\\t81\\t810400605\\t4203\\n1\\t  SORT ORDER BY \\t4225\\t1\\t81\\t810400605\\t4203\\n2\\t  HASH JOIN  \\t4224\\t1\\t81\\t773532036\\t4203\\n3\\t   NESTED LOOPS  \\t4224\\t1\\t81\\t773532036\\t4203\\n4\\t  NESTED LOOPS  \\t\\t\\t\\t\\t\\n5\\t  STATISTICS COLLECTOR  \\t\\t\\t\\t\\t\\n6\\t   TABLE ACCESS FULL BSIS\\t2748\\t6289\\t327028\\t456661695\\t2736\\n7\\t  INDEX UNIQUE SCAN PK_BKPF\\t\\t\\t\\t\\t\\n8\\t  TABLE ACCESS BY INDEX ROWID BKPF\\t1475\\t1\\t29\\t311326990\\t1467\\n9\\t   TABLE ACCESS FULL BKPF\\t1475\\t40000\\t1160000\\t311326990\\t1467\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE SAPR3.BSIS (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BUZEI VARCHAR2(3) NOT NULL, HKONT VARCHAR2(10), DMBTR NUMBER(15,2), WAERS VARCHAR2(3), MONAT VARCHAR2(2), BLDAT VARCHAR2(8), CONSTRAINT pk_bsis PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR, BUZEI));\nCREATE INDEX idx_bsis_query ON SAPR3.BSIS(GJAHR, BUKRS, HKONT, MANDT, BUZEI, WAERS, MONAT, BLDAT);\nCREATE INDEX idx_bsis_join ON SAPR3.BSIS(BELNR, GJAHR, BUKRS);\nCREATE TABLE SAPR3.BKPF (MANDT VARCHAR2(3) NOT NULL, BUKRS VARCHAR2(4) NOT NULL, BELNR VARCHAR2(10) NOT NULL, GJAHR VARCHAR2(4) NOT NULL, BLDAT VARCHAR2(8), CONSTRAINT pk_bkpf PRIMARY KEY (MANDT, BUKRS, BELNR, GJAHR));\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT  \t4225\t1\t81\t810400605\t4203\n1\t  SORT ORDER BY \t4225\t1\t81\t810400605\t4203\n2\t  HASH JOIN  \t4224\t1\t81\t773532036\t4203\n3\t   NESTED LOOPS  \t4224\t1\t81\t773532036\t4203\n4\t  NESTED LOOPS  \t\t\t\t\t\n5\t  STATISTICS COLLECTOR  \t\t\t\t\t\n6\t   TABLE ACCESS FULL BSIS\t2748\t6289\t327028\t456661695\t2736\n7\t  INDEX UNIQUE SCAN PK_BKPF\t\t\t\t\t\n8\t  TABLE ACCESS BY INDEX ROWID BKPF\t1475\t1\t29\t311326990\t1467\n9\t   TABLE ACCESS FULL BKPF\t1475\t40000\t1160000\t311326990\t1467\n\n## Original SQL:\nSELECT\n  t.age,\n  CASE \n  WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days'\n  WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days'\n  ELSE 'Above 7 Days'\n  END AS age_bucket,\n  t.amount_local,\n  t.hkont AS gl_account,\n  t.bukrs AS company_code\nFROM (\n  SELECT \n  b.BUKRS,\n  b.HKONT,\n  b.DMBTR AS amount_local,\n  (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age\n  FROM (\n  SELECT /*+ FIRST_ROWS(30) */\n   BELNR, GJAHR, BUKRS, HKONT, DMBTR\n  FROM SAPR3.BSIS\n  WHERE GJAHR = '2025'\n  AND BUKRS = '0100'\n  AND HKONT = '0000895200'\n  AND MANDT = '500'\n  AND BUZEI = '002'\n  AND WAERS = 'INR'\n  AND MONAT = '01'\n  AND BLDAT = '20240401'\n  ) b\n  JOIN SAPR3.BKPF k\n   ON b.BELNR = k.BELNR\n  AND b.GJAHR = k.GJAHR\n  AND b.BUKRS = k.BUKRS\n) t\nORDER BY t.age;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT t.age, CASE WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days' WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days' ELSE 'Above 7 Days' END AS age_bucket, t.amount_local, t.hkont AS gl_account, t.bukrs AS company_code FROM (SELECT b.BUKRS, b.HKONT, b.DMBTR AS amount_local, (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age FROM (SELECT /*+ INDEX(BSIS idx_bsis_query) */ BELNR, GJAHR, BUKRS, HKONT, DMBTR, MANDT FROM SAPR3.BSIS WHERE GJAHR = '2025' AND BUKRS = '0100' AND HKONT = '0000895200' AND MANDT = '500' AND BUZEI = '002' AND WAERS = 'INR' AND MONAT = '01' AND BLDAT = '20240401') b JOIN SAPR3.BKPF k ON b.BELNR = k.BELNR AND b.GJAHR = k.GJAHR AND b.BUKRS = k.BUKRS AND b.MANDT = k.MANDT) t ORDER BY t.age;"
                    }
                ]
            },
            {
                "case_id": "32",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"32\", \"db_type\": \"postgresql\", \"description\": \"本次改写采用了经典的查询优化技术组合：\\n\\n1. **谓词下推（Predicate Pushdown）**：将out_date的过滤条件从最外层WHERE子句移到tmep_ip CTE内部。这样可以尽早过滤数据，减少CTE物化的数据量，虽然在本例中优化器已经将过滤推到了Parallel Seq Scan阶段，但显式下推使逻辑更清晰，且在某些复杂场景下能帮助优化器更好地生成执行计划。\\n\\n2. **投影裁剪（Column Pruning）**：在diagnosis_ranked子查询中，移除了不再需要的diagnosis_type_name字段。该字段仅用于窗口函数的排序，在rn=1筛选后就没有实际意义了，因此在WindowAgg之后立即裁剪，避免传递到上层的GroupAggregate和Materialize节点。\\n\\n3. **聚合维度优化**：diagnosis_end的GROUP BY从4个字段减少到3个字段。因为diagnosis_type_name在窗口函数排序后已被隐含使用（通过rn=1保证了每组只保留优先级最高的记录），在最终聚合时不需要再作为分组键。这减少了哈希表的键空间和比较开销。\\n\\n4. **逻辑等价性保证**：虽然进行了多处优化，但查询的核心逻辑保持不变：\\n   - 诊断类型的优先级排序规则完全一致\\n   - ROW_NUMBER()窗口函数的分区和排序逻辑相同\\n   - MAX聚合对diagnosis_flag分组的处理逻辑相同\\n   - 最终JOIN关联条件和结果集完全一致\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE his_temp_ip_patient_info (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, inpatient_name VARCHAR(100), age INTEGER, sex VARCHAR(10), in_date TIMESTAMP, out_date TIMESTAMP, times VARCHAR(20), person_type VARCHAR(50), patient_no VARCHAR(50), current_dept_code VARCHAR(50));\", \"CREATE INDEX idx_his_temp_ip_patient_info_register_no_times ON his_temp_ip_patient_info(register_no, times);\", \"CREATE INDEX idx_his_temp_ip_patient_info_out_date ON his_temp_ip_patient_info(out_date);\", \"CREATE TABLE his_temp_ip_settle (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, times VARCHAR(20) NOT NULL, total_cost DECIMAL(12,2));\", \"CREATE INDEX idx_his_temp_ip_settle_register_no_times ON his_temp_ip_settle(register_no, times);\", \"CREATE TABLE emr_temp_ip_patient_diagnosis (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, type VARCHAR(50), diagnosis_type_name VARCHAR(100), diagnosis_flag VARCHAR(1), diagnosis_code VARCHAR(50), diagnosis_name VARCHAR(200), diagnosis_no INTEGER, file_visit_type VARCHAR(10));\", \"CREATE INDEX idx_emr_temp_ip_patient_diagnosis_file_visit ON emr_temp_ip_patient_diagnosis(file_visit_type, inp_no, visit_id);\", \"CREATE INDEX idx_emr_temp_ip_patient_diagnosis_group ON emr_temp_ip_patient_diagnosis(inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag);\", \"CREATE TABLE emr_temp_ip_patient_operation (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, operation_code VARCHAR(50), operation_no INTEGER);\", \"CREATE INDEX idx_emr_temp_ip_patient_operation_inp_visit ON emr_temp_ip_patient_operation(inp_no, visit_id);\"], \"sql\": \"with tmep_ip as (\\n  select \\n  a.register_no as patientid, \\n  a.inpatient_name as patientname, \\n  a.age,\\n  a.sex as gender, \\n  date(a.in_date) as indate, \\n  date(a.out_date) as outdate,\\n  a.times as inhospitaltimes, \\n  a.person_type as persontype, \\n  a.patient_no as serialno,\\n  b.total_cost as medicalcost, \\n  'doctor' as entrymode, \\n  'remind' as defaulttab,\\n  a.current_dept_code as deptcode, \\n  '440100' as citycode \\n  from his_temp_ip_patient_info a \\n  left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times\\n),\\ndiagnosis as (\\n  select \\n  inp_no, \\n  visit_id as times, \\n  type, \\n  diagnosis_type_name,\\n  diagnosis_flag,\\n  case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes,\\n  case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes,\\n  case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names \\n  from emr_temp_ip_patient_diagnosis \\n  where file_visit_type = '2'\\n  group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag\\n),\\ndiagnosis_ranked as (\\n  select \\n  *,\\n  row_number() over (\\n   partition by inp_no, times, type \\n   order by \\n  case \\n  when type = '病历诊断' and diagnosis_type_name = '最后诊断' then 1\\n  when type = '病历诊断' and diagnosis_type_name = '初步诊断' then 2\\n  when type = '首页诊断' and diagnosis_type_name = '出院诊断' then 1\\n  when type = '首页诊断' and diagnosis_type_name = '门诊诊断' then 2\\n  else 3\\n  end\\n  ) as rn\\n  from diagnosis\\n),\\ndiagnosis_end as (\\n  select \\n  inp_no, \\n  times, \\n  type, \\n  diagnosis_type_name,\\n  max(case when diagnosis_flag = '1' then diagnosis_codes end) as diagnosis_codes,\\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_codes end) as chinese_diagnosis_codes,\\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_names end) as chinese_diagnosis_names\\n  from diagnosis_ranked\\n  where rn = 1\\n  group by inp_no, times, type, diagnosis_type_name\\n),\\noperations as (\\n  select \\n  inp_no, \\n  visit_id as times, \\n  string_agg(operation_code, ',' order by operation_no) as operation_codes \\n  from emr_temp_ip_patient_operation\\n  group by inp_no, visit_id \\n)\\nselect \\n  t.patientid, \\n  t.patientname, \\n  t.age,\\n  t.gender, \\n  t.indate, \\n  t.outdate, \\n  t.inhospitaltimes, \\n  d.type,\\n  d.diagnosis_codes as diagnosiscode,\\n  o.operation_codes as operationcode,\\n  t.medicalcost, \\n  t.persontype, \\n  t.entrymode, \\n  t.serialno, \\n  t.defaulttab,\\n  d.chinese_diagnosis_codes as chinesediagnosiscode,\\n  d.chinese_diagnosis_names as chinesediagnosename,\\n  t.deptcode, \\n  t.citycode \\nfrom tmep_ip t \\nleft join diagnosis_end d on t.patientid = d.inp_no and t.inhospitaltimes::varchar = d.times\\nleft join operations o on t.patientid = o.inp_no and t.inhospitaltimes::varchar = o.times\\nwhere t.outdate > '2025-01-01'\\norder by t.outdate desc\", \"explain\": \"QUERY PLAN\\nSort  (cost=445130.58..445963.91 rows=333333 width=308)\\n  Sort Key: (date(a.out_date)) DESC\\n  ->  Merge Left Join  (cost=64922.35..318848.93 rows=333333 width=308)\\n  Merge Cond: (((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))\\n  ->  Gather Merge  (cost=64668.41..197286.44 rows=333333 width=111)\\n  Workers Planned: 2\\n  ->  Merge Left Join  (cost=63668.38..157811.52 rows=138889 width=111)\\n  Merge Cond: (((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))\\n  ->  Sort  (cost=63667.28..64014.50 rows=138889 width=79)\\n  Sort Key: a.register_no, a.times\\n  ->  Parallel Hash Right Join  (cost=24279.33..45629.67 rows=138889 width=79)\\n  Hash Cond: (((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))\\n  ->  Parallel Seq Scan on his_temp_ip_settle b  (cost=0.00..11519.67 rows=416667 width=22)\\n  ->  Parallel Hash  (cost=20432.00..20432.00 rows=138889 width=73)\\n  ->  Parallel Seq Scan on his_temp_ip_patient_info a  (cost=0.00..20432.00 rows=138889 width=73)\\n  Filter: (date(out_date) > '2025-01-01'::date)\\n  ->  GroupAggregate  (cost=1.11..91601.88 rows=100000 width=44)\\n  Group Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\\n  ->  Incremental Sort  (cost=1.11..82851.88 rows=1000000 width=25)\\n  Sort Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id, emr_temp_ip_patient_operation.operation_no\\n  Presorted Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\\n  ->  Index Scan using idx_emr_temp_ip_patient_operation_inp_visit on emr_temp_ip_patient_operation  (cost=0.42..51742.24 rows=1000000 width=25)\\n  ->  Materialize  (cost=253.95..118226.71 rows=489 width=121)\\n  ->  GroupAggregate  (cost=253.95..118220.60 rows=489 width=134)\\n  Group Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\\n  ->  Incremental Sort  (cost=253.95..118203.21 rows=500 width=136)\\n  Sort Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\\n  Presorted Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type\\n  ->  Subquery Scan on diagnosis_ranked  (cost=12.28..118181.09 rows=500 width=136)\\n  Filter: (diagnosis_ranked.rn = 1)\\n  ->  WindowAgg  (cost=12.28..116931.09 rows=100000 width=148)\\n  Run Condition: (row_number() OVER (?) <= 1)\\n  ->  Incremental Sort  (cost=12.28..112681.09 rows=100000 width=140)\\n  Sort Key: diagnosis.inp_no, diagnosis.times, diagnosis.type, (CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\\n  Presorted Key: diagnosis.inp_no, diagnosis.times, diagnosis.type\\n  ->  Subquery Scan on diagnosis  (cost=1.16..109570.13 rows=100000 width=140)\\n  ->  GroupAggregate  (cost=1.16..107570.13 rows=100000 width=136)\\n  Group Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag\\n  ->  Incremental Sort  (cost=1.16..87820.13 rows=1000000 width=76)\\n  Sort Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag, emr_temp_ip_patient_diagnosis.diagnosis_no\\n  Presorted Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id\\n  ->  Index Scan using idx_emr_temp_ip_patient_diagnosis_file_visit on emr_temp_ip_patient_diagnosis  (cost=0.42..56710.49 rows=1000000 width=76)\\n  Index Cond: ((file_visit_type)::text = '2'::text)\\nJIT:\\n  Functions: 59\\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 445130.58, 'Total Cost': 445963.91, 'Plan Rows': 333333, 'Plan Width': 308, 'Sort Key': ['(date(a.out_date)) DESC'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 64922.35, 'Total Cost': 318848.93, 'Plan Rows': 333333, 'Plan Width': 308, 'Inner Unique': False, 'Merge Cond': '(((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))', 'Plans': [{'Node Type': 'Gather Merge', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 64668.41, 'Total Cost': 197286.44, 'Plan Rows': 333333, 'Plan Width': 111, 'Workers Planned': 2, 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 63668.38, 'Total Cost': 157811.52, 'Plan Rows': 138889, 'Plan Width': 111, 'Inner Unique': True, 'Merge Cond': '(((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))', 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 63667.28, 'Total Cost': 64014.5, 'Plan Rows': 138889, 'Plan Width': 79, 'Sort Key': ['a.register_no', 'a.times'], 'Plans': [{'Node Type': 'Hash Join', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Join Type': 'Right', 'Startup Cost': 24279.33, 'Total Cost': 45629.67, 'Plan Rows': 138889, 'Plan Width': 79, 'Inner Unique': False, 'Hash Cond': '(((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_settle', 'Alias': 'b', 'Startup Cost': 0.0, 'Total Cost': 11519.67, 'Plan Rows': 416667, 'Plan Width': 22}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': True, 'Async Capable': False, 'Startup Cost': 20432.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_patient_info', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Filter': \\\"(date(out_date) > '2025-01-01'::date)\\\"}]}]}]}, {'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 91601.88, 'Plan Rows': 100000, 'Plan Width': 44, 'Group Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 82851.88, 'Plan Rows': 1000000, 'Plan Width': 25, 'Sort Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id', 'emr_temp_ip_patient_operation.operation_no'], 'Presorted Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_operation_inp_visit', 'Relation Name': 'emr_temp_ip_patient_operation', 'Alias': 'emr_temp_ip_patient_operation', 'Startup Cost': 0.42, 'Total Cost': 51742.24, 'Plan Rows': 1000000, 'Plan Width': 25}]}]}]}]}, {'Node Type': 'Materialize', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118226.71, 'Plan Rows': 489, 'Plan Width': 121, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118220.6, 'Plan Rows': 489, 'Plan Width': 134, 'Group Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118203.21, 'Plan Rows': 500, 'Plan Width': 136, 'Sort Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Presorted Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis_ranked', 'Startup Cost': 12.28, 'Total Cost': 118181.09, 'Plan Rows': 500, 'Plan Width': 136, 'Filter': '(diagnosis_ranked.rn = 1)', 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 116931.09, 'Plan Rows': 100000, 'Plan Width': 148, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 112681.09, 'Plan Rows': 100000, 'Plan Width': 140, 'Sort Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type', \\\"(CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\\\"], 'Presorted Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis', 'Startup Cost': 1.16, 'Total Cost': 109570.13, 'Plan Rows': 100000, 'Plan Width': 140, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 107570.13, 'Plan Rows': 100000, 'Plan Width': 136, 'Group Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 87820.13, 'Plan Rows': 1000000, 'Plan Width': 76, 'Sort Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag', 'emr_temp_ip_patient_diagnosis.diagnosis_no'], 'Presorted Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_diagnosis_file_visit', 'Relation Name': 'emr_temp_ip_patient_diagnosis', 'Alias': 'emr_temp_ip_patient_diagnosis', 'Startup Cost': 0.42, 'Total Cost': 56710.49, 'Plan Rows': 1000000, 'Plan Width': 76, 'Index Cond': \\\"((file_visit_type)::text = '2'::text)\\\"}]}]}]}]}]}]}]}]}]}]}]}, 'JIT': {'Functions': 59, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE his_temp_ip_patient_info (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, inpatient_name VARCHAR(100), age INTEGER, sex VARCHAR(10), in_date TIMESTAMP, out_date TIMESTAMP, times VARCHAR(20), person_type VARCHAR(50), patient_no VARCHAR(50), current_dept_code VARCHAR(50));\nCREATE INDEX idx_his_temp_ip_patient_info_register_no_times ON his_temp_ip_patient_info(register_no, times);\nCREATE INDEX idx_his_temp_ip_patient_info_out_date ON his_temp_ip_patient_info(out_date);\nCREATE TABLE his_temp_ip_settle (id SERIAL PRIMARY KEY, register_no VARCHAR(50) NOT NULL, times VARCHAR(20) NOT NULL, total_cost DECIMAL(12,2));\nCREATE INDEX idx_his_temp_ip_settle_register_no_times ON his_temp_ip_settle(register_no, times);\nCREATE TABLE emr_temp_ip_patient_diagnosis (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, type VARCHAR(50), diagnosis_type_name VARCHAR(100), diagnosis_flag VARCHAR(1), diagnosis_code VARCHAR(50), diagnosis_name VARCHAR(200), diagnosis_no INTEGER, file_visit_type VARCHAR(10));\nCREATE INDEX idx_emr_temp_ip_patient_diagnosis_file_visit ON emr_temp_ip_patient_diagnosis(file_visit_type, inp_no, visit_id);\nCREATE INDEX idx_emr_temp_ip_patient_diagnosis_group ON emr_temp_ip_patient_diagnosis(inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag);\nCREATE TABLE emr_temp_ip_patient_operation (id SERIAL PRIMARY KEY, inp_no VARCHAR(50) NOT NULL, visit_id VARCHAR(20) NOT NULL, operation_code VARCHAR(50), operation_no INTEGER);\nCREATE INDEX idx_emr_temp_ip_patient_operation_inp_visit ON emr_temp_ip_patient_operation(inp_no, visit_id);\n\n## Explain Output in JSON:\nQUERY PLAN\nSort  (cost=445130.58..445963.91 rows=333333 width=308)\n  Sort Key: (date(a.out_date)) DESC\n  ->  Merge Left Join  (cost=64922.35..318848.93 rows=333333 width=308)\n  Merge Cond: (((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))\n  ->  Gather Merge  (cost=64668.41..197286.44 rows=333333 width=111)\n  Workers Planned: 2\n  ->  Merge Left Join  (cost=63668.38..157811.52 rows=138889 width=111)\n  Merge Cond: (((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))\n  ->  Sort  (cost=63667.28..64014.50 rows=138889 width=79)\n  Sort Key: a.register_no, a.times\n  ->  Parallel Hash Right Join  (cost=24279.33..45629.67 rows=138889 width=79)\n  Hash Cond: (((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))\n  ->  Parallel Seq Scan on his_temp_ip_settle b  (cost=0.00..11519.67 rows=416667 width=22)\n  ->  Parallel Hash  (cost=20432.00..20432.00 rows=138889 width=73)\n  ->  Parallel Seq Scan on his_temp_ip_patient_info a  (cost=0.00..20432.00 rows=138889 width=73)\n  Filter: (date(out_date) > '2025-01-01'::date)\n  ->  GroupAggregate  (cost=1.11..91601.88 rows=100000 width=44)\n  Group Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\n  ->  Incremental Sort  (cost=1.11..82851.88 rows=1000000 width=25)\n  Sort Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id, emr_temp_ip_patient_operation.operation_no\n  Presorted Key: emr_temp_ip_patient_operation.inp_no, emr_temp_ip_patient_operation.visit_id\n  ->  Index Scan using idx_emr_temp_ip_patient_operation_inp_visit on emr_temp_ip_patient_operation  (cost=0.42..51742.24 rows=1000000 width=25)\n  ->  Materialize  (cost=253.95..118226.71 rows=489 width=121)\n  ->  GroupAggregate  (cost=253.95..118220.60 rows=489 width=134)\n  Group Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\n  ->  Incremental Sort  (cost=253.95..118203.21 rows=500 width=136)\n  Sort Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type, diagnosis_ranked.diagnosis_type_name\n  Presorted Key: diagnosis_ranked.inp_no, diagnosis_ranked.times, diagnosis_ranked.type\n  ->  Subquery Scan on diagnosis_ranked  (cost=12.28..118181.09 rows=500 width=136)\n  Filter: (diagnosis_ranked.rn = 1)\n  ->  WindowAgg  (cost=12.28..116931.09 rows=100000 width=148)\n  Run Condition: (row_number() OVER (?) <= 1)\n  ->  Incremental Sort  (cost=12.28..112681.09 rows=100000 width=140)\n  Sort Key: diagnosis.inp_no, diagnosis.times, diagnosis.type, (CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\n  Presorted Key: diagnosis.inp_no, diagnosis.times, diagnosis.type\n  ->  Subquery Scan on diagnosis  (cost=1.16..109570.13 rows=100000 width=140)\n  ->  GroupAggregate  (cost=1.16..107570.13 rows=100000 width=136)\n  Group Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag\n  ->  Incremental Sort  (cost=1.16..87820.13 rows=1000000 width=76)\n  Sort Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id, emr_temp_ip_patient_diagnosis.type, emr_temp_ip_patient_diagnosis.diagnosis_type_name, emr_temp_ip_patient_diagnosis.diagnosis_flag, emr_temp_ip_patient_diagnosis.diagnosis_no\n  Presorted Key: emr_temp_ip_patient_diagnosis.inp_no, emr_temp_ip_patient_diagnosis.visit_id\n  ->  Index Scan using idx_emr_temp_ip_patient_diagnosis_file_visit on emr_temp_ip_patient_diagnosis  (cost=0.42..56710.49 rows=1000000 width=76)\n  Index Cond: ((file_visit_type)::text = '2'::text)\nJIT:\n  Functions: 59\n  Options: Inlining false, Optimization false, Expressions true, Deforming true\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 445130.58, 'Total Cost': 445963.91, 'Plan Rows': 333333, 'Plan Width': 308, 'Sort Key': ['(date(a.out_date)) DESC'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 64922.35, 'Total Cost': 318848.93, 'Plan Rows': 333333, 'Plan Width': 308, 'Inner Unique': False, 'Merge Cond': '(((a.register_no)::text = (diagnosis_ranked.inp_no)::text) AND ((a.times)::text = (diagnosis_ranked.times)::text))', 'Plans': [{'Node Type': 'Gather Merge', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 64668.41, 'Total Cost': 197286.44, 'Plan Rows': 333333, 'Plan Width': 111, 'Workers Planned': 2, 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Left', 'Startup Cost': 63668.38, 'Total Cost': 157811.52, 'Plan Rows': 138889, 'Plan Width': 111, 'Inner Unique': True, 'Merge Cond': '(((a.register_no)::text = (emr_temp_ip_patient_operation.inp_no)::text) AND ((a.times)::text = (emr_temp_ip_patient_operation.visit_id)::text))', 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 63667.28, 'Total Cost': 64014.5, 'Plan Rows': 138889, 'Plan Width': 79, 'Sort Key': ['a.register_no', 'a.times'], 'Plans': [{'Node Type': 'Hash Join', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Join Type': 'Right', 'Startup Cost': 24279.33, 'Total Cost': 45629.67, 'Plan Rows': 138889, 'Plan Width': 79, 'Inner Unique': False, 'Hash Cond': '(((b.register_no)::text = (a.register_no)::text) AND ((b.times)::text = (a.times)::text))', 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_settle', 'Alias': 'b', 'Startup Cost': 0.0, 'Total Cost': 11519.67, 'Plan Rows': 416667, 'Plan Width': 22}, {'Node Type': 'Hash', 'Parent Relationship': 'Inner', 'Parallel Aware': True, 'Async Capable': False, 'Startup Cost': 20432.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': True, 'Async Capable': False, 'Relation Name': 'his_temp_ip_patient_info', 'Alias': 'a', 'Startup Cost': 0.0, 'Total Cost': 20432.0, 'Plan Rows': 138889, 'Plan Width': 73, 'Filter': \"(date(out_date) > '2025-01-01'::date)\"}]}]}]}, {'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 91601.88, 'Plan Rows': 100000, 'Plan Width': 44, 'Group Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.11, 'Total Cost': 82851.88, 'Plan Rows': 1000000, 'Plan Width': 25, 'Sort Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id', 'emr_temp_ip_patient_operation.operation_no'], 'Presorted Key': ['emr_temp_ip_patient_operation.inp_no', 'emr_temp_ip_patient_operation.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_operation_inp_visit', 'Relation Name': 'emr_temp_ip_patient_operation', 'Alias': 'emr_temp_ip_patient_operation', 'Startup Cost': 0.42, 'Total Cost': 51742.24, 'Plan Rows': 1000000, 'Plan Width': 25}]}]}]}]}, {'Node Type': 'Materialize', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118226.71, 'Plan Rows': 489, 'Plan Width': 121, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118220.6, 'Plan Rows': 489, 'Plan Width': 134, 'Group Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 253.95, 'Total Cost': 118203.21, 'Plan Rows': 500, 'Plan Width': 136, 'Sort Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type', 'diagnosis_ranked.diagnosis_type_name'], 'Presorted Key': ['diagnosis_ranked.inp_no', 'diagnosis_ranked.times', 'diagnosis_ranked.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis_ranked', 'Startup Cost': 12.28, 'Total Cost': 118181.09, 'Plan Rows': 500, 'Plan Width': 136, 'Filter': '(diagnosis_ranked.rn = 1)', 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 116931.09, 'Plan Rows': 100000, 'Plan Width': 148, 'Run Condition': '(row_number() OVER (?) <= 1)', 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 12.28, 'Total Cost': 112681.09, 'Plan Rows': 100000, 'Plan Width': 140, 'Sort Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type', \"(CASE WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '最后诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '病历诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '初步诊断'::text)) THEN 2 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '出院诊断'::text)) THEN 1 WHEN (((diagnosis.type)::text = '首页诊断'::text) AND ((diagnosis.diagnosis_type_name)::text = '门诊诊断'::text)) THEN 2 ELSE 3 END)\"], 'Presorted Key': ['diagnosis.inp_no', 'diagnosis.times', 'diagnosis.type'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'diagnosis', 'Startup Cost': 1.16, 'Total Cost': 109570.13, 'Plan Rows': 100000, 'Plan Width': 140, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 107570.13, 'Plan Rows': 100000, 'Plan Width': 136, 'Group Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag'], 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 1.16, 'Total Cost': 87820.13, 'Plan Rows': 1000000, 'Plan Width': 76, 'Sort Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id', 'emr_temp_ip_patient_diagnosis.type', 'emr_temp_ip_patient_diagnosis.diagnosis_type_name', 'emr_temp_ip_patient_diagnosis.diagnosis_flag', 'emr_temp_ip_patient_diagnosis.diagnosis_no'], 'Presorted Key': ['emr_temp_ip_patient_diagnosis.inp_no', 'emr_temp_ip_patient_diagnosis.visit_id'], 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_emr_temp_ip_patient_diagnosis_file_visit', 'Relation Name': 'emr_temp_ip_patient_diagnosis', 'Alias': 'emr_temp_ip_patient_diagnosis', 'Startup Cost': 0.42, 'Total Cost': 56710.49, 'Plan Rows': 1000000, 'Plan Width': 76, 'Index Cond': \"((file_visit_type)::text = '2'::text)\"}]}]}]}]}]}]}]}]}]}]}]}, 'JIT': {'Functions': 59, 'Options': {'Inlining': False, 'Optimization': False, 'Expressions': True, 'Deforming': True}}}]\n\n## Original SQL:\nwith tmep_ip as (\n  select \n  a.register_no as patientid, \n  a.inpatient_name as patientname, \n  a.age,\n  a.sex as gender, \n  date(a.in_date) as indate, \n  date(a.out_date) as outdate,\n  a.times as inhospitaltimes, \n  a.person_type as persontype, \n  a.patient_no as serialno,\n  b.total_cost as medicalcost, \n  'doctor' as entrymode, \n  'remind' as defaulttab,\n  a.current_dept_code as deptcode, \n  '440100' as citycode \n  from his_temp_ip_patient_info a \n  left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times\n),\ndiagnosis as (\n  select \n  inp_no, \n  visit_id as times, \n  type, \n  diagnosis_type_name,\n  diagnosis_flag,\n  case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes,\n  case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes,\n  case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names \n  from emr_temp_ip_patient_diagnosis \n  where file_visit_type = '2'\n  group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag\n),\ndiagnosis_ranked as (\n  select \n  *,\n  row_number() over (\n   partition by inp_no, times, type \n   order by \n  case \n  when type = '病历诊断' and diagnosis_type_name = '最后诊断' then 1\n  when type = '病历诊断' and diagnosis_type_name = '初步诊断' then 2\n  when type = '首页诊断' and diagnosis_type_name = '出院诊断' then 1\n  when type = '首页诊断' and diagnosis_type_name = '门诊诊断' then 2\n  else 3\n  end\n  ) as rn\n  from diagnosis\n),\ndiagnosis_end as (\n  select \n  inp_no, \n  times, \n  type, \n  diagnosis_type_name,\n  max(case when diagnosis_flag = '1' then diagnosis_codes end) as diagnosis_codes,\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_codes end) as chinese_diagnosis_codes,\n  max(case when diagnosis_flag = '0' then chinese_diagnosis_names end) as chinese_diagnosis_names\n  from diagnosis_ranked\n  where rn = 1\n  group by inp_no, times, type, diagnosis_type_name\n),\noperations as (\n  select \n  inp_no, \n  visit_id as times, \n  string_agg(operation_code, ',' order by operation_no) as operation_codes \n  from emr_temp_ip_patient_operation\n  group by inp_no, visit_id \n)\nselect \n  t.patientid, \n  t.patientname, \n  t.age,\n  t.gender, \n  t.indate, \n  t.outdate, \n  t.inhospitaltimes, \n  d.type,\n  d.diagnosis_codes as diagnosiscode,\n  o.operation_codes as operationcode,\n  t.medicalcost, \n  t.persontype, \n  t.entrymode, \n  t.serialno, \n  t.defaulttab,\n  d.chinese_diagnosis_codes as chinesediagnosiscode,\n  d.chinese_diagnosis_names as chinesediagnosename,\n  t.deptcode, \n  t.citycode \nfrom tmep_ip t \nleft join diagnosis_end d on t.patientid = d.inp_no and t.inhospitaltimes::varchar = d.times\nleft join operations o on t.patientid = o.inp_no and t.inhospitaltimes::varchar = o.times\nwhere t.outdate > '2025-01-01'\norder by t.outdate desc\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "with filtered_ip as (select a.register_no, a.inpatient_name, a.age, a.sex, a.in_date, a.out_date, a.times, a.person_type, a.patient_no, a.current_dept_code, b.total_cost from his_temp_ip_patient_info a left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times where a.out_date >= '2025-01-02'::timestamp), diagnosis as (select inp_no, visit_id as times, type, diagnosis_type_name, diagnosis_flag, case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes, case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes, case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names from emr_temp_ip_patient_diagnosis where file_visit_type = '2' group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag), diagnosis_ranked as (select *, row_number() over (partition by inp_no, times, type order by case when type='病历诊断' and diagnosis_type_name='最后诊断' then 1 when type='病历诊断' and diagnosis_type_name='初步诊断' then 2 when type='首页诊断' and diagnosis_type_name='出院诊断' then 1 when type='首页诊断' and diagnosis_type_name='门诊诊断' then 2 else 3 end) as rn from diagnosis), diagnosis_final as (select inp_no, times, type, diagnosis_type_name, max(case when diagnosis_flag='1' then diagnosis_codes end) as diagnosis_codes, max(case when diagnosis_flag='0' then chinese_diagnosis_codes end) as chinese_diagnosis_codes, max(case when diagnosis_flag='0' then chinese_diagnosis_names end) as chinese_diagnosis_names from diagnosis_ranked where rn = 1 group by inp_no, times, type, diagnosis_type_name), operations as (select inp_no, visit_id as times, string_agg(operation_code, ',' order by operation_no) as operation_codes from emr_temp_ip_patient_operation group by inp_no, visit_id) select t.register_no as patientid, t.inpatient_name as patientname, t.age, t.sex as gender, date(t.in_date) as indate, date(t.out_date) as outdate, t.times as inhospitaltimes, d.type, d.diagnosis_codes as diagnosiscode, o.operation_codes as operationcode, t.total_cost as medicalcost, t.person_type as persontype, 'doctor' as entrymode, t.patient_no as serialno, 'remind' as defaulttab, d.chinese_diagnosis_codes as chinesediagnosiscode, d.chinese_diagnosis_names as chinesediagnosename, t.current_dept_code as deptcode, '440100' as citycode from filtered_ip t left join diagnosis_final d on t.register_no = d.inp_no and t.times = d.times left join operations o on t.register_no = o.inp_no and t.times = o.times order by t.out_date desc;"
                    }
                ]
            },
            {
                "case_id": "33",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"33\", \"db_type\": \"mysql\", \"description\": \"这次改写的核心思想是消除WHERE子句中的LEFT函数调用，因为函数作用于列会阻止索引使用。改写策略是将前缀匹配逻辑展开为21个具体的等值比较条件（对应字符串'745070056000500070090'的每个前缀）。每个条件形式为：(code_length = N AND CODE = 'prefix')。理论上，这种改写可以让优化器使用索引，因为CODE列现在是等值比较而非函数参数。然而实际效果适得其反，原因是：1) 条件数量过多（21个OR）导致评估开销增加；2) 每个条件仍需调用CHAR_LENGTH函数验证长度；3) MySQL对多OR条件的索引使用优化有限，最终仍选择全表扫描。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE t_org_architecture (ID INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(100), CODE VARCHAR(50), TYPE VARCHAR(50), principal VARCHAR(100), CATEGORY VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_code ON t_org_architecture(CODE);\"], \"sql\": \"SELECT \\n  ID, \\n  `NAME`, \\n  `CODE`, \\n  `TYPE`, \\n  principal, \\n  CATEGORY \\nFROM \\n  t_org_architecture \\nWHERE \\n  LEFT('745070056000500070090',  LENGTH(`CODE`)) = `CODE` \\nGROUP BY \\n  LENGTH(`CODE`);\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tSIMPLE\\tt_org_architecture\\t\\tALL\\tidx_code\\t\\t\\t\\t993209\\t10.0\\tUsing where; Using temporary\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"101257.36\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"using_filesort\\\": false,\\n   \\\"table\\\": {\\n   \\\"table_name\\\": \\\"t_org_architecture\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"idx_code\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 993209,\\n   \\\"rows_produced_per_join\\\": 99320,\\n   \\\"filtered\\\": \\\"10.00\\\",\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"91325.27\\\",\\n   \\\"eval_cost\\\": \\\"9932.09\\\",\\n   \\\"prefix_cost\\\": \\\"101257.36\\\",\\n   \\\"data_read_per_join\\\": \\\"134M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"ID\\\",\\n   \\\"NAME\\\",\\n   \\\"CODE\\\",\\n   \\\"TYPE\\\",\\n   \\\"principal\\\",\\n   \\\"CATEGORY\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"(left('745070056000500070090',length(`test_db`.`t_org_architecture`.`CODE`)) = `test_db`.`t_org_architecture`.`CODE`)\\\"\\n   }\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE t_org_architecture (ID INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(100), CODE VARCHAR(50), TYPE VARCHAR(50), principal VARCHAR(100), CATEGORY VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_code ON t_org_architecture(CODE);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tSIMPLE\tt_org_architecture\t\tALL\tidx_code\t\t\t\t993209\t10.0\tUsing where; Using temporary\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"101257.36\"\n  },\n  \"grouping_operation\": {\n   \"using_temporary_table\": true,\n   \"using_filesort\": false,\n   \"table\": {\n   \"table_name\": \"t_org_architecture\",\n   \"access_type\": \"ALL\",\n   \"possible_keys\": [\n   \"idx_code\"\n   ],\n   \"rows_examined_per_scan\": 993209,\n   \"rows_produced_per_join\": 99320,\n   \"filtered\": \"10.00\",\n   \"cost_info\": {\n   \"read_cost\": \"91325.27\",\n   \"eval_cost\": \"9932.09\",\n   \"prefix_cost\": \"101257.36\",\n   \"data_read_per_join\": \"134M\"\n   },\n   \"used_columns\": [\n   \"ID\",\n   \"NAME\",\n   \"CODE\",\n   \"TYPE\",\n   \"principal\",\n   \"CATEGORY\"\n   ],\n   \"attached_condition\": \"(left('745070056000500070090',length(`test_db`.`t_org_architecture`.`CODE`)) = `test_db`.`t_org_architecture`.`CODE`)\"\n   }\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  ID, \n  `NAME`, \n  `CODE`, \n  `TYPE`, \n  principal, \n  CATEGORY \nFROM \n  t_org_architecture \nWHERE \n  LEFT('745070056000500070090',  LENGTH(`CODE`)) = `CODE` \nGROUP BY \n  LENGTH(`CODE`);\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT ID, NAME, CODE, TYPE, principal, CATEGORY FROM t_org_architecture WHERE CODE <= '745070056000500070090' AND LEFT('745070056000500070090', LENGTH(CODE)) = CODE GROUP BY LENGTH(CODE) ORDER BY NULL;"
                    }
                ]
            },
            {
                "case_id": "34",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"34\", \"db_type\": \"mysql\", \"description\": \"核心技术是将非Sargable条件(索引列上的函数)改写为Sargable条件(可利用索引的条件)。对日期列使用函数会导致索引失效，改用范围查询可以充分利用索引。同时修正了数据类型不匹配问题(Flag字段定义为CHAR但与整数比较)，并清理了冗余条件。这种改写在保证结果一致性的前提下，通过技术手段显著降低了查询开销\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE m_membermain (MebID INT PRIMARY KEY AUTO_INCREMENT COMMENT '会员ID', Flag CHAR(1) NOT NULL DEFAULT '1' COMMENT '标志位', MebType TINYINT NOT NULL COMMENT '会员类型', CreateTime DATETIME NOT NULL COMMENT '创建时间') ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_flag ON m_membermain(Flag);\", \"CREATE INDEX idx_mebtype ON m_membermain(MebType);\", \"CREATE INDEX idx_createtime ON m_membermain(CreateTime);\", \"CREATE INDEX idx_flag_mebtype_createtime ON m_membermain(Flag, MebType, CreateTime);\"], \"sql\": \"SELECT \\n  count(DISTINCT MebID) \\nFROM \\n  m_membermain mm \\nWHERE \\n  mm.Flag <> '0' \\n  AND mm.MebType IN (1, 2, 5, 6, 8) \\n  AND MebID IS NOT NULL \\n  AND substring(CreateTime, 1, 10) = '2025-09-02' \\nLIMIT \\n  1000;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tSIMPLE\\tmm\\t\\trange\\tPRIMARY,idx_flag,idx_mebtype,idx_createtime,idx_flag_mebtype_createtime\\tidx_flag_mebtype_createtime\\t4\\t\\t499246\\t100.0\\tUsing where; Using index\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"100062.45\\\"\\n  },\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"mm\\\",\\n   \\\"access_type\\\": \\\"range\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"PRIMARY\\\",\\n   \\\"idx_flag\\\",\\n   \\\"idx_mebtype\\\",\\n   \\\"idx_createtime\\\",\\n   \\\"idx_flag_mebtype_createtime\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_flag_mebtype_createtime\\\",\\n   \\\"used_key_parts\\\": [\\n   \\\"Flag\\\"\\n   ],\\n   \\\"key_length\\\": \\\"4\\\",\\n   \\\"rows_examined_per_scan\\\": 499246,\\n   \\\"rows_produced_per_join\\\": 499246,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"using_index\\\": true,\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"50137.85\\\",\\n   \\\"eval_cost\\\": \\\"49924.60\\\",\\n   \\\"prefix_cost\\\": \\\"100062.45\\\",\\n   \\\"data_read_per_join\\\": \\\"7M\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"MebID\\\",\\n   \\\"Flag\\\",\\n   \\\"MebType\\\",\\n   \\\"CreateTime\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`mm`.`Flag` <> '0') and (`test_db`.`mm`.`MebType` in (1,2,5,6,8)) and (substr(`test_db`.`mm`.`CreateTime`,1,10) = '2025-09-02'))\\\"\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE m_membermain (MebID INT PRIMARY KEY AUTO_INCREMENT COMMENT '会员ID', Flag CHAR(1) NOT NULL DEFAULT '1' COMMENT '标志位', MebType TINYINT NOT NULL COMMENT '会员类型', CreateTime DATETIME NOT NULL COMMENT '创建时间') ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_flag ON m_membermain(Flag);\nCREATE INDEX idx_mebtype ON m_membermain(MebType);\nCREATE INDEX idx_createtime ON m_membermain(CreateTime);\nCREATE INDEX idx_flag_mebtype_createtime ON m_membermain(Flag, MebType, CreateTime);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tSIMPLE\tmm\t\trange\tPRIMARY,idx_flag,idx_mebtype,idx_createtime,idx_flag_mebtype_createtime\tidx_flag_mebtype_createtime\t4\t\t499246\t100.0\tUsing where; Using index\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"100062.45\"\n  },\n  \"table\": {\n   \"table_name\": \"mm\",\n   \"access_type\": \"range\",\n   \"possible_keys\": [\n   \"PRIMARY\",\n   \"idx_flag\",\n   \"idx_mebtype\",\n   \"idx_createtime\",\n   \"idx_flag_mebtype_createtime\"\n   ],\n   \"key\": \"idx_flag_mebtype_createtime\",\n   \"used_key_parts\": [\n   \"Flag\"\n   ],\n   \"key_length\": \"4\",\n   \"rows_examined_per_scan\": 499246,\n   \"rows_produced_per_join\": 499246,\n   \"filtered\": \"100.00\",\n   \"using_index\": true,\n   \"cost_info\": {\n   \"read_cost\": \"50137.85\",\n   \"eval_cost\": \"49924.60\",\n   \"prefix_cost\": \"100062.45\",\n   \"data_read_per_join\": \"7M\"\n   },\n   \"used_columns\": [\n   \"MebID\",\n   \"Flag\",\n   \"MebType\",\n   \"CreateTime\"\n   ],\n   \"attached_condition\": \"((`test_db`.`mm`.`Flag` <> '0') and (`test_db`.`mm`.`MebType` in (1,2,5,6,8)) and (substr(`test_db`.`mm`.`CreateTime`,1,10) = '2025-09-02'))\"\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  count(DISTINCT MebID) \nFROM \n  m_membermain mm \nWHERE \n  mm.Flag <> '0' \n  AND mm.MebType IN (1, 2, 5, 6, 8) \n  AND MebID IS NOT NULL \n  AND substring(CreateTime, 1, 10) = '2025-09-02' \nLIMIT \n  1000;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT count(DISTINCT MebID) FROM m_membermain mm WHERE mm.Flag <> '0' AND mm.MebType IN (1,2,5,6,8) AND CreateTime >= '2025-09-02' AND CreateTime < '2025-09-03'"
                    }
                ]
            },
            {
                "case_id": "35",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"35\", \"db_type\": \"mysql\", \"description\": \"这是一个典型的消除无用计算的优化案例。当外层查询只是COUNT(*)时，内层子查询中计算的所有列值（包括通过子查询计算的auditJobIdcounts）都不会影响最终结果。COUNT(*)只关心有多少行满足WHERE条件，而不关心这些行的具体内容。因此可以直接将内层子查询展开，删除所有不必要的列选择和子查询计算，只保留WHERE条件。这种改写消除了189504次依赖子查询执行、临时表物化和34个列的数据读取，大幅提升性能。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE hotel_price_adjustment (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), brand_code VARCHAR(50), brand_name VARCHAR(200), hotel_code VARCHAR(50), hotel_name VARCHAR(200), currency VARCHAR(10), category VARCHAR(50), rate_code VARCHAR(50), rate_name VARCHAR(200), price_array_type VARCHAR(50), price_array_code VARCHAR(50), price_array_sequence INT, price_array TEXT, price_array2 TEXT, date_segment VARCHAR(100), weeks VARCHAR(50), brand_maximum_price DECIMAL(18,2), brand_minimum_price DECIMAL(18,2), room_code VARCHAR(50), room_name VARCHAR(200), room_standard_price DECIMAL(18,2), pre_adjustment_price DECIMAL(18,2), adjusted_price DECIMAL(18,2), price_adjustment_range VARCHAR(50), occupancy INT, status VARCHAR(20), reason TEXT, approve_status VARCHAR(20), approve_reason TEXT, operator VARCHAR(100), create_time DATETIME, update_time DATETIME, CREATE_USER_ID BIGINT) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_hotel_code ON hotel_price_adjustment(HOTEL_CODE);\", \"CREATE INDEX idx_create_user_id ON hotel_price_adjustment(CREATE_USER_ID);\", \"CREATE INDEX idx_apply_id ON hotel_price_adjustment(apply_id);\", \"CREATE TABLE price_adjustment_audit_job (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), job_id VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_apply_id_job_id ON price_adjustment_audit_job(apply_id, job_id);\"], \"sql\": \"SELECT \\n  COUNT(*) \\nFROM \\n  (\\n  SELECT \\n   id, \\n   apply_id, \\n   brand_code, \\n   brand_name, \\n   hotel_code, \\n   hotel_name, \\n   currency, \\n   category, \\n   rate_code, \\n   rate_name, \\n   price_array_type, \\n   price_array_code, \\n   price_array_sequence, \\n   price_array, \\n   price_array2, \\n   date_segment, \\n   weeks, \\n   brand_maximum_price, \\n   brand_minimum_price, \\n   room_code, \\n   room_name, \\n   room_standard_price, \\n   pre_adjustment_price, \\n   adjusted_price, \\n   price_adjustment_range, \\n   occupancy, \\n   status, \\n   reason, \\n   approve_status, \\n   approve_reason, \\n   operator, \\n   create_time, \\n   update_time, \\n   CREATE_USER_ID, \\n   (\\n   SELECT \\n   count(paaj.id) \\n   FROM \\n   price_adjustment_audit_job paaj \\n   WHERE \\n   paaj.apply_id = pa1.apply_id \\n   AND paaj.job_id = '4_004'\\n   ) AS auditJobIdcounts \\n  FROM \\n   hotel_price_adjustment pa1 \\n  WHERE \\n   (\\n   HOTEL_CODE IN ('6199', 'JJXRSEH802967') \\n   OR CREATE_USER_ID = 289865\\n   )\\n  ) TOTAL;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t189504\\t100.0\\t\\n2\\tDERIVED\\tpa1\\t\\tALL\\tidx_hotel_code,idx_create_user_id\\t\\t\\t\\t947046\\t20.01\\tUsing where\\n3\\tDEPENDENT SUBQUERY\\tpaaj\\t\\tref\\tidx_apply_id_job_id\\tidx_apply_id_job_id\\t606\\ttest_db.pa1.apply_id,const\\t189\\t100.0\\tUsing index\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"21321.70\\\"\\n  },\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"TOTAL\\\",\\n   \\\"access_type\\\": \\\"ALL\\\",\\n   \\\"rows_examined_per_scan\\\": 189504,\\n   \\\"rows_produced_per_join\\\": 189504,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"2371.30\\\",\\n   \\\"eval_cost\\\": \\\"18950.40\\\",\\n   \\\"prefix_cost\\\": \\\"21321.70\\\",\\n   \\\"data_read_per_join\\\": \\\"1G\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"id\\\",\\n   \\\"apply_id\\\",\\n   \\\"brand_code\\\",\\n   \\\"brand_name\\\",\\n   \\\"hotel_code\\\",\\n   \\\"hotel_name\\\",\\n   \\\"currency\\\",\\n   \\\"category\\\",\\n   \\\"rate_code\\\",\\n   \\\"rate_name\\\",\\n   \\\"price_array_type\\\",\\n   \\\"price_array_code\\\",\\n   \\\"price_array_sequence\\\",\\n   \\\"price_array\\\",\\n   \\\"price_array2\\\",\\n   \\\"date_segment\\\",\\n   \\\"weeks\\\",\\n   \\\"brand_maximum_price\\\",\\n   \\\"brand_minimum_price\\\",\\n   \\\"room_code\\\",\\n   \\\"room_name\\\",\\n   \\\"room_standard_price\\\",\\n   \\\"pre_adjustment_price\\\",\\n   \\\"adjusted_price\\\",\\n   \\\"price_adjustment_range\\\",\\n   \\\"occupancy\\\",\\n   \\\"status\\\",\\n   \\\"reason\\\",\\n   \\\"approve_status\\\",\\n   \\\"approve_reason\\\",\\n   \\\"operator\\\",\\n   \\\"create_time\\\",\\n   \\\"update_time\\\",\\n   \\\"CREATE_USER_ID\\\",\\n   \\\"auditJobIdcounts\\\"\\n   ],\\n   \\\"materialized_from_subquery\\\": {\\n   \\\"using_temporary_table\\\": true,\\n   \\\"dependent\\\": false,\\n   \\\"cacheable\\\": true,\\n   \\\"query_block\\\": {\\n   \\\"select_id\\\": 2,\\n   \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"119328.41\\\"\\n   },\\n   \\\"table\\\": {\\n  \\\"table_name\\\": \\\"pa1\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_hotel_code\\\",\\n  \\\"idx_create_user_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 947046,\\n  \\\"rows_produced_per_join\\\": 189504,\\n  \\\"filtered\\\": \\\"20.01\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"100378.00\\\",\\n  \\\"eval_cost\\\": \\\"18950.41\\\",\\n  \\\"prefix_cost\\\": \\\"119328.41\\\",\\n  \\\"data_read_per_join\\\": \\\"1G\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"apply_id\\\",\\n  \\\"brand_code\\\",\\n  \\\"brand_name\\\",\\n  \\\"hotel_code\\\",\\n  \\\"hotel_name\\\",\\n  \\\"currency\\\",\\n  \\\"category\\\",\\n  \\\"rate_code\\\",\\n  \\\"rate_name\\\",\\n  \\\"price_array_type\\\",\\n  \\\"price_array_code\\\",\\n  \\\"price_array_sequence\\\",\\n  \\\"price_array\\\",\\n  \\\"price_array2\\\",\\n  \\\"date_segment\\\",\\n  \\\"weeks\\\",\\n  \\\"brand_maximum_price\\\",\\n  \\\"brand_minimum_price\\\",\\n  \\\"room_code\\\",\\n  \\\"room_name\\\",\\n  \\\"room_standard_price\\\",\\n  \\\"pre_adjustment_price\\\",\\n  \\\"adjusted_price\\\",\\n  \\\"price_adjustment_range\\\",\\n  \\\"occupancy\\\",\\n  \\\"status\\\",\\n  \\\"reason\\\",\\n  \\\"approve_status\\\",\\n  \\\"approve_reason\\\",\\n  \\\"operator\\\",\\n  \\\"create_time\\\",\\n  \\\"update_time\\\",\\n  \\\"CREATE_USER_ID\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`pa1`.`hotel_code` in ('6199','JJXRSEH802967')) or (`test_db`.`pa1`.`CREATE_USER_ID` = 289865))\\\"\\n   },\\n   \\\"select_list_subqueries\\\": [\\n  {\\n  \\\"dependent\\\": true,\\n  \\\"cacheable\\\": false,\\n  \\\"query_block\\\": {\\n   \\\"select_id\\\": 3,\\n   \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"22.55\\\"\\n   },\\n   \\\"table\\\": {\\n   \\\"table_name\\\": \\\"paaj\\\",\\n   \\\"access_type\\\": \\\"ref\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"idx_apply_id_job_id\\\"\\n   ],\\n   \\\"key\\\": \\\"idx_apply_id_job_id\\\",\\n   \\\"used_key_parts\\\": [\\n   \\\"apply_id\\\",\\n   \\\"job_id\\\"\\n   ],\\n   \\\"key_length\\\": \\\"606\\\",\\n   \\\"ref\\\": [\\n   \\\"test_db.pa1.apply_id\\\",\\n   \\\"const\\\"\\n   ],\\n   \\\"rows_examined_per_scan\\\": 189,\\n   \\\"rows_produced_per_join\\\": 189,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"using_index\\\": true,\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"3.61\\\",\\n   \\\"eval_cost\\\": \\\"18.94\\\",\\n   \\\"prefix_cost\\\": \\\"22.55\\\",\\n   \\\"data_read_per_join\\\": \\\"113K\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"id\\\",\\n   \\\"apply_id\\\",\\n   \\\"job_id\\\"\\n   ]\\n   }\\n  }\\n  }\\n   ]\\n   }\\n   }\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE hotel_price_adjustment (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), brand_code VARCHAR(50), brand_name VARCHAR(200), hotel_code VARCHAR(50), hotel_name VARCHAR(200), currency VARCHAR(10), category VARCHAR(50), rate_code VARCHAR(50), rate_name VARCHAR(200), price_array_type VARCHAR(50), price_array_code VARCHAR(50), price_array_sequence INT, price_array TEXT, price_array2 TEXT, date_segment VARCHAR(100), weeks VARCHAR(50), brand_maximum_price DECIMAL(18,2), brand_minimum_price DECIMAL(18,2), room_code VARCHAR(50), room_name VARCHAR(200), room_standard_price DECIMAL(18,2), pre_adjustment_price DECIMAL(18,2), adjusted_price DECIMAL(18,2), price_adjustment_range VARCHAR(50), occupancy INT, status VARCHAR(20), reason TEXT, approve_status VARCHAR(20), approve_reason TEXT, operator VARCHAR(100), create_time DATETIME, update_time DATETIME, CREATE_USER_ID BIGINT) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_hotel_code ON hotel_price_adjustment(HOTEL_CODE);\nCREATE INDEX idx_create_user_id ON hotel_price_adjustment(CREATE_USER_ID);\nCREATE INDEX idx_apply_id ON hotel_price_adjustment(apply_id);\nCREATE TABLE price_adjustment_audit_job (id BIGINT PRIMARY KEY AUTO_INCREMENT, apply_id VARCHAR(100), job_id VARCHAR(50)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_apply_id_job_id ON price_adjustment_audit_job(apply_id, job_id);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t189504\t100.0\t\n2\tDERIVED\tpa1\t\tALL\tidx_hotel_code,idx_create_user_id\t\t\t\t947046\t20.01\tUsing where\n3\tDEPENDENT SUBQUERY\tpaaj\t\tref\tidx_apply_id_job_id\tidx_apply_id_job_id\t606\ttest_db.pa1.apply_id,const\t189\t100.0\tUsing index\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"21321.70\"\n  },\n  \"table\": {\n   \"table_name\": \"TOTAL\",\n   \"access_type\": \"ALL\",\n   \"rows_examined_per_scan\": 189504,\n   \"rows_produced_per_join\": 189504,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n   \"read_cost\": \"2371.30\",\n   \"eval_cost\": \"18950.40\",\n   \"prefix_cost\": \"21321.70\",\n   \"data_read_per_join\": \"1G\"\n   },\n   \"used_columns\": [\n   \"id\",\n   \"apply_id\",\n   \"brand_code\",\n   \"brand_name\",\n   \"hotel_code\",\n   \"hotel_name\",\n   \"currency\",\n   \"category\",\n   \"rate_code\",\n   \"rate_name\",\n   \"price_array_type\",\n   \"price_array_code\",\n   \"price_array_sequence\",\n   \"price_array\",\n   \"price_array2\",\n   \"date_segment\",\n   \"weeks\",\n   \"brand_maximum_price\",\n   \"brand_minimum_price\",\n   \"room_code\",\n   \"room_name\",\n   \"room_standard_price\",\n   \"pre_adjustment_price\",\n   \"adjusted_price\",\n   \"price_adjustment_range\",\n   \"occupancy\",\n   \"status\",\n   \"reason\",\n   \"approve_status\",\n   \"approve_reason\",\n   \"operator\",\n   \"create_time\",\n   \"update_time\",\n   \"CREATE_USER_ID\",\n   \"auditJobIdcounts\"\n   ],\n   \"materialized_from_subquery\": {\n   \"using_temporary_table\": true,\n   \"dependent\": false,\n   \"cacheable\": true,\n   \"query_block\": {\n   \"select_id\": 2,\n   \"cost_info\": {\n  \"query_cost\": \"119328.41\"\n   },\n   \"table\": {\n  \"table_name\": \"pa1\",\n  \"access_type\": \"ALL\",\n  \"possible_keys\": [\n  \"idx_hotel_code\",\n  \"idx_create_user_id\"\n  ],\n  \"rows_examined_per_scan\": 947046,\n  \"rows_produced_per_join\": 189504,\n  \"filtered\": \"20.01\",\n  \"cost_info\": {\n  \"read_cost\": \"100378.00\",\n  \"eval_cost\": \"18950.41\",\n  \"prefix_cost\": \"119328.41\",\n  \"data_read_per_join\": \"1G\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"apply_id\",\n  \"brand_code\",\n  \"brand_name\",\n  \"hotel_code\",\n  \"hotel_name\",\n  \"currency\",\n  \"category\",\n  \"rate_code\",\n  \"rate_name\",\n  \"price_array_type\",\n  \"price_array_code\",\n  \"price_array_sequence\",\n  \"price_array\",\n  \"price_array2\",\n  \"date_segment\",\n  \"weeks\",\n  \"brand_maximum_price\",\n  \"brand_minimum_price\",\n  \"room_code\",\n  \"room_name\",\n  \"room_standard_price\",\n  \"pre_adjustment_price\",\n  \"adjusted_price\",\n  \"price_adjustment_range\",\n  \"occupancy\",\n  \"status\",\n  \"reason\",\n  \"approve_status\",\n  \"approve_reason\",\n  \"operator\",\n  \"create_time\",\n  \"update_time\",\n  \"CREATE_USER_ID\"\n  ],\n  \"attached_condition\": \"((`test_db`.`pa1`.`hotel_code` in ('6199','JJXRSEH802967')) or (`test_db`.`pa1`.`CREATE_USER_ID` = 289865))\"\n   },\n   \"select_list_subqueries\": [\n  {\n  \"dependent\": true,\n  \"cacheable\": false,\n  \"query_block\": {\n   \"select_id\": 3,\n   \"cost_info\": {\n   \"query_cost\": \"22.55\"\n   },\n   \"table\": {\n   \"table_name\": \"paaj\",\n   \"access_type\": \"ref\",\n   \"possible_keys\": [\n   \"idx_apply_id_job_id\"\n   ],\n   \"key\": \"idx_apply_id_job_id\",\n   \"used_key_parts\": [\n   \"apply_id\",\n   \"job_id\"\n   ],\n   \"key_length\": \"606\",\n   \"ref\": [\n   \"test_db.pa1.apply_id\",\n   \"const\"\n   ],\n   \"rows_examined_per_scan\": 189,\n   \"rows_produced_per_join\": 189,\n   \"filtered\": \"100.00\",\n   \"using_index\": true,\n   \"cost_info\": {\n   \"read_cost\": \"3.61\",\n   \"eval_cost\": \"18.94\",\n   \"prefix_cost\": \"22.55\",\n   \"data_read_per_join\": \"113K\"\n   },\n   \"used_columns\": [\n   \"id\",\n   \"apply_id\",\n   \"job_id\"\n   ]\n   }\n  }\n  }\n   ]\n   }\n   }\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  COUNT(*) \nFROM \n  (\n  SELECT \n   id, \n   apply_id, \n   brand_code, \n   brand_name, \n   hotel_code, \n   hotel_name, \n   currency, \n   category, \n   rate_code, \n   rate_name, \n   price_array_type, \n   price_array_code, \n   price_array_sequence, \n   price_array, \n   price_array2, \n   date_segment, \n   weeks, \n   brand_maximum_price, \n   brand_minimum_price, \n   room_code, \n   room_name, \n   room_standard_price, \n   pre_adjustment_price, \n   adjusted_price, \n   price_adjustment_range, \n   occupancy, \n   status, \n   reason, \n   approve_status, \n   approve_reason, \n   operator, \n   create_time, \n   update_time, \n   CREATE_USER_ID, \n   (\n   SELECT \n   count(paaj.id) \n   FROM \n   price_adjustment_audit_job paaj \n   WHERE \n   paaj.apply_id = pa1.apply_id \n   AND paaj.job_id = '4_004'\n   ) AS auditJobIdcounts \n  FROM \n   hotel_price_adjustment pa1 \n  WHERE \n   (\n   HOTEL_CODE IN ('6199', 'JJXRSEH802967') \n   OR CREATE_USER_ID = 289865\n   )\n  ) TOTAL;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT COUNT(*) FROM (SELECT id FROM hotel_price_adjustment WHERE hotel_code IN ('6199','JJXRSEH802967') UNION SELECT id FROM hotel_price_adjustment WHERE CREATE_USER_ID = 289865) t"
                    }
                ]
            },
            {
                "case_id": "36",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"36\", \"db_type\": \"mysql\", \"description\": \"这种改写技术通过将OR条件拆分为多个UNION子查询，理论上可以让每个子查询更充分地利用索引。在某些数据库版本或特定场景下，当OR条件导致优化器无法有效使用索引时，这种改写可能带来性能提升。但在本案例中，MySQL的index_merge优化已经能够很好地处理OR条件，反而是UNION引入的额外开销导致性能下降\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE DOCUMENT (id INT PRIMARY KEY AUTO_INCREMENT, pdfKey VARCHAR(255), fileKey VARCHAR(255)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_pdfKey ON DOCUMENT(pdfKey);\", \"CREATE INDEX idx_fileKey ON DOCUMENT(fileKey);\"], \"sql\": \"SELECT \\n  * \\nfrom \\n  DOCUMENT \\nwhere \\n  (\\n  pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne' \\n  or fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'\\n  );\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tSIMPLE\\tDOCUMENT\\t\\tindex_merge\\tidx_pdfKey,idx_fileKey\\tidx_pdfKey,idx_fileKey\\t1023,1023\\t\\t2\\t100.0\\tUsing union(idx_pdfKey,idx_fileKey); Using where\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n   \\\"query_cost\\\": \\\"3.55\\\"\\n  },\\n  \\\"table\\\": {\\n   \\\"table_name\\\": \\\"DOCUMENT\\\",\\n   \\\"access_type\\\": \\\"index_merge\\\",\\n   \\\"possible_keys\\\": [\\n   \\\"idx_pdfKey\\\",\\n   \\\"idx_fileKey\\\"\\n   ],\\n   \\\"key\\\": \\\"union(idx_pdfKey,idx_fileKey)\\\",\\n   \\\"key_length\\\": \\\"1023,1023\\\",\\n   \\\"rows_examined_per_scan\\\": 2,\\n   \\\"rows_produced_per_join\\\": 2,\\n   \\\"filtered\\\": \\\"100.00\\\",\\n   \\\"cost_info\\\": {\\n   \\\"read_cost\\\": \\\"3.35\\\",\\n   \\\"eval_cost\\\": \\\"0.20\\\",\\n   \\\"prefix_cost\\\": \\\"3.55\\\",\\n   \\\"data_read_per_join\\\": \\\"4K\\\"\\n   },\\n   \\\"used_columns\\\": [\\n   \\\"id\\\",\\n   \\\"pdfKey\\\",\\n   \\\"fileKey\\\"\\n   ],\\n   \\\"attached_condition\\\": \\\"((`test_db`.`DOCUMENT`.`pdfKey` = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne') or (`test_db`.`DOCUMENT`.`fileKey` = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'))\\\"\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE DOCUMENT (id INT PRIMARY KEY AUTO_INCREMENT, pdfKey VARCHAR(255), fileKey VARCHAR(255)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_pdfKey ON DOCUMENT(pdfKey);\nCREATE INDEX idx_fileKey ON DOCUMENT(fileKey);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tSIMPLE\tDOCUMENT\t\tindex_merge\tidx_pdfKey,idx_fileKey\tidx_pdfKey,idx_fileKey\t1023,1023\t\t2\t100.0\tUsing union(idx_pdfKey,idx_fileKey); Using where\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n   \"query_cost\": \"3.55\"\n  },\n  \"table\": {\n   \"table_name\": \"DOCUMENT\",\n   \"access_type\": \"index_merge\",\n   \"possible_keys\": [\n   \"idx_pdfKey\",\n   \"idx_fileKey\"\n   ],\n   \"key\": \"union(idx_pdfKey,idx_fileKey)\",\n   \"key_length\": \"1023,1023\",\n   \"rows_examined_per_scan\": 2,\n   \"rows_produced_per_join\": 2,\n   \"filtered\": \"100.00\",\n   \"cost_info\": {\n   \"read_cost\": \"3.35\",\n   \"eval_cost\": \"0.20\",\n   \"prefix_cost\": \"3.55\",\n   \"data_read_per_join\": \"4K\"\n   },\n   \"used_columns\": [\n   \"id\",\n   \"pdfKey\",\n   \"fileKey\"\n   ],\n   \"attached_condition\": \"((`test_db`.`DOCUMENT`.`pdfKey` = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne') or (`test_db`.`DOCUMENT`.`fileKey` = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'))\"\n  }\n  }\n}\n\n## Original SQL:\nSELECT \n  * \nfrom \n  DOCUMENT \nwhere \n  (\n  pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne' \n  or fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'\n  );\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM DOCUMENT WHERE pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne' UNION ALL SELECT * FROM DOCUMENT WHERE fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'"
                    }
                ]
            },
            {
                "case_id": "37",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"37\", \"db_type\": \"oracle\", \"description\": \"问题概述：查询通过 CTE a1 对 FEE_LIST_D 做了大量的聚合（多个 LISTAGG、SUM、MIN 等），并在 a2 中使用 `a1.*` 再做计算和过滤后与 SETL_D_MERGED 连接。实际最终 SELECT 只使用了 a1 中的一部分列（例如 b_fee、min_amt 等列并未被外层查询引用），但由于使用了 `a1.*` 导致这些不必要的列在聚合阶段就被计算/传递，增加了 CPU、内存与 I/O 开销，同时阻止了投影下推优化。建议通过投影下推（在 a1 中仅输出外层实际需要的列，避免 a1.*）来减少中间数据量与聚合成本；同时可考虑在 a1 中下推过滤谓词并为连接列建索引以进一步降低成本。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE FEE_LIST_D (setl_id VARCHAR2(50), MEDINS_LIST_CODG VARCHAR2(100), medins_list_name VARCHAR2(200), hilist_code VARCHAR2(100), hilist_name VARCHAR2(200), MED_CHRGITM_TYPE_NAME VARCHAR2(100), CHRGITM_LV_NAME VARCHAR2(50), BILG_DEPT_NAME VARCHAR2(200), BILG_DR_NAME VARCHAR2(200), ACORD_DEPT_NAME VARCHAR2(200), ACORD_DR_NAME VARCHAR2(200), cnt NUMBER, det_item_fee_sumamt NUMBER(18,2), pric NUMBER(18,4), inscp_amt NUMBER(18,2));\", \"CREATE INDEX idx_fee_list_d_setl_id ON FEE_LIST_D(setl_id);\", \"CREATE INDEX idx_fee_list_d_cnt ON FEE_LIST_D(cnt);\", \"CREATE TABLE SETL_D_MERGED (setl_id VARCHAR2(50) PRIMARY KEY, fixmedins_code VARCHAR2(50), fixmedins_name VARCHAR2(200), HOSP_LV_NAME VARCHAR2(50), mdtrt_id VARCHAR2(50), ipt_otp_no VARCHAR2(50), psn_no VARCHAR2(50), psn_name VARCHAR2(200), certno VARCHAR2(30), GEND_NAME VARCHAR2(20), brdy DATE, age NUMBER, insu_admdvs VARCHAR2(50), INSUTYPE_NAME VARCHAR2(100), PSN_TYPE_NAME VARCHAR2(100), SP_PSN_TYPE_NAME VARCHAR2(100), med_type_name VARCHAR2(100), PAY_LOC_NAME VARCHAR2(100), setl_time DATE, adm_dept_name VARCHAR2(200), dscg_dept_name VARCHAR2(200), begntime DATE, endtime DATE, IPT_DAYS NUMBER, chfpdr_name VARCHAR2(200), adm_diag_dscr VARCHAR2(4000), dscg_maindiag_name VARCHAR2(4000), DIAG_NAME VARCHAR2(4000), dise_no VARCHAR2(50), dise_name VARCHAR2(200), OPRN_NAME VARCHAR2(4000), medfee_sumamt NUMBER(18,2), pool_prop_selfpay NUMBER, hifp_pay NUMBER, hifmi_pay NUMBER, maf_pay NUMBER, cvlserv_pay NUMBER, othfund_pay NUMBER, acct_pay NUMBER, cash_payamt NUMBER, fund_pay_sumamt NUMBER, insutype VARCHAR2(50));\", \"CREATE INDEX idx_setl_d_merged_setl_id ON SETL_D_MERGED(setl_id);\", \"CREATE INDEX idx_setl_d_fund_pay ON SETL_D_MERGED(FUND_PAY_SUMAMT)\"], \"sql\": \"with\\na1 as (\\n  select\\n  setl_id,\\n  -- 聚合项目信息\\n  listagg(distinct MEDINS_LIST_CODG, ',') within group (order by MEDINS_LIST_CODG) b_medins_list_codg,\\n  listagg(distinct medins_list_name, ',') within group (order by medins_list_name) b_medins_list_name,\\n  listagg(distinct f.hilist_code, ',') within group (order by f.hilist_code) b_hilist_code,\\n  listagg(distinct hilist_name, ',') within group (order by hilist_name) b_hilist_name,\\n  listagg(distinct MED_CHRGITM_TYPE_NAME, ',') within group (order by MED_CHRGITM_TYPE_NAME) MED_CHRGITM_TYPE,\\n  listagg(distinct CHRGITM_LV_NAME, ',') within group (order by CHRGITM_LV_NAME) CHRGITM_LV,\\n  listagg(distinct BILG_DEPT_NAME, ',') within group (order by BILG_DEPT_NAME) BILG_DEPT_NAME,\\n  listagg(distinct BILG_DR_NAME, ',') within group (order by BILG_DR_NAME) BILG_DR_NAME,\\n  listagg(distinct ACORD_DEPT_NAME, ',') within group (order by ACORD_DEPT_NAME) ACORD_DEPT_NAME,\\n  listagg(distinct ACORD_DR_NAME, ',') within group (order by ACORD_DR_NAME) ACORD_DR_NAME,\\n  -- 统一转换为“日”单位后的总数量\\n  sum(f.cnt ) as b_cnt,\\n  -- 总费用\\n  sum(f.det_item_fee_sumamt) as b_fee,\\n  -- 转换为“日”单位后的最小单价\\n  min(f.pric ) as min_pric,\\n  -- 转换为“日”单位后的最小金额\\n  min(abs(f.inscp_amt / f.cnt) ) as min_amt\\n  from FEE_LIST_D f\\n  -- 关联单位转换系数表\\n   where f.cnt <> 0\\n   and f.CHRGITM_LV_NAME in ('甲类','乙类')\\n  -- 按结算流水号分组\\n  group by f.setl_id\\n),\\na2 as (\\n  select a1.*,\\n  -- 违规数量\\n  case\\n   when a1.b_cnt > (s.ipt_days *12+24) then a1.b_cnt - (s.ipt_days *12+24)\\n   else 0\\n  end as break_cnt,\\n  -- 违规金额\\n  case\\n   when a1.b_cnt > (s.ipt_days *12+24) then (a1.b_cnt - (s.ipt_days *12+24)) * (a1.min_pric * 1)\\n   else 0\\n  end as break_fee,\\n  -- 违规范围内金额\\n  case\\n   when a1.b_cnt > (s.ipt_days *12+24) then (a1.b_cnt - (s.ipt_days *12+24)) * (a1.min_amt * 1)\\n   else 0\\n  end as break_amt\\n  from a1\\n  -- 关联结算表获取住院天数\\n  inner join SETL_D_MERGED s on a1.setl_id = s.setl_id\\n  -- 过滤违规数据\\n  where a1.b_cnt > (s.ipt_days *12+24)\\n   and s.FUND_PAY_SUMAMT <> 0\\n)\\nselect\\n  s.fixmedins_code 医院代码,\\n  s.fixmedins_name 医院名称,\\n  s.HOSP_LV_NAME 医院级别,\\n  s.setl_id 结算单据号,\\n  s.mdtrt_id 就诊ID,\\n  s.ipt_otp_no 住院号,\\n  s.psn_no 个人编号,\\n  s.psn_name 姓名,\\n  s.certno 身份证号,\\n  s.GEND_NAME 性别,\\n  s.brdy 出生日期,\\n  s.age 年龄,\\n  s.insu_admdvs 统筹区,\\n  s.INSUTYPE_NAME 险种类型,\\n  s.PSN_TYPE_NAME 医疗人员类别,\\n  s.SP_PSN_TYPE_NAME 特殊人员身份类别,\\n  s.med_type_name 就医类型,\\n  s.PAY_LOC_NAME 支付地点类别,\\n  s.setl_time 结算日期,\\n  s.adm_dept_name 入院科室,\\n  s.dscg_dept_name 出院科室,\\n  s.begntime 入院日期,\\n  s.endtime 出院日期,\\n  s.IPT_DAYS 天数,\\n  s.chfpdr_name 主治医生,\\n  s.adm_diag_dscr 入院诊断,\\n  s.dscg_maindiag_name 出院诊断,\\n  s.DIAG_NAME 其他诊断,\\n  s.dise_no 病种编码,\\n  s.dise_name 病种名称,\\n  s.OPRN_NAME 手术及操作名称,\\n  s.medfee_sumamt 总金额,\\n  concat(to_char(s.pool_prop_selfpay * 100), '%') 基本医疗统筹支付比例,\\n  s.hifp_pay 基本医保支付,\\n  s.hifmi_pay 大病报销,\\n  s.maf_pay 医疗救助,\\n  s.cvlserv_pay 公务员补充,\\n  s.othfund_pay 其他支付,\\n  s.acct_pay 个人帐户支付,\\n  s.cash_payamt 个人现金支付,\\n  s.fund_pay_sumamt 基金支付总额,\\n  fl.MED_CHRGITM_TYPE 费用类别,\\n  fl.BILG_DEPT_NAME 开单科室名称,\\n  fl.BILG_DR_NAME 开单医生姓名,\\n  fl.ACORD_DEPT_NAME 受单科室名称,\\n  fl.ACORD_DR_NAME 受单医生姓名,\\n  null 收费日期,\\n  fl.b_medins_list_codg 违规医院项目代码,\\n  fl.b_medins_list_name 违规医院项目名称,\\n  fl.b_hilist_code 违规医保项目代码,\\n  fl.b_hilist_name 违规医保项目名称,\\n  null 正常医院项目代码,\\n  null 正常医院项目名称,\\n  null 正常医保项目代码,\\n  null 正常医保项目名称,\\n  null 正常项目数量,\\n  null 正常项目金额,\\n  fl.b_cnt 违规项目收费数量,\\n  fl.min_pric 违规项目单价,\\n  fl.break_cnt 违规项目数量,\\n  fl.CHRGITM_LV 违规项目支付类别,\\n  fl.break_fee 违规项目金额,\\n  fl.break_amt 违规项目范围内金额,\\n  gettcamount(fl.break_amt, s.pool_prop_selfpay, s.hifp_pay, s.fund_pay_sumamt) 基本统筹违规金额,\\n  getdbamount(fl.break_amt, s.insutype, s.hifmi_pay, s.fund_pay_sumamt) 大病统筹违规金额,\\n  GETMAFAMOUNT(fl.break_amt, s.maf_pay, s.fund_pay_sumamt) 医疗救助违规金额,\\n  case when substr(s.INSU_ADMDVS,1,4) != '{pool_no}' then '是' else '否' end 是否异地,\\n  'CB_0020' 违规规则代码,\\n  '超标准收费' 违规类型,\\n  '按小时收费的血液净化类诊疗项目（如自动腹膜透析、连续性血液净化等），收费数量超过实际提供的诊疗服务数量。' 违规事项,\\n  '《江西省医疗服务价格项目目录（2023年修订版）》中血液净化类诊疗项目收费的真实性。' 违规依据\\nfrom SETL_D_MERGED s\\ninner join a2 fl on s.setl_id = fl.setl_id\\nwhere s.FUND_PAY_SUMAMT <> 0\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t1250\\t1000\\t800000\\t400000\\t1200\\n1\\t  NESTED LOOPS\\t1250\\t1000\\t800000\\t400000\\t1200\\n2\\t   VIEW (A2 - FILTER & JOIN)\\t1000\\t1000\\t600000\\t300000\\t800\\n3\\t  HASH GROUP BY (A1 aggregation)\\t1000\\t1000\\t600000\\t300000\\t800\\n4\\t   TABLE ACCESS FULL FEE_LIST_D\\t900\\t10000\\t5400000\\t270000\\t700\\n5\\t   TABLE ACCESS BY INDEX ROWID SETL_D_MERGED\\t200\\t1000\\t800000\\t80000\\t400\\n6\\t  INDEX UNIQUE SCAN IDX_SETL_D_MERGED_SETL_ID\\t5\\t1000\\t8000\\t2000\\t10\\n7\\t  FILTER (s.FUND_PAY_SUMAMT <> 0 AND a1.b_cnt > (s.ipt_days*12+24))\\t---\\t---\\t---\\t---\\t---\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE FEE_LIST_D (setl_id VARCHAR2(50), MEDINS_LIST_CODG VARCHAR2(100), medins_list_name VARCHAR2(200), hilist_code VARCHAR2(100), hilist_name VARCHAR2(200), MED_CHRGITM_TYPE_NAME VARCHAR2(100), CHRGITM_LV_NAME VARCHAR2(50), BILG_DEPT_NAME VARCHAR2(200), BILG_DR_NAME VARCHAR2(200), ACORD_DEPT_NAME VARCHAR2(200), ACORD_DR_NAME VARCHAR2(200), cnt NUMBER, det_item_fee_sumamt NUMBER(18,2), pric NUMBER(18,4), inscp_amt NUMBER(18,2));\nCREATE INDEX idx_fee_list_d_setl_id ON FEE_LIST_D(setl_id);\nCREATE INDEX idx_fee_list_d_cnt ON FEE_LIST_D(cnt);\nCREATE TABLE SETL_D_MERGED (setl_id VARCHAR2(50) PRIMARY KEY, fixmedins_code VARCHAR2(50), fixmedins_name VARCHAR2(200), HOSP_LV_NAME VARCHAR2(50), mdtrt_id VARCHAR2(50), ipt_otp_no VARCHAR2(50), psn_no VARCHAR2(50), psn_name VARCHAR2(200), certno VARCHAR2(30), GEND_NAME VARCHAR2(20), brdy DATE, age NUMBER, insu_admdvs VARCHAR2(50), INSUTYPE_NAME VARCHAR2(100), PSN_TYPE_NAME VARCHAR2(100), SP_PSN_TYPE_NAME VARCHAR2(100), med_type_name VARCHAR2(100), PAY_LOC_NAME VARCHAR2(100), setl_time DATE, adm_dept_name VARCHAR2(200), dscg_dept_name VARCHAR2(200), begntime DATE, endtime DATE, IPT_DAYS NUMBER, chfpdr_name VARCHAR2(200), adm_diag_dscr VARCHAR2(4000), dscg_maindiag_name VARCHAR2(4000), DIAG_NAME VARCHAR2(4000), dise_no VARCHAR2(50), dise_name VARCHAR2(200), OPRN_NAME VARCHAR2(4000), medfee_sumamt NUMBER(18,2), pool_prop_selfpay NUMBER, hifp_pay NUMBER, hifmi_pay NUMBER, maf_pay NUMBER, cvlserv_pay NUMBER, othfund_pay NUMBER, acct_pay NUMBER, cash_payamt NUMBER, fund_pay_sumamt NUMBER, insutype VARCHAR2(50));\nCREATE INDEX idx_setl_d_merged_setl_id ON SETL_D_MERGED(setl_id);\nCREATE INDEX idx_setl_d_fund_pay ON SETL_D_MERGED(FUND_PAY_SUMAMT)\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t1250\t1000\t800000\t400000\t1200\n1\t  NESTED LOOPS\t1250\t1000\t800000\t400000\t1200\n2\t   VIEW (A2 - FILTER & JOIN)\t1000\t1000\t600000\t300000\t800\n3\t  HASH GROUP BY (A1 aggregation)\t1000\t1000\t600000\t300000\t800\n4\t   TABLE ACCESS FULL FEE_LIST_D\t900\t10000\t5400000\t270000\t700\n5\t   TABLE ACCESS BY INDEX ROWID SETL_D_MERGED\t200\t1000\t800000\t80000\t400\n6\t  INDEX UNIQUE SCAN IDX_SETL_D_MERGED_SETL_ID\t5\t1000\t8000\t2000\t10\n7\t  FILTER (s.FUND_PAY_SUMAMT <> 0 AND a1.b_cnt > (s.ipt_days*12+24))\t---\t---\t---\t---\t---\n\n## Original SQL:\nwith\na1 as (\n  select\n  setl_id,\n  -- 聚合项目信息\n  listagg(distinct MEDINS_LIST_CODG, ',') within group (order by MEDINS_LIST_CODG) b_medins_list_codg,\n  listagg(distinct medins_list_name, ',') within group (order by medins_list_name) b_medins_list_name,\n  listagg(distinct f.hilist_code, ',') within group (order by f.hilist_code) b_hilist_code,\n  listagg(distinct hilist_name, ',') within group (order by hilist_name) b_hilist_name,\n  listagg(distinct MED_CHRGITM_TYPE_NAME, ',') within group (order by MED_CHRGITM_TYPE_NAME) MED_CHRGITM_TYPE,\n  listagg(distinct CHRGITM_LV_NAME, ',') within group (order by CHRGITM_LV_NAME) CHRGITM_LV,\n  listagg(distinct BILG_DEPT_NAME, ',') within group (order by BILG_DEPT_NAME) BILG_DEPT_NAME,\n  listagg(distinct BILG_DR_NAME, ',') within group (order by BILG_DR_NAME) BILG_DR_NAME,\n  listagg(distinct ACORD_DEPT_NAME, ',') within group (order by ACORD_DEPT_NAME) ACORD_DEPT_NAME,\n  listagg(distinct ACORD_DR_NAME, ',') within group (order by ACORD_DR_NAME) ACORD_DR_NAME,\n  -- 统一转换为“日”单位后的总数量\n  sum(f.cnt ) as b_cnt,\n  -- 总费用\n  sum(f.det_item_fee_sumamt) as b_fee,\n  -- 转换为“日”单位后的最小单价\n  min(f.pric ) as min_pric,\n  -- 转换为“日”单位后的最小金额\n  min(abs(f.inscp_amt / f.cnt) ) as min_amt\n  from FEE_LIST_D f\n  -- 关联单位转换系数表\n   where f.cnt <> 0\n   and f.CHRGITM_LV_NAME in ('甲类','乙类')\n  -- 按结算流水号分组\n  group by f.setl_id\n),\na2 as (\n  select a1.*,\n  -- 违规数量\n  case\n   when a1.b_cnt > (s.ipt_days *12+24) then a1.b_cnt - (s.ipt_days *12+24)\n   else 0\n  end as break_cnt,\n  -- 违规金额\n  case\n   when a1.b_cnt > (s.ipt_days *12+24) then (a1.b_cnt - (s.ipt_days *12+24)) * (a1.min_pric * 1)\n   else 0\n  end as break_fee,\n  -- 违规范围内金额\n  case\n   when a1.b_cnt > (s.ipt_days *12+24) then (a1.b_cnt - (s.ipt_days *12+24)) * (a1.min_amt * 1)\n   else 0\n  end as break_amt\n  from a1\n  -- 关联结算表获取住院天数\n  inner join SETL_D_MERGED s on a1.setl_id = s.setl_id\n  -- 过滤违规数据\n  where a1.b_cnt > (s.ipt_days *12+24)\n   and s.FUND_PAY_SUMAMT <> 0\n)\nselect\n  s.fixmedins_code 医院代码,\n  s.fixmedins_name 医院名称,\n  s.HOSP_LV_NAME 医院级别,\n  s.setl_id 结算单据号,\n  s.mdtrt_id 就诊ID,\n  s.ipt_otp_no 住院号,\n  s.psn_no 个人编号,\n  s.psn_name 姓名,\n  s.certno 身份证号,\n  s.GEND_NAME 性别,\n  s.brdy 出生日期,\n  s.age 年龄,\n  s.insu_admdvs 统筹区,\n  s.INSUTYPE_NAME 险种类型,\n  s.PSN_TYPE_NAME 医疗人员类别,\n  s.SP_PSN_TYPE_NAME 特殊人员身份类别,\n  s.med_type_name 就医类型,\n  s.PAY_LOC_NAME 支付地点类别,\n  s.setl_time 结算日期,\n  s.adm_dept_name 入院科室,\n  s.dscg_dept_name 出院科室,\n  s.begntime 入院日期,\n  s.endtime 出院日期,\n  s.IPT_DAYS 天数,\n  s.chfpdr_name 主治医生,\n  s.adm_diag_dscr 入院诊断,\n  s.dscg_maindiag_name 出院诊断,\n  s.DIAG_NAME 其他诊断,\n  s.dise_no 病种编码,\n  s.dise_name 病种名称,\n  s.OPRN_NAME 手术及操作名称,\n  s.medfee_sumamt 总金额,\n  concat(to_char(s.pool_prop_selfpay * 100), '%') 基本医疗统筹支付比例,\n  s.hifp_pay 基本医保支付,\n  s.hifmi_pay 大病报销,\n  s.maf_pay 医疗救助,\n  s.cvlserv_pay 公务员补充,\n  s.othfund_pay 其他支付,\n  s.acct_pay 个人帐户支付,\n  s.cash_payamt 个人现金支付,\n  s.fund_pay_sumamt 基金支付总额,\n  fl.MED_CHRGITM_TYPE 费用类别,\n  fl.BILG_DEPT_NAME 开单科室名称,\n  fl.BILG_DR_NAME 开单医生姓名,\n  fl.ACORD_DEPT_NAME 受单科室名称,\n  fl.ACORD_DR_NAME 受单医生姓名,\n  null 收费日期,\n  fl.b_medins_list_codg 违规医院项目代码,\n  fl.b_medins_list_name 违规医院项目名称,\n  fl.b_hilist_code 违规医保项目代码,\n  fl.b_hilist_name 违规医保项目名称,\n  null 正常医院项目代码,\n  null 正常医院项目名称,\n  null 正常医保项目代码,\n  null 正常医保项目名称,\n  null 正常项目数量,\n  null 正常项目金额,\n  fl.b_cnt 违规项目收费数量,\n  fl.min_pric 违规项目单价,\n  fl.break_cnt 违规项目数量,\n  fl.CHRGITM_LV 违规项目支付类别,\n  fl.break_fee 违规项目金额,\n  fl.break_amt 违规项目范围内金额,\n  gettcamount(fl.break_amt, s.pool_prop_selfpay, s.hifp_pay, s.fund_pay_sumamt) 基本统筹违规金额,\n  getdbamount(fl.break_amt, s.insutype, s.hifmi_pay, s.fund_pay_sumamt) 大病统筹违规金额,\n  GETMAFAMOUNT(fl.break_amt, s.maf_pay, s.fund_pay_sumamt) 医疗救助违规金额,\n  case when substr(s.INSU_ADMDVS,1,4) != '{pool_no}' then '是' else '否' end 是否异地,\n  'CB_0020' 违规规则代码,\n  '超标准收费' 违规类型,\n  '按小时收费的血液净化类诊疗项目（如自动腹膜透析、连续性血液净化等），收费数量超过实际提供的诊疗服务数量。' 违规事项,\n  '《江西省医疗服务价格项目目录（2023年修订版）》中血液净化类诊疗项目收费的真实性。' 违规依据\nfrom SETL_D_MERGED s\ninner join a2 fl on s.setl_id = fl.setl_id\nwhere s.FUND_PAY_SUMAMT <> 0\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "with a1 as (select setl_id,listagg(distinct MEDINS_LIST_CODG, ',') within group (order by MEDINS_LIST_CODG) b_medins_list_codg,listagg(distinct medins_list_name, ',') within group (order by medins_list_name) b_medins_list_name,listagg(distinct hilist_code, ',') within group (order by hilist_code) b_hilist_code,listagg(distinct hilist_name, ',') within group (order by hilist_name) b_hilist_name,listagg(distinct MED_CHRGITM_TYPE_NAME, ',') within group (order by MED_CHRGITM_TYPE_NAME) MED_CHRGITM_TYPE,listagg(distinct CHRGITM_LV_NAME, ',') within group (order by CHRGITM_LV_NAME) CHRGITM_LV,listagg(distinct BILG_DEPT_NAME, ',') within group (order by BILG_DEPT_NAME) BILG_DEPT_NAME,listagg(distinct BILG_DR_NAME, ',') within group (order by BILG_DR_NAME) BILG_DR_NAME,listagg(distinct ACORD_DEPT_NAME, ',') within group (order by ACORD_DEPT_NAME) ACORD_DEPT_NAME,listagg(distinct ACORD_DR_NAME, ',') within group (order by ACORD_DR_NAME) ACORD_DR_NAME,sum(cnt) as b_cnt,sum(det_item_fee_sumamt) as b_fee,min(pric) as min_pric,min(abs(inscp_amt/cnt)) as min_amt from FEE_LIST_D where cnt <> 0 and CHRGITM_LV_NAME in ('甲类','乙类') group by setl_id),a2 as (select a1.*,s.fixmedins_code,s.fixmedins_name,s.HOSP_LV_NAME,s.mdtrt_id,s.ipt_otp_no,s.psn_no,s.psn_name,s.certno,s.GEND_NAME,s.brdy,s.age,s.insu_admdvs,s.INSUTYPE_NAME,s.PSN_TYPE_NAME,s.SP_PSN_TYPE_NAME,s.med_type_name,s.PAY_LOC_NAME,s.setl_time,s.adm_dept_name,s.dscg_dept_name,s.begntime,s.endtime,s.IPT_DAYS,s.chfpdr_name,s.adm_diag_dscr,s.dscg_maindiag_name,s.DIAG_NAME,s.dise_no,s.dise_name,s.OPRN_NAME,s.medfee_sumamt,s.pool_prop_selfpay,s.hifp_pay,s.hifmi_pay,s.maf_pay,s.cvlserv_pay,s.othfund_pay,s.acct_pay,s.cash_payamt,s.fund_pay_sumamt,s.insutype,case when a1.b_cnt > (s.ipt_days*12+24) then a1.b_cnt - (s.ipt_days*12+24) else 0 end as break_cnt,case when a1.b_cnt > (s.ipt_days*12+24) then (a1.b_cnt - (s.ipt_days*12+24)) * (a1.min_pric * 1) else 0 end as break_fee,case when a1.b_cnt > (s.ipt_days*12+24) then (a1.b_cnt - (s.ipt_days*12+24)) * (a1.min_amt * 1) else 0 end as break_amt from a1 inner join SETL_D_MERGED s on a1.setl_id = s.setl_id where a1.b_cnt > (s.ipt_days*12+24) and s.FUND_PAY_SUMAMT <> 0) select a2.fixmedins_code 医院代码,a2.fixmedins_name 医院名称,a2.HOSP_LV_NAME 医院级别,a2.setl_id 结算单据号,a2.mdtrt_id 就诊ID,a2.ipt_otp_no 住院号,a2.psn_no 个人编号,a2.psn_name 姓名,a2.certno 身份证号,a2.GEND_NAME 性别,a2.brdy 出生日期,a2.age 年龄,a2.insu_admdvs 统筹区,a2.INSUTYPE_NAME 险种类型,a2.PSN_TYPE_NAME 医疗人员类别,a2.SP_PSN_TYPE_NAME 特殊人员身份类别,a2.med_type_name 就医类型,a2.PAY_LOC_NAME 支付地点类别,a2.setl_time 结算日期,a2.adm_dept_name 入院科室,a2.dscg_dept_name 出院科室,a2.begntime 入院日期,a2.endtime 出院日期,a2.IPT_DAYS 天数,a2.chfpdr_name 主治医生,a2.adm_diag_dscr 入院诊断,a2.dscg_maindiag_name 出院诊断,a2.DIAG_NAME 其他诊断,a2.dise_no 病种编码,a2.dise_name 病种名称,a2.OPRN_NAME 手术及操作名称,a2.medfee_sumamt 总金额,concat(to_char(a2.pool_prop_selfpay * 100), '%') 基本医疗统筹支付比例,a2.hifp_pay 基本医保支付,a2.hifmi_pay 大病报销,a2.maf_pay 医疗救助,a2.cvlserv_pay 公务员补充,a2.othfund_pay 其他支付,a2.acct_pay 个人帐户支付,a2.cash_payamt 个人现金支付,a2.fund_pay_sumamt 基金支付总额,a2.MED_CHRGITM_TYPE 费用类别,a2.BILG_DEPT_NAME 开单科室名称,a2.BILG_DR_NAME 开单医生姓名,a2.ACORD_DEPT_NAME 受单科室名称,a2.ACORD_DR_NAME 受单医生姓名,null 收费日期,a2.b_medins_list_codg 违规医院项目代码,a2.b_medins_list_name 违规医院项目名称,a2.b_hilist_code 违规医保项目代码,a2.b_hilist_name 违规医保项目名称,null 正常医院项目代码,null 正常医院项目名称,null 正常医保项目代码,null 正常医保项目名称,null 正常项目数量,null 正常项目金额,a2.b_cnt 违规项目收费数量,a2.min_pric 违规项目单价,a2.break_cnt 违规项目数量,a2.CHRGITM_LV 违规项目支付类别,a2.break_fee 违规项目金额,a2.break_amt 违规项目范围内金额,gettcamount(a2.break_amt, a2.pool_prop_selfpay, a2.hifp_pay, a2.fund_pay_sumamt) 基本统筹违规金额,getdbamount(a2.break_amt, a2.insutype, a2.hifmi_pay, a2.fund_pay_sumamt) 大病统筹违规金额,GETMAFAMOUNT(a2.break_amt, a2.maf_pay, a2.fund_pay_sumamt) 医疗救助违规金额,case when substr(a2.INSU_ADMDVS,1,4) != '{pool_no}' then '是' else '否' end 是否异地,'CB_0020' 违规规则代码,'超标准收费' 违规类型,'按小时收费的血液净化类诊疗项目（如自动腹膜透析、连续性血液净化等），收费数量超过实际提供的诊疗服务数量。' 违规事项,'《江西省医疗服务价格项目目录（2023年修订版）》中血液净化类诊疗项目收费的真实性。' 违规依据 from a2"
                    }
                ]
            },
            {
                "case_id": "38",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"38\", \"db_type\": \"oracle\", \"description\": \"问题概述：该查询在 HRM_FLOOR.C_BASE_STATION_T(B) 上有多重等值过滤（BU_ID、HAC_ID、KEY_STATION_ID 列和 MFG_PROCESS_ID、DEL_FLAG），并且在主表 P 上按 WORK_DATE 与 DEL_FLAG 进行筛选，同时包含一个关联的 EXISTS 子查询来确认员工在对应站点的有效执照记录。潜在性能问题包括：1) 如果用于比较的列与字面量类型不匹配（例如 WORK_DATE 字段若为 VARCHAR 则与 DATE 常量比较会发生隐式类型转换），会导致索引失效；2) 缺少覆盖这些谓词和关联列的复合索引，会使得优化器采用全表扫描或大量回表，增加 I/O；3) EXISTS 子查询使用逗号分隔的老式连接写法（F, H）且为相关子查询，会导致对每一行执行索引查找/范围扫描，若 H/F 没有在 (EMP_NO, LICENSE_ID) 与 (LICENSE_ID, STATION_ID) 上建立合适索引，会产生大量随机 I/O。建议：确认 WORK_DATE/相关列数据类型与谓词匹配以避免隐式转换；为 B 表建立复合索引覆盖 (BU_ID, HAC_ID, KEY_STATION_ID, MFG_PROCESS_ID, DEL_FLAG) 或拆分为多个选择性索引；为 P 表建立 (WORK_DATE, DEL_FLAG, STATION_ID, EMP_NO) 索引以支持主谓词和后续关联；为 R_KEY_STATION_MAN_T 与 R_KEY_STATION_LICENSE_T 分别建立针对 (EMP_NO, LICENSE_ID, LOSE_FLAG, DEL_FLAG) 与 (LICENSE_ID, STATION_ID, DEL_FLAG) 的索引；将 EXISTS 子查询改写为显式 JOIN 或至少使用关联索引以减少对每行的重复查找。同时建议将高选择性谓词（如 P.DEL_FLAG=0、B.DEL_FLAG=0、B.BU_ID 等）尽量作为最先评估的过滤条件，降低后续关联数据量。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE HRM_FLOOR.C_BASE_STATION_T (ID NUMBER PRIMARY KEY, STATION_NAME_ENG VARCHAR2(200), BU_ID NUMBER, HAC_ID NUMBER, KEY_STATION_ID NUMBER, MFG_PROCESS_ID NUMBER, DEL_FLAG NUMBER);\", \"CREATE INDEX IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL ON HRM_FLOOR.C_BASE_STATION_T(BU_ID, HAC_ID, KEY_STATION_ID, MFG_PROCESS_ID, DEL_FLAG);\", \"CREATE TABLE HRM_FLOOR.R_EMP_STATION_PLAN_T (ID NUMBER PRIMARY KEY, WORK_DATE DATE, DEL_FLAG NUMBER, HWT_TYPE_ID NUMBER, LINE_ID NUMBER, STATION_ID NUMBER, EMP_NO VARCHAR2(50));\", \"CREATE INDEX IDX_R_EMP_STATION_PLAN_WORKDATE ON HRM_FLOOR.R_EMP_STATION_PLAN_T(WORK_DATE, DEL_FLAG, STATION_ID, EMP_NO);\", \"CREATE TABLE HRM_FLOOR.R_KEY_STATION_MAN_T (ID NUMBER PRIMARY KEY, LICENSE_ID NUMBER, EMP_NO VARCHAR2(50), LOSE_FLAG NUMBER, DEL_FLAG NUMBER);\", \"CREATE INDEX IDX_R_KEY_STATION_MAN_EMP_LICENSE ON HRM_FLOOR.R_KEY_STATION_MAN_T(EMP_NO, LICENSE_ID, LOSE_FLAG, DEL_FLAG);\", \"CREATE TABLE HRM_FLOOR.R_KEY_STATION_LICENSE_T (LICENSE_ID NUMBER PRIMARY KEY, STATION_ID NUMBER, DEL_FLAG NUMBER);\", \"CREATE INDEX IDX_R_KEY_STATION_LICENSE_STATION ON HRM_FLOOR.R_KEY_STATION_LICENSE_T(LICENSE_ID, STATION_ID, DEL_FLAG);\"], \"sql\": \"SELECT P.HWT_TYPE_ID,   --班別ID\\n  HRM_EMP.GET_ID_TO_DESC (P.HWT_TYPE_ID) SHIFT,   --班別\\n  B.FAMILY_ID AS MODEL_ID,   --機種ID\\n  HRM_EMP.GET_ID_TO_DESC (B.FAMILY_ID) AS MODEL_NAME,  --機種名稱\\n  P.LINE_ID,  --線體ID\\n  GET_LOCATION_INFO (P.LINE_ID, '1') AS LINE_NAME,  --線體名稱\\n  P.STATION_ID,  --工站ID\\n  B.STATION_NAME_ENG,   --工站名稱\\n  HRM_EMP.GET_ID_TO_DESC (B.KEY_STATION_ID) KEY_STATION_TYPE,  --工站類型\\n  P.EMP_NO\\n  --,P.CONFIRM_FLAG, --確認狀態\\n  FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P\\n  -- 使用INNER,以便只要 同時符合預排配和工站基礎資訊的\\n  INNER JOIN HRM_FLOOR.C_BASE_STATION_T B\\n  ON  P.STATION_ID = B.ID\\n  AND B.DEL_FLAG = 0\\n  AND B.BU_ID = 245346  --iPad\\n  AND B.HAC_ID = 7137  --CD\\n  AND B.KEY_STATION_ID IN (4976, 8877, 38131)   --K/K+/K++\\n  AND B.MFG_PROCESS_ID = 140185  --製程為Mainline\\n   WHERE  P.WORK_DATE = DATE '2025-08-04'\\n  AND P.DEL_FLAG = 0\\n  -- 確認該員工有對應的「有效執照+在職」鑰匙站記錄（仍需站點一致）\\n  AND EXISTS\\n   (SELECT 1\\n  FROM HRM_FLOOR.R_KEY_STATION_LICENSE_T F,\\n  HRM_FLOOR.R_KEY_STATION_MAN_T H\\n   WHERE  H.LICENSE_ID = F.LICENSE_ID\\n  AND H.EMP_NO = P.EMP_NO\\n  AND H.LOSE_FLAG = 10078\\n  AND H.DEL_FLAG = 0\\n  AND F.DEL_FLAG = 0\\n  AND F.STATION_ID = P.STATION_ID)\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t120\\t200\\t16000\\t8000\\t40\\n1\\t  NESTED LOOPS\\t120\\t200\\t16000\\t8000\\t40\\n2\\t   INDEX RANGE SCAN IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL\\t10\\t200\\t8000\\t1000\\t5\\n3\\t  TABLE ACCESS BY INDEX ROWID C_BASE_STATION_T\\t30\\t200\\t8000\\t2000\\t10\\n4\\t   INDEX RANGE SCAN IDX_R_EMP_STATION_PLAN_WORKDATE\\t20\\t200\\t2000\\t1000\\t5\\n5\\t  TABLE ACCESS BY INDEX ROWID R_EMP_STATION_PLAN_T\\t70\\t200\\t8000\\t5000\\t20\\n6\\t   FILTER (P.WORK_DATE = DATE '2025-08-04' AND P.DEL_FLAG = 0)\\t---\\t---\\t---\\t---\\t---\\n7\\t   NESTED LOOPS (correlated) -- EXISTS subquery\\t20\\t200\\t4000\\t2000\\t5\\n8\\t  INDEX RANGE SCAN IDX_R_KEY_STATION_MAN_EMP_LICENSE (H)\\t2\\t1\\t40\\t10\\t1\\n9\\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_MAN_T\\t5\\t1\\t40\\t20\\t1\\n10\\t  INDEX RANGE SCAN IDX_R_KEY_STATION_LICENSE_STATION (F)\\t5\\t2\\t80\\t20\\t1\\n11\\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_LICENSE_T\\t8\\t2\\t80\\t30\\t1\\n12\\t  FILTER (EXISTS-subquery conditions applied per outer row)\\t---\\t---\\t---\\t---\\t---\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE HRM_FLOOR.C_BASE_STATION_T (ID NUMBER PRIMARY KEY, STATION_NAME_ENG VARCHAR2(200), BU_ID NUMBER, HAC_ID NUMBER, KEY_STATION_ID NUMBER, MFG_PROCESS_ID NUMBER, DEL_FLAG NUMBER);\nCREATE INDEX IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL ON HRM_FLOOR.C_BASE_STATION_T(BU_ID, HAC_ID, KEY_STATION_ID, MFG_PROCESS_ID, DEL_FLAG);\nCREATE TABLE HRM_FLOOR.R_EMP_STATION_PLAN_T (ID NUMBER PRIMARY KEY, WORK_DATE DATE, DEL_FLAG NUMBER, HWT_TYPE_ID NUMBER, LINE_ID NUMBER, STATION_ID NUMBER, EMP_NO VARCHAR2(50));\nCREATE INDEX IDX_R_EMP_STATION_PLAN_WORKDATE ON HRM_FLOOR.R_EMP_STATION_PLAN_T(WORK_DATE, DEL_FLAG, STATION_ID, EMP_NO);\nCREATE TABLE HRM_FLOOR.R_KEY_STATION_MAN_T (ID NUMBER PRIMARY KEY, LICENSE_ID NUMBER, EMP_NO VARCHAR2(50), LOSE_FLAG NUMBER, DEL_FLAG NUMBER);\nCREATE INDEX IDX_R_KEY_STATION_MAN_EMP_LICENSE ON HRM_FLOOR.R_KEY_STATION_MAN_T(EMP_NO, LICENSE_ID, LOSE_FLAG, DEL_FLAG);\nCREATE TABLE HRM_FLOOR.R_KEY_STATION_LICENSE_T (LICENSE_ID NUMBER PRIMARY KEY, STATION_ID NUMBER, DEL_FLAG NUMBER);\nCREATE INDEX IDX_R_KEY_STATION_LICENSE_STATION ON HRM_FLOOR.R_KEY_STATION_LICENSE_T(LICENSE_ID, STATION_ID, DEL_FLAG);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t120\t200\t16000\t8000\t40\n1\t  NESTED LOOPS\t120\t200\t16000\t8000\t40\n2\t   INDEX RANGE SCAN IDX_C_BASE_STATION_BU_HAC_KEY_PROC_DEL\t10\t200\t8000\t1000\t5\n3\t  TABLE ACCESS BY INDEX ROWID C_BASE_STATION_T\t30\t200\t8000\t2000\t10\n4\t   INDEX RANGE SCAN IDX_R_EMP_STATION_PLAN_WORKDATE\t20\t200\t2000\t1000\t5\n5\t  TABLE ACCESS BY INDEX ROWID R_EMP_STATION_PLAN_T\t70\t200\t8000\t5000\t20\n6\t   FILTER (P.WORK_DATE = DATE '2025-08-04' AND P.DEL_FLAG = 0)\t---\t---\t---\t---\t---\n7\t   NESTED LOOPS (correlated) -- EXISTS subquery\t20\t200\t4000\t2000\t5\n8\t  INDEX RANGE SCAN IDX_R_KEY_STATION_MAN_EMP_LICENSE (H)\t2\t1\t40\t10\t1\n9\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_MAN_T\t5\t1\t40\t20\t1\n10\t  INDEX RANGE SCAN IDX_R_KEY_STATION_LICENSE_STATION (F)\t5\t2\t80\t20\t1\n11\t   TABLE ACCESS BY INDEX ROWID R_KEY_STATION_LICENSE_T\t8\t2\t80\t30\t1\n12\t  FILTER (EXISTS-subquery conditions applied per outer row)\t---\t---\t---\t---\t---\n\n## Original SQL:\nSELECT P.HWT_TYPE_ID,   --班別ID\n  HRM_EMP.GET_ID_TO_DESC (P.HWT_TYPE_ID) SHIFT,   --班別\n  B.FAMILY_ID AS MODEL_ID,   --機種ID\n  HRM_EMP.GET_ID_TO_DESC (B.FAMILY_ID) AS MODEL_NAME,  --機種名稱\n  P.LINE_ID,  --線體ID\n  GET_LOCATION_INFO (P.LINE_ID, '1') AS LINE_NAME,  --線體名稱\n  P.STATION_ID,  --工站ID\n  B.STATION_NAME_ENG,   --工站名稱\n  HRM_EMP.GET_ID_TO_DESC (B.KEY_STATION_ID) KEY_STATION_TYPE,  --工站類型\n  P.EMP_NO\n  --,P.CONFIRM_FLAG, --確認狀態\n  FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P\n  -- 使用INNER,以便只要 同時符合預排配和工站基礎資訊的\n  INNER JOIN HRM_FLOOR.C_BASE_STATION_T B\n  ON  P.STATION_ID = B.ID\n  AND B.DEL_FLAG = 0\n  AND B.BU_ID = 245346  --iPad\n  AND B.HAC_ID = 7137  --CD\n  AND B.KEY_STATION_ID IN (4976, 8877, 38131)   --K/K+/K++\n  AND B.MFG_PROCESS_ID = 140185  --製程為Mainline\n   WHERE  P.WORK_DATE = DATE '2025-08-04'\n  AND P.DEL_FLAG = 0\n  -- 確認該員工有對應的「有效執照+在職」鑰匙站記錄（仍需站點一致）\n  AND EXISTS\n   (SELECT 1\n  FROM HRM_FLOOR.R_KEY_STATION_LICENSE_T F,\n  HRM_FLOOR.R_KEY_STATION_MAN_T H\n   WHERE  H.LICENSE_ID = F.LICENSE_ID\n  AND H.EMP_NO = P.EMP_NO\n  AND H.LOSE_FLAG = 10078\n  AND H.DEL_FLAG = 0\n  AND F.DEL_FLAG = 0\n  AND F.STATION_ID = P.STATION_ID)\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT DISTINCT P.HWT_TYPE_ID,HRM_EMP.GET_ID_TO_DESC(P.HWT_TYPE_ID) SHIFT,B.FAMILY_ID AS MODEL_ID,HRM_EMP.GET_ID_TO_DESC(B.FAMILY_ID) AS MODEL_NAME,P.LINE_ID,GET_LOCATION_INFO(P.LINE_ID,'1') AS LINE_NAME,P.STATION_ID,B.STATION_NAME_ENG,HRM_EMP.GET_ID_TO_DESC(B.KEY_STATION_ID) KEY_STATION_TYPE,P.EMP_NO FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P INNER JOIN HRM_FLOOR.C_BASE_STATION_T B ON P.STATION_ID=B.ID AND B.DEL_FLAG=0 AND B.BU_ID=245346 AND B.HAC_ID=7137 AND B.KEY_STATION_ID IN(4976,8877,38131) AND B.MFG_PROCESS_ID=140185 INNER JOIN HRM_FLOOR.R_KEY_STATION_MAN_T H ON H.EMP_NO=P.EMP_NO AND H.LOSE_FLAG=10078 AND H.DEL_FLAG=0 INNER JOIN HRM_FLOOR.R_KEY_STATION_LICENSE_T F ON F.LICENSE_ID=H.LICENSE_ID AND F.STATION_ID=P.STATION_ID AND F.DEL_FLAG=0 WHERE P.WORK_DATE=DATE'2025-08-04' AND P.DEL_FLAG=0"
                    }
                ]
            },
            {
                "case_id": "39",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"39\", \"db_type\": \"sqlserver\", \"description\": \"问题概述：原始查询包含一个全表聚合 + 窗口函数的 CTE（rank_general），多个 LEFT JOIN 与一个 CROSS JOIN(me 子查询)，以及对 otr.otr_consulta 的行级展开 (CROSS APPLY (VALUES ...)) 再做 GROUP BY。性能瓶颈可能来自几处：\\n1) rank_general 需要对 flashdeventas.vetas_y_formas_de_pago 做 GROUP BY 并按 SUM 排序再计算 ROW_NUMBER，若无合适索引/预聚合会导致全表扫描与昂贵的排序；\\n2) me 使用常量筛选但被 CROSS JOIN 到主查，若 me 返回多行会乘扩大外层行数；即使 me 仅返回一行，保留未被外层使用的列会造成不必要的数据传递（可用投影下推移除 proveedor 与 estilo）；\\n3) otr 子查询对 otr.otr_consulta 做了 VALUES 展开后 GROUP BY，若不把高选择性谓词（c.tienda = 3064）下推，会扫描大量无关行并产生大规模聚合中间结果；\\n4) 多个 LEFT JOIN（例如 ranking_tda_jerarquia、control_asignacion_matrices）若缺乏覆盖索引，会引发大量回表和随机 I/O。\\n\\n建议（与实习生给出的规则一致）：\\n- 进行投影下推：在 me 子查询中移除未被外层用到的列（如 proveedor、estilo），减少中间结果宽度；\\n- 进行谓词下推：把高选择性条件 c.tienda = 3064 下推至 otr 的扫描/聚合子查询（即 WHERE oc.id_tienda = 3064），显著降低 otr 聚合量；\\n- 检查并建立必要索引：例如 otr.otr_consulta 上应有 (id_tienda, id_departamento, id_subdepartamento, id_clase, id_subclase, tipo_articulo) 的复合索引或至少 id_tienda 的索引；catalogos.maestro_estilos 可在 (proveedor, estilo) 建索引；catalogos.ranking_tda_jerarquia 在 (id_tienda, departamento, subdepartamento, clase, subclase) 上建索引；clusters.tienda_atributos 在 (centro_comercial, clima, tienda) 建复合/前缀索引；catalogos.tiendas 在 TIENDA 列建主键/索引。 \\n- 对 rank_general 的全表排序开销敏感时，考虑离线物化/周期维护排名表或限制计算范围（若业务允许）。\\n\\n在满足语义前提下（确保移除的列确实不被外层引用，且 c.tienda 为强选择性过滤），方式1 的投影与谓词下推是低风险且立即见效的改进；方式2（更激进的提前过滤/LEFT→INNER 等）若要采用需严格验证不会改变结果。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE catalogos.tiendas (TIENDA INT PRIMARY KEY, nombre NVARCHAR(200), tipo CHAR(1), estatus CHAR(1), marca INT, ciudad NVARCHAR(100), estado NVARCHAR(100), m2 DECIMAL(10,2));\", \"CREATE INDEX IDX_TIENDA_TIPO_MARCA ON catalogos.tiendas(tipo, estatus, marca);\", \"CREATE TABLE flashdeventas.vetas_y_formas_de_pago (ID BIGINT PRIMARY KEY, TIENDA INT, MERCANCIASINIVA DECIMAL(18,4), FECHA DATETIME);\", \"CREATE INDEX IDX_VETAS_TIENDA ON flashdeventas.vetas_y_formas_de_pago(TIENDA);\", \"CREATE TABLE clusters.tienda_atributos (tienda INT PRIMARY KEY, centro_comercial INT, clima NVARCHAR(200));\", \"CREATE INDEX IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos(centro_comercial, clima, tienda);\", \"CREATE TABLE catalogos.maestro_estilos (departamento INT, subdepartamento INT, clase INT, subclase INT, proveedor INT, estilo NVARCHAR(100), tipo_articulo INT);\", \"CREATE INDEX IDX_MAESTRO_ESTILOS_PROV_ESTILO ON catalogos.maestro_estilos(proveedor, estilo);\", \"CREATE TABLE catalogos.ranking_tda_jerarquia (id_tienda INT, departamento INT, subdepartamento INT, clase INT, subclase INT, ranking INT);\", \"CREATE INDEX IDX_RJ_IDTIENDA_DEPT ON catalogos.ranking_tda_jerarquia(id_tienda, departamento, subdepartamento, clase, subclase);\", \"CREATE TABLE catalogos.control_asignacion_matrices (clasificacion INT, matrices_min INT);\", \"CREATE INDEX IDX_CAM_CLASIFICACION ON catalogos.control_asignacion_matrices(clasificacion);\", \"CREATE TABLE otr.otr_consulta (id_tienda INT, id_departamento INT, id_subdepartamento INT, id_clase INT, id_subclase INT, tipo_articulo INT, mes1_compra_adicional DECIMAL(18,4), mes2_compra_adicional DECIMAL(18,4), mes3_compra_adicional DECIMAL(18,4), mes4_compra_adicional DECIMAL(18,4), mes5_compra_adicional DECIMAL(18,4), mes6_compra_adicional DECIMAL(18,4), mes7_compra_adicional DECIMAL(18,4), mes8_compra_adicional DECIMAL(18,4), mes9_compra_adicional DECIMAL(18,4), mes10_compra_adicional DECIMAL(18,4), mes11_compra_adicional DECIMAL(18,4), mes12_compra_adicional DECIMAL(18,4));\", \"CREATE INDEX IDX_OTR_ID_TIENDA_FULL ON otr.otr_consulta(id_tienda, id_departamento, id_subdepartamento, id_clase, id_subclase, tipo_articulo);\", \"CREATE VIEW catalogos.vw_supervisores AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\", \"CREATE VIEW catalogos.vw_regionales AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\"], \"sql\": \";WITH rank_general AS (\\n  SELECT \\n  ta.TIENDA AS id,\\n  ROW_NUMBER() OVER (\\n  ORDER BY SUM(v.MERCANCIASINIVA) DESC\\n  ) AS actual_rank_global\\n  FROM catalogos.tiendas ta\\n  LEFT JOIN flashdeventas.vetas_y_formas_de_pago v ON v.TIENDA = ta.TIENDA\\n  WHERE ta.tipo = 'S' AND estatus = 'A' AND ta.marca = 30\\n  GROUP BY ta.TIENDA\\n) \\nSELECT \\n  rg.actual_rank_global   \\n  ,t.nombre\\n  ,vw_r.nombre as regional\\n  ,vw_s.nombre as supervisor\\n  ,t.estado\\n  ,'RUTA' as ruta  ----\\n  ,t.m2 as tienda_m2\\n  ,'TAMAÑO' as tamanio   ----\\n  ,rj.ranking as rank_jerarquia_n4\\n  ,t.ciudad\\n  ,cam.matrices_min as propuesta\\n  ,otr.abierto_otr as abierto_otr\\n  ,c.* \\nFROM clusters.tienda_atributos c\\nLEFT JOIN catalogos.tiendas t ON c.tienda = t.tienda\\nLEFT JOIN catalogos.vw_supervisores vw_s ON c.tienda = vw_s.tienda\\nLEFT JOIN catalogos.vw_regionales vw_r ON c.tienda = vw_r.tienda\\nLEFT JOIN rank_general rg ON c.tienda = rg.id\\nCROSS JOIN (\\n  SELECT departamento, subdepartamento, clase, subclase, proveedor, estilo, tipo_articulo\\n  FROM catalogos.maestro_estilos me\\n  WHERE me.proveedor = 1162 AND me.estilo = 'C21031101'\\n) me\\nLEFT JOIN catalogos.ranking_tda_jerarquia rj \\n  ON c.tienda = rj.id_tienda\\n  AND rj.departamento = me.departamento\\n  AND rj.subdepartamento = me.subdepartamento\\n  AND rj.clase = me.clase\\n  AND rj.subclase = me.subclase\\nLEFT JOIN catalogos.control_asignacion_matrices cam\\n  ON rj.ranking = cam.clasificacion\\nLEFT JOIN (\\n  SELECT\\n  oc.id_tienda,\\n  oc.id_departamento,\\n  oc.id_subdepartamento,\\n  oc.id_clase,\\n  oc.id_subclase,\\n  oc.tipo_articulo,\\n  SUM(CASE WHEN n >= MONTH(GETDATE()) THEN ISNULL(val, 0) ELSE 0 END) AS abierto_otr\\n  FROM otr.otr_consulta oc\\n  CROSS APPLY (VALUES\\n  (1,  oc.mes1_compra_adicional),\\n  (2,  oc.mes2_compra_adicional),\\n  (3,  oc.mes3_compra_adicional),\\n  (4,  oc.mes4_compra_adicional),\\n  (5,  oc.mes5_compra_adicional),\\n  (6,  oc.mes6_compra_adicional),\\n  (7,  oc.mes7_compra_adicional),\\n  (8,  oc.mes8_compra_adicional),\\n  (9,  oc.mes9_compra_adicional),\\n  (10, oc.mes10_compra_adicional),\\n  (11, oc.mes11_compra_adicional),\\n  (12, oc.mes12_compra_adicional)\\n  ) m(n, val)\\n  GROUP BY\\n  oc.id_tienda,\\n  oc.id_departamento,\\n  oc.id_subdepartamento,\\n  oc.id_clase,\\n  oc.id_subclase,\\n  oc.tipo_articulo\\n) otr\\n  ON  otr.id_tienda = c.tienda\\n  AND otr.id_departamento = me.departamento\\n  AND otr.id_subdepartamento = me.subdepartamento\\n  AND otr.id_clase = me.clase\\n  AND otr.id_subclase = me.subclase\\n  AND otr.tipo_articulo = me.tipo_articulo\\nWHERE 1=1  AND c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t15200\\t10000\\t1200000\\t452000\\t14800\\n1\\t  MERGE JOIN\\t15200\\t10000\\t1200000\\t452000\\t14800\\n2\\t   HASH AGGREGATE (rank_general: SUM + SORT for ROW_NUMBER)\\t9200\\t10000\\t600000\\t300000\\t9000\\n3\\t  TABLE SCAN flashdeventas.vetas_y_formas_de_pago\\t4800\\t10000\\t480000\\t240000\\t4800\\n4\\t   INDEX SEEK catalogos.tiendas (type/estatus/marca filter)\\t200\\t5000\\t80000\\t20000\\t200\\n5\\t   SORT\\t3000\\t10000\\t200000\\t80000\\t3000\\n6\\t   HASH MATCH (left outer join rj/cam/others)\\t2400\\t5000\\t300000\\t100000\\t2400\\n7\\t  VIEW (me CROSS JOIN) -- expands outer rows when me has >1 row\\t50\\t10\\t800\\t500\\t50\\n8\\t  HASH AGGREGATE (otr subquery grouping)\\t6800\\t8000\\t400000\\t160000\\t6800\\n9\\t   TABLE SCAN otr.otr_consulta\\t6600\\t8000\\t380000\\t150000\\t6600\\n10\\t  CROSS APPLY (VALUES ...) expansion per row\\t---\\t---\\t---\\t---\\t---\\n11\\t   NESTED LOOPS (apply joins to clusters.tienda_atributos filtered by centro_comercial/clima/tiena)\\t1200\\t1\\t160\\t600\\t120\\n12\\t  INDEX SEEK IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos (centro_comercial,clima,tienda)\\t10\\t1\\t80\\t20\\t5\\n13\\t  TABLE ACCESS BY INDEX ROWID catalogos.tiendas / vw_supervisores / vw_regionales\\t300\\t1\\t320\\t100\\t30\\n14\\t  FILTER (c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064)\\t---\\t---\\t---\\t---\\t---\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE catalogos.tiendas (TIENDA INT PRIMARY KEY, nombre NVARCHAR(200), tipo CHAR(1), estatus CHAR(1), marca INT, ciudad NVARCHAR(100), estado NVARCHAR(100), m2 DECIMAL(10,2));\nCREATE INDEX IDX_TIENDA_TIPO_MARCA ON catalogos.tiendas(tipo, estatus, marca);\nCREATE TABLE flashdeventas.vetas_y_formas_de_pago (ID BIGINT PRIMARY KEY, TIENDA INT, MERCANCIASINIVA DECIMAL(18,4), FECHA DATETIME);\nCREATE INDEX IDX_VETAS_TIENDA ON flashdeventas.vetas_y_formas_de_pago(TIENDA);\nCREATE TABLE clusters.tienda_atributos (tienda INT PRIMARY KEY, centro_comercial INT, clima NVARCHAR(200));\nCREATE INDEX IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos(centro_comercial, clima, tienda);\nCREATE TABLE catalogos.maestro_estilos (departamento INT, subdepartamento INT, clase INT, subclase INT, proveedor INT, estilo NVARCHAR(100), tipo_articulo INT);\nCREATE INDEX IDX_MAESTRO_ESTILOS_PROV_ESTILO ON catalogos.maestro_estilos(proveedor, estilo);\nCREATE TABLE catalogos.ranking_tda_jerarquia (id_tienda INT, departamento INT, subdepartamento INT, clase INT, subclase INT, ranking INT);\nCREATE INDEX IDX_RJ_IDTIENDA_DEPT ON catalogos.ranking_tda_jerarquia(id_tienda, departamento, subdepartamento, clase, subclase);\nCREATE TABLE catalogos.control_asignacion_matrices (clasificacion INT, matrices_min INT);\nCREATE INDEX IDX_CAM_CLASIFICACION ON catalogos.control_asignacion_matrices(clasificacion);\nCREATE TABLE otr.otr_consulta (id_tienda INT, id_departamento INT, id_subdepartamento INT, id_clase INT, id_subclase INT, tipo_articulo INT, mes1_compra_adicional DECIMAL(18,4), mes2_compra_adicional DECIMAL(18,4), mes3_compra_adicional DECIMAL(18,4), mes4_compra_adicional DECIMAL(18,4), mes5_compra_adicional DECIMAL(18,4), mes6_compra_adicional DECIMAL(18,4), mes7_compra_adicional DECIMAL(18,4), mes8_compra_adicional DECIMAL(18,4), mes9_compra_adicional DECIMAL(18,4), mes10_compra_adicional DECIMAL(18,4), mes11_compra_adicional DECIMAL(18,4), mes12_compra_adicional DECIMAL(18,4));\nCREATE INDEX IDX_OTR_ID_TIENDA_FULL ON otr.otr_consulta(id_tienda, id_departamento, id_subdepartamento, id_clase, id_subclase, tipo_articulo);\nCREATE VIEW catalogos.vw_supervisores AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\nCREATE VIEW catalogos.vw_regionales AS SELECT tienda, nombre FROM catalogos.tiendas; -- 简化示例\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t15200\t10000\t1200000\t452000\t14800\n1\t  MERGE JOIN\t15200\t10000\t1200000\t452000\t14800\n2\t   HASH AGGREGATE (rank_general: SUM + SORT for ROW_NUMBER)\t9200\t10000\t600000\t300000\t9000\n3\t  TABLE SCAN flashdeventas.vetas_y_formas_de_pago\t4800\t10000\t480000\t240000\t4800\n4\t   INDEX SEEK catalogos.tiendas (type/estatus/marca filter)\t200\t5000\t80000\t20000\t200\n5\t   SORT\t3000\t10000\t200000\t80000\t3000\n6\t   HASH MATCH (left outer join rj/cam/others)\t2400\t5000\t300000\t100000\t2400\n7\t  VIEW (me CROSS JOIN) -- expands outer rows when me has >1 row\t50\t10\t800\t500\t50\n8\t  HASH AGGREGATE (otr subquery grouping)\t6800\t8000\t400000\t160000\t6800\n9\t   TABLE SCAN otr.otr_consulta\t6600\t8000\t380000\t150000\t6600\n10\t  CROSS APPLY (VALUES ...) expansion per row\t---\t---\t---\t---\t---\n11\t   NESTED LOOPS (apply joins to clusters.tienda_atributos filtered by centro_comercial/clima/tiena)\t1200\t1\t160\t600\t120\n12\t  INDEX SEEK IDX_TIENDA_ATR_CENTRO_CLIMA ON clusters.tienda_atributos (centro_comercial,clima,tienda)\t10\t1\t80\t20\t5\n13\t  TABLE ACCESS BY INDEX ROWID catalogos.tiendas / vw_supervisores / vw_regionales\t300\t1\t320\t100\t30\n14\t  FILTER (c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064)\t---\t---\t---\t---\t---\n\n## Original SQL:\n;WITH rank_general AS (\n  SELECT \n  ta.TIENDA AS id,\n  ROW_NUMBER() OVER (\n  ORDER BY SUM(v.MERCANCIASINIVA) DESC\n  ) AS actual_rank_global\n  FROM catalogos.tiendas ta\n  LEFT JOIN flashdeventas.vetas_y_formas_de_pago v ON v.TIENDA = ta.TIENDA\n  WHERE ta.tipo = 'S' AND estatus = 'A' AND ta.marca = 30\n  GROUP BY ta.TIENDA\n) \nSELECT \n  rg.actual_rank_global   \n  ,t.nombre\n  ,vw_r.nombre as regional\n  ,vw_s.nombre as supervisor\n  ,t.estado\n  ,'RUTA' as ruta  ----\n  ,t.m2 as tienda_m2\n  ,'TAMAÑO' as tamanio   ----\n  ,rj.ranking as rank_jerarquia_n4\n  ,t.ciudad\n  ,cam.matrices_min as propuesta\n  ,otr.abierto_otr as abierto_otr\n  ,c.* \nFROM clusters.tienda_atributos c\nLEFT JOIN catalogos.tiendas t ON c.tienda = t.tienda\nLEFT JOIN catalogos.vw_supervisores vw_s ON c.tienda = vw_s.tienda\nLEFT JOIN catalogos.vw_regionales vw_r ON c.tienda = vw_r.tienda\nLEFT JOIN rank_general rg ON c.tienda = rg.id\nCROSS JOIN (\n  SELECT departamento, subdepartamento, clase, subclase, proveedor, estilo, tipo_articulo\n  FROM catalogos.maestro_estilos me\n  WHERE me.proveedor = 1162 AND me.estilo = 'C21031101'\n) me\nLEFT JOIN catalogos.ranking_tda_jerarquia rj \n  ON c.tienda = rj.id_tienda\n  AND rj.departamento = me.departamento\n  AND rj.subdepartamento = me.subdepartamento\n  AND rj.clase = me.clase\n  AND rj.subclase = me.subclase\nLEFT JOIN catalogos.control_asignacion_matrices cam\n  ON rj.ranking = cam.clasificacion\nLEFT JOIN (\n  SELECT\n  oc.id_tienda,\n  oc.id_departamento,\n  oc.id_subdepartamento,\n  oc.id_clase,\n  oc.id_subclase,\n  oc.tipo_articulo,\n  SUM(CASE WHEN n >= MONTH(GETDATE()) THEN ISNULL(val, 0) ELSE 0 END) AS abierto_otr\n  FROM otr.otr_consulta oc\n  CROSS APPLY (VALUES\n  (1,  oc.mes1_compra_adicional),\n  (2,  oc.mes2_compra_adicional),\n  (3,  oc.mes3_compra_adicional),\n  (4,  oc.mes4_compra_adicional),\n  (5,  oc.mes5_compra_adicional),\n  (6,  oc.mes6_compra_adicional),\n  (7,  oc.mes7_compra_adicional),\n  (8,  oc.mes8_compra_adicional),\n  (9,  oc.mes9_compra_adicional),\n  (10, oc.mes10_compra_adicional),\n  (11, oc.mes11_compra_adicional),\n  (12, oc.mes12_compra_adicional)\n  ) m(n, val)\n  GROUP BY\n  oc.id_tienda,\n  oc.id_departamento,\n  oc.id_subdepartamento,\n  oc.id_clase,\n  oc.id_subclase,\n  oc.tipo_articulo\n) otr\n  ON  otr.id_tienda = c.tienda\n  AND otr.id_departamento = me.departamento\n  AND otr.id_subdepartamento = me.subdepartamento\n  AND otr.id_clase = me.clase\n  AND otr.id_subclase = me.subclase\n  AND otr.tipo_articulo = me.tipo_articulo\nWHERE 1=1  AND c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": ";WITH rank_general AS (SELECT ta.TIENDA AS id, ROW_NUMBER() OVER (ORDER BY SUM(v.MERCANCIASINIVA) DESC) AS actual_rank_global FROM catalogos.tiendas ta LEFT JOIN flashdeventas.vetas_y_formas_de_pago v ON v.TIENDA = ta.TIENDA WHERE ta.tipo = 'S' AND ta.estatus = 'A' AND ta.marca = 30 GROUP BY ta.TIENDA) SELECT rg.actual_rank_global, t.nombre, vw_r.nombre as regional, vw_s.nombre as supervisor, t.estado, 'RUTA' as ruta, t.m2 as tienda_m2, 'TAMAÑO' as tamanio, rj.ranking as rank_jerarquia_n4, t.ciudad, cam.matrices_min as propuesta, otr.abierto_otr, c.* FROM clusters.tienda_atributos c LEFT JOIN catalogos.tiendas t ON c.tienda = t.tienda LEFT JOIN catalogos.vw_supervisores vw_s ON c.tienda = vw_s.tienda LEFT JOIN catalogos.vw_regionales vw_r ON c.tienda = vw_r.tienda LEFT JOIN rank_general rg ON c.tienda = rg.id CROSS JOIN (SELECT departamento, subdepartamento, clase, subclase, proveedor, estilo, tipo_articulo FROM catalogos.maestro_estilos WHERE proveedor = 1162 AND estilo = 'C21031101') me LEFT JOIN catalogos.ranking_tda_jerarquia rj ON c.tienda = rj.id_tienda AND rj.departamento = me.departamento AND rj.subdepartamento = me.subdepartamento AND rj.clase = me.clase AND rj.subclase = me.subclase LEFT JOIN catalogos.control_asignacion_matrices cam ON rj.ranking = cam.clasificacion LEFT JOIN (SELECT oc.id_tienda, oc.id_departamento, oc.id_subdepartamento, oc.id_clase, oc.id_subclase, oc.tipo_articulo, SUM(CASE WHEN n >= MONTH(GETDATE()) THEN ISNULL(val, 0) ELSE 0 END) AS abierto_otr FROM otr.otr_consulta oc WHERE oc.id_tienda = 3064 CROSS APPLY (VALUES (1, oc.mes1_compra_adicional), (2, oc.mes2_compra_adicional), (3, oc.mes3_compra_adicional), (4, oc.mes4_compra_adicional), (5, oc.mes5_compra_adicional), (6, oc.mes6_compra_adicional), (7, oc.mes7_compra_adicional), (8, oc.mes8_compra_adicional), (9, oc.mes9_compra_adicional), (10, oc.mes10_compra_adicional), (11, oc.mes11_compra_adicional), (12, oc.mes12_compra_adicional)) m(n, val) GROUP BY oc.id_tienda, oc.id_departamento, oc.id_subdepartamento, oc.id_clase, oc.id_subclase, oc.tipo_articulo) otr ON otr.id_tienda = c.tienda AND otr.id_departamento = me.departamento AND otr.id_subdepartamento = me.subdepartamento AND otr.id_clase = me.clase AND otr.id_subclase = me.subclase AND otr.tipo_articulo = me.tipo_articulo WHERE c.centro_comercial = 1 AND c.clima LIKE '%calor todo el tiempo%' AND c.tienda = 3064"
                    }
                ]
            },
            {
                "case_id": "40",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"40\", \"db_type\": \"oracle\", \"description\": \"问题概述：此查询包含三层嵌套用于实现基于 ROWNUM 的分页（最内层包含大范围的 SELECT + 多个 LEFT JOIN + 多个标量子查询与函数调用；中间一层再包一层并限制 ROWNUM<=10；最外层再按 rn>0 过滤），导致不必要的视图物化与数据传递开销。主要性能隐患还有：1) 大量标量子查询（例如从 RES_SYS.PUB_MFR、RES_SYS.PUB_DIC_EQP_TYPE、RES_SYS.PUB_RME_EQP_MODEL 等按 ID 查询名称）会对每一行触发独立索引/表访问，开销成倍放大；2) 频繁调用的行级函数（RES_ENTITY.SF_GET_DESC_CHINA / SF_GET_STAFF_NAME 等）若未缓存，会导致大量 CPU 时间；3) IN 子查询包含 CONNECT BY 的递归层次查询，若不先将其物化为较小集合，会使主表筛选成本增高；4) 宽表 SELECT *（以及许多未必要的列和文本转换）增加了 I/O 与网络传输量。建议：删除最外层冗余的 `where rn > 0` 并把分页逻辑简化；把 `ROWNUM <= 10` 的限制尽量下推或改为 `FETCH FIRST 10 ROWS` / 使用 FIRST_ROWS 优化；将标量子查询改写为 LEFT JOIN（或事先使用单表缓存/物化视图）以避免每行重复访问；为常用的连接/过滤列（ENT_ENTITY.ENTITY_ID、ENT_ROOM.ENTITY_ID、ENT_ENTITY.STATION_CODE、STA_STATION.STATION_CODE/ STATION_ID、STA_APP_INFO.STATION_ID、STA_BIZ_INFO.STATION_CODE、REG_MANAGE.REGION_ID）建立合适索引；对昂贵的行级函数考虑结果缓存或提前物化；对 CONNECT BY 结果先计算并临时表化以减少重复计算。这样可显著减少全表扫描、嵌套循环和重复的随机 I/O。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE RES_ENTITY.ENT_ENTITY (ENTITY_ID VARCHAR2(50) PRIMARY KEY, DELETE_STATE VARCHAR2(2), RES_TYPE_ID NUMBER, STATION_CODE VARCHAR2(50), TIME_TO_OVERDUE VARCHAR2(50), CHECK_MODE_ID NUMBER, BUSINESS_ID NUMBER, SUB_BUSINESS_ID NUMBER, PROP_ID NUMBER, OLD_PROP_ID NUMBER, PROPERTY_ID NUMBER, ENTITY_STATE_ID NUMBER, IS_LOCKED_ID NUMBER, IS_FAULT_ID NUMBER, IS_OVERDUE NUMBER, WARRANTY_GRADE_ID NUMBER, IS_OUTMAINTENANCE_ID NUMBER, ASSETS_RECEIVE_TYPE_ID NUMBER, ENTITY_CREATE_SOURCE_ID NUMBER, SOURCE_SYSTEM_ID NUMBER, CHECK_RESULT_ID NUMBER, SERVICE_STATE_ID NUMBER, IS_MONITOR_ID NUMBER, MONITOR_STYLE_ID NUMBER, IS_UPLOAD_PHOTO NUMBER, STORAGE_STATE_ID NUMBER, IS_STORAGE NUMBER, RES_FROM_PROJBUILDTYPE_ID NUMBER, SPLIT_MERGE_REASON_ID NUMBER, SOURCE_RES_NO VARCHAR2(100), ROOM_ID VARCHAR2(50), RES_TYPE_ID_TEXT VARCHAR2(100), DEV_TYPE_ID NUMBER, DEV_MODEL_ID NUMBER, OLD_DEV_MODEL_ID NUMBER, MFR_ID NUMBER, DW_MFR_ID NUMBER, OLD_DW_MFR_ID NUMBER, MNT_MFR_ID NUMBER, MODIFY_OP VARCHAR2(50), CREATE_OP VARCHAR2(50), CHECK_PERSON VARCHAR2(50), STATION_CODE_ALT VARCHAR2(50));\", \"CREATE INDEX IDX_ENT_ENTITY_DELETE_RES_TYPE_STCODE ON RES_ENTITY.ENT_ENTITY(DELETE_STATE, RES_TYPE_ID, STATION_CODE);\", \"CREATE TABLE RES_ENTITY.ENT_ROOM (ENTITY_ID VARCHAR2(50), WIDTH NUMBER, LENGTH NUMBER, HEIGHT NUMBER, AREA NUMBER, FLOOR_NO NUMBER, IS_OIL_MACH_ROOM NUMBER, IS_HAVE_WALL NUMBER, STRUCTURE_ID NUMBER, ADDRESS VARCHAR2(400), AIRBLAST_STYLE NUMBER, VACANT_CABLE_SEAT NUMBER, CONTACTS VARCHAR2(200), LINK_TEL VARCHAR2(50), NUM_HOLE_FEED NUMBER, NUM_HOLE_FEED_OCCU NUMBER, NUM_HOLE_FEED_FREE NUMBER, LIGHT_PROTECTION_BRAND VARCHAR2(200), LIGHT_PROTECTION_MODE VARCHAR2(200), FIRE_EXTINGUISHER_TYPE VARCHAR2(100), NUM_FIRE_EXTINGUISHER NUMBER, STATION_ROAD_ID NUMBER, DEGREE_ARRIVAL_ID NUMBER, REASON_UNARRIVAL VARCHAR2(400), IS_ARRIVEL NUMBER, IS_POWER NUMBER, REASON_UNPOWER VARCHAR2(400), INOUT_MODE NUMBER, PLATE_DRAWINGS_ID VARCHAR2(50), DECORATION_DRAWINGS_ID VARCHAR2(50), DESIGN_DRAWINGS_ID VARCHAR2(50), GROUND_SYSTEM_DRAWINGS_ID VARCHAR2(50), IS_EXPAND_OIL_ROOM NUMBER, SECURITY_ENVIRONMENT_ID NUMBER, GENERATION_TIME DATE, WNG_STYLE NUMBER, ROOM_GRADE_ID NUMBER, NUM_RMEBAY_TOTAL NUMBER, NUM_RMEBAY_FREE NUMBER, PRODUCT_TYPE NUMBER, ENT_AUDIT_RESULT_ID NUMBER, AUDIT_FLOW_RESULT_ID NUMBER, MANUAL_IDENT_RESULT_ID NUMBER, AGENT_MNT_CONTACT VARCHAR2(50), IS_VR_FULLSCENE_ID NUMBER, IS_SHARE NUMBER, SHARE_UNIT_ID VARCHAR2(50), INTEG_CABINET_SPACE_NUM NUMBER, INTEG_CABINET_AC_BRAND VARCHAR2(200), INTEG_CABINET_AC_MODEL_DC VARCHAR2(200), INTEG_CABINET_AC_NUM_DC NUMBER, INTEG_CABINET_AC_MODEL VARCHAR2(200), INTEG_CABINET_AC_NUM_DC_AC NUMBER, INTEG_CABINET_AC_NUM_ID VARCHAR2(50), INTEG_CABINET_AC_MFR_ID NUMBER, INTEG_CABINET_AC_NUM_ID_TEXT VARCHAR2(200));\", \"CREATE INDEX IDX_ENT_ROOM_ENTITY_ID ON RES_ENTITY.ENT_ROOM(ENTITY_ID);\", \"CREATE TABLE RES_ENTITY.STA_STATION (STATION_ID NUMBER PRIMARY KEY, STATION_CODE VARCHAR2(50), DISTRICT_PROVINCE_ID VARCHAR2(50), DISTRICT_REGION_ID VARCHAR2(50), DISTRICT_COUNTY_ID VARCHAR2(50), STATION_NAME VARCHAR2(200));\", \"CREATE INDEX IDX_STA_STATION_STATION_CODE ON RES_ENTITY.STA_STATION(STATION_CODE);\", \"CREATE TABLE RES_ENTITY.STA_APP_INFO (STATION_ID NUMBER, APP_REGION_ID VARCHAR2(50));\", \"CREATE INDEX IDX_STA_APP_INFO_STATION_ID ON RES_ENTITY.STA_APP_INFO(STATION_ID);\", \"CREATE TABLE RES_ENTITY.STA_BIZ_INFO (STATION_CODE VARCHAR2(50), REGION_ID VARCHAR2(50));\", \"CREATE INDEX IDX_STA_BIZ_INFO_REGION_ID ON RES_ENTITY.STA_BIZ_INFO(REGION_ID);\", \"CREATE TABLE RES_ENTITY.REG_MANAGE (REGION_ID VARCHAR2(50) PRIMARY KEY, SUPER_REGION_ID VARCHAR2(50), REGION_NAME VARCHAR2(200), DELETE_STATE VARCHAR2(2));\", \"CREATE INDEX IDX_REG_MANAGE_REGION_ID ON RES_ENTITY.REG_MANAGE(REGION_ID);\", \"CREATE TABLE RES_SYS.PUB_MFR (MFR_ID NUMBER PRIMARY KEY, MFR VARCHAR2(200), DELETE_STATE VARCHAR2(2));\", \"CREATE INDEX IDX_PUB_MFR_MFR_ID ON RES_SYS.PUB_MFR(MFR_ID);\", \"CREATE TABLE RES_SYS.PUB_DIC_EQP_TYPE (EQP_TYPE_ID NUMBER PRIMARY KEY, EQP_TYPE VARCHAR2(200), DELETE_STATE VARCHAR2(2));\", \"CREATE INDEX IDX_PUB_DIC_EQP_TYPE_ID ON RES_SYS.PUB_DIC_EQP_TYPE(EQP_TYPE_ID);\", \"CREATE TABLE RES_SYS.PUB_RME_EQP_MODEL (EQP_MODEL_ID NUMBER PRIMARY KEY, EQP_MODEL VARCHAR2(200), DELETE_STATE VARCHAR2(2));\", \"CREATE INDEX IDX_PUB_RME_EQP_MODEL_ID ON RES_SYS.PUB_RME_EQP_MODEL(EQP_MODEL_ID);\"], \"sql\": \"select *  from (select t.*,ROWNUM AS rn  from (SELECT\\n\\tEE.*,\\n\\tB.WIDTH,\\n\\tB.LENGTH,\\n\\tB.HEIGHT,\\n\\tB.AREA,\\n\\tB.FLOOR_NO,\\n\\tB.IS_OIL_MACH_ROOM,\\n\\tB.IS_HAVE_WALL,\\n\\tB.STRUCTURE_ID,\\n\\tB.ADDRESS,\\n\\tB.AIRBLAST_STYLE,\\n\\tB.VACANT_CABLE_SEAT,\\n\\tB.CONTACTS,\\n\\tB.LINK_TEL,\\n\\tB.NUM_HOLE_FEED,\\n\\tB.NUM_HOLE_FEED_OCCU,\\n\\tB.NUM_HOLE_FEED_FREE,\\n\\tB.LIGHT_PROTECTION_BRAND,\\n\\tB.LIGHT_PROTECTION_MODE,\\n\\tB.FIRE_EXTINGUISHER_TYPE,\\n\\tB.NUM_FIRE_EXTINGUISHER,\\n\\tB.STATION_ROAD_ID,\\n\\tB.DEGREE_ARRIVAL_ID,\\n\\tB.REASON_UNARRIVAL,\\n\\tB.IS_ARRIVEL,\\n\\tB.IS_POWER,\\n\\tB.REASON_UNPOWER,\\n\\tB.INOUT_MODE,\\n\\tB.PLATE_DRAWINGS_ID,\\n\\tB.DECORATION_DRAWINGS_ID,\\n\\tB.DESIGN_DRAWINGS_ID,\\n\\tB.GROUND_SYSTEM_DRAWINGS_ID,\\n\\tB.IS_EXPAND_OIL_ROOM,\\n\\tB.SECURITY_ENVIRONMENT_ID,\\n\\tB.GENERATION_TIME,\\n\\tB.WNG_STYLE,\\n\\tB.ROOM_GRADE_ID,\\n\\tB.NUM_RMEBAY_TOTAL,\\n\\tB.NUM_RMEBAY_FREE,\\n\\tB.PRODUCT_TYPE,\\n\\tB.ENT_AUDIT_RESULT_ID,\\n\\tB.AUDIT_FLOW_RESULT_ID,\\n\\tB.MANUAL_IDENT_RESULT_ID,\\n\\tB.AGENT_MNT_CONTACT,\\n\\tB.IS_VR_FULLSCENE_ID,\\n\\tB.IS_SHARE,\\n\\tB.SHARE_UNIT_ID,\\n\\tB.INTEG_CABINET_SPACE_NUM,\\n\\tB.INTEG_CABINET_AC_BRAND,\\n\\tB.INTEG_CABINET_AC_MODEL_DC,\\n\\tB.INTEG_CABINET_AC_NUM_DC,\\n\\tB.INTEG_CABINET_AC_MODEL,\\n\\tB.INTEG_CABINET_AC_NUM_DC_AC,\\n\\tB.INTEG_CABINET_SPACE_NUM AS INTEG_CABINET_SPACE_NUM_TEXT,\\n\\tEE.RES_FROM_PROJECT_NAME AS RES_FROM_PROJECT_NAME_TEXT,\\n\\tB.INTEG_CABINET_AC_NUM_ID,\\n\\tres_entity.SF_GET_DESC_CHINA(B.INTEG_CABINET_AC_NUM_ID) AS INTEG_CABINET_AC_NUM_ID_TEXT,\\n\\tB.INTEG_CABINET_AC_MFR_ID,\\n\\tB.INTEG_CABINET_AC_MODEL,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=B.INTEG_CABINET_AC_MFR_ID and delete_state='0') AS INTEG_CABINET_AC_MFR_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.TIME_TO_OVERDUE) AS TIME_TO_OVERDUE_TEXT,\\n\\t(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=B.MANUAL_IDENT_RESULT_ID AND DELETE_STATE = '0') AS MANUAL_IDENT_RESULT_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_STAFF_NAME(B.AGENT_MNT_CONTACT) AS AGENT_MNT_CONTACT_TEXT,\\n\\tCASE WHEN B.IS_VR_FULLSCENE_ID = 1 THEN '有' WHEN B.IS_VR_FULLSCENE_ID= 0 THEN '无' END AS IS_VR_FULLSCENE_ID_TEXT,\\n\\tCASE WHEN B.AIRBLAST_STYLE = 1 THEN '下送风' WHEN B.AIRBLAST_STYLE= 0 THEN '上送风' END AS AIRBLAST_STYLE_TEXT,\\n\\tCASE WHEN B.WNG_STYLE = 1 THEN '上走线' WHEN B.WNG_STYLE= 0 THEN '下走线' END AS WNG_STYLE_STYLE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_SHARE) AS IS_SHARE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.SHARE_UNIT_ID) AS SHARE_UNIT_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.AUDIT_FLOW_RESULT_ID) AS AUDIT_FLOW_RESULT_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.ENT_AUDIT_RESULT_ID) AS ENT_AUDIT_RESULT_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.PRODUCT_TYPE) AS PRODUCT_TYPE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_OIL_MACH_ROOM) AS IS_OIL_MACH_ROOM_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_HAVE_WALL) AS IS_HAVE_WALL_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.STRUCTURE_ID) AS STRUCTURE_ID_TEXT, \\n\\tres_entity.SF_GET_DESC_CHINA(B.VACANT_CABLE_SEAT) AS VACANT_CABLE_SEAT_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.STATION_ROAD_ID) AS STATION_ROAD_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.DEGREE_ARRIVAL_ID) AS DEGREE_ARRIVAL_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_ARRIVEL) AS IS_ARRIVEL_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_POWER) AS IS_POWER_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.INOUT_MODE) AS INOUT_MODE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.IS_EXPAND_OIL_ROOM) AS IS_EXPAND_OIL_ROOM_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.SECURITY_ENVIRONMENT_ID) AS SECURITY_ENVIRONMENT_ID_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.WNG_STYLE) AS WNG_STYLE_TEXT,\\n\\tres_entity.SF_GET_DESC_CHINA(B.ROOM_GRADE_ID) AS ROOM_GRADE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_MODE_ID) AS CHECK_MODE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.BUSINESS_ID) AS BUSINESS_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SUB_BUSINESS_ID) AS SUB_BUSINESS_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.PROP_ID) AS PROP_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.OLD_PROP_ID) AS OLD_PROP_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.PROPERTY_ID) AS PROPERTY_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_STATE_ID) AS ENTITY_STATE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_LOCKED_ID) AS IS_LOCKED_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_FAULT_ID) AS IS_FAULT_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OVERDUE) AS IS_OVERDUE_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.WARRANTY_GRADE_ID) AS WARRANTY_GRADE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OUTMAINTENANCE_ID) AS IS_OUTMAINTENANCE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ASSETS_RECEIVE_TYPE_ID) AS ASSETS_RECEIVE_TYPE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_CREATE_SOURCE_ID) AS ENTITY_CREATE_SOURCE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SOURCE_SYSTEM_ID) AS SOURCE_SYSTEM_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_RESULT_ID) AS CHECK_RESULT_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SERVICE_STATE_ID) AS SERVICE_STATE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_MONITOR_ID) AS IS_MONITOR_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.MONITOR_STYLE_ID) AS MONITOR_STYLE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_UPLOAD_PHOTO) AS IS_UPLOAD_PHOTO_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.STORAGE_STATE_ID) AS STORAGE_STATE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_STORAGE) AS IS_STORAGE_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.RES_FROM_PROJBUILDTYPE_ID) AS RES_FROM_PROJBUILDTYPE_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SPLIT_MERGE_REASON_ID) AS SPLIT_MERGE_REASON_ID_TEXT,\\n\\tEE.SOURCE_RES_NO AS SOURCE_RES_NO_TEXT,\\n\\t(SELECT ENTITY_NAME FROM res_entity.ent_entity WHERE ENTITY_ID=EE.ROOM_ID and res_type_id='205' and delete_state='0') AS ROOM_ID_TEXT,\\n\\t(SELECT RES_TYPE FROM RES_SYS.PUB_DIC_RES_TYPE WHERE RES_TYPE_ID=EE.RES_TYPE_ID and delete_state='0') AS RES_TYPE_ID_TEXT,\\n\\t(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=EE.DEV_TYPE_ID and delete_state='0') AS DEV_TYPE_ID_TEXT,\\n\\t(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.DEV_MODEL_ID and delete_state='0') AS DEV_MODEL_ID_TEXT,\\n\\t(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.OLD_DEV_MODEL_ID and delete_state='0') AS OLD_DEV_MODEL_ID_TEXT,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MFR_ID and delete_state='0') AS MFR_ID_TEXT,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.DW_MFR_ID and delete_state='0') AS DW_MFR_ID_TEXT,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.OLD_DW_MFR_ID and delete_state='0') AS OLD_DW_MFR_ID_TEXT,\\n\\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MNT_MFR_ID and delete_state='0') AS MNT_MFR_ID_TEXT,\\n\\tRES_ENTITY.SF_GET_STAFF_NAME(EE.MODIFY_OP) AS MODIFY_OP_TEXT,\\n\\tRES_ENTITY.SF_GET_STAFF_NAME(EE.CREATE_OP) AS CREATE_OP_TEXT,\\n\\tRES_ENTITY.SF_GET_STAFF_NAME(EE.CHECK_PERSON) AS CHECK_PERSON_TEXT,\\n\\tST.DISTRICT_PROVINCE_ID,\\n\\tST.DISTRICT_REGION_ID,\\n\\tST.DISTRICT_COUNTY_ID,\\n\\tST.STATION_NAME,\\n\\tST.STATION_NAME AS STATION_ID_TEXT,\\n\\tD.APP_REGION_ID,\\n\\t(SELECT REGION_NAME FROM res_entity.REG_MANAGE WHERE REGION_ID = D.APP_REGION_ID AND delete_state = '0') AS APP_REGION_ID_TEXT,\\n\\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) AS DISTRICT_PROVINCE_ID_TEXT,\\n\\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) AS DISTRICT_REGION_ID_TEXT,\\n\\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS DISTRICT_COUNTY_ID_TEXT,\\n\\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS REGION_ID_TEXT \\nFROM RES_ENTITY.ENT_ENTITY EE \\nLEFT JOIN RES_ENTITY.ENT_ROOM B ON B.ENTITY_ID = EE.ENTITY_ID\\nLEFT JOIN RES_ENTITY.STA_STATION ST ON ST.STATION_CODE = EE.STATION_CODE  \\nLEFT JOIN RES_ENTITY.STA_APP_INFO D ON ST.STATION_ID=D.STATION_ID\\nWHERE EE.DELETE_STATE = '0' AND EE.RES_TYPE_ID=205  \\nAND EE.STATION_CODE in  (select station_code  from res_entity.sta_biz_info  where  REGION_ID in (  select REGION_ID from res_entity.reg_manage  connect by prior REGION_ID = SUPER_REGION_ID and nvl(delete_state, '0') = '0' start with region_id in ('000102000000000000370100') ) ) \\n)t where ROWNUM <= 10) where rn > 0;\", \"explain\": \"ID\\tPLAN_STEP\\tCOST\\tCARDINALITY\\tBYTES\\tCPU_COST\\tIO_COST\\n0\\tSELECT STATEMENT\\t4200\\t10\\t120000\\t360000\\t14000\\n1\\t  NESTED LOOPS\\t4200\\t10\\t120000\\t360000\\t14000\\n2\\t   TABLE ACCESS FULL RES_ENTITY.ENT_ENTITY\\t3000\\t10000\\t800000\\t240000\\t10000\\n3\\t  FILTER (EE.DELETE_STATE='0' AND EE.RES_TYPE_ID=205 AND EE.STATION_CODE IN (... CONNECT BY result ...))\\t---\\t---\\t---\\t---\\t---\\n4\\t   NESTED LOOPS\\t1200\\t10\\t24000\\t80000\\t4000\\n5\\t  INDEX UNIQUE SCAN IDX_ENT_ROOM_ENTITY_ID (ENT_ROOM)\\t10\\t10\\t800\\t4000\\t50\\n6\\t   TABLE ACCESS BY INDEX ROWID RES_ENTITY.ENT_ROOM\\t20\\t10\\t800\\t2000\\t100\\n7\\t  INDEX RANGE SCAN IDX_STA_STATION_STATION_CODE (STA_STATION)\\t50\\t10\\t2000\\t5000\\t200\\n8\\t   TABLE ACCESS BY INDEX ROWID RES_ENTITY.STA_STATION\\t60\\t10\\t2000\\t4000\\t200\\n9\\t  TABLE ACCESS BY INDEX ROWID RES_ENTITY.STA_APP_INFO\\t40\\t10\\t1600\\t3000\\t150\\n10\\t  NESTED LOOPS (correlated scalar subquery evaluations)\\t800\\t10\\t20000\\t60000\\t3000\\n11\\t   INDEX RANGE SCAN IDX_PUB_MFR_MFR_ID (RES_SYS.PUB_MFR)\\t5\\t10\\t800\\t2000\\t20\\n12\\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_MFR\\t10\\t10\\t800\\t2000\\t30\\n13\\t   INDEX RANGE SCAN IDX_PUB_DIC_EQP_TYPE_ID (RES_SYS.PUB_DIC_EQP_TYPE)\\t5\\t10\\t800\\t2000\\t20\\n14\\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_DIC_EQP_TYPE\\t10\\t10\\t800\\t2000\\t30\\n15\\t   INDEX RANGE SCAN IDX_PUB_RME_EQP_MODEL_ID (RES_SYS.PUB_RME_EQP_MODEL)\\t5\\t10\\t800\\t2000\\t20\\n16\\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_RME_EQP_MODEL\\t10\\t10\\t800\\t2000\\t30\\n17\\t  FILTER (ROWNUM <= 10 applied in inner view)\\t---\\t---\\t---\\t---\\t---\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE RES_ENTITY.ENT_ENTITY (ENTITY_ID VARCHAR2(50) PRIMARY KEY, DELETE_STATE VARCHAR2(2), RES_TYPE_ID NUMBER, STATION_CODE VARCHAR2(50), TIME_TO_OVERDUE VARCHAR2(50), CHECK_MODE_ID NUMBER, BUSINESS_ID NUMBER, SUB_BUSINESS_ID NUMBER, PROP_ID NUMBER, OLD_PROP_ID NUMBER, PROPERTY_ID NUMBER, ENTITY_STATE_ID NUMBER, IS_LOCKED_ID NUMBER, IS_FAULT_ID NUMBER, IS_OVERDUE NUMBER, WARRANTY_GRADE_ID NUMBER, IS_OUTMAINTENANCE_ID NUMBER, ASSETS_RECEIVE_TYPE_ID NUMBER, ENTITY_CREATE_SOURCE_ID NUMBER, SOURCE_SYSTEM_ID NUMBER, CHECK_RESULT_ID NUMBER, SERVICE_STATE_ID NUMBER, IS_MONITOR_ID NUMBER, MONITOR_STYLE_ID NUMBER, IS_UPLOAD_PHOTO NUMBER, STORAGE_STATE_ID NUMBER, IS_STORAGE NUMBER, RES_FROM_PROJBUILDTYPE_ID NUMBER, SPLIT_MERGE_REASON_ID NUMBER, SOURCE_RES_NO VARCHAR2(100), ROOM_ID VARCHAR2(50), RES_TYPE_ID_TEXT VARCHAR2(100), DEV_TYPE_ID NUMBER, DEV_MODEL_ID NUMBER, OLD_DEV_MODEL_ID NUMBER, MFR_ID NUMBER, DW_MFR_ID NUMBER, OLD_DW_MFR_ID NUMBER, MNT_MFR_ID NUMBER, MODIFY_OP VARCHAR2(50), CREATE_OP VARCHAR2(50), CHECK_PERSON VARCHAR2(50), STATION_CODE_ALT VARCHAR2(50));\nCREATE INDEX IDX_ENT_ENTITY_DELETE_RES_TYPE_STCODE ON RES_ENTITY.ENT_ENTITY(DELETE_STATE, RES_TYPE_ID, STATION_CODE);\nCREATE TABLE RES_ENTITY.ENT_ROOM (ENTITY_ID VARCHAR2(50), WIDTH NUMBER, LENGTH NUMBER, HEIGHT NUMBER, AREA NUMBER, FLOOR_NO NUMBER, IS_OIL_MACH_ROOM NUMBER, IS_HAVE_WALL NUMBER, STRUCTURE_ID NUMBER, ADDRESS VARCHAR2(400), AIRBLAST_STYLE NUMBER, VACANT_CABLE_SEAT NUMBER, CONTACTS VARCHAR2(200), LINK_TEL VARCHAR2(50), NUM_HOLE_FEED NUMBER, NUM_HOLE_FEED_OCCU NUMBER, NUM_HOLE_FEED_FREE NUMBER, LIGHT_PROTECTION_BRAND VARCHAR2(200), LIGHT_PROTECTION_MODE VARCHAR2(200), FIRE_EXTINGUISHER_TYPE VARCHAR2(100), NUM_FIRE_EXTINGUISHER NUMBER, STATION_ROAD_ID NUMBER, DEGREE_ARRIVAL_ID NUMBER, REASON_UNARRIVAL VARCHAR2(400), IS_ARRIVEL NUMBER, IS_POWER NUMBER, REASON_UNPOWER VARCHAR2(400), INOUT_MODE NUMBER, PLATE_DRAWINGS_ID VARCHAR2(50), DECORATION_DRAWINGS_ID VARCHAR2(50), DESIGN_DRAWINGS_ID VARCHAR2(50), GROUND_SYSTEM_DRAWINGS_ID VARCHAR2(50), IS_EXPAND_OIL_ROOM NUMBER, SECURITY_ENVIRONMENT_ID NUMBER, GENERATION_TIME DATE, WNG_STYLE NUMBER, ROOM_GRADE_ID NUMBER, NUM_RMEBAY_TOTAL NUMBER, NUM_RMEBAY_FREE NUMBER, PRODUCT_TYPE NUMBER, ENT_AUDIT_RESULT_ID NUMBER, AUDIT_FLOW_RESULT_ID NUMBER, MANUAL_IDENT_RESULT_ID NUMBER, AGENT_MNT_CONTACT VARCHAR2(50), IS_VR_FULLSCENE_ID NUMBER, IS_SHARE NUMBER, SHARE_UNIT_ID VARCHAR2(50), INTEG_CABINET_SPACE_NUM NUMBER, INTEG_CABINET_AC_BRAND VARCHAR2(200), INTEG_CABINET_AC_MODEL_DC VARCHAR2(200), INTEG_CABINET_AC_NUM_DC NUMBER, INTEG_CABINET_AC_MODEL VARCHAR2(200), INTEG_CABINET_AC_NUM_DC_AC NUMBER, INTEG_CABINET_AC_NUM_ID VARCHAR2(50), INTEG_CABINET_AC_MFR_ID NUMBER, INTEG_CABINET_AC_NUM_ID_TEXT VARCHAR2(200));\nCREATE INDEX IDX_ENT_ROOM_ENTITY_ID ON RES_ENTITY.ENT_ROOM(ENTITY_ID);\nCREATE TABLE RES_ENTITY.STA_STATION (STATION_ID NUMBER PRIMARY KEY, STATION_CODE VARCHAR2(50), DISTRICT_PROVINCE_ID VARCHAR2(50), DISTRICT_REGION_ID VARCHAR2(50), DISTRICT_COUNTY_ID VARCHAR2(50), STATION_NAME VARCHAR2(200));\nCREATE INDEX IDX_STA_STATION_STATION_CODE ON RES_ENTITY.STA_STATION(STATION_CODE);\nCREATE TABLE RES_ENTITY.STA_APP_INFO (STATION_ID NUMBER, APP_REGION_ID VARCHAR2(50));\nCREATE INDEX IDX_STA_APP_INFO_STATION_ID ON RES_ENTITY.STA_APP_INFO(STATION_ID);\nCREATE TABLE RES_ENTITY.STA_BIZ_INFO (STATION_CODE VARCHAR2(50), REGION_ID VARCHAR2(50));\nCREATE INDEX IDX_STA_BIZ_INFO_REGION_ID ON RES_ENTITY.STA_BIZ_INFO(REGION_ID);\nCREATE TABLE RES_ENTITY.REG_MANAGE (REGION_ID VARCHAR2(50) PRIMARY KEY, SUPER_REGION_ID VARCHAR2(50), REGION_NAME VARCHAR2(200), DELETE_STATE VARCHAR2(2));\nCREATE INDEX IDX_REG_MANAGE_REGION_ID ON RES_ENTITY.REG_MANAGE(REGION_ID);\nCREATE TABLE RES_SYS.PUB_MFR (MFR_ID NUMBER PRIMARY KEY, MFR VARCHAR2(200), DELETE_STATE VARCHAR2(2));\nCREATE INDEX IDX_PUB_MFR_MFR_ID ON RES_SYS.PUB_MFR(MFR_ID);\nCREATE TABLE RES_SYS.PUB_DIC_EQP_TYPE (EQP_TYPE_ID NUMBER PRIMARY KEY, EQP_TYPE VARCHAR2(200), DELETE_STATE VARCHAR2(2));\nCREATE INDEX IDX_PUB_DIC_EQP_TYPE_ID ON RES_SYS.PUB_DIC_EQP_TYPE(EQP_TYPE_ID);\nCREATE TABLE RES_SYS.PUB_RME_EQP_MODEL (EQP_MODEL_ID NUMBER PRIMARY KEY, EQP_MODEL VARCHAR2(200), DELETE_STATE VARCHAR2(2));\nCREATE INDEX IDX_PUB_RME_EQP_MODEL_ID ON RES_SYS.PUB_RME_EQP_MODEL(EQP_MODEL_ID);\n\n## Explain Output in JSON:\nID\tPLAN_STEP\tCOST\tCARDINALITY\tBYTES\tCPU_COST\tIO_COST\n0\tSELECT STATEMENT\t4200\t10\t120000\t360000\t14000\n1\t  NESTED LOOPS\t4200\t10\t120000\t360000\t14000\n2\t   TABLE ACCESS FULL RES_ENTITY.ENT_ENTITY\t3000\t10000\t800000\t240000\t10000\n3\t  FILTER (EE.DELETE_STATE='0' AND EE.RES_TYPE_ID=205 AND EE.STATION_CODE IN (... CONNECT BY result ...))\t---\t---\t---\t---\t---\n4\t   NESTED LOOPS\t1200\t10\t24000\t80000\t4000\n5\t  INDEX UNIQUE SCAN IDX_ENT_ROOM_ENTITY_ID (ENT_ROOM)\t10\t10\t800\t4000\t50\n6\t   TABLE ACCESS BY INDEX ROWID RES_ENTITY.ENT_ROOM\t20\t10\t800\t2000\t100\n7\t  INDEX RANGE SCAN IDX_STA_STATION_STATION_CODE (STA_STATION)\t50\t10\t2000\t5000\t200\n8\t   TABLE ACCESS BY INDEX ROWID RES_ENTITY.STA_STATION\t60\t10\t2000\t4000\t200\n9\t  TABLE ACCESS BY INDEX ROWID RES_ENTITY.STA_APP_INFO\t40\t10\t1600\t3000\t150\n10\t  NESTED LOOPS (correlated scalar subquery evaluations)\t800\t10\t20000\t60000\t3000\n11\t   INDEX RANGE SCAN IDX_PUB_MFR_MFR_ID (RES_SYS.PUB_MFR)\t5\t10\t800\t2000\t20\n12\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_MFR\t10\t10\t800\t2000\t30\n13\t   INDEX RANGE SCAN IDX_PUB_DIC_EQP_TYPE_ID (RES_SYS.PUB_DIC_EQP_TYPE)\t5\t10\t800\t2000\t20\n14\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_DIC_EQP_TYPE\t10\t10\t800\t2000\t30\n15\t   INDEX RANGE SCAN IDX_PUB_RME_EQP_MODEL_ID (RES_SYS.PUB_RME_EQP_MODEL)\t5\t10\t800\t2000\t20\n16\t  TABLE ACCESS BY INDEX ROWID RES_SYS.PUB_RME_EQP_MODEL\t10\t10\t800\t2000\t30\n17\t  FILTER (ROWNUM <= 10 applied in inner view)\t---\t---\t---\t---\t---\n\n## Original SQL:\nselect *  from (select t.*,ROWNUM AS rn  from (SELECT\n\tEE.*,\n\tB.WIDTH,\n\tB.LENGTH,\n\tB.HEIGHT,\n\tB.AREA,\n\tB.FLOOR_NO,\n\tB.IS_OIL_MACH_ROOM,\n\tB.IS_HAVE_WALL,\n\tB.STRUCTURE_ID,\n\tB.ADDRESS,\n\tB.AIRBLAST_STYLE,\n\tB.VACANT_CABLE_SEAT,\n\tB.CONTACTS,\n\tB.LINK_TEL,\n\tB.NUM_HOLE_FEED,\n\tB.NUM_HOLE_FEED_OCCU,\n\tB.NUM_HOLE_FEED_FREE,\n\tB.LIGHT_PROTECTION_BRAND,\n\tB.LIGHT_PROTECTION_MODE,\n\tB.FIRE_EXTINGUISHER_TYPE,\n\tB.NUM_FIRE_EXTINGUISHER,\n\tB.STATION_ROAD_ID,\n\tB.DEGREE_ARRIVAL_ID,\n\tB.REASON_UNARRIVAL,\n\tB.IS_ARRIVEL,\n\tB.IS_POWER,\n\tB.REASON_UNPOWER,\n\tB.INOUT_MODE,\n\tB.PLATE_DRAWINGS_ID,\n\tB.DECORATION_DRAWINGS_ID,\n\tB.DESIGN_DRAWINGS_ID,\n\tB.GROUND_SYSTEM_DRAWINGS_ID,\n\tB.IS_EXPAND_OIL_ROOM,\n\tB.SECURITY_ENVIRONMENT_ID,\n\tB.GENERATION_TIME,\n\tB.WNG_STYLE,\n\tB.ROOM_GRADE_ID,\n\tB.NUM_RMEBAY_TOTAL,\n\tB.NUM_RMEBAY_FREE,\n\tB.PRODUCT_TYPE,\n\tB.ENT_AUDIT_RESULT_ID,\n\tB.AUDIT_FLOW_RESULT_ID,\n\tB.MANUAL_IDENT_RESULT_ID,\n\tB.AGENT_MNT_CONTACT,\n\tB.IS_VR_FULLSCENE_ID,\n\tB.IS_SHARE,\n\tB.SHARE_UNIT_ID,\n\tB.INTEG_CABINET_SPACE_NUM,\n\tB.INTEG_CABINET_AC_BRAND,\n\tB.INTEG_CABINET_AC_MODEL_DC,\n\tB.INTEG_CABINET_AC_NUM_DC,\n\tB.INTEG_CABINET_AC_MODEL,\n\tB.INTEG_CABINET_AC_NUM_DC_AC,\n\tB.INTEG_CABINET_SPACE_NUM AS INTEG_CABINET_SPACE_NUM_TEXT,\n\tEE.RES_FROM_PROJECT_NAME AS RES_FROM_PROJECT_NAME_TEXT,\n\tB.INTEG_CABINET_AC_NUM_ID,\n\tres_entity.SF_GET_DESC_CHINA(B.INTEG_CABINET_AC_NUM_ID) AS INTEG_CABINET_AC_NUM_ID_TEXT,\n\tB.INTEG_CABINET_AC_MFR_ID,\n\tB.INTEG_CABINET_AC_MODEL,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=B.INTEG_CABINET_AC_MFR_ID and delete_state='0') AS INTEG_CABINET_AC_MFR_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.TIME_TO_OVERDUE) AS TIME_TO_OVERDUE_TEXT,\n\t(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=B.MANUAL_IDENT_RESULT_ID AND DELETE_STATE = '0') AS MANUAL_IDENT_RESULT_ID_TEXT,\n\tRES_ENTITY.SF_GET_STAFF_NAME(B.AGENT_MNT_CONTACT) AS AGENT_MNT_CONTACT_TEXT,\n\tCASE WHEN B.IS_VR_FULLSCENE_ID = 1 THEN '有' WHEN B.IS_VR_FULLSCENE_ID= 0 THEN '无' END AS IS_VR_FULLSCENE_ID_TEXT,\n\tCASE WHEN B.AIRBLAST_STYLE = 1 THEN '下送风' WHEN B.AIRBLAST_STYLE= 0 THEN '上送风' END AS AIRBLAST_STYLE_TEXT,\n\tCASE WHEN B.WNG_STYLE = 1 THEN '上走线' WHEN B.WNG_STYLE= 0 THEN '下走线' END AS WNG_STYLE_STYLE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_SHARE) AS IS_SHARE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.SHARE_UNIT_ID) AS SHARE_UNIT_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.AUDIT_FLOW_RESULT_ID) AS AUDIT_FLOW_RESULT_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.ENT_AUDIT_RESULT_ID) AS ENT_AUDIT_RESULT_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.PRODUCT_TYPE) AS PRODUCT_TYPE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_OIL_MACH_ROOM) AS IS_OIL_MACH_ROOM_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_HAVE_WALL) AS IS_HAVE_WALL_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.STRUCTURE_ID) AS STRUCTURE_ID_TEXT, \n\tres_entity.SF_GET_DESC_CHINA(B.VACANT_CABLE_SEAT) AS VACANT_CABLE_SEAT_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.STATION_ROAD_ID) AS STATION_ROAD_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.DEGREE_ARRIVAL_ID) AS DEGREE_ARRIVAL_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_ARRIVEL) AS IS_ARRIVEL_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_POWER) AS IS_POWER_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.INOUT_MODE) AS INOUT_MODE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.IS_EXPAND_OIL_ROOM) AS IS_EXPAND_OIL_ROOM_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.SECURITY_ENVIRONMENT_ID) AS SECURITY_ENVIRONMENT_ID_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.WNG_STYLE) AS WNG_STYLE_TEXT,\n\tres_entity.SF_GET_DESC_CHINA(B.ROOM_GRADE_ID) AS ROOM_GRADE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_MODE_ID) AS CHECK_MODE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.BUSINESS_ID) AS BUSINESS_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SUB_BUSINESS_ID) AS SUB_BUSINESS_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.PROP_ID) AS PROP_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.OLD_PROP_ID) AS OLD_PROP_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.PROPERTY_ID) AS PROPERTY_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_STATE_ID) AS ENTITY_STATE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_LOCKED_ID) AS IS_LOCKED_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_FAULT_ID) AS IS_FAULT_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OVERDUE) AS IS_OVERDUE_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.WARRANTY_GRADE_ID) AS WARRANTY_GRADE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OUTMAINTENANCE_ID) AS IS_OUTMAINTENANCE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ASSETS_RECEIVE_TYPE_ID) AS ASSETS_RECEIVE_TYPE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_CREATE_SOURCE_ID) AS ENTITY_CREATE_SOURCE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SOURCE_SYSTEM_ID) AS SOURCE_SYSTEM_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_RESULT_ID) AS CHECK_RESULT_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SERVICE_STATE_ID) AS SERVICE_STATE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_MONITOR_ID) AS IS_MONITOR_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.MONITOR_STYLE_ID) AS MONITOR_STYLE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_UPLOAD_PHOTO) AS IS_UPLOAD_PHOTO_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.STORAGE_STATE_ID) AS STORAGE_STATE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.IS_STORAGE) AS IS_STORAGE_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.RES_FROM_PROJBUILDTYPE_ID) AS RES_FROM_PROJBUILDTYPE_ID_TEXT,\n\tRES_ENTITY.SF_GET_DESC_CHINA(EE.SPLIT_MERGE_REASON_ID) AS SPLIT_MERGE_REASON_ID_TEXT,\n\tEE.SOURCE_RES_NO AS SOURCE_RES_NO_TEXT,\n\t(SELECT ENTITY_NAME FROM res_entity.ent_entity WHERE ENTITY_ID=EE.ROOM_ID and res_type_id='205' and delete_state='0') AS ROOM_ID_TEXT,\n\t(SELECT RES_TYPE FROM RES_SYS.PUB_DIC_RES_TYPE WHERE RES_TYPE_ID=EE.RES_TYPE_ID and delete_state='0') AS RES_TYPE_ID_TEXT,\n\t(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=EE.DEV_TYPE_ID and delete_state='0') AS DEV_TYPE_ID_TEXT,\n\t(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.DEV_MODEL_ID and delete_state='0') AS DEV_MODEL_ID_TEXT,\n\t(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.OLD_DEV_MODEL_ID and delete_state='0') AS OLD_DEV_MODEL_ID_TEXT,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MFR_ID and delete_state='0') AS MFR_ID_TEXT,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.DW_MFR_ID and delete_state='0') AS DW_MFR_ID_TEXT,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.OLD_DW_MFR_ID and delete_state='0') AS OLD_DW_MFR_ID_TEXT,\n\t(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MNT_MFR_ID and delete_state='0') AS MNT_MFR_ID_TEXT,\n\tRES_ENTITY.SF_GET_STAFF_NAME(EE.MODIFY_OP) AS MODIFY_OP_TEXT,\n\tRES_ENTITY.SF_GET_STAFF_NAME(EE.CREATE_OP) AS CREATE_OP_TEXT,\n\tRES_ENTITY.SF_GET_STAFF_NAME(EE.CHECK_PERSON) AS CHECK_PERSON_TEXT,\n\tST.DISTRICT_PROVINCE_ID,\n\tST.DISTRICT_REGION_ID,\n\tST.DISTRICT_COUNTY_ID,\n\tST.STATION_NAME,\n\tST.STATION_NAME AS STATION_ID_TEXT,\n\tD.APP_REGION_ID,\n\t(SELECT REGION_NAME FROM res_entity.REG_MANAGE WHERE REGION_ID = D.APP_REGION_ID AND delete_state = '0') AS APP_REGION_ID_TEXT,\n\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) AS DISTRICT_PROVINCE_ID_TEXT,\n\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) AS DISTRICT_REGION_ID_TEXT,\n\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS DISTRICT_COUNTY_ID_TEXT,\n\tres_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS REGION_ID_TEXT \nFROM RES_ENTITY.ENT_ENTITY EE \nLEFT JOIN RES_ENTITY.ENT_ROOM B ON B.ENTITY_ID = EE.ENTITY_ID\nLEFT JOIN RES_ENTITY.STA_STATION ST ON ST.STATION_CODE = EE.STATION_CODE  \nLEFT JOIN RES_ENTITY.STA_APP_INFO D ON ST.STATION_ID=D.STATION_ID\nWHERE EE.DELETE_STATE = '0' AND EE.RES_TYPE_ID=205  \nAND EE.STATION_CODE in  (select station_code  from res_entity.sta_biz_info  where  REGION_ID in (  select REGION_ID from res_entity.reg_manage  connect by prior REGION_ID = SUPER_REGION_ID and nvl(delete_state, '0') = '0' start with region_id in ('000102000000000000370100') ) ) \n)t where ROWNUM <= 10) where rn > 0;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select * from (select t.*,row_number()over(order by t.entity_id)as rn from(select/*+use_hash(ee sb rm dt em rt)*/ee.*,b.width,b.length,b.height,b.area,b.floor_no,b.is_oil_mach_room,b.is_have_wall,b.structure_id,b.address,b.airblast_style,b.vacant_cable_seat,b.contacts,b.link_tel,b.num_hole_feed,b.num_hole_feed_occu,b.num_hole_feed_free,b.light_protection_brand,b.light_protection_mode,b.fire_extinguisher_type,b.num_fire_extinguisher,b.station_road_id,b.degree_arrival_id,b.reason_unarrival,b.is_arrivel,b.is_power,b.reason_unpower,b.inout_mode,b.plate_drawings_id,b.decoration_drawings_id,b.design_drawings_id,b.ground_system_drawings_id,b.is_expand_oil_room,b.security_environment_id,b.generation_time,b.wng_style,b.room_grade_id,b.num_rmebay_total,b.num_rmebay_free,b.product_type,b.ent_audit_result_id,b.audit_flow_result_id,b.manual_ident_result_id,b.agent_mnt_contact,b.is_vr_fullscene_id,b.is_share,b.share_unit_id,b.integ_cabinet_space_num,b.integ_cabinet_ac_brand,b.integ_cabinet_ac_model_dc,b.integ_cabinet_ac_num_dc,b.integ_cabinet_ac_model,b.integ_cabinet_ac_num_dc_ac,b.integ_cabinet_space_num,ee.res_from_project_name,b.integ_cabinet_ac_num_id,res_entity.sf_get_desc_china(b.integ_cabinet_ac_num_id),b.integ_cabinet_ac_mfr_id,b.integ_cabinet_ac_model,mf1.mfr,res_entity.sf_get_desc_china(ee.time_to_overdue),eqt1.eqp_type,res_entity.sf_get_staff_name(b.agent_mnt_contact),case when b.is_vr_fullscene_id=1then'有'when b.is_vr_fullscene_id=0then'无'end,case when b.airblast_style=1then'下送风'when b.airblast_style=0then'上送风'end,case when b.wng_style=1then'上走线'when b.wng_style=0then'下走线'end,res_entity.sf_get_desc_china(b.is_share),res_entity.sf_get_desc_china(b.share_unit_id),res_entity.sf_get_desc_china(b.audit_flow_result_id),res_entity.sf_get_desc_china(b.ent_audit_result_id),res_entity.sf_get_desc_china(b.product_type),res_entity.sf_get_desc_china(b.is_oil_mach_room),res_entity.sf_get_desc_china(b.is_have_wall),res_entity.sf_get_desc_china(b.structure_id),res_entity.sf_get_desc_china(b.vacant_cable_seat),res_entity.sf_get_desc_china(b.station_road_id),res_entity.sf_get_desc_china(b.degree_arrival_id),res_entity.sf_get_desc_china(b.is_arrivel),res_entity.sf_get_desc_china(b.is_power),res_entity.sf_get_desc_china(b.inout_mode),res_entity.sf_get_desc_china(b.is_expand_oil_room),res_entity.sf_get_desc_china(b.security_environment_id),res_entity.sf_get_desc_china(b.wng_style),res_entity.sf_get_desc_china(b.room_grade_id),res_entity.sf_get_desc_china(ee.check_mode_id),res_entity.sf_get_desc_china(ee.business_id),res_entity.sf_get_desc_china(ee.sub_business_id),res_entity.sf_get_desc_china(ee.prop_id),res_entity.sf_get_desc_china(ee.old_prop_id),res_entity.sf_get_desc_china(ee.property_id),res_entity.sf_get_desc_china(ee.entity_state_id),res_entity.sf_get_desc_china(ee.is_locked_id),res_entity.sf_get_desc_china(ee.is_fault_id),res_entity.sf_get_desc_china(ee.is_overdue),res_entity.sf_get_desc_china(ee.warranty_grade_id),res_entity.sf_get_desc_china(ee.is_outmaintenance_id),res_entity.sf_get_desc_china(ee.assets_receive_type_id),res_entity.sf_get_desc_china(ee.entity_create_source_id),res_entity.sf_get_desc_china(ee.source_system_id),res_entity.sf_get_desc_china(ee.check_result_id),res_entity.sf_get_desc_china(ee.service_state_id),res_entity.sf_get_desc_china(ee.is_monitor_id),res_entity.sf_get_desc_china(ee.monitor_style_id),res_entity.sf_get_desc_china(ee.is_upload_photo),res_entity.sf_get_desc_china(ee.storage_state_id),res_entity.sf_get_desc_china(ee.is_storage),res_entity.sf_get_desc_china(ee.res_from_projbuildtype_id),res_entity.sf_get_desc_china(ee.split_merge_reason_id),ee.source_res_no,(select entity_name from res_entity.ent_entity where entity_id=ee.room_id and res_type_id='205'and delete_state='0'),rt.res_type,eqt2.eqp_type,em1.eqp_model,em2.eqp_model,mf2.mfr,mf3.mfr,mf4.mfr,mf5.mfr,res_entity.sf_get_staff_name(ee.modify_op),res_entity.sf_get_staff_name(ee.create_op),res_entity.sf_get_staff_name(ee.check_person),st.district_province_id,st.district_region_id,st.district_county_id,st.station_name,st.station_name,d.app_region_id,(select region_name from res_entity.reg_manage where region_id=d.app_region_id and delete_state='0'),res_entity.sf_get_district_name(st.district_province_id),res_entity.sf_get_district_name(st.district_region_id),res_entity.sf_get_district_name(st.district_county_id),res_entity.sf_get_district_name(st.district_province_id)||res_entity.sf_get_district_name(st.district_region_id)||res_entity.sf_get_district_name(st.district_county_id)from res_entity.ent_entity ee left join res_entity.ent_room b on b.entity_id=ee.entity_id left join res_entity.sta_station st on st.station_code=ee.station_code left join res_entity.sta_app_info d on st.station_id=d.station_id left join res_sys.pub_mfr mf1 on mf1.mfr_id=b.integ_cabinet_ac_mfr_id and mf1.delete_state='0'left join res_sys.pub_dic_eqp_type eqt1 on eqt1.eqp_type_id=b.manual_ident_result_id and eqt1.delete_state='0'left join res_sys.pub_dic_res_type rt on rt.res_type_id=ee.res_type_id and rt.delete_state='0'left join res_sys.pub_dic_eqp_type eqt2 on eqt2.eqp_type_id=ee.dev_type_id and eqt2.delete_state='0'left join res_sys.pub_rme_eqp_model em1 on em1.eqp_model_id=ee.dev_model_id and em1.delete_state='0'left join res_sys.pub_rme_eqp_model em2 on em2.eqp_model_id=ee.old_dev_model_id and em2.delete_state='0'left join res_sys.pub_mfr mf2 on mf2.mfr_id=ee.mfr_id and mf2.delete_state='0'left join res_sys.pub_mfr mf3 on mf3.mfr_id=ee.dw_mfr_id and mf3.delete_state='0'left join res_sys.pub_mfr mf4 on mf4.mfr_id=ee.old_dw_mfr_id and mf4.delete_state='0'left join res_sys.pub_mfr mf5 on mf5.mfr_id=ee.mnt_mfr_id and mf5.delete_state='0'where ee.delete_state='0'and ee.res_type_id=205 and ee.station_code in(select distinct station_code from res_entity.sta_biz_info where region_id in(select region_id from res_entity.reg_manage where delete_state='0'connect by prior region_id=super_region_id start with region_id in('000102000000000000370100'))))t where rn<=10"
                    }
                ]
            },
            {
                "case_id": "41",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"41\", \"db_type\": \"postgresql\", \"description\": \"该SQL旨在统计四个不同时间窗口内（过去7、13、25、2小时），各行政区划的'zdjs'指标最大值。存在显著的性能问题：1. **冗余列投影**：最内层查询选取了`zdbh`、`zxjs`等后续聚合不需要的字段，增加了不必要的I/O和内存开销。2. **无效排序**：四个作为JOIN源表的子查询（Derived Table）内部均包含`ORDER BY \\\"zdjs\\\" desc`但无`LIMIT`，这种排序在关联操作中是无意义的，且可能触发额外的排序操作。3. **多层嵌套**：存在冗余的子查询层级，导致生成不必要的临时结果集。优化方向包括移除无效排序、裁剪非必要列以及子查询扁平化。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE SCHEMA IF NOT EXISTS WHYJ_SJZL;\", \"CREATE TABLE WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" (\\\"xzqhdm\\\" VARCHAR(50), \\\"zdbh\\\" VARCHAR(50), \\\"zdjs\\\" NUMERIC, \\\"zxjs\\\" NUMERIC, \\\"gxsj\\\" TIMESTAMP);\", \"CREATE INDEX idx_ds_dm_tqyj_jssk_gxsj ON WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\"(\\\"gxsj\\\");\", \"CREATE INDEX idx_ds_dm_tqyj_jssk_xzqhdm ON WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\"(\\\"xzqhdm\\\");\"], \"sql\": \"select \\\"a\\\".\\\"qh\\\" as \\\"qhmc\\\",\\\"d\\\".\\\"zdjs\\\" as \\\"1xszdjs\\\",\\\"a\\\".\\\"zdjs\\\" as \\\"6xszdjs\\\",\\\"b\\\".\\\"zdjs\\\" as \\\"12xszdjs\\\",\\\"c\\\".\\\"zdjs\\\" as \\\"24xszdjs\\\" from\\n(select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '7' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"a\\\" \\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '13' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"b\\\" on \\\"a\\\".\\\"qh\\\" = \\\"b\\\".\\\"qh\\\" \\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '25' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"c\\\" on \\\"a\\\".\\\"qh\\\" = \\\"c\\\".\\\"qh\\\"\\nleft join (select \\ncase substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end as \\\"qh\\\" ,max(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",sum(\\\"zdjs\\\") as \\\"zdjs\\\" from (\\nselect \\\"xzqhdm\\\",\\\"zdbh\\\",\\\"zdjs\\\",\\\"zxjs\\\",\\\"gxsj\\\" from WHYJ_SJZL.\\\"ds_dm_tqyj_jssk\\\" where \\n\\\"gxsj\\\">=NOW() - INTERVAL '2' HOUR\\n) group by \\\"xzqhdm\\\" \\n) \\ngroup by case substr(\\\"xzqhdm\\\",1,6) \\n\\t when '420102' then '江岸区'\\n\\t when '420103' then '江汉区'\\n\\t when '420104' then '硚口区'\\n\\t when '420105' then '汉阳区'\\n\\t when '420106' then '武昌区'\\n\\t when '420107' then '青山区'\\n\\t when '420111' then '洪山区'\\n\\t when '420112' then '东西湖区'\\n\\t when '420113' then '汉南区'\\n\\t when '420114' then '蔡甸区'\\n\\t when '420115' then '江夏区'\\n\\t when '420116' then '黄陂区'\\n\\t when '420117' then '新洲区' end \\norder by \\\"zdjs\\\" desc ) \\\"d\\\" on \\\"a\\\".\\\"qh\\\" = \\\"d\\\".\\\"qh\\\"\\norder by \\\"6xszdjs\\\" desc\", \"explain\": \"Sort  (cost=10890.12..10890.62 rows=200 width=160)\\n  Sort Key: a.zdjs DESC\\n  ->  Hash Left Join  (cost=8167.58..10882.48 rows=200 width=160)\\n  Hash Cond: (a.qh = d.qh)\\n  ->  Hash Left Join  (cost=5445.05..8159.95 rows=200 width=128)\\n  Hash Cond: (a.qh = c.qh)\\n  ->  Hash Left Join  (cost=2722.53..5437.43 rows=200 width=96)\\n  Hash Cond: (a.qh = b.qh)\\n  ->  Subquery Scan on a  (cost=0.00..2714.90 rows=200 width=64)\\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\\n  Sort Key: (max(sum(ds_dm_tqyj_jssk.zdjs))) DESC\\n  ->  HashAggregate  (cost=2704.40..2706.90 rows=200 width=42)\\n  Group Key: CASE substr(ds_dm_tqyj_jssk.xzqhdm, 1, 6) ... END\\n  ->  HashAggregate  (cost=2500.00..2600.00 rows=2000 width=18)\\n  Group Key: ds_dm_tqyj_jssk.xzqhdm\\n  ->  Seq Scan on ds_dm_tqyj_jssk  (cost=0.00..2200.00 rows=100000 width=58)\\n  Filter: (gxsj >= (now() - '07:00:00'::interval))\\n  ->  Hash  (cost=2714.90..2714.90 rows=200 width=64)\\n  ->  Subquery Scan on b  (cost=0.00..2714.90 rows=200 width=64)\\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\\n  ->  HashAggregate ...\\n  ->  Seq Scan on ds_dm_tqyj_jssk ...\\n  ->  Hash ...\\n  ->  Subquery Scan on c ...\\n  ->  Hash ...\\n  ->  Subquery Scan on d ...\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE SCHEMA IF NOT EXISTS WHYJ_SJZL;\nCREATE TABLE WHYJ_SJZL.\"ds_dm_tqyj_jssk\" (\"xzqhdm\" VARCHAR(50), \"zdbh\" VARCHAR(50), \"zdjs\" NUMERIC, \"zxjs\" NUMERIC, \"gxsj\" TIMESTAMP);\nCREATE INDEX idx_ds_dm_tqyj_jssk_gxsj ON WHYJ_SJZL.\"ds_dm_tqyj_jssk\"(\"gxsj\");\nCREATE INDEX idx_ds_dm_tqyj_jssk_xzqhdm ON WHYJ_SJZL.\"ds_dm_tqyj_jssk\"(\"xzqhdm\");\n\n## Explain Output in JSON:\nSort  (cost=10890.12..10890.62 rows=200 width=160)\n  Sort Key: a.zdjs DESC\n  ->  Hash Left Join  (cost=8167.58..10882.48 rows=200 width=160)\n  Hash Cond: (a.qh = d.qh)\n  ->  Hash Left Join  (cost=5445.05..8159.95 rows=200 width=128)\n  Hash Cond: (a.qh = c.qh)\n  ->  Hash Left Join  (cost=2722.53..5437.43 rows=200 width=96)\n  Hash Cond: (a.qh = b.qh)\n  ->  Subquery Scan on a  (cost=0.00..2714.90 rows=200 width=64)\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\n  Sort Key: (max(sum(ds_dm_tqyj_jssk.zdjs))) DESC\n  ->  HashAggregate  (cost=2704.40..2706.90 rows=200 width=42)\n  Group Key: CASE substr(ds_dm_tqyj_jssk.xzqhdm, 1, 6) ... END\n  ->  HashAggregate  (cost=2500.00..2600.00 rows=2000 width=18)\n  Group Key: ds_dm_tqyj_jssk.xzqhdm\n  ->  Seq Scan on ds_dm_tqyj_jssk  (cost=0.00..2200.00 rows=100000 width=58)\n  Filter: (gxsj >= (now() - '07:00:00'::interval))\n  ->  Hash  (cost=2714.90..2714.90 rows=200 width=64)\n  ->  Subquery Scan on b  (cost=0.00..2714.90 rows=200 width=64)\n  ->  Sort  (cost=2714.40..2714.90 rows=200 width=42)\n  ->  HashAggregate ...\n  ->  Seq Scan on ds_dm_tqyj_jssk ...\n  ->  Hash ...\n  ->  Subquery Scan on c ...\n  ->  Hash ...\n  ->  Subquery Scan on d ...\n\n## Original SQL:\nselect \"a\".\"qh\" as \"qhmc\",\"d\".\"zdjs\" as \"1xszdjs\",\"a\".\"zdjs\" as \"6xszdjs\",\"b\".\"zdjs\" as \"12xszdjs\",\"c\".\"zdjs\" as \"24xszdjs\" from\n(select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '7' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"a\" \nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '13' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"b\" on \"a\".\"qh\" = \"b\".\"qh\" \nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '25' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"c\" on \"a\".\"qh\" = \"c\".\"qh\"\nleft join (select \ncase substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end as \"qh\" ,max(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",sum(\"zdjs\") as \"zdjs\" from (\nselect \"xzqhdm\",\"zdbh\",\"zdjs\",\"zxjs\",\"gxsj\" from WHYJ_SJZL.\"ds_dm_tqyj_jssk\" where \n\"gxsj\">=NOW() - INTERVAL '2' HOUR\n) group by \"xzqhdm\" \n) \ngroup by case substr(\"xzqhdm\",1,6) \n\t when '420102' then '江岸区'\n\t when '420103' then '江汉区'\n\t when '420104' then '硚口区'\n\t when '420105' then '汉阳区'\n\t when '420106' then '武昌区'\n\t when '420107' then '青山区'\n\t when '420111' then '洪山区'\n\t when '420112' then '东西湖区'\n\t when '420113' then '汉南区'\n\t when '420114' then '蔡甸区'\n\t when '420115' then '江夏区'\n\t when '420116' then '黄陂区'\n\t when '420117' then '新洲区' end \norder by \"zdjs\" desc ) \"d\" on \"a\".\"qh\" = \"d\".\"qh\"\norder by \"6xszdjs\" desc\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH district_map AS (SELECT '420102' as \"code\", '江岸区' as \"name\" UNION ALL SELECT '420103', '江汉区' UNION ALL SELECT '420104', '硚口区' UNION ALL SELECT '420105', '汉阳区' UNION ALL SELECT '420106', '武昌区' UNION ALL SELECT '420107', '青山区' UNION ALL SELECT '420111', '洪山区' UNION ALL SELECT '420112', '东西湖区' UNION ALL SELECT '420113', '汉南区' UNION ALL SELECT '420114', '蔡甸区' UNION ALL SELECT '420115', '江夏区' UNION ALL SELECT '420116', '黄陂区' UNION ALL SELECT '420117', '新洲区'), window_sums AS (SELECT \"xzqhdm\", SUBSTR(\"xzqhdm\", 1, 6) as \"district_code\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '7' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_7h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '13' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_13h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '25' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_25h\", SUM(CASE WHEN \"gxsj\" >= NOW() - INTERVAL '2' HOUR THEN \"zdjs\" ELSE 0 END) as \"sum_2h\" FROM WHYJ_SJZL.\"ds_dm_tqyj_jssk\" WHERE \"gxsj\" >= NOW() - INTERVAL '25' HOUR GROUP BY \"xzqhdm\", SUBSTR(\"xzqhdm\", 1, 6)), district_results AS (SELECT d.\"name\" as \"qh\", MAX(\"sum_7h\") as \"max_7h\", MAX(\"sum_13h\") as \"max_13h\", MAX(\"sum_25h\") as \"max_25h\", MAX(\"sum_2h\") as \"max_2h\" FROM window_sums ws JOIN district_map d ON ws.\"district_code\" = d.\"code\" GROUP BY d.\"name\") SELECT \"qh\" as \"qhmc\", \"max_2h\" as \"1xszdjs\", \"max_7h\" as \"6xszdjs\", \"max_13h\" as \"12xszdjs\", \"max_25h\" as \"24xszdjs\" FROM district_results ORDER BY \"6xszdjs\" DESC;"
                    }
                ]
            },
            {
                "case_id": "42",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"42\", \"db_type\": \"mysql\", \"description\": \"该SQL查询存在显著的性能瓶颈，主要体现为：1. **谓词未下推**：核心过滤条件`CUSTOMER_ID`位于最外层，导致内部巨大的UNION ALL派生表（由四部分组成）必须先全量物化及聚合，无法利用索引提前过滤数据。2. **隐式内连接**：对LEFT JOIN表`t_dgm_send_info`的字段进行了`SEND_STATE='70'`的等值过滤，语义上已变为内连接，但写法可能误导优化器或导致低效的执行路径。3. **冗余的聚合与排序**：外层的`GROUP BY temp.MIXED_NO`在业务逻辑上可能是冗余的（子查询已确保唯一性或JOIN关系未导致膨胀），且`HAVING`子句中包含了本应在WHERE中过滤的非聚合条件，导致了不必要的临时表和排序开销。4. **宽表投影**：派生表输出了大量后续未使用的列，增加了内存和I/O负担。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE DATABASE IF NOT EXISTS zjjs_mpm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_rmm;\", \"CREATE DATABASE IF NOT EXISTS zjjs_qdm;\", \"CREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\", \"CREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\", \"CREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\", \"CREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\", \"CREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\", \"CREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\", \"CREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\", \"CREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\", \"CREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\", \"CREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\", \"CREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\", \"CREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\", \"CREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\"], \"sql\": \"SELECT\\n  temp.*,\\n  t_rmm_store.STORE_NAME,\\n  t_rmm_location.LOCATION_NAME,\\n  t_qdm_standard.STANDARD_NAME,\\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\\n  ) AS `SEND_NUMBER`,\\n  IF (\\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\\n  ) AS `RETURN_NUMBER`\\nFROM\\n  t_dgm_send_info_detail\\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\\n  LEFT JOIN (\\n  SELECT\\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\\n   IFNULL(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   ) AS MIXED_NO,\\n   '30' AS SPOT_TYPE,\\n   v_pre_product_material.MATERIAL_NO,\\n   v_pre_product_material.PACKAGE_NO,\\n   v_pre_product_material.PSR_ID,\\n   v_pre_product_material.CUSTOMER_ID,\\n   v_pre_product_material.CONTRACT_ID,\\n   v_pre_product_material.CONTRACT_NO,\\n   v_pre_product_material.NUMBER,\\n   v_pre_product_material.NET_WEIGHT,\\n   v_pre_product_material.GROSS_WT,\\n   v_pre_product_material.STORE_ID,\\n   v_pre_product_material.LOCATION_ID,\\n   v_pre_product_material.STANDARD_ID,\\n   v_pre_product_material.STEEL_GRADE,\\n   v_pre_product_material.SURFACE_GROUP_DESC,\\n   v_pre_product_material.CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (v_pre_product_material.LENGTH IS NOT NULL)\\n  AND (v_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*',\\n  v_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  v_pre_product_material.THICK,\\n  '*',\\n  v_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   SUM(\\n  IF (\\n  t_sam_contract_detail.BUY_UNIT = '10',\\n  -- 单位测试\\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\\n  )\\n   ) AS `PRICE`\\n  FROM\\n   v_pre_product_material\\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\\n  WHERE\\n   v_pre_product_material.IS_ISSUED = '1'\\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\\n   AND v_pre_product_material.NI36_TAG = '0'\\n   AND v_pre_product_material.MATERIAL_STATE != '110'\\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\\n   AND NOT EXISTS (\\n  SELECT\\n  1\\n  FROM\\n  v_pre_product_material v2\\n  WHERE\\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\\n  GROUP BY\\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\\n  HAVING\\n  SUM(\\n   CASE\\n  WHEN IS_ISSUED != '1' THEN 1\\n  ELSE 0\\n   END\\n  ) > 0\\n   )\\n  GROUP BY\\n   COALESCE(\\n  v_pre_product_material.PACKAGE_NO,\\n  v_pre_product_material.MATERIAL_NO\\n   )\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '10' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   NULL AS `PACKAGE_NO`,\\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   1 AS NUMBER,\\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\\n   t_inm_store_info.STORE_ID AS STORE_ID,\\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_inm_store_info.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   t_inm_store_info.VARIETY_ID,\\n   IF (\\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  t_inm_store_info.MATERIAL_LENGTH\\n  ),\\n  CONCAT_WS(\\n  \\\"*\\\",\\n  t_inm_store_info.MATERIAL_THICK,\\n  t_inm_store_info.MATERIAL_WIDTH,\\n  'C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\\n   '30' AS SPOT_TYPE,\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\\n   t_pre_product_material.PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   t_pre_product_material.NUMBER AS NUMBER,\\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\\n   t_pre_product_material.STORE_ID AS STORE_ID,\\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\\n   t_pre_product_material.STEEL_GRADE,\\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   IF(\\n  (t_pre_product_material.LENGTH IS NOT NULL)\\n  AND (t_pre_product_material.LENGTH != 0),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*',\\n  t_pre_product_material.LENGTH\\n  ),\\n  CONCAT(\\n  t_pre_product_material.THICK,\\n  '*',\\n  t_pre_product_material.WIDTH,\\n  '*C'\\n  )\\n   ) AS specs,\\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\\n  UNION ALL\\n  SELECT\\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\\n   t_sam_contract.CUSTOMER_ID,\\n   t_sam_contract.CONTRACT_ID,\\n   t_sam_contract.CONTRACT_NO,\\n   NULL AS NUMBER,\\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\\n   NULL AS GROSS_WT,\\n   '/' AS STORE_ID,\\n   '/' AS LOCATION_ID,\\n   NULL AS STANDARD_ID,\\n   t_pre_scrap.STEEL_GRADE,\\n   NULL AS SURFACE_GROUP_DESC,\\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\\n   NULL AS VARIETY_ID,\\n   NULL AS specs,\\n   -- 单位测试\\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\\n  FROM\\n   t_sam_contract_detail\\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\\n  WHERE\\n   t_sam_contract.CONTRACT_TYPE = '20'\\n   AND t_sam_contract_detail.IS_DELETE = '0'\\n   AND t_sam_contract.IS_DELETE = '0'\\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\\n  GROUP BY\\n   t_pre_scrap.BATCH_NO\\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\\nWHERE\\n  t_dgm_send_info.SEND_STATE = '70'\\n  AND temp.CUSTOMER_ID = '1930921074703462401'\\ngroup by\\n  temp.MIXED_NO\\nhaving\\n  SEND_NUMBER > RETURN_NUMBER\\nLIMIT\\n  100\", \"explain\": \"id\\tselect_type\\ttable\\ttype\\tkey\\trows\\tExtra\\n1\\tPRIMARY\\tt_dgm_send_info\\tALL\\tPRIMARY\\t1000\\tUsing where; Using temporary; Using filesort\\n1\\tPRIMARY\\tt_dgm_send_info_detail\\tref\\tSEND_ID\\t10\\tUsing where\\n1\\tPRIMARY\\t<derived2>\\tref\\t<auto_key0>\\t150\\tUsing where\\n1\\tPRIMARY\\tt_rmm_store\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_rmm_location\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_qdm_standard\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_bdm_column\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tt_dgm_send_info_return_detail\\tref\\tCONNECT_DETAIL_ID\\t1\\tUsing where\\n2\\tDERIVED\\tv_pre_product_material\\tALL\\tNULL\\t50000\\tUsing where; Using temporary; Using filesort\\n2\\tDERIVED\\tmaterial\\tref\\tMATERIAL_NO\\t1\\tUsing index\\n2\\tDERIVED\\tpackage\\tref\\tPACKAGE_NO\\t1\\tUsing index\\n3\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n3\\tUNION\\tt_sam_contract\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n4\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t20000\\tUsing where\\n5\\tUNION\\tt_sam_contract_detail\\tALL\\tNULL\\t10000\\tUsing where\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE DATABASE IF NOT EXISTS zjjs_mpm;\nCREATE DATABASE IF NOT EXISTS zjjs_rmm;\nCREATE DATABASE IF NOT EXISTS zjjs_qdm;\nCREATE TABLE t_dgm_send_info_detail (SEND_PRODUCT_DETAIL_ID INT PRIMARY KEY, SEND_ID INT, MIXED_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(SEND_ID), INDEX(MIXED_NO));\nCREATE TABLE t_dgm_send_info (SEND_ID INT PRIMARY KEY, SEND_STATE VARCHAR(10));\nCREATE TABLE t_dgm_send_info_return_detail (CONNECT_DETAIL_ID INT, WEIGHT DECIMAL(10,2), NUMBER INT, INDEX(CONNECT_DETAIL_ID));\nCREATE TABLE v_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), CONTRACT_DETAIL_ID INT, THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2), CONTRACT_DELIVERY_ID INT, IS_ISSUED VARCHAR(10), IS_SPOT_RESOURCE VARCHAR(10), NI36_TAG VARCHAR(10), MATERIAL_STATE VARCHAR(10), CONTRACT_TYPE VARCHAR(10));\nCREATE TABLE t_dgm_send_plan_detail (MATERIAL_NO VARCHAR(50), PACKAGE_NO VARCHAR(50));\nCREATE TABLE t_mao_contract_delivery_subkey (CONTRACT_DELIVERY_ID INT, CONTRACT_DETAIL_ID INT, INDEX(CONTRACT_DELIVERY_ID));\nCREATE TABLE t_sam_contract_detail (CONTRACT_DETAILS_ID INT PRIMARY KEY, CONTRACT_ID VARCHAR(50), BUY_UNIT VARCHAR(10), TAX_PRICE DECIMAL(10,2), NUMBER INT, IN_TAX_TOTAL DECIMAL(10,2), PRODUCT_MATERIAL_NO VARCHAR(50), SPOT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), SCRAP_INFO_ID INT);\nCREATE TABLE t_sam_contract (CONTRACT_ID VARCHAR(50), CUSTOMER_ID VARCHAR(50), CONTRACT_NO VARCHAR(50), CONTRACT_TYPE VARCHAR(10), IS_DELETE VARCHAR(10), CONTRACT_STATE VARCHAR(10), INDEX(CONTRACT_ID));\nCREATE TABLE t_inm_store_info (MATERIAL_NO VARCHAR(50), NEW_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), VARIETY_ID VARCHAR(50), MATERIAL_LENGTH DECIMAL(10,2), MATERIAL_THICK DECIMAL(10,2), MATERIAL_WIDTH DECIMAL(10,2), STOCK_ID VARCHAR(50));\nCREATE TABLE zjjs_mpm.t_bdm_column (COLUMN_ID VARCHAR(50), COLUMN_NAME VARCHAR(100));\nCREATE TABLE t_pre_product_material (PRODUCE_MATERIAL_ID INT, PACKAGE_NO VARCHAR(50), MATERIAL_NO VARCHAR(50), PSR_ID VARCHAR(50), NUMBER INT, NET_WEIGHT DECIMAL(10,2), GROSS_WT DECIMAL(10,2), STORE_ID VARCHAR(50), LOCATION_ID VARCHAR(50), STANDARD_ID VARCHAR(50), STEEL_GRADE VARCHAR(50), SURFACE_GROUP_DESC VARCHAR(100), THICK DECIMAL(10,2), WIDTH DECIMAL(10,2), LENGTH DECIMAL(10,2));\nCREATE TABLE t_pre_scrap (SCRAP_INFO_ID INT, BATCH_NO VARCHAR(50), PRODUCT_NAME VARCHAR(100), WEIGHT DECIMAL(10,2), STEEL_GRADE VARCHAR(50));\nCREATE TABLE zjjs_rmm.t_rmm_store (STORE_ID VARCHAR(50), STORE_NAME VARCHAR(100));\nCREATE TABLE zjjs_rmm.t_rmm_location (LOCATION_ID VARCHAR(50), LOCATION_NAME VARCHAR(100));\nCREATE TABLE zjjs_qdm.t_qdm_standard (STANDARD_ID VARCHAR(50), STANDARD_NAME VARCHAR(100));\n\n## Explain Output in JSON:\nid\tselect_type\ttable\ttype\tkey\trows\tExtra\n1\tPRIMARY\tt_dgm_send_info\tALL\tPRIMARY\t1000\tUsing where; Using temporary; Using filesort\n1\tPRIMARY\tt_dgm_send_info_detail\tref\tSEND_ID\t10\tUsing where\n1\tPRIMARY\t<derived2>\tref\t<auto_key0>\t150\tUsing where\n1\tPRIMARY\tt_rmm_store\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_rmm_location\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_qdm_standard\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_bdm_column\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tt_dgm_send_info_return_detail\tref\tCONNECT_DETAIL_ID\t1\tUsing where\n2\tDERIVED\tv_pre_product_material\tALL\tNULL\t50000\tUsing where; Using temporary; Using filesort\n2\tDERIVED\tmaterial\tref\tMATERIAL_NO\t1\tUsing index\n2\tDERIVED\tpackage\tref\tPACKAGE_NO\t1\tUsing index\n3\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n3\tUNION\tt_sam_contract\teq_ref\tPRIMARY\t1\tUsing where\n4\tUNION\tt_sam_contract_detail\tALL\tNULL\t20000\tUsing where\n5\tUNION\tt_sam_contract_detail\tALL\tNULL\t10000\tUsing where\n\n## Original SQL:\nSELECT\n  temp.*,\n  t_rmm_store.STORE_NAME,\n  t_rmm_location.LOCATION_NAME,\n  t_qdm_standard.STANDARD_NAME,\n  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,\n  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,\n  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_detail.NUMBER, 0)\n  ) AS `SEND_NUMBER`,\n  IF (\n  t_dgm_send_info_detail.SPOT_TYPE = '40',\n  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),\n  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)\n  ) AS `RETURN_NUMBER`\nFROM\n  t_dgm_send_info_detail\n  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID\n  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID\n  LEFT JOIN (\n  SELECT\n   v_pre_product_material.PRODUCE_MATERIAL_ID,\n   IFNULL(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   ) AS MIXED_NO,\n   '30' AS SPOT_TYPE,\n   v_pre_product_material.MATERIAL_NO,\n   v_pre_product_material.PACKAGE_NO,\n   v_pre_product_material.PSR_ID,\n   v_pre_product_material.CUSTOMER_ID,\n   v_pre_product_material.CONTRACT_ID,\n   v_pre_product_material.CONTRACT_NO,\n   v_pre_product_material.NUMBER,\n   v_pre_product_material.NET_WEIGHT,\n   v_pre_product_material.GROSS_WT,\n   v_pre_product_material.STORE_ID,\n   v_pre_product_material.LOCATION_ID,\n   v_pre_product_material.STANDARD_ID,\n   v_pre_product_material.STEEL_GRADE,\n   v_pre_product_material.SURFACE_GROUP_DESC,\n   v_pre_product_material.CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (v_pre_product_material.LENGTH IS NOT NULL)\n  AND (v_pre_product_material.LENGTH != 0),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*',\n  v_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  v_pre_product_material.THICK,\n  '*',\n  v_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   SUM(\n  IF (\n  t_sam_contract_detail.BUY_UNIT = '10',\n  -- 单位测试\n  t_sam_contract_detail.TAX_PRICE * v_pre_product_material.NET_WEIGHT,\n  t_sam_contract_detail.TAX_PRICE * IFNULL(t_sam_contract_detail.NUMBER, 1)\n  )\n   ) AS `PRICE`\n  FROM\n   v_pre_product_material\n   LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO\n   LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO\n   LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID\n   LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID\n  WHERE\n   v_pre_product_material.IS_ISSUED = '1'\n   AND v_pre_product_material.IS_SPOT_RESOURCE = '0'\n   AND v_pre_product_material.NI36_TAG = '0'\n   AND v_pre_product_material.MATERIAL_STATE != '110'\n   AND v_pre_product_material.CONTRACT_TYPE != '60'\n   AND NOT EXISTS (\n  SELECT\n  1\n  FROM\n  v_pre_product_material v2\n  WHERE\n  v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO\n  OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO\n  GROUP BY\n  COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)\n  HAVING\n  SUM(\n   CASE\n  WHEN IS_ISSUED != '1' THEN 1\n  ELSE 0\n   END\n  ) > 0\n   )\n  GROUP BY\n   COALESCE(\n  v_pre_product_material.PACKAGE_NO,\n  v_pre_product_material.MATERIAL_NO\n   )\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '10' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   NULL AS `PACKAGE_NO`,\n   t_bdm_column.COLUMN_NAME AS `PSR_ID`,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   1 AS NUMBER,\n   t_inm_store_info.NEW_WEIGHT AS `NET_WEIGHT`,\n   t_inm_store_info.GROSS_WT AS GROSS_WT,\n   t_inm_store_info.STORE_ID AS STORE_ID,\n   t_inm_store_info.LOCATION_ID AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_inm_store_info.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   t_inm_store_info.VARIETY_ID,\n   IF (\n  t_inm_store_info.MATERIAL_LENGTH IS NOT NULL\n  AND t_inm_store_info.MATERIAL_LENGTH != 0,\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  t_inm_store_info.MATERIAL_LENGTH\n  ),\n  CONCAT_WS(\n  \"*\",\n  t_inm_store_info.MATERIAL_THICK,\n  t_inm_store_info.MATERIAL_WIDTH,\n  'C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO\n   LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '10'\n   AND t_inm_store_info.STOCK_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_pre_product_material.PRODUCE_MATERIAL_ID AS `PRODUCE_MATERIAL_ID`,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MIXED_NO`,\n   '30' AS SPOT_TYPE,\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO AS `MATERIAL_NO`,\n   t_pre_product_material.PACKAGE_NO AS `PACKAGE_NO`,\n   t_pre_product_material.PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   t_pre_product_material.NUMBER AS NUMBER,\n   t_pre_product_material.NET_WEIGHT AS NET_WEIGHT,\n   t_pre_product_material.GROSS_WT AS GROSS_WT,\n   t_pre_product_material.STORE_ID AS STORE_ID,\n   t_pre_product_material.LOCATION_ID AS LOCATION_ID,\n   t_pre_product_material.STANDARD_ID AS STANDARD_ID,\n   t_pre_product_material.STEEL_GRADE,\n   t_pre_product_material.SURFACE_GROUP_DESC AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   IF(\n  (t_pre_product_material.LENGTH IS NOT NULL)\n  AND (t_pre_product_material.LENGTH != 0),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*',\n  t_pre_product_material.LENGTH\n  ),\n  CONCAT(\n  t_pre_product_material.THICK,\n  '*',\n  t_pre_product_material.WIDTH,\n  '*C'\n  )\n   ) AS specs,\n   t_sam_contract_detail.IN_TAX_TOTAL AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO\n   OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')\n   AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_sam_contract_detail.PRODUCT_MATERIAL_NO\n  UNION ALL\n  SELECT\n   t_sam_contract_detail.SCRAP_INFO_ID AS `PRODUCE_MATERIAL_ID`,\n   t_pre_scrap.BATCH_NO AS `MIXED_NO`,\n   t_sam_contract_detail.SPOT_TYPE AS SPOT_TYPE,\n   t_pre_scrap.BATCH_NO AS `MATERIAL_NO`,\n   t_pre_scrap.BATCH_NO AS `PACKAGE_NO`,\n   t_pre_scrap.PRODUCT_NAME AS PSR_ID,\n   t_sam_contract.CUSTOMER_ID,\n   t_sam_contract.CONTRACT_ID,\n   t_sam_contract.CONTRACT_NO,\n   NULL AS NUMBER,\n   t_pre_scrap.WEIGHT AS NET_WEIGHT,\n   NULL AS GROSS_WT,\n   '/' AS STORE_ID,\n   '/' AS LOCATION_ID,\n   NULL AS STANDARD_ID,\n   t_pre_scrap.STEEL_GRADE,\n   NULL AS SURFACE_GROUP_DESC,\n   t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,\n   NULL AS VARIETY_ID,\n   NULL AS specs,\n   -- 单位测试\n   t_pre_scrap.WEIGHT * t_sam_contract_detail.TAX_PRICE AS `PRICE`\n  FROM\n   t_sam_contract_detail\n   LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID\n   LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID\n  WHERE\n   t_sam_contract.CONTRACT_TYPE = '20'\n   AND t_sam_contract_detail.IS_DELETE = '0'\n   AND t_sam_contract.IS_DELETE = '0'\n   AND t_sam_contract_detail.SPOT_TYPE = '40'\n   AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')\n  GROUP BY\n   t_pre_scrap.BATCH_NO\n  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO\n  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID\n  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID\n  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID\n  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE\nWHERE\n  t_dgm_send_info.SEND_STATE = '70'\n  AND temp.CUSTOMER_ID = '1930921074703462401'\ngroup by\n  temp.MIXED_NO\nhaving\n  SEND_NUMBER > RETURN_NUMBER\nLIMIT\n  100\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT temp.*,t_rmm_store.STORE_NAME,t_rmm_location.LOCATION_NAME,t_qdm_standard.STANDARD_NAME,t_bdm_column.COLUMN_NAME AS STEEL_GRADE_NAME,t_dgm_send_info.SEND_ID AS CONNECT_ID,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS CONNECT_DETAIL_ID,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0)) AS SEND_NUMBER,IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) AS RETURN_NUMBER FROM t_dgm_send_info_detail INNER JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID=t_dgm_send_info_detail.SEND_ID AND t_dgm_send_info.SEND_STATE='70' LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID=t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID INNER JOIN (SELECT v_pre_product_material.PRODUCE_MATERIAL_ID,IFNULL(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) AS MIXED_NO,'30' AS SPOT_TYPE,v_pre_product_material.MATERIAL_NO,v_pre_product_material.PACKAGE_NO,v_pre_product_material.PSR_ID,v_pre_product_material.CUSTOMER_ID,v_pre_product_material.CONTRACT_ID,v_pre_product_material.CONTRACT_NO,v_pre_product_material.NUMBER,v_pre_product_material.NET_WEIGHT,v_pre_product_material.GROSS_WT,v_pre_product_material.STORE_ID,v_pre_product_material.LOCATION_ID,v_pre_product_material.STANDARD_ID,v_pre_product_material.STEEL_GRADE,v_pre_product_material.SURFACE_GROUP_DESC,v_pre_product_material.CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((v_pre_product_material.LENGTH IS NOT NULL) AND (v_pre_product_material.LENGTH!=0),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*',v_pre_product_material.LENGTH),CONCAT(v_pre_product_material.THICK,'*',v_pre_product_material.WIDTH,'*C')) AS specs,SUM(IF(t_sam_contract_detail.BUY_UNIT='10',t_sam_contract_detail.TAX_PRICE*v_pre_product_material.NET_WEIGHT,t_sam_contract_detail.TAX_PRICE*IFNULL(t_sam_contract_detail.NUMBER,1))) AS PRICE FROM v_pre_product_material LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID=v_pre_product_material.CONTRACT_DELIVERY_ID LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID=t_sam_contract_detail.CONTRACT_DETAILS_ID WHERE v_pre_product_material.IS_ISSUED='1' AND v_pre_product_material.IS_SPOT_RESOURCE='0' AND v_pre_product_material.NI36_TAG='0' AND v_pre_product_material.MATERIAL_STATE!='110' AND v_pre_product_material.CONTRACT_TYPE!='60' AND v_pre_product_material.CUSTOMER_ID='1930921074703462401' GROUP BY COALESCE(v_pre_product_material.PACKAGE_NO,v_pre_product_material.MATERIAL_NO) UNION ALL SELECT t_sam_contract_detail.CONTRACT_DETAILS_ID AS PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'10' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,NULL AS PACKAGE_NO,t_bdm_column.COLUMN_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,1 AS NUMBER,t_inm_store_info.NEW_WEIGHT AS NET_WEIGHT,t_inm_store_info.GROSS_WT,t_inm_store_info.STORE_ID,t_inm_store_info.LOCATION_ID,NULL AS STANDARD_ID,t_inm_store_info.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,t_inm_store_info.VARIETY_ID,IF(t_inm_store_info.MATERIAL_LENGTH IS NOT NULL AND t_inm_store_info.MATERIAL_LENGTH!=0,CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,t_inm_store_info.MATERIAL_LENGTH),CONCAT_WS('*',t_inm_store_info.MATERIAL_THICK,t_inm_store_info.MATERIAL_WIDTH,'C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='10' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO=t_sam_contract_detail.PRODUCT_MATERIAL_NO AND t_inm_store_info.STOCK_ID IS NOT NULL LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID=t_bdm_column.COLUMN_ID GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_pre_product_material.PRODUCE_MATERIAL_ID,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,'30' AS SPOT_TYPE,t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MATERIAL_NO,t_pre_product_material.PACKAGE_NO,t_pre_product_material.PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,t_pre_product_material.NUMBER,t_pre_product_material.NET_WEIGHT,t_pre_product_material.GROSS_WT,t_pre_product_material.STORE_ID,t_pre_product_material.LOCATION_ID,t_pre_product_material.STANDARD_ID,t_pre_product_material.STEEL_GRADE,t_pre_product_material.SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID AS CONTRACT_DETAIL_ID,NULL AS VARIETY_ID,IF((t_pre_product_material.LENGTH IS NOT NULL) AND (t_pre_product_material.LENGTH!=0),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*',t_pre_product_material.LENGTH),CONCAT(t_pre_product_material.THICK,'*',t_pre_product_material.WIDTH,'*C')) AS specs,t_sam_contract_detail.IN_TAX_TOTAL AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE IN('20','30') AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' INNER JOIN t_pre_product_material ON(t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.PACKAGE_NO OR t_sam_contract_detail.PRODUCT_MATERIAL_NO=t_pre_product_material.MATERIAL_NO) AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL GROUP BY t_sam_contract_detail.PRODUCT_MATERIAL_NO UNION ALL SELECT t_sam_contract_detail.SCRAP_INFO_ID AS PRODUCE_MATERIAL_ID,t_pre_scrap.BATCH_NO AS MIXED_NO,t_sam_contract_detail.SPOT_TYPE,t_pre_scrap.BATCH_NO AS MATERIAL_NO,t_pre_scrap.BATCH_NO AS PACKAGE_NO,t_pre_scrap.PRODUCT_NAME AS PSR_ID,t_sam_contract.CUSTOMER_ID,t_sam_contract.CONTRACT_ID,t_sam_contract.CONTRACT_NO,NULL AS NUMBER,t_pre_scrap.WEIGHT AS NET_WEIGHT,NULL AS GROSS_WT,'/' AS STORE_ID,'/' AS LOCATION_ID,NULL AS STANDARD_ID,t_pre_scrap.STEEL_GRADE,NULL AS SURFACE_GROUP_DESC,t_sam_contract_detail.CONTRACT_DETAILS_ID,NULL AS VARIETY_ID,NULL AS specs,t_pre_scrap.WEIGHT*t_sam_contract_detail.TAX_PRICE AS PRICE FROM t_sam_contract_detail INNER JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID=t_sam_contract_detail.CONTRACT_ID AND t_sam_contract.CONTRACT_TYPE='20' AND t_sam_contract_detail.IS_DELETE='0' AND t_sam_contract.IS_DELETE='0' AND t_sam_contract_detail.SPOT_TYPE='40' AND t_sam_contract.CONTRACT_STATE IN('40','50','70') AND t_sam_contract.CUSTOMER_ID='1930921074703462401' LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID=t_sam_contract_detail.SCRAP_INFO_ID GROUP BY t_pre_scrap.BATCH_NO) as temp ON temp.MIXED_NO=t_dgm_send_info_detail.MIXED_NO LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store ON t_rmm_store.STORE_ID=temp.STORE_ID LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location ON t_rmm_location.LOCATION_ID=temp.LOCATION_ID LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard ON t_qdm_standard.STANDARD_ID=temp.STANDARD_ID LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_bdm_column.COLUMN_ID=temp.STEEL_GRADE GROUP BY temp.MIXED_NO,t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID HAVING IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_detail.WEIGHT,0),IFNULL(t_dgm_send_info_detail.NUMBER,0))>IF(t_dgm_send_info_detail.SPOT_TYPE='40',IFNULL(t_dgm_send_info_return_detail.WEIGHT,0),IFNULL(t_dgm_send_info_return_detail.NUMBER,0)) LIMIT 100"
                    }
                ]
            },
            {
                "case_id": "43",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"43\", \"db_type\": \"mysql\", \"description\": \"改写前的SQL在子查询条件（col_pk_varchar）中使用了数值字面量进行范围查询（BETWEEN 192 AND 171），而col_pk_varchar列是VARCHAR类型。MySQL在比较不同类型时可能触发类型隐式转换，导致索引失效（本次场景中未失效但引发了多余扫描）。改写后显式使用字符串字面量（BETWEEN '192' AND '171'），确保类型一致，使优化器能准确评估区间有效性。同时，由于数字192大于171，字符集下同样不成立，优化器能立即识别并跳过该子查询扫描。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE dble_jumpstringhash_int_1 (col_int_auto_increment INT NOT NULL AUTO_INCREMENT, col_pk_char CHAR(1) NOT NULL, col_pk_varchar VARCHAR(100) NOT NULL, col_pk_date DATE NOT NULL, col_pk_decimal_not_null DECIMAL(10,0) NOT NULL, col_pk_numeric_not_null DECIMAL(10,0) NOT NULL, col_int_not_null INT NOT NULL, col_int_not_null__1 INT NOT NULL, col_int_8_not_null TINYINT NOT NULL, col_int_8_not_null__1 TINYINT NOT NULL, col_bigint_not_null BIGINT NOT NULL, col_smallint_not_null SMALLINT NOT NULL, col_tinyint_not_null TINYINT NOT NULL, col_float_not_null FLOAT NOT NULL, col_double_not_null DOUBLE NOT NULL, col_decimal_not_null DECIMAL(10,0) NOT NULL, col_numeric_not_null DECIMAL(10,0) NOT NULL, col_bit_not_null BIT(1) NOT NULL, col_bit_not_null__1 BIT(1) NOT NULL, col_char_3_not_null CHAR(3) NOT NULL, col_char_255_not_null CHAR(255) NOT NULL, col_varchar_1_not_null VARCHAR(1) NOT NULL, col_varchar_64_not_null VARCHAR(64) NOT NULL, col_varchar_2048_not_null VARCHAR(2048) NOT NULL, col_binary_8_not_null BINARY(8) NOT NULL, col_varbinary_8_not_null VARBINARY(8) NOT NULL, col_date_not_null DATE NOT NULL, col_time_not_null TIME NOT NULL, col_datetime_not_null DATETIME NOT NULL, col_year_not_null YEAR NOT NULL, col_text_not_null TEXT NOT NULL, col_bool_not_null TINYINT(1) NOT NULL, col_boolean_not_null TINYINT(1) NOT NULL, col_longtext_not_null LONGTEXT NOT NULL, col_mediumtext_not_null MEDIUMTEXT NOT NULL, col_tinyblob_not_null TINYBLOB NOT NULL, col_mediumblob_not_null MEDIUMBLOB NOT NULL, col_longblob_not_null LONGBLOB NOT NULL, col_blob_not_null BLOB NOT NULL, PRIMARY KEY (col_int_auto_increment, col_pk_char, col_pk_varchar, col_pk_date, col_pk_decimal_not_null, col_pk_numeric_not_null)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_dble_jumpstringhash_int_1_col_varchar_64_not_null ON dble_jumpstringhash_int_1(col_varchar_64_not_null);\", \"CREATE TABLE dble_stringhash_datetime_2 (col_pk_varchar VARCHAR(100) NOT NULL, PRIMARY KEY (col_pk_varchar)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_dble_stringhash_datetime_2_col_pk_varchar ON dble_stringhash_datetime_2(col_pk_varchar);\"], \"sql\": \"SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM ( SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM dble_jumpstringhash_int_1 WHERE NOT EXISTS (SELECT 1 FROM dble_stringhash_datetime_2 WHERE col_pk_varchar BETWEEN 192 AND 171) ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39 LIMIT 97 OFFSET 5) AS t WHERE col_varchar_64_not_null LIKE '%p%' ORDER BY col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null DESC LIMIT 215 OFFSET 3;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t102\\t11.11\\tUsing where; Using temporary; Using filesort\\n2\\tDERIVED\\tdble_jumpstringhash_int_1\\t\\tALL\\t\\t\\t\\t\\t416710\\t100.0\\tUsing filesort\\n3\\tSUBQUERY\\tdble_stringhash_datetime_2\\t\\tindex\\tPRIMARY,idx_dble_stringhash_datetime_2_col_pk_varchar\\tPRIMARY\\t402\\t\\t505934\\t11.11\\tUsing where; Using index\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"25.31\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_filesort\\\": false,\\n  \\\"duplicates_removal\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"11.33\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"t\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 102,\\n  \\\"rows_produced_per_join\\\": 11,\\n  \\\"filtered\\\": \\\"11.11\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"12.84\\\",\\n  \\\"eval_cost\\\": \\\"1.13\\\",\\n  \\\"prefix_cost\\\": \\\"13.98\\\",\\n  \\\"data_read_per_join\\\": \\\"111K\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"col_int_auto_increment\\\",\\n  \\\"col_pk_char\\\",\\n  \\\"col_pk_varchar\\\",\\n  \\\"col_pk_date\\\",\\n  \\\"col_pk_decimal_not_null\\\",\\n  \\\"col_pk_numeric_not_null\\\",\\n  \\\"col_int_not_null\\\",\\n  \\\"col_int_not_null__1\\\",\\n  \\\"col_int_8_not_null\\\",\\n  \\\"col_int_8_not_null__1\\\",\\n  \\\"col_bigint_not_null\\\",\\n  \\\"col_smallint_not_null\\\",\\n  \\\"col_tinyint_not_null\\\",\\n  \\\"col_float_not_null\\\",\\n  \\\"col_double_not_null\\\",\\n  \\\"col_decimal_not_null\\\",\\n  \\\"col_numeric_not_null\\\",\\n  \\\"col_bit_not_null\\\",\\n  \\\"col_bit_not_null__1\\\",\\n  \\\"col_char_3_not_null\\\",\\n  \\\"col_char_255_not_null\\\",\\n  \\\"col_varchar_1_not_null\\\",\\n  \\\"col_varchar_64_not_null\\\",\\n  \\\"col_varchar_2048_not_null\\\",\\n  \\\"col_binary_8_not_null\\\",\\n  \\\"col_varbinary_8_not_null\\\",\\n  \\\"col_date_not_null\\\",\\n  \\\"col_time_not_null\\\",\\n  \\\"col_datetime_not_null\\\",\\n  \\\"col_year_not_null\\\",\\n  \\\"col_text_not_null\\\",\\n  \\\"col_bool_not_null\\\",\\n  \\\"col_boolean_not_null\\\",\\n  \\\"col_longtext_not_null\\\",\\n  \\\"col_mediumtext_not_null\\\",\\n  \\\"col_tinyblob_not_null\\\",\\n  \\\"col_mediumblob_not_null\\\",\\n  \\\"col_longblob_not_null\\\",\\n  \\\"col_blob_not_null\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`t`.`col_varchar_64_not_null` like '%p%')\\\",\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"121752.86\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_filesort\\\": true,\\n  \\\"duplicates_removal\\\": {\\n  \\\"using_filesort\\\": false,\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"dble_jumpstringhash_int_1\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 416710,\\n  \\\"rows_produced_per_join\\\": 416710,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"80081.86\\\",\\n  \\\"eval_cost\\\": \\\"41671.00\\\",\\n  \\\"prefix_cost\\\": \\\"121752.86\\\",\\n  \\\"data_read_per_join\\\": \\\"3G\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"col_int_auto_increment\\\",\\n  \\\"col_pk_char\\\",\\n  \\\"col_pk_varchar\\\",\\n  \\\"col_pk_date\\\",\\n  \\\"col_pk_decimal_not_null\\\",\\n  \\\"col_pk_numeric_not_null\\\",\\n  \\\"col_int_not_null\\\",\\n  \\\"col_int_not_null__1\\\",\\n  \\\"col_int_8_not_null\\\",\\n  \\\"col_int_8_not_null__1\\\",\\n  \\\"col_bigint_not_null\\\",\\n  \\\"col_smallint_not_null\\\",\\n  \\\"col_tinyint_not_null\\\",\\n  \\\"col_float_not_null\\\",\\n  \\\"col_double_not_null\\\",\\n  \\\"col_decimal_not_null\\\",\\n  \\\"col_numeric_not_null\\\",\\n  \\\"col_bit_not_null\\\",\\n  \\\"col_bit_not_null__1\\\",\\n  \\\"col_char_3_not_null\\\",\\n  \\\"col_char_255_not_null\\\",\\n  \\\"col_varchar_1_not_null\\\",\\n  \\\"col_varchar_64_not_null\\\",\\n  \\\"col_varchar_2048_not_null\\\",\\n  \\\"col_binary_8_not_null\\\",\\n  \\\"col_varbinary_8_not_null\\\",\\n  \\\"col_date_not_null\\\",\\n  \\\"col_time_not_null\\\",\\n  \\\"col_datetime_not_null\\\",\\n  \\\"col_year_not_null\\\",\\n  \\\"col_text_not_null\\\",\\n  \\\"col_bool_not_null\\\",\\n  \\\"col_boolean_not_null\\\",\\n  \\\"col_longtext_not_null\\\",\\n  \\\"col_mediumtext_not_null\\\",\\n  \\\"col_tinyblob_not_null\\\",\\n  \\\"col_mediumblob_not_null\\\",\\n  \\\"col_longblob_not_null\\\",\\n  \\\"col_blob_not_null\\\"\\n  ]\\n  },\\n  \\\"optimized_away_subqueries\\\": [\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"51146.65\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"dble_stringhash_datetime_2\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_dble_stringhash_datetime_2_col_pk_varchar\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"col_pk_varchar\\\"\\n  ],\\n  \\\"key_length\\\": \\\"402\\\",\\n  \\\"rows_examined_per_scan\\\": 505934,\\n  \\\"rows_produced_per_join\\\": 56209,\\n  \\\"filtered\\\": \\\"11.11\\\",\\n  \\\"using_index\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"45525.72\\\",\\n  \\\"eval_cost\\\": \\\"5620.93\\\",\\n  \\\"prefix_cost\\\": \\\"51146.65\\\",\\n  \\\"data_read_per_join\\\": \\\"21M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"col_pk_varchar\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`dble_jumpstringhash_int`.`dble_stringhash_datetime_2`.`col_pk_varchar` between 192 and 171)\\\"\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE dble_jumpstringhash_int_1 (col_int_auto_increment INT NOT NULL AUTO_INCREMENT, col_pk_char CHAR(1) NOT NULL, col_pk_varchar VARCHAR(100) NOT NULL, col_pk_date DATE NOT NULL, col_pk_decimal_not_null DECIMAL(10,0) NOT NULL, col_pk_numeric_not_null DECIMAL(10,0) NOT NULL, col_int_not_null INT NOT NULL, col_int_not_null__1 INT NOT NULL, col_int_8_not_null TINYINT NOT NULL, col_int_8_not_null__1 TINYINT NOT NULL, col_bigint_not_null BIGINT NOT NULL, col_smallint_not_null SMALLINT NOT NULL, col_tinyint_not_null TINYINT NOT NULL, col_float_not_null FLOAT NOT NULL, col_double_not_null DOUBLE NOT NULL, col_decimal_not_null DECIMAL(10,0) NOT NULL, col_numeric_not_null DECIMAL(10,0) NOT NULL, col_bit_not_null BIT(1) NOT NULL, col_bit_not_null__1 BIT(1) NOT NULL, col_char_3_not_null CHAR(3) NOT NULL, col_char_255_not_null CHAR(255) NOT NULL, col_varchar_1_not_null VARCHAR(1) NOT NULL, col_varchar_64_not_null VARCHAR(64) NOT NULL, col_varchar_2048_not_null VARCHAR(2048) NOT NULL, col_binary_8_not_null BINARY(8) NOT NULL, col_varbinary_8_not_null VARBINARY(8) NOT NULL, col_date_not_null DATE NOT NULL, col_time_not_null TIME NOT NULL, col_datetime_not_null DATETIME NOT NULL, col_year_not_null YEAR NOT NULL, col_text_not_null TEXT NOT NULL, col_bool_not_null TINYINT(1) NOT NULL, col_boolean_not_null TINYINT(1) NOT NULL, col_longtext_not_null LONGTEXT NOT NULL, col_mediumtext_not_null MEDIUMTEXT NOT NULL, col_tinyblob_not_null TINYBLOB NOT NULL, col_mediumblob_not_null MEDIUMBLOB NOT NULL, col_longblob_not_null LONGBLOB NOT NULL, col_blob_not_null BLOB NOT NULL, PRIMARY KEY (col_int_auto_increment, col_pk_char, col_pk_varchar, col_pk_date, col_pk_decimal_not_null, col_pk_numeric_not_null)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_dble_jumpstringhash_int_1_col_varchar_64_not_null ON dble_jumpstringhash_int_1(col_varchar_64_not_null);\nCREATE TABLE dble_stringhash_datetime_2 (col_pk_varchar VARCHAR(100) NOT NULL, PRIMARY KEY (col_pk_varchar)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_dble_stringhash_datetime_2_col_pk_varchar ON dble_stringhash_datetime_2(col_pk_varchar);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t102\t11.11\tUsing where; Using temporary; Using filesort\n2\tDERIVED\tdble_jumpstringhash_int_1\t\tALL\t\t\t\t\t416710\t100.0\tUsing filesort\n3\tSUBQUERY\tdble_stringhash_datetime_2\t\tindex\tPRIMARY,idx_dble_stringhash_datetime_2_col_pk_varchar\tPRIMARY\t402\t\t505934\t11.11\tUsing where; Using index\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"25.31\"\n  },\n  \"ordering_operation\": {\n  \"using_filesort\": false,\n  \"duplicates_removal\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": true,\n  \"cost_info\": {\n  \"sort_cost\": \"11.33\"\n  },\n  \"table\": {\n  \"table_name\": \"t\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 102,\n  \"rows_produced_per_join\": 11,\n  \"filtered\": \"11.11\",\n  \"cost_info\": {\n  \"read_cost\": \"12.84\",\n  \"eval_cost\": \"1.13\",\n  \"prefix_cost\": \"13.98\",\n  \"data_read_per_join\": \"111K\"\n  },\n  \"used_columns\": [\n  \"col_int_auto_increment\",\n  \"col_pk_char\",\n  \"col_pk_varchar\",\n  \"col_pk_date\",\n  \"col_pk_decimal_not_null\",\n  \"col_pk_numeric_not_null\",\n  \"col_int_not_null\",\n  \"col_int_not_null__1\",\n  \"col_int_8_not_null\",\n  \"col_int_8_not_null__1\",\n  \"col_bigint_not_null\",\n  \"col_smallint_not_null\",\n  \"col_tinyint_not_null\",\n  \"col_float_not_null\",\n  \"col_double_not_null\",\n  \"col_decimal_not_null\",\n  \"col_numeric_not_null\",\n  \"col_bit_not_null\",\n  \"col_bit_not_null__1\",\n  \"col_char_3_not_null\",\n  \"col_char_255_not_null\",\n  \"col_varchar_1_not_null\",\n  \"col_varchar_64_not_null\",\n  \"col_varchar_2048_not_null\",\n  \"col_binary_8_not_null\",\n  \"col_varbinary_8_not_null\",\n  \"col_date_not_null\",\n  \"col_time_not_null\",\n  \"col_datetime_not_null\",\n  \"col_year_not_null\",\n  \"col_text_not_null\",\n  \"col_bool_not_null\",\n  \"col_boolean_not_null\",\n  \"col_longtext_not_null\",\n  \"col_mediumtext_not_null\",\n  \"col_tinyblob_not_null\",\n  \"col_mediumblob_not_null\",\n  \"col_longblob_not_null\",\n  \"col_blob_not_null\"\n  ],\n  \"attached_condition\": \"(`t`.`col_varchar_64_not_null` like '%p%')\",\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"121752.86\"\n  },\n  \"ordering_operation\": {\n  \"using_filesort\": true,\n  \"duplicates_removal\": {\n  \"using_filesort\": false,\n  \"table\": {\n  \"table_name\": \"dble_jumpstringhash_int_1\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 416710,\n  \"rows_produced_per_join\": 416710,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"80081.86\",\n  \"eval_cost\": \"41671.00\",\n  \"prefix_cost\": \"121752.86\",\n  \"data_read_per_join\": \"3G\"\n  },\n  \"used_columns\": [\n  \"col_int_auto_increment\",\n  \"col_pk_char\",\n  \"col_pk_varchar\",\n  \"col_pk_date\",\n  \"col_pk_decimal_not_null\",\n  \"col_pk_numeric_not_null\",\n  \"col_int_not_null\",\n  \"col_int_not_null__1\",\n  \"col_int_8_not_null\",\n  \"col_int_8_not_null__1\",\n  \"col_bigint_not_null\",\n  \"col_smallint_not_null\",\n  \"col_tinyint_not_null\",\n  \"col_float_not_null\",\n  \"col_double_not_null\",\n  \"col_decimal_not_null\",\n  \"col_numeric_not_null\",\n  \"col_bit_not_null\",\n  \"col_bit_not_null__1\",\n  \"col_char_3_not_null\",\n  \"col_char_255_not_null\",\n  \"col_varchar_1_not_null\",\n  \"col_varchar_64_not_null\",\n  \"col_varchar_2048_not_null\",\n  \"col_binary_8_not_null\",\n  \"col_varbinary_8_not_null\",\n  \"col_date_not_null\",\n  \"col_time_not_null\",\n  \"col_datetime_not_null\",\n  \"col_year_not_null\",\n  \"col_text_not_null\",\n  \"col_bool_not_null\",\n  \"col_boolean_not_null\",\n  \"col_longtext_not_null\",\n  \"col_mediumtext_not_null\",\n  \"col_tinyblob_not_null\",\n  \"col_mediumblob_not_null\",\n  \"col_longblob_not_null\",\n  \"col_blob_not_null\"\n  ]\n  },\n  \"optimized_away_subqueries\": [\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"51146.65\"\n  },\n  \"table\": {\n  \"table_name\": \"dble_stringhash_datetime_2\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_dble_stringhash_datetime_2_col_pk_varchar\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"col_pk_varchar\"\n  ],\n  \"key_length\": \"402\",\n  \"rows_examined_per_scan\": 505934,\n  \"rows_produced_per_join\": 56209,\n  \"filtered\": \"11.11\",\n  \"using_index\": true,\n  \"cost_info\": {\n  \"read_cost\": \"45525.72\",\n  \"eval_cost\": \"5620.93\",\n  \"prefix_cost\": \"51146.65\",\n  \"data_read_per_join\": \"21M\"\n  },\n  \"used_columns\": [\n  \"col_pk_varchar\"\n  ],\n  \"attached_condition\": \"(`dble_jumpstringhash_int`.`dble_stringhash_datetime_2`.`col_pk_varchar` between 192 and 171)\"\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n}\n\n## Original SQL:\nSELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM ( SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM dble_jumpstringhash_int_1 WHERE NOT EXISTS (SELECT 1 FROM dble_stringhash_datetime_2 WHERE col_pk_varchar BETWEEN 192 AND 171) ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39 LIMIT 97 OFFSET 5) AS t WHERE col_varchar_64_not_null LIKE '%p%' ORDER BY col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null DESC LIMIT 215 OFFSET 3;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM (SELECT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM dble_jumpstringhash_int_1 ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39 LIMIT 97 OFFSET 5) AS t WHERE col_varchar_64_not_null LIKE '%p%' ORDER BY col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null DESC LIMIT 215 OFFSET 3;"
                    }
                ]
            },
            {
                "case_id": "44",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"44\", \"db_type\": \"mysql\", \"description\": \"该改写方法消除了UNION ALL结构，避免了重复扫描表和创建临时表的开销。核心策略是将两个分支的冲突条件（一个包含特定uuid列表且无视private，另一个排除该列表且要求private=0）用OR组合起来，集成到同一个查询中。同时保持非重复性过滤条件（如全文检索和标签过滤）在最外层执行一次，避免了冗余操作。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE document_template (id VARCHAR(36) PRIMARY KEY, title VARCHAR(255) NOT NULL, owner_id VARCHAR(36) NOT NULL, private TINYINT(1) NOT NULL DEFAULT 0, deleted_at TIMESTAMP NULL DEFAULT NULL, FULLTEXT INDEX idx_title (title)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_owner_id ON document_template(owner_id);\", \"CREATE INDEX idx_deleted_at ON document_template(deleted_at);\", \"CREATE INDEX idx_private ON document_template(private);\", \"CREATE TABLE `user` (id VARCHAR(36) PRIMARY KEY, uuid VARCHAR(36) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_uuid ON `user`(uuid);\", \"CREATE TABLE tag_thing (document_template_id VARCHAR(36) NOT NULL, tag_id VARCHAR(36) NOT NULL, deleted_at TIMESTAMP NULL DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_document_template_id ON tag_thing(document_template_id);\", \"CREATE INDEX idx_tag_id ON tag_thing(tag_id);\", \"CREATE INDEX idx_deleted_at ON tag_thing(deleted_at);\"], \"sql\": \"(SELECT d.id, d.title\\r\\n  FROM document_template d\\r\\n  JOIN `user` u ON u.id = d.owner_id\\r\\n  WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\\r\\n  SELECT 1 FROM tag_thing tt0\\r\\n  WHERE tt0.document_template_id = d.id\\r\\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\\r\\n  AND tt0.deleted_at IS NULL\\r\\n  )) UNION ALL (SELECT d.id, d.title\\r\\n  FROM document_template d\\r\\n  JOIN `user` u ON u.id = d.owner_id\\r\\n  WHERE d.private = 0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\\r\\n  SELECT 1 FROM tag_thing tt0\\r\\n  WHERE tt0.document_template_id = d.id\\r\\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\\r\\n  AND tt0.deleted_at IS NULL\\r\\n  )) ORDER BY title ASC LIMIT 10 OFFSET 0;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\td\\t\\tfulltext\\tPRIMARY,idx_owner_id,idx_deleted_at,idx_title\\tidx_title\\t0\\tconst\\t1\\t18.14\\tUsing where; Ft_hints: rank > 0\\n1\\tPRIMARY\\tu\\t\\teq_ref\\tPRIMARY,idx_uuid\\tPRIMARY\\t146\\ttest_db.d.owner_id\\t1\\t5.0\\tUsing where\\n1\\tPRIMARY\\ttt0\\t\\tref\\tidx_document_template_id,idx_tag_id,idx_deleted_at\\tidx_document_template_id\\t146\\ttest_db.d.id\\t4\\t25.0\\tUsing where; FirstMatch(u)\\n3\\tUNION\\td\\t\\tfulltext\\tPRIMARY,idx_owner_id,idx_deleted_at,idx_private,idx_title\\tidx_title\\t0\\tconst\\t1\\t9.07\\tUsing where; Ft_hints: rank > 0\\n3\\tUNION\\tu\\t\\teq_ref\\tPRIMARY,idx_uuid\\tPRIMARY\\t146\\ttest_db.d.owner_id\\t1\\t50.0\\tUsing where\\n3\\tUNION\\ttt0\\t\\tref\\tidx_document_template_id,idx_tag_id,idx_deleted_at\\tidx_document_template_id\\t146\\ttest_db.d.id\\t4\\t25.0\\tUsing where; FirstMatch(u)\\n5\\tUNION RESULT\\t<union1,3>\\t\\tALL\\t\\t\\t\\t\\t\\t\\tUsing temporary; Using filesort\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"union_result\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"select_id\\\": 5,\\n  \\\"table_name\\\": \\\"<union1,3>\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"using_filesort\\\": true,\\n  \\\"query_specifications\\\": [\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"1.31\\\"\\n  },\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"d\\\",\\n  \\\"access_type\\\": \\\"fulltext\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_owner_id\\\",\\n  \\\"idx_deleted_at\\\",\\n  \\\"idx_title\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_title\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"title\\\"\\n  ],\\n  \\\"key_length\\\": \\\"0\\\",\\n  \\\"ref\\\": [\\n  \\\"const\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"18.14\\\",\\n  \\\"ft_hints\\\": \\\"rank > 0\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1.00\\\",\\n  \\\"eval_cost\\\": \\\"0.02\\\",\\n  \\\"prefix_cost\\\": \\\"1.10\\\",\\n  \\\"data_read_per_join\\\": \\\"239\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"title\\\",\\n  \\\"owner_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_uuid\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.owner_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"5.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.18\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.29\\\",\\n  \\\"data_read_per_join\\\": \\\"2\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"uuid\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`uuid` in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"tt0\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_document_template_id\\\",\\n  \\\"idx_tag_id\\\",\\n  \\\"idx_deleted_at\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_document_template_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"document_template_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 4,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"25.00\\\",\\n  \\\"first_match\\\": \\\"u\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.02\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.31\\\",\\n  \\\"data_read_per_join\\\": \\\"2\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"document_template_id\\\",\\n  \\\"tag_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\\\"\\n  }\\n  }\\n  ]\\n  }\\n  },\\n  {\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"1.29\\\"\\n  },\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"d\\\",\\n  \\\"access_type\\\": \\\"fulltext\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_owner_id\\\",\\n  \\\"idx_deleted_at\\\",\\n  \\\"idx_private\\\",\\n  \\\"idx_title\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_title\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"title\\\"\\n  ],\\n  \\\"key_length\\\": \\\"0\\\",\\n  \\\"ref\\\": [\\n  \\\"const\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"9.07\\\",\\n  \\\"ft_hints\\\": \\\"rank > 0\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1.00\\\",\\n  \\\"eval_cost\\\": \\\"0.01\\\",\\n  \\\"prefix_cost\\\": \\\"1.10\\\",\\n  \\\"data_read_per_join\\\": \\\"119\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"title\\\",\\n  \\\"owner_id\\\",\\n  \\\"private\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`d`.`private` = 0) and (`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_uuid\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.owner_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"50.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.09\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.19\\\",\\n  \\\"data_read_per_join\\\": \\\"13\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"uuid\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`uuid` not in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"tt0\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_document_template_id\\\",\\n  \\\"idx_tag_id\\\",\\n  \\\"idx_deleted_at\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_document_template_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"document_template_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"146\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.d.id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 4,\\n  \\\"rows_produced_per_join\\\": 0,\\n  \\\"filtered\\\": \\\"25.00\\\",\\n  \\\"first_match\\\": \\\"u\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"0.08\\\",\\n  \\\"eval_cost\\\": \\\"0.00\\\",\\n  \\\"prefix_cost\\\": \\\"1.30\\\",\\n  \\\"data_read_per_join\\\": \\\"13\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"document_template_id\\\",\\n  \\\"tag_id\\\",\\n  \\\"deleted_at\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\\\"\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  ]\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE document_template (id VARCHAR(36) PRIMARY KEY, title VARCHAR(255) NOT NULL, owner_id VARCHAR(36) NOT NULL, private TINYINT(1) NOT NULL DEFAULT 0, deleted_at TIMESTAMP NULL DEFAULT NULL, FULLTEXT INDEX idx_title (title)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_owner_id ON document_template(owner_id);\nCREATE INDEX idx_deleted_at ON document_template(deleted_at);\nCREATE INDEX idx_private ON document_template(private);\nCREATE TABLE `user` (id VARCHAR(36) PRIMARY KEY, uuid VARCHAR(36) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_uuid ON `user`(uuid);\nCREATE TABLE tag_thing (document_template_id VARCHAR(36) NOT NULL, tag_id VARCHAR(36) NOT NULL, deleted_at TIMESTAMP NULL DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_document_template_id ON tag_thing(document_template_id);\nCREATE INDEX idx_tag_id ON tag_thing(tag_id);\nCREATE INDEX idx_deleted_at ON tag_thing(deleted_at);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\td\t\tfulltext\tPRIMARY,idx_owner_id,idx_deleted_at,idx_title\tidx_title\t0\tconst\t1\t18.14\tUsing where; Ft_hints: rank > 0\n1\tPRIMARY\tu\t\teq_ref\tPRIMARY,idx_uuid\tPRIMARY\t146\ttest_db.d.owner_id\t1\t5.0\tUsing where\n1\tPRIMARY\ttt0\t\tref\tidx_document_template_id,idx_tag_id,idx_deleted_at\tidx_document_template_id\t146\ttest_db.d.id\t4\t25.0\tUsing where; FirstMatch(u)\n3\tUNION\td\t\tfulltext\tPRIMARY,idx_owner_id,idx_deleted_at,idx_private,idx_title\tidx_title\t0\tconst\t1\t9.07\tUsing where; Ft_hints: rank > 0\n3\tUNION\tu\t\teq_ref\tPRIMARY,idx_uuid\tPRIMARY\t146\ttest_db.d.owner_id\t1\t50.0\tUsing where\n3\tUNION\ttt0\t\tref\tidx_document_template_id,idx_tag_id,idx_deleted_at\tidx_document_template_id\t146\ttest_db.d.id\t4\t25.0\tUsing where; FirstMatch(u)\n5\tUNION RESULT\t<union1,3>\t\tALL\t\t\t\t\t\t\tUsing temporary; Using filesort\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"union_result\": {\n  \"using_temporary_table\": true,\n  \"select_id\": 5,\n  \"table_name\": \"<union1,3>\",\n  \"access_type\": \"ALL\",\n  \"using_filesort\": true,\n  \"query_specifications\": [\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"1.31\"\n  },\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"d\",\n  \"access_type\": \"fulltext\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_owner_id\",\n  \"idx_deleted_at\",\n  \"idx_title\"\n  ],\n  \"key\": \"idx_title\",\n  \"used_key_parts\": [\n  \"title\"\n  ],\n  \"key_length\": \"0\",\n  \"ref\": [\n  \"const\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"18.14\",\n  \"ft_hints\": \"rank > 0\",\n  \"cost_info\": {\n  \"read_cost\": \"1.00\",\n  \"eval_cost\": \"0.02\",\n  \"prefix_cost\": \"1.10\",\n  \"data_read_per_join\": \"239\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"title\",\n  \"owner_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_uuid\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.owner_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"5.00\",\n  \"cost_info\": {\n  \"read_cost\": \"0.18\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.29\",\n  \"data_read_per_join\": \"2\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"uuid\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`uuid` in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"tt0\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_document_template_id\",\n  \"idx_tag_id\",\n  \"idx_deleted_at\"\n  ],\n  \"key\": \"idx_document_template_id\",\n  \"used_key_parts\": [\n  \"document_template_id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.id\"\n  ],\n  \"rows_examined_per_scan\": 4,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"25.00\",\n  \"first_match\": \"u\",\n  \"cost_info\": {\n  \"read_cost\": \"0.02\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.31\",\n  \"data_read_per_join\": \"2\"\n  },\n  \"used_columns\": [\n  \"document_template_id\",\n  \"tag_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\"\n  }\n  }\n  ]\n  }\n  },\n  {\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"1.29\"\n  },\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"d\",\n  \"access_type\": \"fulltext\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_owner_id\",\n  \"idx_deleted_at\",\n  \"idx_private\",\n  \"idx_title\"\n  ],\n  \"key\": \"idx_title\",\n  \"used_key_parts\": [\n  \"title\"\n  ],\n  \"key_length\": \"0\",\n  \"ref\": [\n  \"const\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"9.07\",\n  \"ft_hints\": \"rank > 0\",\n  \"cost_info\": {\n  \"read_cost\": \"1.00\",\n  \"eval_cost\": \"0.01\",\n  \"prefix_cost\": \"1.10\",\n  \"data_read_per_join\": \"119\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"title\",\n  \"owner_id\",\n  \"private\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`d`.`private` = 0) and (`test_db`.`d`.`deleted_at` is null) and ((match `test_db`.`d`.`title` against ('Epaul' in boolean mode)) > 0) and (`test_db`.`d`.`title` like '%Epaul%'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_uuid\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.owner_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"50.00\",\n  \"cost_info\": {\n  \"read_cost\": \"0.09\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.19\",\n  \"data_read_per_join\": \"13\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"uuid\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`uuid` not in ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a'))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"tt0\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_document_template_id\",\n  \"idx_tag_id\",\n  \"idx_deleted_at\"\n  ],\n  \"key\": \"idx_document_template_id\",\n  \"used_key_parts\": [\n  \"document_template_id\"\n  ],\n  \"key_length\": \"146\",\n  \"ref\": [\n  \"test_db.d.id\"\n  ],\n  \"rows_examined_per_scan\": 4,\n  \"rows_produced_per_join\": 0,\n  \"filtered\": \"25.00\",\n  \"first_match\": \"u\",\n  \"cost_info\": {\n  \"read_cost\": \"0.08\",\n  \"eval_cost\": \"0.00\",\n  \"prefix_cost\": \"1.30\",\n  \"data_read_per_join\": \"13\"\n  },\n  \"used_columns\": [\n  \"document_template_id\",\n  \"tag_id\",\n  \"deleted_at\"\n  ],\n  \"attached_condition\": \"((`test_db`.`tt0`.`tag_id` = '9963ebcd-c834-4ff1-bdf5-229ef1b59204') and (`test_db`.`tt0`.`deleted_at` is null))\"\n  }\n  }\n  ]\n  }\n  }\n  ]\n  }\n  }\n}\n\n## Original SQL:\n(SELECT d.id, d.title\r\n  FROM document_template d\r\n  JOIN `user` u ON u.id = d.owner_id\r\n  WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\r\n  SELECT 1 FROM tag_thing tt0\r\n  WHERE tt0.document_template_id = d.id\r\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\r\n  AND tt0.deleted_at IS NULL\r\n  )) UNION ALL (SELECT d.id, d.title\r\n  FROM document_template d\r\n  JOIN `user` u ON u.id = d.owner_id\r\n  WHERE d.private = 0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 AND d.title LIKE '%Epaul%' AND EXISTS (\r\n  SELECT 1 FROM tag_thing tt0\r\n  WHERE tt0.document_template_id = d.id\r\n  AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'\r\n  AND tt0.deleted_at IS NULL\r\n  )) ORDER BY title ASC LIMIT 10 OFFSET 0;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "(SELECT d.id, d.title FROM document_template d INNER JOIN `user` u ON u.id = d.owner_id INNER JOIN tag_thing tt ON tt.document_template_id = d.id AND tt.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204' AND tt.deleted_at IS NULL WHERE u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0) UNION ALL (SELECT d.id, d.title FROM document_template d INNER JOIN `user` u ON u.id = d.owner_id INNER JOIN tag_thing tt ON tt.document_template_id = d.id AND tt.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204' AND tt.deleted_at IS NULL WHERE d.private=0 AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765','f2abfee7-c8a1-4540-9a0e-75921263650a') AND d.deleted_at IS NULL AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0) ORDER BY title ASC LIMIT 10 OFFSET 0;"
                    }
                ]
            },
            {
                "case_id": "45",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"45\", \"db_type\": \"postgresql\", \"description\": \"改写后的SQL直接将原始SQL中的WITH子句直接在句同为一层的查询中，移除了不必要的子查询结构（CTE），这是优化SQL编写方式的常用方法。在PostgreSQL处理用例，对于非递归的CTE，查询优化器通常能够直接优化内部逻辑，故改写可能带来可见提升效果不明显。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE Student (s_id SERIAL PRIMARY KEY, s_name VARCHAR(100) NOT NULL, s_sex CHAR(1) NOT NULL);\", \"CREATE TABLE Score (id SERIAL PRIMARY KEY, s_id INTEGER NOT NULL, c_id INTEGER NOT NULL, s_score NUMERIC(5,2) NOT NULL, FOREIGN KEY (s_id) REFERENCES Student (s_id));\", \"CREATE INDEX idx_score_s_id ON Score(s_id);\", \"CREATE INDEX idx_score_s_score ON Score(s_score);\", \"CREATE INDEX idx_score_c_id ON Score(c_id);\"], \"sql\": \"WITH StudentStats AS (\\r\\n  SELECT \\r\\n  s.s_id,\\r\\n  s.s_name,\\r\\n  s.s_sex,\\r\\n  COUNT(DISTINCT sc.c_id) AS course_count,\\r\\n  AVG(sc.s_score) AS avg_score,\\r\\n  SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) AS excellent_course_count\\r\\n  FROM Student s\\r\\n  JOIN Score sc ON s.s_id = sc.s_id\\r\\n  GROUP BY s.s_id, s.s_name, s.s_sex\\r\\n  HAVING AVG(sc.s_score) > 80 AND SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) >= 2\\r\\n)\\r\\nSELECT \\r\\n  ss.s_id,\\r\\n  ss.s_name,\\r\\n  ss.s_sex,\\r\\n  ss.course_count,\\r\\n  ss.avg_score,\\r\\n  ss.excellent_course_count,\\r\\n  RANK() OVER (PARTITION BY ss.s_sex ORDER BY ss.avg_score DESC) AS gender_rank\\r\\nFROM StudentStats ss\\r\\nORDER BY ss.avg_score DESC;\", \"explain\": \"QUERY PLAN\\nSort  (cost=87015.43..87154.32 rows=55556 width=74)\\n  Sort Key: ss.avg_score DESC\\n  ->  WindowAgg  (cost=79055.04..80166.16 rows=55556 width=74)\\n  ->  Sort  (cost=79055.04..79193.93 rows=55556 width=66)\\n  Sort Key: ss.s_sex, ss.avg_score DESC\\n  ->  Subquery Scan on ss  (cost=3.35..72394.76 rows=55556 width=66)\\n  ->  GroupAggregate  (cost=3.35..72394.76 rows=55556 width=66)\\n  Group Key: s.s_id\\n  Filter: ((avg(sc.s_score) > '80'::numeric) AND (sum(CASE WHEN (sc.s_score > '90'::numeric) THEN 1 ELSE 0 END) >= 2))\\n  ->  Incremental Sort  (cost=3.35..57394.76 rows=500000 width=27)\\n  Sort Key: s.s_id, sc.c_id\\n  Presorted Key: s.s_id\\n  ->  Merge Join  (cost=3.27..34894.76 rows=500000 width=27)\\n  Merge Cond: (s.s_id = sc.s_id)\\n  ->  Index Scan using student_pkey on student s  (cost=0.42..16184.42 rows=500000 width=18)\\n  ->  Index Scan using idx_score_s_id on score sc  (cost=0.42..25147.43 rows=500000 width=13)\\n\\nJSON执行计划:\\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 87015.43, 'Total Cost': 87154.32, 'Plan Rows': 55556, 'Plan Width': 74, 'Sort Key': ['ss.avg_score DESC'], 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 79055.04, 'Total Cost': 80166.16, 'Plan Rows': 55556, 'Plan Width': 74, 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 79055.04, 'Total Cost': 79193.93, 'Plan Rows': 55556, 'Plan Width': 66, 'Sort Key': ['ss.s_sex', 'ss.avg_score DESC'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'ss', 'Startup Cost': 3.35, 'Total Cost': 72394.76, 'Plan Rows': 55556, 'Plan Width': 66, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 3.35, 'Total Cost': 72394.76, 'Plan Rows': 55556, 'Plan Width': 66, 'Group Key': ['s.s_id'], 'Filter': \\\"((avg(sc.s_score) > '80'::numeric) AND (sum(CASE WHEN (sc.s_score > '90'::numeric) THEN 1 ELSE 0 END) >= 2))\\\", 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 3.35, 'Total Cost': 57394.76, 'Plan Rows': 500000, 'Plan Width': 27, 'Sort Key': ['s.s_id', 'sc.c_id'], 'Presorted Key': ['s.s_id'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 3.27, 'Total Cost': 34894.76, 'Plan Rows': 500000, 'Plan Width': 27, 'Inner Unique': False, 'Merge Cond': '(s.s_id = sc.s_id)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'student_pkey', 'Relation Name': 'student', 'Alias': 's', 'Startup Cost': 0.42, 'Total Cost': 16184.42, 'Plan Rows': 500000, 'Plan Width': 18}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_score_s_id', 'Relation Name': 'score', 'Alias': 'sc', 'Startup Cost': 0.42, 'Total Cost': 25147.43, 'Plan Rows': 500000, 'Plan Width': 13}]}]}]}]}]}]}]}}]\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE Student (s_id SERIAL PRIMARY KEY, s_name VARCHAR(100) NOT NULL, s_sex CHAR(1) NOT NULL);\nCREATE TABLE Score (id SERIAL PRIMARY KEY, s_id INTEGER NOT NULL, c_id INTEGER NOT NULL, s_score NUMERIC(5,2) NOT NULL, FOREIGN KEY (s_id) REFERENCES Student (s_id));\nCREATE INDEX idx_score_s_id ON Score(s_id);\nCREATE INDEX idx_score_s_score ON Score(s_score);\nCREATE INDEX idx_score_c_id ON Score(c_id);\n\n## Explain Output in JSON:\nQUERY PLAN\nSort  (cost=87015.43..87154.32 rows=55556 width=74)\n  Sort Key: ss.avg_score DESC\n  ->  WindowAgg  (cost=79055.04..80166.16 rows=55556 width=74)\n  ->  Sort  (cost=79055.04..79193.93 rows=55556 width=66)\n  Sort Key: ss.s_sex, ss.avg_score DESC\n  ->  Subquery Scan on ss  (cost=3.35..72394.76 rows=55556 width=66)\n  ->  GroupAggregate  (cost=3.35..72394.76 rows=55556 width=66)\n  Group Key: s.s_id\n  Filter: ((avg(sc.s_score) > '80'::numeric) AND (sum(CASE WHEN (sc.s_score > '90'::numeric) THEN 1 ELSE 0 END) >= 2))\n  ->  Incremental Sort  (cost=3.35..57394.76 rows=500000 width=27)\n  Sort Key: s.s_id, sc.c_id\n  Presorted Key: s.s_id\n  ->  Merge Join  (cost=3.27..34894.76 rows=500000 width=27)\n  Merge Cond: (s.s_id = sc.s_id)\n  ->  Index Scan using student_pkey on student s  (cost=0.42..16184.42 rows=500000 width=18)\n  ->  Index Scan using idx_score_s_id on score sc  (cost=0.42..25147.43 rows=500000 width=13)\n\nJSON执行计划:\n[{'Plan': {'Node Type': 'Sort', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 87015.43, 'Total Cost': 87154.32, 'Plan Rows': 55556, 'Plan Width': 74, 'Sort Key': ['ss.avg_score DESC'], 'Plans': [{'Node Type': 'WindowAgg', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 79055.04, 'Total Cost': 80166.16, 'Plan Rows': 55556, 'Plan Width': 74, 'Plans': [{'Node Type': 'Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 79055.04, 'Total Cost': 79193.93, 'Plan Rows': 55556, 'Plan Width': 66, 'Sort Key': ['ss.s_sex', 'ss.avg_score DESC'], 'Plans': [{'Node Type': 'Subquery Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Alias': 'ss', 'Startup Cost': 3.35, 'Total Cost': 72394.76, 'Plan Rows': 55556, 'Plan Width': 66, 'Plans': [{'Node Type': 'Aggregate', 'Strategy': 'Sorted', 'Partial Mode': 'Simple', 'Parent Relationship': 'Subquery', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 3.35, 'Total Cost': 72394.76, 'Plan Rows': 55556, 'Plan Width': 66, 'Group Key': ['s.s_id'], 'Filter': \"((avg(sc.s_score) > '80'::numeric) AND (sum(CASE WHEN (sc.s_score > '90'::numeric) THEN 1 ELSE 0 END) >= 2))\", 'Plans': [{'Node Type': 'Incremental Sort', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Startup Cost': 3.35, 'Total Cost': 57394.76, 'Plan Rows': 500000, 'Plan Width': 27, 'Sort Key': ['s.s_id', 'sc.c_id'], 'Presorted Key': ['s.s_id'], 'Plans': [{'Node Type': 'Merge Join', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Startup Cost': 3.27, 'Total Cost': 34894.76, 'Plan Rows': 500000, 'Plan Width': 27, 'Inner Unique': False, 'Merge Cond': '(s.s_id = sc.s_id)', 'Plans': [{'Node Type': 'Index Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'student_pkey', 'Relation Name': 'student', 'Alias': 's', 'Startup Cost': 0.42, 'Total Cost': 16184.42, 'Plan Rows': 500000, 'Plan Width': 18}, {'Node Type': 'Index Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Scan Direction': 'Forward', 'Index Name': 'idx_score_s_id', 'Relation Name': 'score', 'Alias': 'sc', 'Startup Cost': 0.42, 'Total Cost': 25147.43, 'Plan Rows': 500000, 'Plan Width': 13}]}]}]}]}]}]}]}}]\n\n## Original SQL:\nWITH StudentStats AS (\r\n  SELECT \r\n  s.s_id,\r\n  s.s_name,\r\n  s.s_sex,\r\n  COUNT(DISTINCT sc.c_id) AS course_count,\r\n  AVG(sc.s_score) AS avg_score,\r\n  SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) AS excellent_course_count\r\n  FROM Student s\r\n  JOIN Score sc ON s.s_id = sc.s_id\r\n  GROUP BY s.s_id, s.s_name, s.s_sex\r\n  HAVING AVG(sc.s_score) > 80 AND SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) >= 2\r\n)\r\nSELECT \r\n  ss.s_id,\r\n  ss.s_name,\r\n  ss.s_sex,\r\n  ss.course_count,\r\n  ss.avg_score,\r\n  ss.excellent_course_count,\r\n  RANK() OVER (PARTITION BY ss.s_sex ORDER BY ss.avg_score DESC) AS gender_rank\r\nFROM StudentStats ss\r\nORDER BY ss.avg_score DESC;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT ss.s_id, ss.s_name, ss.s_sex, ss.course_count, ss.avg_score, ss.excellent_course_count, RANK() OVER (PARTITION BY ss.s_sex ORDER BY ss.avg_score DESC) AS gender_rank FROM (SELECT s.s_id, s.s_name, s.s_sex, COUNT(DISTINCT sc.c_id) AS course_count, AVG(sc.s_score) AS avg_score, COUNT(*) FILTER (WHERE sc.s_score > 90) AS excellent_course_count FROM Student s JOIN Score sc ON s.s_id = sc.s_id GROUP BY s.s_id, s.s_name, s.s_sex HAVING AVG(sc.s_score) > 80 AND COUNT(*) FILTER (WHERE sc.s_score > 90) >= 2) ss ORDER BY ss.avg_score DESC;"
                    }
                ]
            },
            {
                "case_id": "46",
                "case_weight": 2,
                "case_content": "{\"case_id\": \"46\", \"db_type\": \"mysql\", \"description\": \"此改写技术通过将外层过滤条件下推到子查询内部，减少子查询需要处理的数据规模，尤其对于需要聚合（group by）和窗口计算（row_number）的操作，避免对无效数据进行计算，从而提升整体性能。\", \"difficulty_level\": \"2\", \"create_table_statements\": [\"CREATE TABLE users (user_id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) NOT NULL, status VARCHAR(50) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_users_status ON users(status);\", \"CREATE TABLE orders (order_id INT PRIMARY KEY AUTO_INCREMENT, user_id INT NOT NULL, order_date DATE NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_orders_user_id ON orders(user_id);\", \"CREATE INDEX idx_orders_order_date ON orders(order_date);\", \"CREATE INDEX idx_orders_user_id_order_date ON orders(user_id, order_date);\", \"CREATE TABLE order_items (order_item_id INT PRIMARY KEY AUTO_INCREMENT, order_id INT NOT NULL, product_id INT NOT NULL, quantity DECIMAL(10,2) NOT NULL, unit_price DECIMAL(10,2) NOT NULL, discount DECIMAL(5,2) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_order_items_order_id ON order_items(order_id);\", \"CREATE INDEX idx_order_items_product_id ON order_items(product_id);\", \"CREATE TABLE products (product_id INT PRIMARY KEY AUTO_INCREMENT, product_name VARCHAR(255) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\"], \"sql\": \"select /*QB_1*/ u.user_id,\\r\\n  u.username, COUNT(distinct o.order_id) as total_orders,\\r\\n  SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent,\\r\\n  AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value,\\r\\n  MAX(o.order_date) as last_order_date,\\r\\n  SQ_1758176107425.GROUP_CONCAT_ as top_products\\r\\nfrom users as u\\r\\ninner join orders as o\\r\\non u.user_id = o.user_id \\r\\nleft outer join order_items as oi\\r\\non o.order_id = oi.order_id \\r\\nleft outer join (\\r\\n  select /*SQ_1758176107425*/ oi2.user_id,\\r\\n  GROUP_CONCAT(distinct oi2.product_name order by oi2.product_name separator ', ') as GROUP_CONCAT_\\r\\n  from (\\r\\n  select /*QB_2*/ o3.user_id,\\r\\n  p.product_name,\\r\\n  row_number() over (partition by o3.user_id order by sum(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num\\r\\n  from order_items as oi2\\r\\n  inner join products as p\\r\\n  on oi2.product_id = p.product_id\\r\\n  inner join orders as o3\\r\\n  on o3.order_id = oi2.order_id\\r\\n  group by o3.user_id,\\r\\n  p.product_name\\r\\n  ) as oi2\\r\\n  where oi2.rank_num <= 3 \\r\\n  group by oi2.user_id \\r\\n  ) as SQ_1758176107425\\r\\non SQ_1758176107425.user_id = u.user_id\\r\\nwhere u.status = 'active'\\r\\n  and o.order_date >= DATE_SUB(CURRENT_DATE(),\\r\\n  interval '3' YEAR)\\r\\ngroup by u.user_id, u.username\\r\\nhaving COUNT(distinct o.order_id) > 0\\r\\norder by total_spent desc;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\to\\t\\tindex\\tidx_orders_user_id,idx_orders_order_date,idx_orders_user_id_order_date\\tidx_orders_user_id_order_date\\t7\\t\\t499550\\t50.0\\tUsing where; Using index; Using temporary; Using filesort\\n1\\tPRIMARY\\tu\\t\\teq_ref\\tPRIMARY,idx_users_status\\tPRIMARY\\t4\\ttest_db.o.user_id\\t1\\t50.0\\tUsing where\\n1\\tPRIMARY\\toi\\t\\tref\\tidx_order_items_order_id\\tidx_order_items_order_id\\t4\\ttest_db.o.order_id\\t5\\t100.0\\t\\n1\\tPRIMARY\\t<derived2>\\t\\tref\\t<auto_key0>\\t<auto_key0>\\t4\\ttest_db.o.user_id\\t10\\t100.0\\t\\n2\\tDERIVED\\t<derived3>\\t\\tALL\\t\\t\\t\\t\\t499070\\t33.33\\tUsing where; Using filesort\\n3\\tDERIVED\\toi2\\t\\tALL\\tidx_order_items_order_id,idx_order_items_product_id\\t\\t\\t\\t499070\\t100.0\\tUsing temporary; Using filesort\\n3\\tDERIVED\\tp\\t\\teq_ref\\tPRIMARY\\tPRIMARY\\t4\\ttest_db.oi2.product_id\\t1\\t100.0\\t\\n3\\tDERIVED\\to3\\t\\teq_ref\\tPRIMARY\\tPRIMARY\\t4\\ttest_db.oi2.order_id\\t1\\t100.0\\t\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"2701392.56\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_filesort\\\": true,\\n  \\\"grouping_operation\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": true,\\n  \\\"buffer_result\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"o\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_orders_user_id\\\",\\n  \\\"idx_orders_order_date\\\",\\n  \\\"idx_orders_user_id_order_date\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_orders_user_id_order_date\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"user_id\\\",\\n  \\\"order_date\\\"\\n  ],\\n  \\\"key_length\\\": \\\"7\\\",\\n  \\\"rows_examined_per_scan\\\": 499550,\\n  \\\"rows_produced_per_join\\\": 249775,\\n  \\\"filtered\\\": \\\"50.00\\\",\\n  \\\"using_index\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"25225.75\\\",\\n  \\\"eval_cost\\\": \\\"24977.50\\\",\\n  \\\"prefix_cost\\\": \\\"50203.25\\\",\\n  \\\"data_read_per_join\\\": \\\"3M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_id\\\",\\n  \\\"user_id\\\",\\n  \\\"order_date\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`o`.`order_date` >= <cache>((curdate() - interval '3' year)))\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"u\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\",\\n  \\\"idx_users_status\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"user_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.o.user_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 124887,\\n  \\\"filtered\\\": \\\"50.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"205251.09\\\",\\n  \\\"eval_cost\\\": \\\"12488.72\\\",\\n  \\\"prefix_cost\\\": \\\"280431.84\\\",\\n  \\\"data_read_per_join\\\": \\\"72M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"user_id\\\",\\n  \\\"username\\\",\\n  \\\"status\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`test_db`.`u`.`status` = 'active')\\\"\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"oi\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_order_items_order_id\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_order_items_order_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"order_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.o.order_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 5,\\n  \\\"rows_produced_per_join\\\": 628820,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"157205.24\\\",\\n  \\\"eval_cost\\\": \\\"62882.10\\\",\\n  \\\"prefix_cost\\\": \\\"500519.18\\\",\\n  \\\"data_read_per_join\\\": \\\"19M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_item_id\\\",\\n  \\\"order_id\\\",\\n  \\\"quantity\\\",\\n  \\\"unit_price\\\",\\n  \\\"discount\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"SQ_1758176107425\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"<auto_key0>\\\"\\n  ],\\n  \\\"key\\\": \\\"<auto_key0>\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"user_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.o.user_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 10,\\n  \\\"rows_produced_per_join\\\": 6288209,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1572052.41\\\",\\n  \\\"eval_cost\\\": \\\"628820.97\\\",\\n  \\\"prefix_cost\\\": \\\"2701392.56\\\",\\n  \\\"data_read_per_join\\\": \\\"143M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"user_id\\\",\\n  \\\"GROUP_CONCAT_\\\"\\n  ],\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"222487.90\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n  \\\"using_filesort\\\": true,\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"166340.03\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"oi2\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 499070,\\n  \\\"rows_produced_per_join\\\": 166340,\\n  \\\"filtered\\\": \\\"33.33\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"39513.87\\\",\\n  \\\"eval_cost\\\": \\\"16634.00\\\",\\n  \\\"prefix_cost\\\": \\\"56147.88\\\",\\n  \\\"data_read_per_join\\\": \\\"164M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"user_id\\\",\\n  \\\"product_name\\\",\\n  \\\"rank_num\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`oi2`.`rank_num` <= 3)\\\",\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"898686.75\\\"\\n  },\\n  \\\"windowing\\\": {\\n  \\\"windows\\\": [\\n  {\\n  \\\"name\\\": \\\"<unnamed window>\\\",\\n  \\\"using_filesort\\\": true,\\n  \\\"filesort_key\\\": [\\n  \\\"`user_id`\\\",\\n  \\\"sum(((`quantity` * `unit_price`) * (1 - (`discount` / 100)))) desc\\\"\\n  ],\\n  \\\"functions\\\": [\\n  \\\"row_number\\\"\\n  ]\\n  }\\n  ],\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"499070.00\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": false,\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"oi2\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_order_items_order_id\\\",\\n  \\\"idx_order_items_product_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 499070,\\n  \\\"rows_produced_per_join\\\": 499070,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"360.75\\\",\\n  \\\"eval_cost\\\": \\\"49907.00\\\",\\n  \\\"prefix_cost\\\": \\\"50267.75\\\",\\n  \\\"data_read_per_join\\\": \\\"15M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_item_id\\\",\\n  \\\"order_id\\\",\\n  \\\"product_id\\\",\\n  \\\"quantity\\\",\\n  \\\"unit_price\\\",\\n  \\\"discount\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"p\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"product_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.oi2.product_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 499070,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"124767.50\\\",\\n  \\\"eval_cost\\\": \\\"49907.00\\\",\\n  \\\"prefix_cost\\\": \\\"224942.25\\\",\\n  \\\"data_read_per_join\\\": \\\"491M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"product_id\\\",\\n  \\\"product_name\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"o3\\\",\\n  \\\"access_type\\\": \\\"eq_ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"PRIMARY\\\"\\n  ],\\n  \\\"key\\\": \\\"PRIMARY\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"order_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.oi2.order_id\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 1,\\n  \\\"rows_produced_per_join\\\": 499070,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"124767.50\\\",\\n  \\\"eval_cost\\\": \\\"49907.00\\\",\\n  \\\"prefix_cost\\\": \\\"399616.75\\\",\\n  \\\"data_read_per_join\\\": \\\"7M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"order_id\\\",\\n  \\\"user_id\\\"\\n  ]\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Fail",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE users (user_id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) NOT NULL, status VARCHAR(50) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_users_status ON users(status);\nCREATE TABLE orders (order_id INT PRIMARY KEY AUTO_INCREMENT, user_id INT NOT NULL, order_date DATE NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_orders_user_id ON orders(user_id);\nCREATE INDEX idx_orders_order_date ON orders(order_date);\nCREATE INDEX idx_orders_user_id_order_date ON orders(user_id, order_date);\nCREATE TABLE order_items (order_item_id INT PRIMARY KEY AUTO_INCREMENT, order_id INT NOT NULL, product_id INT NOT NULL, quantity DECIMAL(10,2) NOT NULL, unit_price DECIMAL(10,2) NOT NULL, discount DECIMAL(5,2) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_order_items_order_id ON order_items(order_id);\nCREATE INDEX idx_order_items_product_id ON order_items(product_id);\nCREATE TABLE products (product_id INT PRIMARY KEY AUTO_INCREMENT, product_name VARCHAR(255) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\to\t\tindex\tidx_orders_user_id,idx_orders_order_date,idx_orders_user_id_order_date\tidx_orders_user_id_order_date\t7\t\t499550\t50.0\tUsing where; Using index; Using temporary; Using filesort\n1\tPRIMARY\tu\t\teq_ref\tPRIMARY,idx_users_status\tPRIMARY\t4\ttest_db.o.user_id\t1\t50.0\tUsing where\n1\tPRIMARY\toi\t\tref\tidx_order_items_order_id\tidx_order_items_order_id\t4\ttest_db.o.order_id\t5\t100.0\t\n1\tPRIMARY\t<derived2>\t\tref\t<auto_key0>\t<auto_key0>\t4\ttest_db.o.user_id\t10\t100.0\t\n2\tDERIVED\t<derived3>\t\tALL\t\t\t\t\t499070\t33.33\tUsing where; Using filesort\n3\tDERIVED\toi2\t\tALL\tidx_order_items_order_id,idx_order_items_product_id\t\t\t\t499070\t100.0\tUsing temporary; Using filesort\n3\tDERIVED\tp\t\teq_ref\tPRIMARY\tPRIMARY\t4\ttest_db.oi2.product_id\t1\t100.0\t\n3\tDERIVED\to3\t\teq_ref\tPRIMARY\tPRIMARY\t4\ttest_db.oi2.order_id\t1\t100.0\t\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"2701392.56\"\n  },\n  \"ordering_operation\": {\n  \"using_filesort\": true,\n  \"grouping_operation\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": true,\n  \"buffer_result\": {\n  \"using_temporary_table\": true,\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"o\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"idx_orders_user_id\",\n  \"idx_orders_order_date\",\n  \"idx_orders_user_id_order_date\"\n  ],\n  \"key\": \"idx_orders_user_id_order_date\",\n  \"used_key_parts\": [\n  \"user_id\",\n  \"order_date\"\n  ],\n  \"key_length\": \"7\",\n  \"rows_examined_per_scan\": 499550,\n  \"rows_produced_per_join\": 249775,\n  \"filtered\": \"50.00\",\n  \"using_index\": true,\n  \"cost_info\": {\n  \"read_cost\": \"25225.75\",\n  \"eval_cost\": \"24977.50\",\n  \"prefix_cost\": \"50203.25\",\n  \"data_read_per_join\": \"3M\"\n  },\n  \"used_columns\": [\n  \"order_id\",\n  \"user_id\",\n  \"order_date\"\n  ],\n  \"attached_condition\": \"(`test_db`.`o`.`order_date` >= <cache>((curdate() - interval '3' year)))\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"u\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\",\n  \"idx_users_status\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"user_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.o.user_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 124887,\n  \"filtered\": \"50.00\",\n  \"cost_info\": {\n  \"read_cost\": \"205251.09\",\n  \"eval_cost\": \"12488.72\",\n  \"prefix_cost\": \"280431.84\",\n  \"data_read_per_join\": \"72M\"\n  },\n  \"used_columns\": [\n  \"user_id\",\n  \"username\",\n  \"status\"\n  ],\n  \"attached_condition\": \"(`test_db`.`u`.`status` = 'active')\"\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"oi\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_order_items_order_id\"\n  ],\n  \"key\": \"idx_order_items_order_id\",\n  \"used_key_parts\": [\n  \"order_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.o.order_id\"\n  ],\n  \"rows_examined_per_scan\": 5,\n  \"rows_produced_per_join\": 628820,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"157205.24\",\n  \"eval_cost\": \"62882.10\",\n  \"prefix_cost\": \"500519.18\",\n  \"data_read_per_join\": \"19M\"\n  },\n  \"used_columns\": [\n  \"order_item_id\",\n  \"order_id\",\n  \"quantity\",\n  \"unit_price\",\n  \"discount\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"SQ_1758176107425\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"<auto_key0>\"\n  ],\n  \"key\": \"<auto_key0>\",\n  \"used_key_parts\": [\n  \"user_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.o.user_id\"\n  ],\n  \"rows_examined_per_scan\": 10,\n  \"rows_produced_per_join\": 6288209,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"1572052.41\",\n  \"eval_cost\": \"628820.97\",\n  \"prefix_cost\": \"2701392.56\",\n  \"data_read_per_join\": \"143M\"\n  },\n  \"used_columns\": [\n  \"user_id\",\n  \"GROUP_CONCAT_\"\n  ],\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"222487.90\"\n  },\n  \"grouping_operation\": {\n  \"using_filesort\": true,\n  \"cost_info\": {\n  \"sort_cost\": \"166340.03\"\n  },\n  \"table\": {\n  \"table_name\": \"oi2\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 499070,\n  \"rows_produced_per_join\": 166340,\n  \"filtered\": \"33.33\",\n  \"cost_info\": {\n  \"read_cost\": \"39513.87\",\n  \"eval_cost\": \"16634.00\",\n  \"prefix_cost\": \"56147.88\",\n  \"data_read_per_join\": \"164M\"\n  },\n  \"used_columns\": [\n  \"user_id\",\n  \"product_name\",\n  \"rank_num\"\n  ],\n  \"attached_condition\": \"(`oi2`.`rank_num` <= 3)\",\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"898686.75\"\n  },\n  \"windowing\": {\n  \"windows\": [\n  {\n  \"name\": \"<unnamed window>\",\n  \"using_filesort\": true,\n  \"filesort_key\": [\n  \"`user_id`\",\n  \"sum(((`quantity` * `unit_price`) * (1 - (`discount` / 100)))) desc\"\n  ],\n  \"functions\": [\n  \"row_number\"\n  ]\n  }\n  ],\n  \"cost_info\": {\n  \"sort_cost\": \"499070.00\"\n  },\n  \"grouping_operation\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": false,\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"oi2\",\n  \"access_type\": \"ALL\",\n  \"possible_keys\": [\n  \"idx_order_items_order_id\",\n  \"idx_order_items_product_id\"\n  ],\n  \"rows_examined_per_scan\": 499070,\n  \"rows_produced_per_join\": 499070,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"360.75\",\n  \"eval_cost\": \"49907.00\",\n  \"prefix_cost\": \"50267.75\",\n  \"data_read_per_join\": \"15M\"\n  },\n  \"used_columns\": [\n  \"order_item_id\",\n  \"order_id\",\n  \"product_id\",\n  \"quantity\",\n  \"unit_price\",\n  \"discount\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"p\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"product_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.oi2.product_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 499070,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"124767.50\",\n  \"eval_cost\": \"49907.00\",\n  \"prefix_cost\": \"224942.25\",\n  \"data_read_per_join\": \"491M\"\n  },\n  \"used_columns\": [\n  \"product_id\",\n  \"product_name\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"o3\",\n  \"access_type\": \"eq_ref\",\n  \"possible_keys\": [\n  \"PRIMARY\"\n  ],\n  \"key\": \"PRIMARY\",\n  \"used_key_parts\": [\n  \"order_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"test_db.oi2.order_id\"\n  ],\n  \"rows_examined_per_scan\": 1,\n  \"rows_produced_per_join\": 499070,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"124767.50\",\n  \"eval_cost\": \"49907.00\",\n  \"prefix_cost\": \"399616.75\",\n  \"data_read_per_join\": \"7M\"\n  },\n  \"used_columns\": [\n  \"order_id\",\n  \"user_id\"\n  ]\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n}\n\n## Original SQL:\nselect /*QB_1*/ u.user_id,\r\n  u.username, COUNT(distinct o.order_id) as total_orders,\r\n  SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent,\r\n  AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value,\r\n  MAX(o.order_date) as last_order_date,\r\n  SQ_1758176107425.GROUP_CONCAT_ as top_products\r\nfrom users as u\r\ninner join orders as o\r\non u.user_id = o.user_id \r\nleft outer join order_items as oi\r\non o.order_id = oi.order_id \r\nleft outer join (\r\n  select /*SQ_1758176107425*/ oi2.user_id,\r\n  GROUP_CONCAT(distinct oi2.product_name order by oi2.product_name separator ', ') as GROUP_CONCAT_\r\n  from (\r\n  select /*QB_2*/ o3.user_id,\r\n  p.product_name,\r\n  row_number() over (partition by o3.user_id order by sum(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num\r\n  from order_items as oi2\r\n  inner join products as p\r\n  on oi2.product_id = p.product_id\r\n  inner join orders as o3\r\n  on o3.order_id = oi2.order_id\r\n  group by o3.user_id,\r\n  p.product_name\r\n  ) as oi2\r\n  where oi2.rank_num <= 3 \r\n  group by oi2.user_id \r\n  ) as SQ_1758176107425\r\non SQ_1758176107425.user_id = u.user_id\r\nwhere u.status = 'active'\r\n  and o.order_date >= DATE_SUB(CURRENT_DATE(),\r\n  interval '3' YEAR)\r\ngroup by u.user_id, u.username\r\nhaving COUNT(distinct o.order_id) > 0\r\norder by total_spent desc;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "select u.user_id, u.username, COUNT(distinct o.order_id) as total_orders, SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent, AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value, MAX(o.order_date) as last_order_date, tp.top_products from users u inner join orders o on u.user_id = o.user_id and o.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 YEAR) left join order_items oi on o.order_id = oi.order_id left join (select user_id, GROUP_CONCAT(distinct product_name order by product_name separator ', ') as top_products from (select o3.user_id, p.product_name, row_number() over (partition by o3.user_id order by SUM(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num from orders o3 inner join order_items oi2 on o3.order_id = oi2.order_id inner join products p on oi2.product_id = p.product_id where o3.order_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 YEAR) group by o3.user_id, p.product_name) ranked_products where rank_num <= 3 group by user_id) tp on tp.user_id = u.user_id where u.status = 'active' group by u.user_id, u.username having COUNT(distinct o.order_id) > 0 order by total_spent desc;"
                    }
                ]
            },
            {
                "case_id": "47",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"47\", \"db_type\": \"mysql\", \"description\": \"通过分析业务逻辑：avg_cust_rate子查询基于vehicle_type, booking_status, payment_method分组，而base表在JOIN时使用相同的字段组合匹配，因此不可能存在base记录在avg_cust_rate中找不到对应分组的情况。同时，WHERE条件要求字段差值的绝对值>=1，强制avg_cust_rate.avg_v必须有值，故LEFT JOIN时保留的NULL记录必然被WHERE过滤。改为INNER JOIN排除了这些无效记录，减少了中间结果集大小。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE ride_bookings (id BIGINT PRIMARY KEY AUTO_INCREMENT, vehicle_type VARCHAR(50) NOT NULL, booking_status VARCHAR(50) NOT NULL, payment_method VARCHAR(50) NOT NULL, ride_distance NUMERIC(10,2) NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_grouping ON ride_bookings (vehicle_type, booking_status, payment_method);\", \"CREATE INDEX idx_ride_distance ON ride_bookings (ride_distance);\"], \"sql\": \"select * \\r\\nfrom (\\r\\nselect base.vehicle_type, base.booking_status, base.payment_method, base.ride_distance, coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0) as rate, \\r\\n row_number() over(partition by base.vehicle_type order by abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) desc ) as rank_num \\r\\nfrom ride_bookings base \\r\\nleft join (\\r\\n\\tselect vehicle_type, booking_status,payment_method,coalesce(avg(ride_distance), 0) as avg_v\\r\\n\\tfrom ride_bookings \\r\\n\\tgroup by vehicle_type, booking_status,payment_method\\r\\n) avg_cust_rate \\r\\non base.vehicle_type = avg_cust_rate.vehicle_type and base.booking_status = avg_cust_rate.booking_status and base.payment_method = avg_cust_rate.payment_method \\r\\nwhere abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) >= 1 \\r\\n) fn \\r\\nwhere rank_num <=5;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\t<derived2>\\t\\tALL\\t\\t\\t\\t\\t4987160\\t33.33\\tUsing where\\n2\\tDERIVED\\tbase\\t\\tALL\\t\\t\\t\\t\\t498713\\t100.0\\tUsing temporary; Using filesort\\n2\\tDERIVED\\t<derived3>\\t\\tref\\t<auto_key0>\\t<auto_key0>\\t606\\ttest_db.base.vehicle_type,test_db.base.booking_status,test_db.base.payment_method\\t10\\t100.0\\tUsing where\\n3\\tDERIVED\\tride_bookings\\t\\tindex\\tidx_grouping\\tidx_grouping\\t606\\t\\t498713\\t100.0\\t\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"561058.00\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"fn\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 4987160,\\n  \\\"rows_produced_per_join\\\": 1662220,\\n  \\\"filtered\\\": \\\"33.33\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"394835.96\\\",\\n  \\\"eval_cost\\\": \\\"166222.04\\\",\\n  \\\"prefix_cost\\\": \\\"561058.00\\\",\\n  \\\"data_read_per_join\\\": \\\"1001M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\",\\n  \\\"ride_distance\\\",\\n  \\\"rate\\\",\\n  \\\"rank_num\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"(`fn`.`rank_num` <= 5)\\\",\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"6783026.30\\\"\\n  },\\n  \\\"windowing\\\": {\\n  \\\"windows\\\": [\\n  {\\n  \\\"name\\\": \\\"<unnamed window>\\\",\\n  \\\"using_filesort\\\": true,\\n  \\\"filesort_key\\\": [\\n  \\\"`vehicle_type`\\\",\\n  \\\"abs((coalesce(`ride_distance`,0) - coalesce(`avg_v`,0))) desc\\\"\\n  ],\\n  \\\"functions\\\": [\\n  \\\"row_number\\\"\\n  ]\\n  }\\n  ],\\n  \\\"cost_info\\\": {\\n  \\\"sort_cost\\\": \\\"4987160.00\\\"\\n  },\\n  \\\"buffer_result\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"nested_loop\\\": [\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"base\\\",\\n  \\\"access_type\\\": \\\"ALL\\\",\\n  \\\"rows_examined_per_scan\\\": 498713,\\n  \\\"rows_produced_per_join\\\": 498713,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"489.00\\\",\\n  \\\"eval_cost\\\": \\\"49871.30\\\",\\n  \\\"prefix_cost\\\": \\\"50360.30\\\",\\n  \\\"data_read_per_join\\\": \\\"296M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\",\\n  \\\"ride_distance\\\"\\n  ]\\n  }\\n  },\\n  {\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"avg_cust_rate\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"<auto_key0>\\\"\\n  ],\\n  \\\"key\\\": \\\"<auto_key0>\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\"\\n  ],\\n  \\\"key_length\\\": \\\"606\\\",\\n  \\\"ref\\\": [\\n  \\\"test_db.base.vehicle_type\\\",\\n  \\\"test_db.base.booking_status\\\",\\n  \\\"test_db.base.payment_method\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 10,\\n  \\\"rows_produced_per_join\\\": 4987160,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"1246790.00\\\",\\n  \\\"eval_cost\\\": \\\"498716.00\\\",\\n  \\\"prefix_cost\\\": \\\"1795866.30\\\",\\n  \\\"data_read_per_join\\\": \\\"2G\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\",\\n  \\\"avg_v\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"<if>(found_match(avg_cust_rate), (abs((coalesce(`test_db`.`base`.`ride_distance`,0) - coalesce(`avg_cust_rate`.`avg_v`,0))) >= 1), true)\\\",\\n  \\\"materialized_from_subquery\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"dependent\\\": false,\\n  \\\"cacheable\\\": true,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"50360.30\\\"\\n  },\\n  \\\"grouping_operation\\\": {\\n  \\\"using_filesort\\\": false,\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"ride_bookings\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_grouping\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_grouping\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\"\\n  ],\\n  \\\"key_length\\\": \\\"606\\\",\\n  \\\"rows_examined_per_scan\\\": 498713,\\n  \\\"rows_produced_per_join\\\": 498713,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"489.00\\\",\\n  \\\"eval_cost\\\": \\\"49871.30\\\",\\n  \\\"prefix_cost\\\": \\\"50360.30\\\",\\n  \\\"data_read_per_join\\\": \\\"296M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"id\\\",\\n  \\\"vehicle_type\\\",\\n  \\\"booking_status\\\",\\n  \\\"payment_method\\\",\\n  \\\"ride_distance\\\"\\n  ]\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n  }\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE ride_bookings (id BIGINT PRIMARY KEY AUTO_INCREMENT, vehicle_type VARCHAR(50) NOT NULL, booking_status VARCHAR(50) NOT NULL, payment_method VARCHAR(50) NOT NULL, ride_distance NUMERIC(10,2) NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_grouping ON ride_bookings (vehicle_type, booking_status, payment_method);\nCREATE INDEX idx_ride_distance ON ride_bookings (ride_distance);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\t<derived2>\t\tALL\t\t\t\t\t4987160\t33.33\tUsing where\n2\tDERIVED\tbase\t\tALL\t\t\t\t\t498713\t100.0\tUsing temporary; Using filesort\n2\tDERIVED\t<derived3>\t\tref\t<auto_key0>\t<auto_key0>\t606\ttest_db.base.vehicle_type,test_db.base.booking_status,test_db.base.payment_method\t10\t100.0\tUsing where\n3\tDERIVED\tride_bookings\t\tindex\tidx_grouping\tidx_grouping\t606\t\t498713\t100.0\t\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"561058.00\"\n  },\n  \"table\": {\n  \"table_name\": \"fn\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 4987160,\n  \"rows_produced_per_join\": 1662220,\n  \"filtered\": \"33.33\",\n  \"cost_info\": {\n  \"read_cost\": \"394835.96\",\n  \"eval_cost\": \"166222.04\",\n  \"prefix_cost\": \"561058.00\",\n  \"data_read_per_join\": \"1001M\"\n  },\n  \"used_columns\": [\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\",\n  \"ride_distance\",\n  \"rate\",\n  \"rank_num\"\n  ],\n  \"attached_condition\": \"(`fn`.`rank_num` <= 5)\",\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"6783026.30\"\n  },\n  \"windowing\": {\n  \"windows\": [\n  {\n  \"name\": \"<unnamed window>\",\n  \"using_filesort\": true,\n  \"filesort_key\": [\n  \"`vehicle_type`\",\n  \"abs((coalesce(`ride_distance`,0) - coalesce(`avg_v`,0))) desc\"\n  ],\n  \"functions\": [\n  \"row_number\"\n  ]\n  }\n  ],\n  \"cost_info\": {\n  \"sort_cost\": \"4987160.00\"\n  },\n  \"buffer_result\": {\n  \"using_temporary_table\": true,\n  \"nested_loop\": [\n  {\n  \"table\": {\n  \"table_name\": \"base\",\n  \"access_type\": \"ALL\",\n  \"rows_examined_per_scan\": 498713,\n  \"rows_produced_per_join\": 498713,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"489.00\",\n  \"eval_cost\": \"49871.30\",\n  \"prefix_cost\": \"50360.30\",\n  \"data_read_per_join\": \"296M\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\",\n  \"ride_distance\"\n  ]\n  }\n  },\n  {\n  \"table\": {\n  \"table_name\": \"avg_cust_rate\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"<auto_key0>\"\n  ],\n  \"key\": \"<auto_key0>\",\n  \"used_key_parts\": [\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\"\n  ],\n  \"key_length\": \"606\",\n  \"ref\": [\n  \"test_db.base.vehicle_type\",\n  \"test_db.base.booking_status\",\n  \"test_db.base.payment_method\"\n  ],\n  \"rows_examined_per_scan\": 10,\n  \"rows_produced_per_join\": 4987160,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"1246790.00\",\n  \"eval_cost\": \"498716.00\",\n  \"prefix_cost\": \"1795866.30\",\n  \"data_read_per_join\": \"2G\"\n  },\n  \"used_columns\": [\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\",\n  \"avg_v\"\n  ],\n  \"attached_condition\": \"<if>(found_match(avg_cust_rate), (abs((coalesce(`test_db`.`base`.`ride_distance`,0) - coalesce(`avg_cust_rate`.`avg_v`,0))) >= 1), true)\",\n  \"materialized_from_subquery\": {\n  \"using_temporary_table\": true,\n  \"dependent\": false,\n  \"cacheable\": true,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"50360.30\"\n  },\n  \"grouping_operation\": {\n  \"using_filesort\": false,\n  \"table\": {\n  \"table_name\": \"ride_bookings\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"idx_grouping\"\n  ],\n  \"key\": \"idx_grouping\",\n  \"used_key_parts\": [\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\"\n  ],\n  \"key_length\": \"606\",\n  \"rows_examined_per_scan\": 498713,\n  \"rows_produced_per_join\": 498713,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"489.00\",\n  \"eval_cost\": \"49871.30\",\n  \"prefix_cost\": \"50360.30\",\n  \"data_read_per_join\": \"296M\"\n  },\n  \"used_columns\": [\n  \"id\",\n  \"vehicle_type\",\n  \"booking_status\",\n  \"payment_method\",\n  \"ride_distance\"\n  ]\n  }\n  }\n  }\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n  }\n  }\n  }\n}\n\n## Original SQL:\nselect * \r\nfrom (\r\nselect base.vehicle_type, base.booking_status, base.payment_method, base.ride_distance, coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0) as rate, \r\n row_number() over(partition by base.vehicle_type order by abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) desc ) as rank_num \r\nfrom ride_bookings base \r\nleft join (\r\n\tselect vehicle_type, booking_status,payment_method,coalesce(avg(ride_distance), 0) as avg_v\r\n\tfrom ride_bookings \r\n\tgroup by vehicle_type, booking_status,payment_method\r\n) avg_cust_rate \r\non base.vehicle_type = avg_cust_rate.vehicle_type and base.booking_status = avg_cust_rate.booking_status and base.payment_method = avg_cust_rate.payment_method \r\nwhere abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) >= 1 \r\n) fn \r\nwhere rank_num <=5;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT * FROM (SELECT vehicle_type, booking_status, payment_method, ride_distance, rate, row_number() over(partition by vehicle_type order by abs(rate) desc) as rank_num FROM (SELECT vehicle_type, booking_status, payment_method, ride_distance, coalesce(ride_distance, 0) - coalesce(avg(ride_distance) over (partition by vehicle_type, booking_status, payment_method), 0) as rate FROM ride_bookings) t WHERE abs(rate) >= 1) fn WHERE rank_num <= 5;"
                    }
                ]
            },
            {
                "case_id": "48",
                "case_weight": 3,
                "case_content": "{\"case_id\": \"48\", \"db_type\": \"mysql\", \"description\": \"改写前的SQL对每个分组结果（每个customer_id）执行两个相关子查询，导致对每个成组的customer_id都要额外扫描两次表。改写后将子查询逻辑合并到主查询的聚合函数中，利用主查询的分组直接计算平均值和最大值，避免了N+1查询问题，大幅减少了重复扫描次数。\", \"difficulty_level\": \"3\", \"create_table_statements\": [\"CREATE TABLE ride_bookings (booking_id INT PRIMARY KEY AUTO_INCREMENT, customer_id INT NOT NULL, booking_value DECIMAL(10,2) NOT NULL, driver_rating DECIMAL(3,2), booking_status VARCHAR(50) NOT NULL, booking_date DATETIME NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\", \"CREATE INDEX idx_customer_id ON ride_bookings(customer_id);\", \"CREATE INDEX idx_booking_status_date ON ride_bookings(booking_status, booking_date);\"], \"sql\": \"SELECT \\r\\n  rb.customer_id,\\r\\n  COUNT(DISTINCT rb.booking_id) AS total_bookings,\\r\\n  SUM(rb.booking_value) AS total_revenue,\\r\\n  (SELECT AVG(driver_rating) FROM ride_bookings WHERE customer_id = rb.customer_id) AS avg_driver_rating,\\r\\n  (SELECT MAX(booking_date) FROM ride_bookings WHERE customer_id = rb.customer_id) AS last_booking_date\\r\\nFROM \\r\\n  ride_bookings rb\\r\\nWHERE \\r\\n  rb.booking_status IN ('Completed', 'Cancelled', 'No Show')\\r\\n  AND rb.booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY)\\r\\nGROUP BY \\r\\n  rb.customer_id\\r\\nHAVING \\r\\n  total_bookings > 10\\r\\nORDER BY \\r\\n  total_revenue DESC,\\r\\n  avg_driver_rating ASC;\", \"explain\": \"id\\tselect_type\\ttable\\tpartitions\\ttype\\tpossible_keys\\tkey\\tkey_len\\tref\\trows\\tfiltered\\tExtra\\n1\\tPRIMARY\\trb\\t\\tindex\\tidx_customer_id,idx_booking_status_date\\tidx_customer_id\\t4\\t\\t498576\\t100.0\\tUsing where; Using temporary; Using filesort\\n3\\tDEPENDENT SUBQUERY\\tride_bookings\\t\\tref\\tidx_customer_id\\tidx_customer_id\\t4\\tfunc\\t25\\t100.0\\t\\n2\\tDEPENDENT SUBQUERY\\tride_bookings\\t\\tref\\tidx_customer_id\\tidx_customer_id\\t4\\tfunc\\t25\\t100.0\\t\\n\\nJSON执行计划:\\n{\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 1,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"50266.35\\\"\\n  },\\n  \\\"ordering_operation\\\": {\\n  \\\"using_temporary_table\\\": true,\\n  \\\"using_filesort\\\": true,\\n  \\\"grouping_operation\\\": {\\n  \\\"using_filesort\\\": false,\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"rb\\\",\\n  \\\"access_type\\\": \\\"index\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_customer_id\\\",\\n  \\\"idx_booking_status_date\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_customer_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"customer_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"rows_examined_per_scan\\\": 498576,\\n  \\\"rows_produced_per_join\\\": 498576,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"408.75\\\",\\n  \\\"eval_cost\\\": \\\"49857.60\\\",\\n  \\\"prefix_cost\\\": \\\"50266.35\\\",\\n  \\\"data_read_per_join\\\": \\\"106M\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"booking_id\\\",\\n  \\\"customer_id\\\",\\n  \\\"booking_value\\\",\\n  \\\"booking_status\\\",\\n  \\\"booking_date\\\"\\n  ],\\n  \\\"attached_condition\\\": \\\"((`test_db`.`rb`.`booking_status` in ('Completed','Cancelled','No Show')) and (`test_db`.`rb`.`booking_date` >= <cache>((curdate() - interval 180 day))))\\\"\\n  },\\n  \\\"select_list_subqueries\\\": [\\n  {\\n  \\\"dependent\\\": true,\\n  \\\"cacheable\\\": false,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 3,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"8.82\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"ride_bookings\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_customer_id\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_customer_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"customer_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"func\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 25,\\n  \\\"rows_produced_per_join\\\": 25,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"6.30\\\",\\n  \\\"eval_cost\\\": \\\"2.52\\\",\\n  \\\"prefix_cost\\\": \\\"8.82\\\",\\n  \\\"data_read_per_join\\\": \\\"5K\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"customer_id\\\",\\n  \\\"booking_date\\\"\\n  ]\\n  }\\n  }\\n  },\\n  {\\n  \\\"dependent\\\": true,\\n  \\\"cacheable\\\": false,\\n  \\\"query_block\\\": {\\n  \\\"select_id\\\": 2,\\n  \\\"cost_info\\\": {\\n  \\\"query_cost\\\": \\\"8.82\\\"\\n  },\\n  \\\"table\\\": {\\n  \\\"table_name\\\": \\\"ride_bookings\\\",\\n  \\\"access_type\\\": \\\"ref\\\",\\n  \\\"possible_keys\\\": [\\n  \\\"idx_customer_id\\\"\\n  ],\\n  \\\"key\\\": \\\"idx_customer_id\\\",\\n  \\\"used_key_parts\\\": [\\n  \\\"customer_id\\\"\\n  ],\\n  \\\"key_length\\\": \\\"4\\\",\\n  \\\"ref\\\": [\\n  \\\"func\\\"\\n  ],\\n  \\\"rows_examined_per_scan\\\": 25,\\n  \\\"rows_produced_per_join\\\": 25,\\n  \\\"filtered\\\": \\\"100.00\\\",\\n  \\\"cost_info\\\": {\\n  \\\"read_cost\\\": \\\"6.30\\\",\\n  \\\"eval_cost\\\": \\\"2.52\\\",\\n  \\\"prefix_cost\\\": \\\"8.82\\\",\\n  \\\"data_read_per_join\\\": \\\"5K\\\"\\n  },\\n  \\\"used_columns\\\": [\\n  \\\"customer_id\\\",\\n  \\\"driver_rating\\\"\\n  ]\\n  }\\n  }\\n  }\\n  ]\\n  }\\n  }\\n  }\\n}\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE ride_bookings (booking_id INT PRIMARY KEY AUTO_INCREMENT, customer_id INT NOT NULL, booking_value DECIMAL(10,2) NOT NULL, driver_rating DECIMAL(3,2), booking_status VARCHAR(50) NOT NULL, booking_date DATETIME NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\nCREATE INDEX idx_customer_id ON ride_bookings(customer_id);\nCREATE INDEX idx_booking_status_date ON ride_bookings(booking_status, booking_date);\n\n## Explain Output in JSON:\nid\tselect_type\ttable\tpartitions\ttype\tpossible_keys\tkey\tkey_len\tref\trows\tfiltered\tExtra\n1\tPRIMARY\trb\t\tindex\tidx_customer_id,idx_booking_status_date\tidx_customer_id\t4\t\t498576\t100.0\tUsing where; Using temporary; Using filesort\n3\tDEPENDENT SUBQUERY\tride_bookings\t\tref\tidx_customer_id\tidx_customer_id\t4\tfunc\t25\t100.0\t\n2\tDEPENDENT SUBQUERY\tride_bookings\t\tref\tidx_customer_id\tidx_customer_id\t4\tfunc\t25\t100.0\t\n\nJSON执行计划:\n{\n  \"query_block\": {\n  \"select_id\": 1,\n  \"cost_info\": {\n  \"query_cost\": \"50266.35\"\n  },\n  \"ordering_operation\": {\n  \"using_temporary_table\": true,\n  \"using_filesort\": true,\n  \"grouping_operation\": {\n  \"using_filesort\": false,\n  \"table\": {\n  \"table_name\": \"rb\",\n  \"access_type\": \"index\",\n  \"possible_keys\": [\n  \"idx_customer_id\",\n  \"idx_booking_status_date\"\n  ],\n  \"key\": \"idx_customer_id\",\n  \"used_key_parts\": [\n  \"customer_id\"\n  ],\n  \"key_length\": \"4\",\n  \"rows_examined_per_scan\": 498576,\n  \"rows_produced_per_join\": 498576,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"408.75\",\n  \"eval_cost\": \"49857.60\",\n  \"prefix_cost\": \"50266.35\",\n  \"data_read_per_join\": \"106M\"\n  },\n  \"used_columns\": [\n  \"booking_id\",\n  \"customer_id\",\n  \"booking_value\",\n  \"booking_status\",\n  \"booking_date\"\n  ],\n  \"attached_condition\": \"((`test_db`.`rb`.`booking_status` in ('Completed','Cancelled','No Show')) and (`test_db`.`rb`.`booking_date` >= <cache>((curdate() - interval 180 day))))\"\n  },\n  \"select_list_subqueries\": [\n  {\n  \"dependent\": true,\n  \"cacheable\": false,\n  \"query_block\": {\n  \"select_id\": 3,\n  \"cost_info\": {\n  \"query_cost\": \"8.82\"\n  },\n  \"table\": {\n  \"table_name\": \"ride_bookings\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_customer_id\"\n  ],\n  \"key\": \"idx_customer_id\",\n  \"used_key_parts\": [\n  \"customer_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"func\"\n  ],\n  \"rows_examined_per_scan\": 25,\n  \"rows_produced_per_join\": 25,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"6.30\",\n  \"eval_cost\": \"2.52\",\n  \"prefix_cost\": \"8.82\",\n  \"data_read_per_join\": \"5K\"\n  },\n  \"used_columns\": [\n  \"customer_id\",\n  \"booking_date\"\n  ]\n  }\n  }\n  },\n  {\n  \"dependent\": true,\n  \"cacheable\": false,\n  \"query_block\": {\n  \"select_id\": 2,\n  \"cost_info\": {\n  \"query_cost\": \"8.82\"\n  },\n  \"table\": {\n  \"table_name\": \"ride_bookings\",\n  \"access_type\": \"ref\",\n  \"possible_keys\": [\n  \"idx_customer_id\"\n  ],\n  \"key\": \"idx_customer_id\",\n  \"used_key_parts\": [\n  \"customer_id\"\n  ],\n  \"key_length\": \"4\",\n  \"ref\": [\n  \"func\"\n  ],\n  \"rows_examined_per_scan\": 25,\n  \"rows_produced_per_join\": 25,\n  \"filtered\": \"100.00\",\n  \"cost_info\": {\n  \"read_cost\": \"6.30\",\n  \"eval_cost\": \"2.52\",\n  \"prefix_cost\": \"8.82\",\n  \"data_read_per_join\": \"5K\"\n  },\n  \"used_columns\": [\n  \"customer_id\",\n  \"driver_rating\"\n  ]\n  }\n  }\n  }\n  ]\n  }\n  }\n  }\n}\n\n## Original SQL:\nSELECT \r\n  rb.customer_id,\r\n  COUNT(DISTINCT rb.booking_id) AS total_bookings,\r\n  SUM(rb.booking_value) AS total_revenue,\r\n  (SELECT AVG(driver_rating) FROM ride_bookings WHERE customer_id = rb.customer_id) AS avg_driver_rating,\r\n  (SELECT MAX(booking_date) FROM ride_bookings WHERE customer_id = rb.customer_id) AS last_booking_date\r\nFROM \r\n  ride_bookings rb\r\nWHERE \r\n  rb.booking_status IN ('Completed', 'Cancelled', 'No Show')\r\n  AND rb.booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY)\r\nGROUP BY \r\n  rb.customer_id\r\nHAVING \r\n  total_bookings > 10\r\nORDER BY \r\n  total_revenue DESC,\r\n  avg_driver_rating ASC;\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT t1.customer_id, t1.total_bookings, t1.total_revenue, t2.avg_driver_rating, t2.last_booking_date FROM (SELECT customer_id, COUNT(DISTINCT booking_id) AS total_bookings, SUM(booking_value) AS total_revenue FROM ride_bookings WHERE booking_status IN ('Completed', 'Cancelled', 'No Show') AND booking_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY) GROUP BY customer_id HAVING COUNT(DISTINCT booking_id) > 10) t1 LEFT JOIN (SELECT customer_id, AVG(driver_rating) AS avg_driver_rating, MAX(booking_date) AS last_booking_date FROM ride_bookings GROUP BY customer_id) t2 ON t1.customer_id = t2.customer_id ORDER BY t1.total_revenue DESC, t2.avg_driver_rating ASC;"
                    }
                ]
            },
            {
                "case_id": "49",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"49\", \"db_type\": \"mysql\", \"description\": \"该SQL用于统计库存车辆数及首次入库数，涉及近20个表的LEFT JOIN。主要性能问题有：1. **投影冗余**：作为连接源的两个子查询（Derived Tables `mo` 和 `purchase`）输出了大量外部查询不需要的列（如`AUDIT_STATUS`、`NEW_HOUSE_ID`、`PURCHASE_ORDER_CODE`等）。这导致中间结果集（临时表）宽度过大，显著增加了内存消耗和I/O开销。2. **子查询效率低**：`mo`子查询内部嵌套了分组聚合和IN子查询，且未有效过滤数据。3. **谓词下推机会**：主表`t_mdm_dlr_car_store`的过滤条件`IS_ENABLE='1'`位于WHERE子句，虽然优化器通常处理，但在复杂宽表连接中，显式下推或精简数据源能获得更稳定的执行计划。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE t_mdm_dlr_car_store (CAR_ID INT, SALES_PLAN_CODE VARCHAR(50), DLR_ID INT, CAR_STOCK_HOUSE_ID INT, CAR_SALE_HOUSE_ID INT, IS_ENABLE CHAR(1), FIRST_IN_HOSTSTOCK_DATE DATETIME, INDEX(CAR_ID), INDEX(SALES_PLAN_CODE));\", \"CREATE TABLE t_mdm_dlr_car (CAR_ID INT PRIMARY KEY, CAR_CONFIG_ID INT, OPTIONAL_PAG_ID INT, CAR_COLOR_ID INT, CAR_INCOLOR_ID INT);\", \"CREATE TABLE t_ve_bu_sale_order_d (SALE_PLAN_CODE VARCHAR(50), SALE_ORDER_ID INT, DELIVERY_FAC_HW_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE), INDEX(SALE_ORDER_ID));\", \"CREATE TABLE t_ve_bu_sale_order (SALE_ORDER_ID INT PRIMARY KEY);\", \"CREATE TABLE t_mdm_ve_car_config (CAR_CONFIG_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_bu_inv_apply_d (link_order_id INT, is_Enable CHAR(1), INDEX(link_order_id));\", \"CREATE TABLE t_ve_bu_movestock_order (MOVESTOCK_ORDER_CODE VARCHAR(50), CAR_ID INT, VIN VARCHAR(50), AUDIT_STATUS VARCHAR(20), NEW_HOUSE_ID INT, NEW_DLR_ID INT, INDEX(CAR_ID), INDEX(VIN));\", \"CREATE TABLE t_ve_bu_month_plan_d (SALES_PLAN_CODE VARCHAR(50), INSTORE_TIME DATETIME, INDEX(SALES_PLAN_CODE));\", \"CREATE TABLE t_usc_mdm_org_dlr (DLR_ID INT PRIMARY KEY, CITY_ID INT);\", \"CREATE TABLE T_USC_MDM_ORG_CITY (CITY_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_db_zb_stock (ZB_STOCK_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_db_car_stock_house (CAR_STOCK_HOUSE_ID INT PRIMARY KEY, CAR_HOUSE_CODE VARCHAR(50));\", \"CREATE TABLE t_mdm_ve_car_optionalpag (OPTIONAL_PAG_ID INT PRIMARY KEY);\", \"CREATE TABLE t_mdm_car_color (CAR_COLOR_ID INT PRIMARY KEY);\", \"CREATE TABLE t_mdm_car_incolor (CAR_INCOLOR_ID INT PRIMARY KEY);\", \"CREATE TABLE t_ve_finance_wholesale_purchase_order (SALES_PLAN_CODE VARCHAR(50), WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), ORDER_STATUS VARCHAR(50), INDEX(SALES_PLAN_CODE));\", \"CREATE TABLE t_ve_bu_invoice_info_upload (WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), IS_ENABLE CHAR(1), INDEX(WHOLESALE_PURCHASE_ORDER_CODE));\", \"CREATE TABLE t_prc_mds_lookup_value (LOOKUP_VALUE_CODE VARCHAR(50), LOOKUP_TYPE_CODE VARCHAR(50), INDEX(LOOKUP_VALUE_CODE));\", \"CREATE TABLE t_ve_bu_purchase_order (PURCHASE_ORDER_CODE VARCHAR(50), SALE_PLAN_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE));\"], \"sql\": \"SELECT count(1) stockNum, COUNT(c.FIRST_IN_HOSTSTOCK_DATE ) hostStockNum -- , -- DATE_FORMAT( Max(mpd.INSTORE_TIME), '%Y-%m-%d %H%:%i:%s') maxStoreTime FROM t_mdm_dlr_car_store c LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID = SO.SALE_ORDER_ID LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID = car.CAR_CONFIG_ID LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id = iad.link_order_id and iad.is_Enable='1' LEFT JOIN (SELECT MOVESTOCK_ORDER_CODE,CAR_ID,AUDIT_STATUS,NEW_HOUSE_ID,NEW_DLR_ID from t_ve_bu_movestock_order WHERE MOVESTOCK_ORDER_CODE in ( SELECT max(MOVESTOCK_ORDER_CODE) from t_ve_bu_movestock_order GROUP BY VIN )) mo ON mo.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID = tumod.DLR_ID LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID = tumod.CITY_ID LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID = c.CAR_SALE_HOUSE_ID LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID = optionl.OPTIONAL_PAG_ID LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID = cols.CAR_COLOR_ID LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID = incol.CAR_INCOLOR_ID left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE = SOD.DELIVERY_FAC_HW_CODE left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE = c.SALES_PLAN_CODE left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE = tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE = '1' left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE = ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE = 'VE1414' left join (select max(PURCHASE_ORDER_CODE) PURCHASE_ORDER_CODE ,SALE_PLAN_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE ) purchase on purchase.SALE_PLAN_CODE =c.SALES_PLAN_CODE WHERE c.IS_ENABLE = '1'\", \"explain\": \"id\\tselect_type\\ttable\\ttype\\tkey\\trows\\tExtra\\n1\\tPRIMARY\\tc\\tALL\\tNULL\\t1000\\tUsing where\\n1\\tPRIMARY\\tCAR\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tSOD\\tref\\tSALE_PLAN_CODE\\t1\\tUsing index\\n1\\tPRIMARY\\tSO\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tcon\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tiad\\tref\\tlink_order_id\\t1\\tUsing where\\n1\\tPRIMARY\\t<derived2>\\tref\\t<auto_key0>\\t10\\tUsing where\\n1\\tPRIMARY\\tmpd\\tref\\tSALES_PLAN_CODE\\t1\\tUsing index\\n1\\tPRIMARY\\ttumod\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tCI\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\ttvdzs\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\ttvdcsh\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tSHd\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\toptionl\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tcols\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\tincol\\teq_ref\\tPRIMARY\\t1\\tUsing index\\n1\\tPRIMARY\\toge\\teq_ref\\tPRIMARY\\t1\\tUsing where\\n1\\tPRIMARY\\tord\\tref\\tSALES_PLAN_CODE\\t1\\tUsing index\\n1\\tPRIMARY\\ttvbiiu\\tref\\tWHOLESALE_PURCHASE_ORDER_CODE\\t1\\tUsing where\\n1\\tPRIMARY\\tv5\\tref\\tLOOKUP_VALUE_CODE\\t1\\tUsing where\\n1\\tPRIMARY\\t<derived4>\\tref\\t<auto_key0>\\t10\\tUsing where\\n2\\tDERIVED\\tt_ve_bu_movestock_order\\tALL\\tNULL\\t5000\\tUsing where\\n3\\tDEPENDENT SUBQUERY\\tt_ve_bu_movestock_order\\tindex\\tVIN\\t5000\\tUsing index\\n4\\tDERIVED\\tt_ve_bu_purchase_order\\tindex\\tSALE_PLAN_CODE\\t2000\\tUsing index\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE t_mdm_dlr_car_store (CAR_ID INT, SALES_PLAN_CODE VARCHAR(50), DLR_ID INT, CAR_STOCK_HOUSE_ID INT, CAR_SALE_HOUSE_ID INT, IS_ENABLE CHAR(1), FIRST_IN_HOSTSTOCK_DATE DATETIME, INDEX(CAR_ID), INDEX(SALES_PLAN_CODE));\nCREATE TABLE t_mdm_dlr_car (CAR_ID INT PRIMARY KEY, CAR_CONFIG_ID INT, OPTIONAL_PAG_ID INT, CAR_COLOR_ID INT, CAR_INCOLOR_ID INT);\nCREATE TABLE t_ve_bu_sale_order_d (SALE_PLAN_CODE VARCHAR(50), SALE_ORDER_ID INT, DELIVERY_FAC_HW_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE), INDEX(SALE_ORDER_ID));\nCREATE TABLE t_ve_bu_sale_order (SALE_ORDER_ID INT PRIMARY KEY);\nCREATE TABLE t_mdm_ve_car_config (CAR_CONFIG_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_bu_inv_apply_d (link_order_id INT, is_Enable CHAR(1), INDEX(link_order_id));\nCREATE TABLE t_ve_bu_movestock_order (MOVESTOCK_ORDER_CODE VARCHAR(50), CAR_ID INT, VIN VARCHAR(50), AUDIT_STATUS VARCHAR(20), NEW_HOUSE_ID INT, NEW_DLR_ID INT, INDEX(CAR_ID), INDEX(VIN));\nCREATE TABLE t_ve_bu_month_plan_d (SALES_PLAN_CODE VARCHAR(50), INSTORE_TIME DATETIME, INDEX(SALES_PLAN_CODE));\nCREATE TABLE t_usc_mdm_org_dlr (DLR_ID INT PRIMARY KEY, CITY_ID INT);\nCREATE TABLE T_USC_MDM_ORG_CITY (CITY_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_db_zb_stock (ZB_STOCK_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_db_car_stock_house (CAR_STOCK_HOUSE_ID INT PRIMARY KEY, CAR_HOUSE_CODE VARCHAR(50));\nCREATE TABLE t_mdm_ve_car_optionalpag (OPTIONAL_PAG_ID INT PRIMARY KEY);\nCREATE TABLE t_mdm_car_color (CAR_COLOR_ID INT PRIMARY KEY);\nCREATE TABLE t_mdm_car_incolor (CAR_INCOLOR_ID INT PRIMARY KEY);\nCREATE TABLE t_ve_finance_wholesale_purchase_order (SALES_PLAN_CODE VARCHAR(50), WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), ORDER_STATUS VARCHAR(50), INDEX(SALES_PLAN_CODE));\nCREATE TABLE t_ve_bu_invoice_info_upload (WHOLESALE_PURCHASE_ORDER_CODE VARCHAR(50), IS_ENABLE CHAR(1), INDEX(WHOLESALE_PURCHASE_ORDER_CODE));\nCREATE TABLE t_prc_mds_lookup_value (LOOKUP_VALUE_CODE VARCHAR(50), LOOKUP_TYPE_CODE VARCHAR(50), INDEX(LOOKUP_VALUE_CODE));\nCREATE TABLE t_ve_bu_purchase_order (PURCHASE_ORDER_CODE VARCHAR(50), SALE_PLAN_CODE VARCHAR(50), INDEX(SALE_PLAN_CODE));\n\n## Explain Output in JSON:\nid\tselect_type\ttable\ttype\tkey\trows\tExtra\n1\tPRIMARY\tc\tALL\tNULL\t1000\tUsing where\n1\tPRIMARY\tCAR\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tSOD\tref\tSALE_PLAN_CODE\t1\tUsing index\n1\tPRIMARY\tSO\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tcon\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tiad\tref\tlink_order_id\t1\tUsing where\n1\tPRIMARY\t<derived2>\tref\t<auto_key0>\t10\tUsing where\n1\tPRIMARY\tmpd\tref\tSALES_PLAN_CODE\t1\tUsing index\n1\tPRIMARY\ttumod\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tCI\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\ttvdzs\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\ttvdcsh\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tSHd\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\toptionl\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tcols\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\tincol\teq_ref\tPRIMARY\t1\tUsing index\n1\tPRIMARY\toge\teq_ref\tPRIMARY\t1\tUsing where\n1\tPRIMARY\tord\tref\tSALES_PLAN_CODE\t1\tUsing index\n1\tPRIMARY\ttvbiiu\tref\tWHOLESALE_PURCHASE_ORDER_CODE\t1\tUsing where\n1\tPRIMARY\tv5\tref\tLOOKUP_VALUE_CODE\t1\tUsing where\n1\tPRIMARY\t<derived4>\tref\t<auto_key0>\t10\tUsing where\n2\tDERIVED\tt_ve_bu_movestock_order\tALL\tNULL\t5000\tUsing where\n3\tDEPENDENT SUBQUERY\tt_ve_bu_movestock_order\tindex\tVIN\t5000\tUsing index\n4\tDERIVED\tt_ve_bu_purchase_order\tindex\tSALE_PLAN_CODE\t2000\tUsing index\n\n## Original SQL:\nSELECT count(1) stockNum, COUNT(c.FIRST_IN_HOSTSTOCK_DATE ) hostStockNum -- , -- DATE_FORMAT( Max(mpd.INSTORE_TIME), '%Y-%m-%d %H%:%i:%s') maxStoreTime FROM t_mdm_dlr_car_store c LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID = SO.SALE_ORDER_ID LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID = car.CAR_CONFIG_ID LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id = iad.link_order_id and iad.is_Enable='1' LEFT JOIN (SELECT MOVESTOCK_ORDER_CODE,CAR_ID,AUDIT_STATUS,NEW_HOUSE_ID,NEW_DLR_ID from t_ve_bu_movestock_order WHERE MOVESTOCK_ORDER_CODE in ( SELECT max(MOVESTOCK_ORDER_CODE) from t_ve_bu_movestock_order GROUP BY VIN )) mo ON mo.CAR_ID = c.CAR_ID LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE = c.SALES_PLAN_CODE LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID = tumod.DLR_ID LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID = tumod.CITY_ID LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID = c.CAR_STOCK_HOUSE_ID LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID = c.CAR_SALE_HOUSE_ID LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID = optionl.OPTIONAL_PAG_ID LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID = cols.CAR_COLOR_ID LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID = incol.CAR_INCOLOR_ID left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE = SOD.DELIVERY_FAC_HW_CODE left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE = c.SALES_PLAN_CODE left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE = tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE = '1' left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE = ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE = 'VE1414' left join (select max(PURCHASE_ORDER_CODE) PURCHASE_ORDER_CODE ,SALE_PLAN_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE ) purchase on purchase.SALE_PLAN_CODE =c.SALES_PLAN_CODE WHERE c.IS_ENABLE = '1'\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "SELECT count(1) stockNum,COUNT(c.FIRST_IN_HOSTSTOCK_DATE) hostStockNum FROM t_mdm_dlr_car_store c LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID=c.CAR_ID LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE=c.SALES_PLAN_CODE LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID=SO.SALE_ORDER_ID LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID=car.CAR_CONFIG_ID LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id=iad.link_order_id and iad.is_Enable='1' LEFT JOIN(SELECT m.MOVESTOCK_ORDER_CODE,m.CAR_ID,m.AUDIT_STATUS,m.NEW_HOUSE_ID,m.NEW_DLR_ID FROM t_ve_bu_movestock_order m INNER JOIN(SELECT VIN,MAX(MOVESTOCK_ORDER_CODE) max_code FROM t_ve_bu_movestock_order GROUP BY VIN)mm ON m.VIN=mm.VIN AND m.MOVESTOCK_ORDER_CODE=mm.max_code)mo ON mo.CAR_ID=c.CAR_ID LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE=c.SALES_PLAN_CODE LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID=tumod.DLR_ID LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID=tumod.CITY_ID LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID=c.CAR_STOCK_HOUSE_ID LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID=c.CAR_STOCK_HOUSE_ID LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID=c.CAR_SALE_HOUSE_ID LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID=optionl.OPTIONAL_PAG_ID LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID=cols.CAR_COLOR_ID LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID=incol.CAR_INCOLOR_ID left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE=SOD.DELIVERY_FAC_HW_CODE left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE=c.SALES_PLAN_CODE left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE=tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE='1' left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE=ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE='VE1414' left join(select SALE_PLAN_CODE,MAX(PURCHASE_ORDER_CODE) PURCHASE_ORDER_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE)purchase on purchase.SALE_PLAN_CODE=c.SALES_PLAN_CODE WHERE c.IS_ENABLE='1'"
                    }
                ]
            },
            {
                "case_id": "50",
                "case_weight": 1,
                "case_content": "{\"case_id\": \"50\", \"db_type\": \"sqlserver\", \"description\": \"该SQL查询用于筛选特定的索赔记录（claim），逻辑上包含复杂的`OR`条件关联查询和用于去重的关联子查询。存在的主要性能瓶颈：1. **无输出的JOIN操作**：查询对`serie`表进行了两次LEFT JOIN（分别作为`serie`和`exchange_serie`），但在SELECT列表中并未请求这些表的任何字段，仅用于WHERE子句的过滤。这种写法增加了不必要的连接开销。2. **谓词未下推**：WHERE子句中包含跨表的`OR`逻辑 `(A AND B) OR (C AND D)`，这通常阻止优化器有效地利用索引进行过滤，导致优化器可能选择扫描整个`claim`表后再进行过滤，而不是先通过索引定位。3. **昂贵的关联子查询**：为了保留每个`claim_folder_id`下的最新记录，使用了关联子查询 `c.id = (SELECT MAX(...) ...)`，这会导致对每一行结果都执行一次子查询（N+1问题），在数据量大时性能急剧下降。\", \"difficulty_level\": \"1\", \"create_table_statements\": [\"CREATE TABLE claim (id int PRIMARY KEY, sap_code nvarchar(4000), claim_folder_id int, repair_date datetime, claim_status_id int, is_e2e bit, serie_id int, exchange_serie_id int, serial_number nvarchar(4000), production_code nvarchar(4000), exchange_serial_number nvarchar(4000), exchange_production_code nvarchar(4000));\", \"CREATE TABLE serie (id int PRIMARY KEY, sap_code nvarchar(4000));\", \"CREATE INDEX idx_claim_folder ON claim(claim_folder_id);\", \"CREATE INDEX idx_claim_serial ON claim(serial_number);\", \"CREATE INDEX idx_serie_sap ON serie(sap_code);\"], \"sql\": \"SELECT c.id, \\r\\n   c.sap_code, \\r\\n   c.claim_folder_id, \\r\\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, \\r\\n   c.claim_status_id AS status, \\r\\n   c.is_e2e AS e2e \\r\\nFROM claim c \\r\\nLEFT JOIN serie \\r\\nON serie.id = c.serie_id \\r\\nLEFT JOIN serie exchange_serie \\r\\nON exchange_serie.id = c.exchange_serie_id \\r\\nWHERE ( ((serie.sap_code = @P0 \\r\\nOR serie.sap_code = CONCAT('4000', @P1)) \\r\\nAND c.serial_number = @P2 \\r\\nAND c.production_code = @P3) \\r\\nOR ((exchange_serie.sap_code = @P4 \\r\\nOR exchange_serie.sap_code = CONCAT('4000', @P5)) \\r\\nAND c.exchange_serial_number = @P6 \\r\\nAND c.exchange_production_code = @P7) ) \\r\\nAND (c.serial_number NOT IN (@P8) \\r\\nAND c.production_code NOT IN (@P9, @P10, @P11)) \\r\\nAND c.id = \\r\\n   (\\r\\n   SELECT MAX(c2.id) \\r\\n   FROM claim c2 \\r\\n   WHERE c2.claim_folder_id = c.claim_folder_id \\r\\n   OR (c.claim_folder_id IS NULL \\r\\n  AND c2.id = c.id)\\r\\n   ) \\r\\nORDER BY c.id DESC\\r\\n\\r\\n*/\\r\\n(@P0 nvarchar(4000),@P1 nvarchar(4000),@P2 nvarchar(4000),@P3 nvarchar(4000),@P4 nvarchar(4000),@P5 \\r\\nnvarchar(4000),@P6 nvarchar(4000),@P7 nvarchar(4000),@P8 nvarchar(4000),@P9 nvarchar(4000),@P10  \\r\\nnvarchar(4000),@P11 nvarchar(4000)) \\r\\n/* BEGIN ACTIVE SECTION (comment inserted by DPA) */  \\r\\nSELECT c.id,  \\r\\n   c.sap_code,  \\r\\n   c.claim_folder_id,  \\r\\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF,  \\r\\n   c.claim_status_id AS status,  \\r\\n   c.is_e2e AS e2e  \\r\\nFROM claim c  \\r\\nLEFT JOIN serie  \\r\\nON serie.id = c.serie_id  \\r\\nLEFT JOIN serie exchange_serie  \\r\\nON exchange_serie.id = c.exchange_serie_id  \\r\\nWHERE ( ((serie.sap_code = @P0  \\r\\nOR serie.sap_code = CONCAT('4000', @P1))  \\r\\nAND c.serial_number = @P2  \\r\\nAND c.production_code = @P3)  \\r\\nOR ((exchange_serie.sap_code = @P4  \\r\\nOR exchange_serie.sap_code = CONCAT('4000', @P5))  \\r\\nAND c.exchange_serial_number = @P6  \\r\\nAND c.exchange_production_code = @P7) )  \\r\\nAND (c.serial_number NOT IN (@P8)  \\r\\nAND c.production_code NOT IN (@P9, @P10, @P11))  \\r\\nAND c.id =  \\r\\n   ( \\r\\n   SELECT MAX(c2.id)  \\r\\n   FROM claim c2  \\r\\n   WHERE c2.claim_folder_id = c.claim_folder_id  \\r\\n   OR (c.claim_folder_id IS NULL  \\r\\n  AND c2.id = c.id) \\r\\n   )  \\r\\nORDER BY c.id DESC\", \"explain\": \"  |--Sort(ORDER BY:([c].[id] DESC))\\n       |--Filter(WHERE:([c].[id]=[Expr1009]))\\n            |--Nested Loops(Left Outer Join, WHERE:(... OR ...))\\n                 |--Nested Loops(Left Outer Join, WHERE:(...))\\n                 |    |--Table Scan(OBJECT:([claim] AS [c]), WHERE:([c].[serial_number] NOT IN (@P8) AND [c].[production_code] NOT IN (@P9, @P10, @P11)))\\n                 |    |--Index Seek(OBJECT:([serie] AS [serie]), SEEK:([serie].[id]=[c].[serie_id]))\\n                 |--Index Seek(OBJECT:([serie] AS [exchange_serie]), SEEK:([exchange_serie].[id]=[c].[exchange_serie_id]))\\n            |--Stream Aggregate(DEFINE:([Expr1009]=MAX([c2].[id])))\\n                 |--Index Seek(OBJECT:([claim] AS [c2]), SEEK:([c2].[claim_folder_id]=[c].[claim_folder_id]))\"}",
                "case_eval_result": "Pass",
                "mode_question": "You are a database expert in SQL performance optimization.\nGiven the table definitions, explain output and the original SQL, apply appropriate optimizations.\nOutput only the optimized SQL as a single-line statement with no markdown or extra text.\n\n## Table Definitions:\nCREATE TABLE claim (id int PRIMARY KEY, sap_code nvarchar(4000), claim_folder_id int, repair_date datetime, claim_status_id int, is_e2e bit, serie_id int, exchange_serie_id int, serial_number nvarchar(4000), production_code nvarchar(4000), exchange_serial_number nvarchar(4000), exchange_production_code nvarchar(4000));\nCREATE TABLE serie (id int PRIMARY KEY, sap_code nvarchar(4000));\nCREATE INDEX idx_claim_folder ON claim(claim_folder_id);\nCREATE INDEX idx_claim_serial ON claim(serial_number);\nCREATE INDEX idx_serie_sap ON serie(sap_code);\n\n## Explain Output in JSON:\n  |--Sort(ORDER BY:([c].[id] DESC))\n       |--Filter(WHERE:([c].[id]=[Expr1009]))\n            |--Nested Loops(Left Outer Join, WHERE:(... OR ...))\n                 |--Nested Loops(Left Outer Join, WHERE:(...))\n                 |    |--Table Scan(OBJECT:([claim] AS [c]), WHERE:([c].[serial_number] NOT IN (@P8) AND [c].[production_code] NOT IN (@P9, @P10, @P11)))\n                 |    |--Index Seek(OBJECT:([serie] AS [serie]), SEEK:([serie].[id]=[c].[serie_id]))\n                 |--Index Seek(OBJECT:([serie] AS [exchange_serie]), SEEK:([exchange_serie].[id]=[c].[exchange_serie_id]))\n            |--Stream Aggregate(DEFINE:([Expr1009]=MAX([c2].[id])))\n                 |--Index Seek(OBJECT:([claim] AS [c2]), SEEK:([c2].[claim_folder_id]=[c].[claim_folder_id]))\n\n## Original SQL:\nSELECT c.id, \r\n   c.sap_code, \r\n   c.claim_folder_id, \r\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, \r\n   c.claim_status_id AS status, \r\n   c.is_e2e AS e2e \r\nFROM claim c \r\nLEFT JOIN serie \r\nON serie.id = c.serie_id \r\nLEFT JOIN serie exchange_serie \r\nON exchange_serie.id = c.exchange_serie_id \r\nWHERE ( ((serie.sap_code = @P0 \r\nOR serie.sap_code = CONCAT('4000', @P1)) \r\nAND c.serial_number = @P2 \r\nAND c.production_code = @P3) \r\nOR ((exchange_serie.sap_code = @P4 \r\nOR exchange_serie.sap_code = CONCAT('4000', @P5)) \r\nAND c.exchange_serial_number = @P6 \r\nAND c.exchange_production_code = @P7) ) \r\nAND (c.serial_number NOT IN (@P8) \r\nAND c.production_code NOT IN (@P9, @P10, @P11)) \r\nAND c.id = \r\n   (\r\n   SELECT MAX(c2.id) \r\n   FROM claim c2 \r\n   WHERE c2.claim_folder_id = c.claim_folder_id \r\n   OR (c.claim_folder_id IS NULL \r\n  AND c2.id = c.id)\r\n   ) \r\nORDER BY c.id DESC\r\n\r\n*/\r\n(@P0 nvarchar(4000),@P1 nvarchar(4000),@P2 nvarchar(4000),@P3 nvarchar(4000),@P4 nvarchar(4000),@P5 \r\nnvarchar(4000),@P6 nvarchar(4000),@P7 nvarchar(4000),@P8 nvarchar(4000),@P9 nvarchar(4000),@P10  \r\nnvarchar(4000),@P11 nvarchar(4000)) \r\n/* BEGIN ACTIVE SECTION (comment inserted by DPA) */  \r\nSELECT c.id,  \r\n   c.sap_code,  \r\n   c.claim_folder_id,  \r\n   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF,  \r\n   c.claim_status_id AS status,  \r\n   c.is_e2e AS e2e  \r\nFROM claim c  \r\nLEFT JOIN serie  \r\nON serie.id = c.serie_id  \r\nLEFT JOIN serie exchange_serie  \r\nON exchange_serie.id = c.exchange_serie_id  \r\nWHERE ( ((serie.sap_code = @P0  \r\nOR serie.sap_code = CONCAT('4000', @P1))  \r\nAND c.serial_number = @P2  \r\nAND c.production_code = @P3)  \r\nOR ((exchange_serie.sap_code = @P4  \r\nOR exchange_serie.sap_code = CONCAT('4000', @P5))  \r\nAND c.exchange_serial_number = @P6  \r\nAND c.exchange_production_code = @P7) )  \r\nAND (c.serial_number NOT IN (@P8)  \r\nAND c.production_code NOT IN (@P9, @P10, @P11))  \r\nAND c.id =  \r\n   ( \r\n   SELECT MAX(c2.id)  \r\n   FROM claim c2  \r\n   WHERE c2.claim_folder_id = c.claim_folder_id  \r\n   OR (c.claim_folder_id IS NULL  \r\n  AND c2.id = c.id) \r\n   )  \r\nORDER BY c.id DESC\n\n## Optimized SQL:\n",
                "model_answers": [
                    {
                        "case_evaluation_count": 1,
                        "model_answer": "WITH ranked_claims AS (SELECT c.*, ROW_NUMBER() OVER (PARTITION BY ISNULL(c.claim_folder_id, c.id) ORDER BY c.id DESC) AS rn FROM claim c WHERE c.serial_number NOT IN (@P8) AND c.production_code NOT IN (@P9, @P10, @P11)) SELECT rc.id, rc.sap_code, rc.claim_folder_id, DATEDIFF(day, rc.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, rc.claim_status_id AS status, rc.is_e2e AS e2e FROM ranked_claims rc LEFT JOIN serie ON serie.id = rc.serie_id LEFT JOIN serie exchange_serie ON exchange_serie.id = rc.exchange_serie_id WHERE rc.rn = 1 AND (((serie.sap_code = @P0 OR serie.sap_code = CONCAT('4000', @P1)) AND rc.serial_number = @P2 AND rc.production_code = @P3) OR ((exchange_serie.sap_code = @P4 OR exchange_serie.sap_code = CONCAT('4000', @P5)) AND rc.exchange_serial_number = @P6 AND rc.exchange_production_code = @P7)) ORDER BY rc.id DESC"
                    }
                ]
            }
        ]
    }
]