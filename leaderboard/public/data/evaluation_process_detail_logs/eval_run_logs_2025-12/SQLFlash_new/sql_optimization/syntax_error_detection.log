
=================================================
SQL Capability Evaluation Process Report
=================================================
Run ID: 20251212_103956_312
Run Dimensions: sql_optimization
Run Indicator: syntax_error_detection
Evaluation Timestamp: 2025-12-12T16:03:26.445231
Target: SQLFlash
Judge LLMs: deepseek-r1, o4-mini, gemini-2.5-pro
-------------------------------------------------

[2025-12-12 15:07:43.339473] Run Indicator: sql_optimization, Parameters size: 268592B
[2025-12-12 15:07:43.352302] 
--- Capability: sql_optimization Indicator syntax_error_detection.jsonl Evaluating Type: hybrid  ---
[2025-12-12 15:07:43.352475] Concurrency: 3 concurrent cases, 3 concurrent judges
[2025-12-12 15:07:43.353491] Reuse cached Application answers for this indicator
[2025-12-12 15:07:45.088202] [Case:1][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_name FROM students WHERE EXISTS (SELECT 1 FROM students s WHERE s.student_id = students.student_id);

[2025-12-12 15:07:45.088739] [Case:1][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_name FROM students WHERE EXISTS (SELECT 1 FROM students s WHERE s.student_id = students.student_id);

[2025-12-12 15:07:45.089284] [Case:1][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_name FROM students WHERE EXISTS (SELECT 1 FROM students s WHERE s.student_id = students.student_id);

[2025-12-12 15:07:48.346320] [Case:1][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:07:52.179867] [Case:1][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:08:20.361198] [Case:1][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:08:20.362662] [1] hybrid Eval Final Result: True
[2025-12-12 15:08:20.364028] [Case:2][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT outer_dt.teacher_id, outer_dt.teacher_name 
FROM students 
JOIN (
  SELECT teacher_id, teacher_name 
  FROM teachers 
  WHERE teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!'
) AS outer_dt 
ON students.teacher_id = outer_dt.teacher_id;

[2025-12-12 15:08:20.366643] [Case:2][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT outer_dt.teacher_id, outer_dt.teacher_name 
FROM students 
JOIN (
  SELECT teacher_id, teacher_name 
  FROM teachers 
  WHERE teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!'
) AS outer_dt 
ON students.teacher_id = outer_dt.teacher_id;

[2025-12-12 15:08:20.369964] [Case:2][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT outer_dt.teacher_id, outer_dt.teacher_name 
FROM students 
JOIN (
  SELECT teacher_id, teacher_name 
  FROM teachers 
  WHERE teacher_name >= 'Dr. ' AND teacher_name < 'Dr.!'
) AS outer_dt 
ON students.teacher_id = outer_dt.teacher_id;

[2025-12-12 15:08:24.368767] [Case:2][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:08:26.810372] [Case:2][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:08:57.330973] [Case:2][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:08:57.332388] [2] hybrid Eval Final Result: True
[2025-12-12 15:08:57.333765] [Case:3][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT initial_students.student_id, initial_students.student_name, final_courses.course_name, final_enrollments.enrollment_date, final_teachers.teacher_name 
FROM (
    SELECT student_id, student_name, major 
    FROM students 
    WHERE enroll_count > 5
      AND major = 'Physics'
) AS initial_students 
JOIN (
    SELECT e.student_id, e.course_id, e.enrollment_date 
    FROM enrollments e 
    WHERE e.enrollment_year = 2024
      AND e.enrollment_date >= '2024-01-01 00:00:00' 
      AND e.enrollment_date < '2024-07-01 00:00:00'
) AS final_enrollments 
ON initial_students.student_id = final_enrollments.student_id 
JOIN (
    SELECT course_id, course_name, department_id 
    FROM courses 
    WHERE course_credits >= 3
      AND course_name LIKE 'Advanced %'
) AS final_courses 
ON final_enrollments.course_id = final_courses.course_id 
LEFT JOIN (
    SELECT t.teacher_id, t.teacher_name 
    FROM teachers t 
    JOIN departments d ON t.department_id = d.department_id 
    WHERE d.location = 'Building A'
) AS final_teachers 
ON final_courses.department_id = final_teachers.teacher_id;

[2025-12-12 15:08:57.335595] [Case:3][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT initial_students.student_id, initial_students.student_name, final_courses.course_name, final_enrollments.enrollment_date, final_teachers.teacher_name 
FROM (
    SELECT student_id, student_name, major 
    FROM students 
    WHERE enroll_count > 5
      AND major = 'Physics'
) AS initial_students 
JOIN (
    SELECT e.student_id, e.course_id, e.enrollment_date 
    FROM enrollments e 
    WHERE e.enrollment_year = 2024
      AND e.enrollment_date >= '2024-01-01 00:00:00' 
      AND e.enrollment_date < '2024-07-01 00:00:00'
) AS final_enrollments 
ON initial_students.student_id = final_enrollments.student_id 
JOIN (
    SELECT course_id, course_name, department_id 
    FROM courses 
    WHERE course_credits >= 3
      AND course_name LIKE 'Advanced %'
) AS final_courses 
ON final_enrollments.course_id = final_courses.course_id 
LEFT JOIN (
    SELECT t.teacher_id, t.teacher_name 
    FROM teachers t 
    JOIN departments d ON t.department_id = d.department_id 
    WHERE d.location = 'Building A'
) AS final_teachers 
ON final_courses.department_id = final_teachers.teacher_id;

[2025-12-12 15:08:57.334904] [Case:3][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT initial_students.student_id, initial_students.student_name, final_courses.course_name, final_enrollments.enrollment_date, final_teachers.teacher_name 
FROM (
    SELECT student_id, student_name, major 
    FROM students 
    WHERE enroll_count > 5
      AND major = 'Physics'
) AS initial_students 
JOIN (
    SELECT e.student_id, e.course_id, e.enrollment_date 
    FROM enrollments e 
    WHERE e.enrollment_year = 2024
      AND e.enrollment_date >= '2024-01-01 00:00:00' 
      AND e.enrollment_date < '2024-07-01 00:00:00'
) AS final_enrollments 
ON initial_students.student_id = final_enrollments.student_id 
JOIN (
    SELECT course_id, course_name, department_id 
    FROM courses 
    WHERE course_credits >= 3
      AND course_name LIKE 'Advanced %'
) AS final_courses 
ON final_enrollments.course_id = final_courses.course_id 
LEFT JOIN (
    SELECT t.teacher_id, t.teacher_name 
    FROM teachers t 
    JOIN departments d ON t.department_id = d.department_id 
    WHERE d.location = 'Building A'
) AS final_teachers 
ON final_courses.department_id = final_teachers.teacher_id;

[2025-12-12 15:09:04.843324] [Case:3][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:09:08.218391] [Case:3][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:10:44.027964] [Case:3][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:10:44.029916] [3] hybrid Eval Final Result: True
[2025-12-12 15:10:44.031227] [Case:4][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT s.student_id, s.student_name, s.date_of_birth 
FROM students s
WHERE EXISTS (
    SELECT 1 
    FROM students
    WHERE gender = 'Male'
    ORDER BY student_id DESC 
    LIMIT 1
) 
AND s.student_id = (
    SELECT student_id 
    FROM students
    WHERE gender = 'Male'
    ORDER BY student_id DESC 
    LIMIT 1
)

[2025-12-12 15:10:44.031757] [Case:4][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT s.student_id, s.student_name, s.date_of_birth 
FROM students s
WHERE EXISTS (
    SELECT 1 
    FROM students
    WHERE gender = 'Male'
    ORDER BY student_id DESC 
    LIMIT 1
) 
AND s.student_id = (
    SELECT student_id 
    FROM students
    WHERE gender = 'Male'
    ORDER BY student_id DESC 
    LIMIT 1
)

[2025-12-12 15:10:44.032549] [Case:4][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT s.student_id, s.student_name, s.date_of_birth 
FROM students s
WHERE EXISTS (
    SELECT 1 
    FROM students
    WHERE gender = 'Male'
    ORDER BY student_id DESC 
    LIMIT 1
) 
AND s.student_id = (
    SELECT student_id 
    FROM students
    WHERE gender = 'Male'
    ORDER BY student_id DESC 
    LIMIT 1
)

[2025-12-12 15:10:53.666703] [Case:4][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:10:57.175153] [Case:4][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:13:17.203066] [Case:4][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:13:17.210043] [4] hybrid Eval Final Result: True
[2025-12-12 15:13:17.214442] [Case:5][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM teachers WHERE LEFT(teacher_name, 4) = 'Dr. ' ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id;

[2025-12-12 15:13:17.215084] [Case:5][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM teachers WHERE LEFT(teacher_name, 4) = 'Dr. ' ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id;

[2025-12-12 15:13:17.216928] [Case:5][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT outer_dt.teacher_id, outer_dt.teacher_name FROM students JOIN ( SELECT teacher_id, teacher_name FROM teachers WHERE LEFT(teacher_name, 4) = 'Dr. ' ) AS outer_dt ON students.teacher_id = outer_dt.teacher_id;

[2025-12-12 15:13:22.515823] [Case:5][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:13:24.292089] [Case:5][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:13:50.325899] [Case:5][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:13:50.327456] [5] hybrid Eval Final Result: True
[2025-12-12 15:13:50.328920] [Case:6][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_id, CONCAT("id_", student_id) as student_id2 FROM enrollments WHERE CONCAT("id_", student_id) >= "id_1000" LIMIT 10;

[2025-12-12 15:13:50.329363] [Case:6][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_id, CONCAT("id_", student_id) as student_id2 FROM enrollments WHERE CONCAT("id_", student_id) >= "id_1000" LIMIT 10;

[2025-12-12 15:13:50.331725] [Case:6][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_id, CONCAT("id_", student_id) as student_id2 FROM enrollments WHERE CONCAT("id_", student_id) >= "id_1000" LIMIT 10;

[2025-12-12 15:13:56.524019] [Case:6][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:13:57.090772] [Case:6][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:15:51.717360] [Case:6][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:15:51.719111] [6] hybrid Eval Final Result: True
[2025-12-12 15:15:51.720595] [Case:7][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * FROM students WHERE NOT EXISTS ( SELECT 1 FROM enrollments WHERE students.student_id = enrollments.student_id AND enrollment_id > 1000 );

[2025-12-12 15:15:51.721099] [Case:7][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * FROM students WHERE NOT EXISTS ( SELECT 1 FROM enrollments WHERE students.student_id = enrollments.student_id AND enrollment_id > 1000 );

[2025-12-12 15:15:51.721526] [Case:7][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * FROM students WHERE NOT EXISTS ( SELECT 1 FROM enrollments WHERE students.student_id = enrollments.student_id AND enrollment_id > 1000 );

[2025-12-12 15:15:56.404882] [Case:7][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:15:56.816353] [Case:7][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:16:09.361388] [Case:7][Run:1] [deepseek-r1] Model Output Response:
```{"answer": "yes"}
[2025-12-12 15:16:09.362750] [7] hybrid Eval Final Result: True
[2025-12-12 15:16:09.363960] [Case:8][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE (enrollment_date > CAST('1993-11-26' AS DATE) OR enrollment_date < CAST('1991-11-26' AS DATE)) AND student_id = 1999 GROUP BY student_id

[2025-12-12 15:16:09.364551] [Case:8][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE (enrollment_date > CAST('1993-11-26' AS DATE) OR enrollment_date < CAST('1991-11-26' AS DATE)) AND student_id = 1999 GROUP BY student_id

[2025-12-12 15:16:09.365251] [Case:8][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_id, MAX(enrollment_date) latest_date FROM enrollments WHERE (enrollment_date > CAST('1993-11-26' AS DATE) OR enrollment_date < CAST('1991-11-26' AS DATE)) AND student_id = 1999 GROUP BY student_id

[2025-12-12 15:16:14.412053] [Case:8][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:16:15.716925] [Case:8][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:16:45.414534] [Case:8][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:16:45.415708] [8] hybrid Eval Final Result: True
[2025-12-12 15:16:45.417047] [Case:9][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_id FROM students s WHERE s.gender = 'Female' AND s.date_of_birth <= CAST('2000-01-01' AS DATE) AND s.student_name != '张凯' AND EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id) LIMIT 10;

[2025-12-12 15:16:45.417521] [Case:9][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_id FROM students s WHERE s.gender = 'Female' AND s.date_of_birth <= CAST('2000-01-01' AS DATE) AND s.student_name != '张凯' AND EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id) LIMIT 10;

[2025-12-12 15:16:45.418992] [Case:9][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_id FROM students s WHERE s.gender = 'Female' AND s.date_of_birth <= CAST('2000-01-01' AS DATE) AND s.student_name != '张凯' AND EXISTS (SELECT 1 FROM enrollments e WHERE e.student_id = s.student_id) LIMIT 10;

[2025-12-12 15:16:49.770695] [Case:9][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:16:52.746017] [Case:9][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:17:12.864949] [Case:9][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:17:12.866094] [9] hybrid Eval Final Result: True
[2025-12-12 15:17:12.866947] [Case:10][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * 
FROM students 
WHERE EXISTS ( SELECT 1 
                 FROM enrollments AS inner_dt 
                 WHERE inner_dt.student_id = students.student_id );

[2025-12-12 15:17:12.867223] [Case:10][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * 
FROM students 
WHERE EXISTS ( SELECT 1 
                 FROM enrollments AS inner_dt 
                 WHERE inner_dt.student_id = students.student_id );

[2025-12-12 15:17:12.867669] [Case:10][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * 
FROM students 
WHERE EXISTS ( SELECT 1 
                 FROM enrollments AS inner_dt 
                 WHERE inner_dt.student_id = students.student_id );

[2025-12-12 15:17:16.354468] [Case:10][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:17:21.580877] [Case:10][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:17:32.201478] [Case:10][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:17:32.202874] [10] hybrid Eval Final Result: True
[2025-12-12 15:17:32.204274] [Case:11][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_name, date_of_birth
FROM (
    SELECT 
        student_name, 
        date_of_birth,
        CASE 
            WHEN student_name IS NOT NULL 
            THEN COUNT(*) OVER (PARTITION BY CASE WHEN student_name IS NOT NULL THEN 1 ELSE 0 END ORDER BY student_name) 
            ELSE 0 
        END AS name_count,
        CASE 
            WHEN date_of_birth IS NOT NULL 
            THEN COUNT(*) OVER (PARTITION BY CASE WHEN date_of_birth IS NOT NULL THEN 1 ELSE 0 END ORDER BY date_of_birth) 
            ELSE 0 
        END AS dob_count
    FROM students
) AS T
WHERE name_count <= 3 AND dob_count <= 2
ORDER BY student_name, date_of_birth;

[2025-12-12 15:17:32.205696] [Case:11][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_name, date_of_birth
FROM (
    SELECT 
        student_name, 
        date_of_birth,
        CASE 
            WHEN student_name IS NOT NULL 
            THEN COUNT(*) OVER (PARTITION BY CASE WHEN student_name IS NOT NULL THEN 1 ELSE 0 END ORDER BY student_name) 
            ELSE 0 
        END AS name_count,
        CASE 
            WHEN date_of_birth IS NOT NULL 
            THEN COUNT(*) OVER (PARTITION BY CASE WHEN date_of_birth IS NOT NULL THEN 1 ELSE 0 END ORDER BY date_of_birth) 
            ELSE 0 
        END AS dob_count
    FROM students
) AS T
WHERE name_count <= 3 AND dob_count <= 2
ORDER BY student_name, date_of_birth;

[2025-12-12 15:17:32.207748] [Case:11][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT student_name, date_of_birth
FROM (
    SELECT 
        student_name, 
        date_of_birth,
        CASE 
            WHEN student_name IS NOT NULL 
            THEN COUNT(*) OVER (PARTITION BY CASE WHEN student_name IS NOT NULL THEN 1 ELSE 0 END ORDER BY student_name) 
            ELSE 0 
        END AS name_count,
        CASE 
            WHEN date_of_birth IS NOT NULL 
            THEN COUNT(*) OVER (PARTITION BY CASE WHEN date_of_birth IS NOT NULL THEN 1 ELSE 0 END ORDER BY date_of_birth) 
            ELSE 0 
        END AS dob_count
    FROM students
) AS T
WHERE name_count <= 3 AND dob_count <= 2
ORDER BY student_name, date_of_birth;

[2025-12-12 15:17:37.769933] [Case:11][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:17:42.666883] [Case:11][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:19:29.530506] [Case:11][Run:1] [deepseek-r1] Model Output Response:
{"answer": "yes"}
[2025-12-12 15:19:29.531744] [11] hybrid Eval Final Result: True
[2025-12-12 15:19:29.532467] [Case:12][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * FROM students WHERE LEFT(student_name, 4) IN ('John', 'Jane');

[2025-12-12 15:19:29.533011] [Case:12][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * FROM students WHERE LEFT(student_name, 4) IN ('John', 'Jane');

[2025-12-12 15:19:29.533342] [Case:12][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * FROM students WHERE LEFT(student_name, 4) IN ('John', 'Jane');

[2025-12-12 15:19:34.333901] [Case:12][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:19:34.764876] [Case:12][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:21:00.944774] [Case:12][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:21:00.946478] [12] hybrid Eval Final Result: True
[2025-12-12 15:21:00.947433] [Case:13][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * FROM (  (SELECT name FROM users)  UNION  (SELECT title FROM articles) ) AS mixed  ORDER BY name LIMIT 5;

[2025-12-12 15:21:00.947955] [Case:13][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * FROM (  (SELECT name FROM users)  UNION  (SELECT title FROM articles) ) AS mixed  ORDER BY name LIMIT 5;

[2025-12-12 15:21:00.948464] [Case:13][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * FROM (  (SELECT name FROM users)  UNION  (SELECT title FROM articles) ) AS mixed  ORDER BY name LIMIT 5;

[2025-12-12 15:21:05.433891] [Case:13][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:21:08.058263] [Case:13][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:22:34.166250] [Case:13][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:22:34.167639] [13] hybrid Eval Final Result: True
[2025-12-12 15:22:34.169088] [Case:14][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * 
FROM ( 
    SELECT *, MAX(id) OVER() AS max_id 
    FROM students 
) t 
WHERE id = max_id;

[2025-12-12 15:22:34.169936] [Case:14][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * 
FROM ( 
    SELECT *, MAX(id) OVER() AS max_id 
    FROM students 
) t 
WHERE id = max_id;

[2025-12-12 15:22:34.170698] [Case:14][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT * 
FROM ( 
    SELECT *, MAX(id) OVER() AS max_id 
    FROM students 
) t 
WHERE id = max_id;

[2025-12-12 15:22:39.245183] [Case:14][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:22:42.246662] [Case:14][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:23:12.163171] [Case:14][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:23:12.164393] [14] hybrid Eval Final Result: True
[2025-12-12 15:23:12.165231] [Case:15][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT COUNT(*) 
FROM enrollments 
WHERE student_id < 1000 
  AND enrollment_date >= '2023-01-01';

[2025-12-12 15:23:12.165614] [Case:15][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT COUNT(*) 
FROM enrollments 
WHERE student_id < 1000 
  AND enrollment_date >= '2023-01-01';

[2025-12-12 15:23:12.167403] [Case:15][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT COUNT(*) 
FROM enrollments 
WHERE student_id < 1000 
  AND enrollment_date >= '2023-01-01';

[2025-12-12 15:23:15.045072] [Case:15][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:23:17.782521] [Case:15][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:23:40.470710] [Case:15][Run:1] [deepseek-r1] Model Output Response:
```{
  "answer": "yes"
}
[2025-12-12 15:23:40.471847] [15] hybrid Eval Final Result: True
[2025-12-12 15:23:40.472815] [Case:16][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT o.o_custkey FROM orders o

[2025-12-12 15:23:40.473309] [Case:16][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT o.o_custkey FROM orders o

[2025-12-12 15:23:40.473589] [Case:16][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT o.o_custkey FROM orders o

[2025-12-12 15:23:43.767492] [Case:16][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:23:44.893824] [Case:16][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:24:00.458981] [Case:16][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:24:00.460314] [16] hybrid Eval Final Result: True
[2025-12-12 15:24:00.461511] [Case:17][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT c.* FROM customer c LEFT JOIN orders o ON c.c_custkey > o.o_custkey

[2025-12-12 15:24:00.461897] [Case:17][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT c.* FROM customer c LEFT JOIN orders o ON c.c_custkey > o.o_custkey

[2025-12-12 15:24:00.463186] [Case:17][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT c.* FROM customer c LEFT JOIN orders o ON c.c_custkey > o.o_custkey

[2025-12-12 15:24:04.105317] [Case:17][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:24:04.497140] [Case:17][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:24:22.459223] [Case:17][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:24:22.460600] [17] hybrid Eval Final Result: True
[2025-12-12 15:24:22.461875] [Case:18][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT c.* FROM customer AS c LEFT JOIN orders AS o ON c.c_custkey > o.o_custkey

[2025-12-12 15:24:22.463585] [Case:18][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT c.* FROM customer AS c LEFT JOIN orders AS o ON c.c_custkey > o.o_custkey

[2025-12-12 15:24:22.464880] [Case:18][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT c.* FROM customer AS c LEFT JOIN orders AS o ON c.c_custkey > o.o_custkey

[2025-12-12 15:24:25.622126] [Case:18][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:24:27.469355] [Case:18][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:24:48.520564] [Case:18][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:24:48.522391] [18] hybrid Eval Final Result: True
[2025-12-12 15:24:48.524413] [Case:19][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT DISTINCT PatientRecords.PatientID, PatientRecords.Name, TreatmentHistory.TreatmentDate FROM PatientRecords INNER JOIN TreatmentHistory ON PatientRecords.PatientID = TreatmentHistory.PatientID ORDER BY TreatmentHistory.TreatmentDate DESC

[2025-12-12 15:24:48.525013] [Case:19][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT DISTINCT PatientRecords.PatientID, PatientRecords.Name, TreatmentHistory.TreatmentDate FROM PatientRecords INNER JOIN TreatmentHistory ON PatientRecords.PatientID = TreatmentHistory.PatientID ORDER BY TreatmentHistory.TreatmentDate DESC

[2025-12-12 15:24:48.525777] [Case:19][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT DISTINCT PatientRecords.PatientID, PatientRecords.Name, TreatmentHistory.TreatmentDate FROM PatientRecords INNER JOIN TreatmentHistory ON PatientRecords.PatientID = TreatmentHistory.PatientID ORDER BY TreatmentHistory.TreatmentDate DESC

[2025-12-12 15:24:52.859912] [Case:19][Run:1] [o4-mini] Model Output Response:
{"answer": "yes"}
[2025-12-12 15:24:55.106147] [Case:19][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:25:07.817950] [Case:19][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:25:07.819689] [19] hybrid Eval Final Result: True
[2025-12-12 15:25:07.820856] [Case:20][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT o_custkey FROM orders

[2025-12-12 15:25:07.822304] [Case:20][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT o_custkey FROM orders

[2025-12-12 15:25:07.824436] [Case:20][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT o_custkey FROM orders

[2025-12-12 15:25:11.147759] [Case:20][Run:1] [o4-mini] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:25:13.117010] [Case:20][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:25:19.453691] [Case:20][Run:1] [deepseek-r1] Model Output Response:
```{"answer": "yes"}
[2025-12-12 15:25:19.454953] [20] hybrid Eval Final Result: True
[2025-12-12 15:25:19.456129] [Case:21][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select a.rpt_dt,s.region_cd , t.factor_cd,t.factor_value,t.option_init from SCORE_RATING_RECORD a
join score_rating_region_record s on a.score_rating_record_id =s.score_rating_record_id
join SCORE_RATING_RECORD_DETAIL t on s.score_rating_region_record_id =t.score_rating_region_record_id
where a.score_rating_record_id =1951215209649586177
order by s.region_cd , t.factor_cd;

[2025-12-12 15:25:19.456856] [Case:21][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select a.rpt_dt,s.region_cd , t.factor_cd,t.factor_value,t.option_init from SCORE_RATING_RECORD a
join score_rating_region_record s on a.score_rating_record_id =s.score_rating_record_id
join SCORE_RATING_RECORD_DETAIL t on s.score_rating_region_record_id =t.score_rating_region_record_id
where a.score_rating_record_id =1951215209649586177
order by s.region_cd , t.factor_cd;

[2025-12-12 15:25:19.457646] [Case:21][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select a.rpt_dt,s.region_cd , t.factor_cd,t.factor_value,t.option_init from SCORE_RATING_RECORD a
join score_rating_region_record s on a.score_rating_record_id =s.score_rating_record_id
join SCORE_RATING_RECORD_DETAIL t on s.score_rating_region_record_id =t.score_rating_region_record_id
where a.score_rating_record_id =1951215209649586177
order by s.region_cd , t.factor_cd;

[2025-12-12 15:25:24.734658] [Case:21][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:25:25.468315] [Case:21][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:25:59.487571] [Case:21][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:25:59.489136] [21] hybrid Eval Final Result: True
[2025-12-12 15:25:59.490719] [Case:22][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (
  SELECT FD_FILE_ID, sum(countNumber) sumNumber FROM (
  SELECT FD_MODEL_ID,count(1) countNumber from
  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL
  <if test="startDate != null and startDate != ''">
   and FD_READ_TIME >= to_timestamp(#{startDate} || ' 00:00:00','yyyy-mm-dd hh24:mi:ss')
  </if>
  <if test="endDate != null and endDate != ''">
   and FD_READ_TIME &lt;= to_timestamp(#{endDate} || ' 23:59:59.999999','yyyy-mm-dd hh24:mi:ss.ff')
  </if>
  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID
  WHERE EXISTS (
        SELECT 1 
        FROM MANUAL_FILE_BASIC_INFO mfbi2 
        LEFT JOIN XMAIR_MANUAL_BASIC_INFO xmbi2 ON xmbi2.PKID = mfbi2.MANUAL_ID
        WHERE mfbi2.PKID = mf.FD_FILE_ID
          AND mfbi2.IS_DELETED = '0'
        <if test=" typeIdsByMfId != null  and typeIdsByMfId.size>0">
          AND xmbi2.TYPE_ID in 
          <foreach collection="typeIdsByMfId" item="typeId" open="(" separator="," close=")">
          #{typeId}
          </foreach>
        </if>
    )
  GROUP BY FD_FILE_ID ) w
  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi
  ON mfbi.PKID = w.FD_FILE_ID
  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID
  <where>
   mfbi.IS_DELETED = '0'
   <if test=" typeIdsByMfId != null  and typeIdsByMfId.size>0">
  and  xmbi.TYPE_ID in
  <foreach collection="typeIdsByMfId" item="typeId" open="(" separator="," close=")">
  #{typeId}
  </foreach>
   </if>
   and rownum <![CDATA[ <= ]]> 10
  </where>

[2025-12-12 15:25:59.491955] [Case:22][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (
  SELECT FD_FILE_ID, sum(countNumber) sumNumber FROM (
  SELECT FD_MODEL_ID,count(1) countNumber from
  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL
  <if test="startDate != null and startDate != ''">
   and FD_READ_TIME >= to_timestamp(#{startDate} || ' 00:00:00','yyyy-mm-dd hh24:mi:ss')
  </if>
  <if test="endDate != null and endDate != ''">
   and FD_READ_TIME &lt;= to_timestamp(#{endDate} || ' 23:59:59.999999','yyyy-mm-dd hh24:mi:ss.ff')
  </if>
  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID
  WHERE EXISTS (
        SELECT 1 
        FROM MANUAL_FILE_BASIC_INFO mfbi2 
        LEFT JOIN XMAIR_MANUAL_BASIC_INFO xmbi2 ON xmbi2.PKID = mfbi2.MANUAL_ID
        WHERE mfbi2.PKID = mf.FD_FILE_ID
          AND mfbi2.IS_DELETED = '0'
        <if test=" typeIdsByMfId != null  and typeIdsByMfId.size>0">
          AND xmbi2.TYPE_ID in 
          <foreach collection="typeIdsByMfId" item="typeId" open="(" separator="," close=")">
          #{typeId}
          </foreach>
        </if>
    )
  GROUP BY FD_FILE_ID ) w
  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi
  ON mfbi.PKID = w.FD_FILE_ID
  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID
  <where>
   mfbi.IS_DELETED = '0'
   <if test=" typeIdsByMfId != null  and typeIdsByMfId.size>0">
  and  xmbi.TYPE_ID in
  <foreach collection="typeIdsByMfId" item="typeId" open="(" separator="," close=")">
  #{typeId}
  </foreach>
   </if>
   and rownum <![CDATA[ <= ]]> 10
  </where>

[2025-12-12 15:25:59.493771] [Case:22][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT mfbi.pkid,mfbi.FD_FILE_NAME,mfbi.FD_NO fdNo,w.sumNumber countNumber FROM (
  SELECT FD_FILE_ID, sum(countNumber) sumNumber FROM (
  SELECT FD_MODEL_ID,count(1) countNumber from
  SYS_READ_HIS_LOG WHERE FD_MODEL_NAME= 'com.xmair.core.entity.DO.XmairManualFileNew' AND  FD_MODEL_ID IS NOT NULL
  <if test="startDate != null and startDate != ''">
   and FD_READ_TIME >= to_timestamp(#{startDate} || ' 00:00:00','yyyy-mm-dd hh24:mi:ss')
  </if>
  <if test="endDate != null and endDate != ''">
   and FD_READ_TIME &lt;= to_timestamp(#{endDate} || ' 23:59:59.999999','yyyy-mm-dd hh24:mi:ss.ff')
  </if>
  GROUP BY FD_MODEL_ID ) t LEFT JOIN MANUAL_FILE mf ON mf.FD_ID = t.FD_MODEL_ID
  WHERE EXISTS (
        SELECT 1 
        FROM MANUAL_FILE_BASIC_INFO mfbi2 
        LEFT JOIN XMAIR_MANUAL_BASIC_INFO xmbi2 ON xmbi2.PKID = mfbi2.MANUAL_ID
        WHERE mfbi2.PKID = mf.FD_FILE_ID
          AND mfbi2.IS_DELETED = '0'
        <if test=" typeIdsByMfId != null  and typeIdsByMfId.size>0">
          AND xmbi2.TYPE_ID in 
          <foreach collection="typeIdsByMfId" item="typeId" open="(" separator="," close=")">
          #{typeId}
          </foreach>
        </if>
    )
  GROUP BY FD_FILE_ID ) w
  LEFT JOIN MANUAL_FILE_BASIC_INFO mfbi
  ON mfbi.PKID = w.FD_FILE_ID
  left join XMAIR_MANUAL_BASIC_INFO xmbi  ON xmbi.PKID  = mfbi.MANUAL_ID
  <where>
   mfbi.IS_DELETED = '0'
   <if test=" typeIdsByMfId != null  and typeIdsByMfId.size>0">
  and  xmbi.TYPE_ID in
  <foreach collection="typeIdsByMfId" item="typeId" open="(" separator="," close=")">
  #{typeId}
  </foreach>
   </if>
   and rownum <![CDATA[ <= ]]> 10
  </where>

[2025-12-12 15:26:02.751328] [Case:22][Run:1] [o4-mini] Model Output Response:
{"answer":"no"}
[2025-12-12 15:26:05.673817] [Case:22][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:26:54.281753] [Case:22][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:26:54.285270] [22] hybrid Eval Final Result: False
[2025-12-12 15:26:54.324570] [Case:23][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState 
FROM mrtopration A 
INNER JOIN mrtrecordinfo B ON A.ID = B.ID 
LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID 
WHERE A.ID IN (SELECT bid FROM (SELECT B.ID AS bid, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn 
             FROM mrtrecordinfo B 
             WHERE TO_CHAR(B.ID) LIKE :"SYS_B_0" || :1 || :" SYS_B_1" 
               AND EXISTS (SELECT 1 FROM mrtopration A WHERE A.ID = B.ID) 
             GROUP BY B.ID, B.IN_DATE) 
             WHERE rn BETWEEN :2 + :"SYS_B_2" AND :3 + :4 ) 
ORDER BY A.OPERDATE DESC

[2025-12-12 15:26:54.335119] [Case:23][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState 
FROM mrtopration A 
INNER JOIN mrtrecordinfo B ON A.ID = B.ID 
LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID 
WHERE A.ID IN (SELECT bid FROM (SELECT B.ID AS bid, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn 
             FROM mrtrecordinfo B 
             WHERE TO_CHAR(B.ID) LIKE :"SYS_B_0" || :1 || :" SYS_B_1" 
               AND EXISTS (SELECT 1 FROM mrtopration A WHERE A.ID = B.ID) 
             GROUP BY B.ID, B.IN_DATE) 
             WHERE rn BETWEEN :2 + :"SYS_B_2" AND :3 + :4 ) 
ORDER BY A.OPERDATE DESC

[2025-12-12 15:26:54.422331] [Case:23][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT A.ID AS id, A.PRAMARYID AS primaryId, A.OPERCODE AS operCode, A.OPERNAME AS operName, A.OPERDEPT AS operDept, A.OPERDATE AS operDate, A.MARK AS mark, C.BACKREASON AS mark1, A.MARK2 AS mark2, A.MARK3 AS mark3, A.MARK4 AS mark4, A.OPERTYPE AS operType, A.NEXTOPERTYPE AS nextOperType, A.PREOPERTYPE AS preOperType, A.VALID AS valid, A.CONFIRMUSER AS confirmUser, A.CONFIRMDEPT AS confirmDept, A.VERSIONNUMBER AS versionNumber, B.IN_TIMES AS inTimes, B.NAME AS patient, B.IN_DATE AS inDate, B.OUT_DATE AS outDate, B.OUT_DEPT AS outDept, B.RECORD_STATE AS recordState 
FROM mrtopration A 
INNER JOIN mrtrecordinfo B ON A.ID = B.ID 
LEFT JOIN mrtrecordregresses C ON B.ID = C.RECODE_NO AND A.OPERDATE = C.OPER_DATE AND A.OPERCODE = C.OPERID 
WHERE A.ID IN (SELECT bid FROM (SELECT B.ID AS bid, ROW_NUMBER() OVER (ORDER BY B.IN_DATE DESC) AS rn 
             FROM mrtrecordinfo B 
             WHERE TO_CHAR(B.ID) LIKE :"SYS_B_0" || :1 || :" SYS_B_1" 
               AND EXISTS (SELECT 1 FROM mrtopration A WHERE A.ID = B.ID) 
             GROUP BY B.ID, B.IN_DATE) 
             WHERE rn BETWEEN :2 + :"SYS_B_2" AND :3 + :4 ) 
ORDER BY A.OPERDATE DESC

[2025-12-12 15:27:06.986252] [Case:23][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:27:14.131203] [Case:23][Run:1] [o4-mini] Model Output Response:
{"answer":"no"}
[2025-12-12 15:29:44.583319] [Case:23][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:29:44.584440] [23] hybrid Eval Final Result: False
[2025-12-12 15:29:44.585339] [Case:24][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT
  t1.inst_id,
  m.end_time AS checktime,
  t1.conn,
  t2.activeconn,
  m.sqlthroughput,
  m.sqlavgtime,
  m.user_commits,
  m.user_rollbacks,
  m.user_commits + m.user_rollbacks AS transactioncount,
  m.transactionavgtime
FROM
  (SELECT
    inst_id,
    COUNT(*) conn
  FROM
    gv$session
  WHERE
    TYPE = 'USER'
  GROUP BY
    inst_id
  ) t1,
  (SELECT
    inst_id,
    COUNT(*) activeconn
  FROM
    gv$session
  WHERE
    TYPE = 'USER'
    AND status = 'ACTIVE'
  GROUP BY
    inst_id
  ) t2,
  (
  SELECT
     *
  FROM
     (
    SELECT
    inst_id,
    end_time,
    metric_name,
    CASE
        WHEN metric_name IN ('Executions Per Sec','User Commits Per Sec','User Rollbacks Per Sec') 
            THEN round(VALUE, 2)
        WHEN metric_name IN ('SQL Service Response Time','Response Time Per Txn') 
            THEN round(VALUE * 10, 2)
    END VALUE
    FROM
    gv$sysmetric
    WHERE
    round(intsize_csec / 100, 0) = 60
    AND metric_name IN (
     'Executions Per Sec',
     'User Commits Per Sec',
     'User Rollbacks Per Sec',
     'SQL Service Response Time',
     'Response Time Per Txn'
    )
     ) PIVOT (
    AVG(VALUE) FOR metric_name IN (
    'Executions Per Sec' sqlthroughput,
    'SQL Service Response Time' sqlavgtime,
    'User Commits Per Sec' user_commits,
    'User Rollbacks Per Sec' user_rollbacks,
    'Response Time Per Txn' transactionavgtime
    )
     )
  ) m
WHERE
  t1.inst_id = t2.inst_id
  AND t1.inst_id = m.inst_id
ORDER BY
  inst_id

[2025-12-12 15:29:44.586097] [Case:24][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT
  t1.inst_id,
  m.end_time AS checktime,
  t1.conn,
  t2.activeconn,
  m.sqlthroughput,
  m.sqlavgtime,
  m.user_commits,
  m.user_rollbacks,
  m.user_commits + m.user_rollbacks AS transactioncount,
  m.transactionavgtime
FROM
  (SELECT
    inst_id,
    COUNT(*) conn
  FROM
    gv$session
  WHERE
    TYPE = 'USER'
  GROUP BY
    inst_id
  ) t1,
  (SELECT
    inst_id,
    COUNT(*) activeconn
  FROM
    gv$session
  WHERE
    TYPE = 'USER'
    AND status = 'ACTIVE'
  GROUP BY
    inst_id
  ) t2,
  (
  SELECT
     *
  FROM
     (
    SELECT
    inst_id,
    end_time,
    metric_name,
    CASE
        WHEN metric_name IN ('Executions Per Sec','User Commits Per Sec','User Rollbacks Per Sec') 
            THEN round(VALUE, 2)
        WHEN metric_name IN ('SQL Service Response Time','Response Time Per Txn') 
            THEN round(VALUE * 10, 2)
    END VALUE
    FROM
    gv$sysmetric
    WHERE
    round(intsize_csec / 100, 0) = 60
    AND metric_name IN (
     'Executions Per Sec',
     'User Commits Per Sec',
     'User Rollbacks Per Sec',
     'SQL Service Response Time',
     'Response Time Per Txn'
    )
     ) PIVOT (
    AVG(VALUE) FOR metric_name IN (
    'Executions Per Sec' sqlthroughput,
    'SQL Service Response Time' sqlavgtime,
    'User Commits Per Sec' user_commits,
    'User Rollbacks Per Sec' user_rollbacks,
    'Response Time Per Txn' transactionavgtime
    )
     )
  ) m
WHERE
  t1.inst_id = t2.inst_id
  AND t1.inst_id = m.inst_id
ORDER BY
  inst_id

[2025-12-12 15:29:44.587525] [Case:24][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT
  t1.inst_id,
  m.end_time AS checktime,
  t1.conn,
  t2.activeconn,
  m.sqlthroughput,
  m.sqlavgtime,
  m.user_commits,
  m.user_rollbacks,
  m.user_commits + m.user_rollbacks AS transactioncount,
  m.transactionavgtime
FROM
  (SELECT
    inst_id,
    COUNT(*) conn
  FROM
    gv$session
  WHERE
    TYPE = 'USER'
  GROUP BY
    inst_id
  ) t1,
  (SELECT
    inst_id,
    COUNT(*) activeconn
  FROM
    gv$session
  WHERE
    TYPE = 'USER'
    AND status = 'ACTIVE'
  GROUP BY
    inst_id
  ) t2,
  (
  SELECT
     *
  FROM
     (
    SELECT
    inst_id,
    end_time,
    metric_name,
    CASE
        WHEN metric_name IN ('Executions Per Sec','User Commits Per Sec','User Rollbacks Per Sec') 
            THEN round(VALUE, 2)
        WHEN metric_name IN ('SQL Service Response Time','Response Time Per Txn') 
            THEN round(VALUE * 10, 2)
    END VALUE
    FROM
    gv$sysmetric
    WHERE
    round(intsize_csec / 100, 0) = 60
    AND metric_name IN (
     'Executions Per Sec',
     'User Commits Per Sec',
     'User Rollbacks Per Sec',
     'SQL Service Response Time',
     'Response Time Per Txn'
    )
     ) PIVOT (
    AVG(VALUE) FOR metric_name IN (
    'Executions Per Sec' sqlthroughput,
    'SQL Service Response Time' sqlavgtime,
    'User Commits Per Sec' user_commits,
    'User Rollbacks Per Sec' user_rollbacks,
    'Response Time Per Txn' transactionavgtime
    )
     )
  ) m
WHERE
  t1.inst_id = t2.inst_id
  AND t1.inst_id = m.inst_id
ORDER BY
  inst_id

[2025-12-12 15:29:56.705081] [Case:24][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:29:58.424850] [Case:24][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:32:22.431013] [Case:24][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:32:22.437066] [24] hybrid Eval Final Result: True
[2025-12-12 15:32:22.441749] [Case:25][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT acctg.tenant_id, acctg.gl_account_id, ac.code, acctg.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg LEFT JOIN gl_account_balance A ON (A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id) AND A.tenant_id = 1065587309019136 LEFT JOIN gl_account ac ON (ac.id = acctg.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (acctg.base_posted_dr1 != ifnull(A.base_posted_dr, 0) OR acctg.base_posted_cr1 != ifnull(A.base_posted_cr, 0)) UNION SELECT A.tenant_id, A.gl_account_id, ac.code, A.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM gl_account_balance A LEFT JOIN (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id LEFT JOIN gl_account ac ON (ac.id = A.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND A.acctg_period NOT LIKE '%00' AND (A.base_posted_dr != ifnull(acctg.base_posted_dr1, 0) OR A.base_posted_cr != ifnull(acctg.base_posted_cr1, 0))) AND A.tenant_id = 1065587309019136 LIMIT 50001;

[2025-12-12 15:32:22.442618] [Case:25][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT acctg.tenant_id, acctg.gl_account_id, ac.code, acctg.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg LEFT JOIN gl_account_balance A ON (A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id) AND A.tenant_id = 1065587309019136 LEFT JOIN gl_account ac ON (ac.id = acctg.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (acctg.base_posted_dr1 != ifnull(A.base_posted_dr, 0) OR acctg.base_posted_cr1 != ifnull(A.base_posted_cr, 0)) UNION SELECT A.tenant_id, A.gl_account_id, ac.code, A.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM gl_account_balance A LEFT JOIN (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id LEFT JOIN gl_account ac ON (ac.id = A.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND A.acctg_period NOT LIKE '%00' AND (A.base_posted_dr != ifnull(acctg.base_posted_dr1, 0) OR A.base_posted_cr != ifnull(acctg.base_posted_cr1, 0))) AND A.tenant_id = 1065587309019136 LIMIT 50001;

[2025-12-12 15:32:22.445677] [Case:25][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT acctg.tenant_id, acctg.gl_account_id, ac.code, acctg.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg LEFT JOIN gl_account_balance A ON (A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id) AND A.tenant_id = 1065587309019136 LEFT JOIN gl_account ac ON (ac.id = acctg.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (acctg.base_posted_dr1 != ifnull(A.base_posted_dr, 0) OR acctg.base_posted_cr1 != ifnull(A.base_posted_cr, 0)) UNION SELECT A.tenant_id, A.gl_account_id, ac.code, A.acctg_period, A.base_posted_dr, A.base_posted_cr, acctg.base_posted_dr1, acctg.base_posted_cr1 FROM gl_account_balance A LEFT JOIN (SELECT A.tenant_id, A.gl_account_id, B.acctg_period, sum(A.base_posted_dr) AS base_posted_dr1, sum(base_posted_cr) AS base_posted_cr1 FROM acctg_trans_detail A LEFT JOIN acctg_trans B ON (A.master_voucher_id = B.id AND A.tenant_id = B.tenant_id) AND B.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND (voucher_status_enum IS NULL OR voucher_status_enum != 'CANCELLED') AND (B.bo_name IS NULL OR B.bo_name != 'DraftAcctgTrans')) AND A.tenant_id = 1065587309019136 GROUP BY tenant_id, A.gl_account_id, B.acctg_period) acctg ON A.gl_account_id = acctg.gl_account_id AND A.acctg_period = acctg.acctg_period AND A.tenant_id = acctg.tenant_id LEFT JOIN gl_account ac ON (ac.id = A.gl_account_id) AND ac.tenant_id = 1065587309019136 WHERE (A.tenant_id = 1065587309019136 AND A.acctg_period NOT LIKE '%00' AND (A.base_posted_dr != ifnull(acctg.base_posted_dr1, 0) OR A.base_posted_cr != ifnull(acctg.base_posted_cr1, 0))) AND A.tenant_id = 1065587309019136 LIMIT 50001;

[2025-12-12 15:32:43.799723] [Case:25][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:32:51.238868] [Case:25][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:34:08.884446] [Case:25][Run:1] [deepseek-r1] Model Output Response:
{"answer": "yes"}
[2025-12-12 15:34:08.885760] [25] hybrid Eval Final Result: True
[2025-12-12 15:34:08.887414] [Case:26][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select
    'lxzdqdwjf5nys',
    '连续在当前单位参保5年以上',
    c.aac147,
    '是',
    '连续在当前单位参保5年以上'
from
    (
        select a.* 
        from dwd_csi_ac02 a
        where a.aae140 = '110'
          and a.aac008 = '1'
          and a.aac031 = '1'
          and a.aac030 <= (fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)|| '31')::numeric
          and a.aae041 <= fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)::numeric
          and (a.aae042 >= to_char(current_timestamp, 'yyyymm')::numeric or a.aae042 is null)
    ) a,
    (
        select * 
        from dwd_hrss_ac99 c 
        where c.aac147 is not null
    ) c
where a.aac001 = c.aac001::varchar
limit 1

[2025-12-12 15:34:08.888454] [Case:26][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select
    'lxzdqdwjf5nys',
    '连续在当前单位参保5年以上',
    c.aac147,
    '是',
    '连续在当前单位参保5年以上'
from
    (
        select a.* 
        from dwd_csi_ac02 a
        where a.aae140 = '110'
          and a.aac008 = '1'
          and a.aac031 = '1'
          and a.aac030 <= (fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)|| '31')::numeric
          and a.aae041 <= fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)::numeric
          and (a.aae042 >= to_char(current_timestamp, 'yyyymm')::numeric or a.aae042 is null)
    ) a,
    (
        select * 
        from dwd_hrss_ac99 c 
        where c.aac147 is not null
    ) c
where a.aac001 = c.aac001::varchar
limit 1

[2025-12-12 15:34:08.889606] [Case:26][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select
    'lxzdqdwjf5nys',
    '连续在当前单位参保5年以上',
    c.aac147,
    '是',
    '连续在当前单位参保5年以上'
from
    (
        select a.* 
        from dwd_csi_ac02 a
        where a.aae140 = '110'
          and a.aac008 = '1'
          and a.aac031 = '1'
          and a.aac030 <= (fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)|| '31')::numeric
          and a.aae041 <= fun_addmonth(to_char(current_timestamp, 'yyyymm')::varchar,-61)::numeric
          and (a.aae042 >= to_char(current_timestamp, 'yyyymm')::numeric or a.aae042 is null)
    ) a,
    (
        select * 
        from dwd_hrss_ac99 c 
        where c.aac147 is not null
    ) c
where a.aac001 = c.aac001::varchar
limit 1

[2025-12-12 15:34:17.768225] [Case:26][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:34:22.287638] [Case:26][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:35:30.781974] [Case:26][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:35:30.783606] [26] hybrid Eval Final Result: True
[2025-12-12 15:35:30.785367] [Case:27][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
with temp as(
    select ct.member_num, ct.balance
    from cash_transaction ct
    inner join (
        select member_num, max(id) as max_id
        from cash_transaction
        where cash_type=2
        group by member_num
    ) t_max on ct.id = t_max.max_id
    where ct.balance <> 0.00
)
select * from temp a 
full outer join
( select member_num,credit_available from  cash where  credit_available<>0 ) b
on a.member_num = b.member_num
where a.balance <> b.credit_available
   or a.member_num is null
   or b.member_num is null

[2025-12-12 15:35:30.786690] [Case:27][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
with temp as(
    select ct.member_num, ct.balance
    from cash_transaction ct
    inner join (
        select member_num, max(id) as max_id
        from cash_transaction
        where cash_type=2
        group by member_num
    ) t_max on ct.id = t_max.max_id
    where ct.balance <> 0.00
)
select * from temp a 
full outer join
( select member_num,credit_available from  cash where  credit_available<>0 ) b
on a.member_num = b.member_num
where a.balance <> b.credit_available
   or a.member_num is null
   or b.member_num is null

[2025-12-12 15:35:30.787709] [Case:27][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
with temp as(
    select ct.member_num, ct.balance
    from cash_transaction ct
    inner join (
        select member_num, max(id) as max_id
        from cash_transaction
        where cash_type=2
        group by member_num
    ) t_max on ct.id = t_max.max_id
    where ct.balance <> 0.00
)
select * from temp a 
full outer join
( select member_num,credit_available from  cash where  credit_available<>0 ) b
on a.member_num = b.member_num
where a.balance <> b.credit_available
   or a.member_num is null
   or b.member_num is null

[2025-12-12 15:35:34.750271] [Case:27][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:35:38.354500] [Case:27][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:36:47.391161] [Case:27][Run:1] [deepseek-r1] Model Output Response:
```{
  "answer": "yes"
}
[2025-12-12 15:36:47.392765] [27] hybrid Eval Final Result: True
[2025-12-12 15:36:47.395206] [Case:28][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT DISTINCT accounts.acc_account_no, 
  accounts.acc_subacc_no, 
  account_headers.acch_title,
  to_char(accounts.acc_incep_date,'DD/MM/YYYY') acc_incep_date,
  htax.ACCTAX_EFF_DATE_FROM,
  to_char(audit_header.audh_date, 'DD-MON-YYYY') approved_date,
  account_types.act_long_name, 
  transactions.tran_amount_cr,
  transactions.tran_create_by,
  CASE WHEN (trunc(accounts.acc_incep_date) - trunc(audit_header.audh_date)) < 0 THEN 0 ELSE
   (trunc(accounts.acc_incep_date) - trunc(audit_header.audh_date)) END time_on_approved,
  account_headers.acch_brn_code
  FROM accounts 
  JOIN account_headers ON account_headers.acch_account_no = accounts.acc_account_no
  JOIN account_types ON accounts.acc_act_code = account_types.act_code
  JOIN 
   (
  SELECT tran_account_no, tran_subacc_no, min(tran_seqno) first_tran_seq
  FROM transactions
  WHERE tran_amount_cr IS NOT NULL
  AND tran_trans_code IN ('RIC','RSAV')
  AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE
  AND tran_pay_method not in ('C','CQ')   --Exclude cash and cheque receipts as those accounts will already have the passbook.
  GROUP BY tran_account_no, tran_subacc_no
   ) first_trans
   ON first_trans.tran_account_no = accounts.acc_account_no AND first_trans.tran_subacc_no = accounts.acc_subacc_no
  JOIN transactions ON transactions.tran_seqno = first_trans.first_tran_seq
  JOIN audit_header ON accounts.acc_account_no = audit_header.audh_key1
   AND accounts.acc_subacc_no = audit_header.audh_key2
  JOIN audit_detail
   ON audit_header.audh_seqno = audit_detail.audd_audh_seqno
   AND audit_header.audh_table_prefix = 'ACC'
   AND audit_detail.audd_col_sufix = 'PROCESS_STATUS'
   AND audit_header.audh_change_type  = 'I'
   AND audit_detail.audd_old_value IS NULL 
   AND audit_detail.audd_new_value = TO_NUMBER(1)
   JOIN ACCOUNT_LINKS al ON al.accl_account_no = accounts.ACC_ACCOUNT_NO and al.accl_subacc_no = accounts.ACC_SUBACC_NO and al.accl_holder_pos = 1
   JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax 
  ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO
   AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO
   AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO
  WHERE accounts.acc_gact_type IN ('S', 'IC') 
   AND accounts.acc_incep_date BETWEEN TO_DATE(IN_INCEP_FROM_DATE, 'YYYY-MM-DD') and TO_DATE(IN_INCEP_TO_DATE, 'YYYY-MM-DD')

[2025-12-12 15:36:47.396018] [Case:28][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT DISTINCT accounts.acc_account_no, 
  accounts.acc_subacc_no, 
  account_headers.acch_title,
  to_char(accounts.acc_incep_date,'DD/MM/YYYY') acc_incep_date,
  htax.ACCTAX_EFF_DATE_FROM,
  to_char(audit_header.audh_date, 'DD-MON-YYYY') approved_date,
  account_types.act_long_name, 
  transactions.tran_amount_cr,
  transactions.tran_create_by,
  CASE WHEN (trunc(accounts.acc_incep_date) - trunc(audit_header.audh_date)) < 0 THEN 0 ELSE
   (trunc(accounts.acc_incep_date) - trunc(audit_header.audh_date)) END time_on_approved,
  account_headers.acch_brn_code
  FROM accounts 
  JOIN account_headers ON account_headers.acch_account_no = accounts.acc_account_no
  JOIN account_types ON accounts.acc_act_code = account_types.act_code
  JOIN 
   (
  SELECT tran_account_no, tran_subacc_no, min(tran_seqno) first_tran_seq
  FROM transactions
  WHERE tran_amount_cr IS NOT NULL
  AND tran_trans_code IN ('RIC','RSAV')
  AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE
  AND tran_pay_method not in ('C','CQ')   --Exclude cash and cheque receipts as those accounts will already have the passbook.
  GROUP BY tran_account_no, tran_subacc_no
   ) first_trans
   ON first_trans.tran_account_no = accounts.acc_account_no AND first_trans.tran_subacc_no = accounts.acc_subacc_no
  JOIN transactions ON transactions.tran_seqno = first_trans.first_tran_seq
  JOIN audit_header ON accounts.acc_account_no = audit_header.audh_key1
   AND accounts.acc_subacc_no = audit_header.audh_key2
  JOIN audit_detail
   ON audit_header.audh_seqno = audit_detail.audd_audh_seqno
   AND audit_header.audh_table_prefix = 'ACC'
   AND audit_detail.audd_col_sufix = 'PROCESS_STATUS'
   AND audit_header.audh_change_type  = 'I'
   AND audit_detail.audd_old_value IS NULL 
   AND audit_detail.audd_new_value = TO_NUMBER(1)
   JOIN ACCOUNT_LINKS al ON al.accl_account_no = accounts.ACC_ACCOUNT_NO and al.accl_subacc_no = accounts.ACC_SUBACC_NO and al.accl_holder_pos = 1
   JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax 
  ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO
   AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO
   AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO
  WHERE accounts.acc_gact_type IN ('S', 'IC') 
   AND accounts.acc_incep_date BETWEEN TO_DATE(IN_INCEP_FROM_DATE, 'YYYY-MM-DD') and TO_DATE(IN_INCEP_TO_DATE, 'YYYY-MM-DD')

[2025-12-12 15:36:47.397821] [Case:28][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT DISTINCT accounts.acc_account_no, 
  accounts.acc_subacc_no, 
  account_headers.acch_title,
  to_char(accounts.acc_incep_date,'DD/MM/YYYY') acc_incep_date,
  htax.ACCTAX_EFF_DATE_FROM,
  to_char(audit_header.audh_date, 'DD-MON-YYYY') approved_date,
  account_types.act_long_name, 
  transactions.tran_amount_cr,
  transactions.tran_create_by,
  CASE WHEN (trunc(accounts.acc_incep_date) - trunc(audit_header.audh_date)) < 0 THEN 0 ELSE
   (trunc(accounts.acc_incep_date) - trunc(audit_header.audh_date)) END time_on_approved,
  account_headers.acch_brn_code
  FROM accounts 
  JOIN account_headers ON account_headers.acch_account_no = accounts.acc_account_no
  JOIN account_types ON accounts.acc_act_code = account_types.act_code
  JOIN 
   (
  SELECT tran_account_no, tran_subacc_no, min(tran_seqno) first_tran_seq
  FROM transactions
  WHERE tran_amount_cr IS NOT NULL
  AND tran_trans_code IN ('RIC','RSAV')
  AND tran_date BETWEEN IN_FUND_FROM_DATE AND IN_FUND_TO_DATE
  AND tran_pay_method not in ('C','CQ')   --Exclude cash and cheque receipts as those accounts will already have the passbook.
  GROUP BY tran_account_no, tran_subacc_no
   ) first_trans
   ON first_trans.tran_account_no = accounts.acc_account_no AND first_trans.tran_subacc_no = accounts.acc_subacc_no
  JOIN transactions ON transactions.tran_seqno = first_trans.first_tran_seq
  JOIN audit_header ON accounts.acc_account_no = audit_header.audh_key1
   AND accounts.acc_subacc_no = audit_header.audh_key2
  JOIN audit_detail
   ON audit_header.audh_seqno = audit_detail.audd_audh_seqno
   AND audit_header.audh_table_prefix = 'ACC'
   AND audit_detail.audd_col_sufix = 'PROCESS_STATUS'
   AND audit_header.audh_change_type  = 'I'
   AND audit_detail.audd_old_value IS NULL 
   AND audit_detail.audd_new_value = TO_NUMBER(1)
   JOIN ACCOUNT_LINKS al ON al.accl_account_no = accounts.ACC_ACCOUNT_NO and al.accl_subacc_no = accounts.ACC_SUBACC_NO and al.accl_holder_pos = 1
   JOIN SUMMIT.ACCOUNT_HOLDING_TAX htax 
  ON htax.ACCTAX_ACCOUNT_NO = al.ACCL_ACCOUNT_NO
   AND htax.ACCTAX_SUBACC_NO = al.ACCL_SUBACC_NO
   AND htax.ACCTAX_CUST_SEQNO = al.ACCL_CUST_SEQNO
  WHERE accounts.acc_gact_type IN ('S', 'IC') 
   AND accounts.acc_incep_date BETWEEN TO_DATE(IN_INCEP_FROM_DATE, 'YYYY-MM-DD') and TO_DATE(IN_INCEP_TO_DATE, 'YYYY-MM-DD')

[2025-12-12 15:37:01.032625] [Case:28][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:37:11.325757] [Case:28][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:38:36.972919] [Case:28][Run:1] [deepseek-r1] Model Output Response:
{"answer": "yes"}
[2025-12-12 15:38:36.973855] [28] hybrid Eval Final Result: True
[2025-12-12 15:38:36.975421] [Case:29][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select
  count(*)
from
  (
  select
   1
  from
   (
  select
  t3.jobid,
  t3.createtime,
  row_number() over (
   partition by
  t3.jobid
   order by
  t3.createtime desc
  ) as rn
  from
  jobinfo_his t3
  where
  exists (
   select
  1
   from
  jobinfo_his t2
   where
  t2.jobid = t3.jobid
  and substr(t2.jobid, 0, 1) = 'A'
  and exists (
  select
   1
  from
   jobinfo_his t1
  where
   t1.jobid = t2.jobid
   and t1.jobstatus = 'O'
  )
  and not exists (
  select
   1
  from
   jobinfo_his t4
  where
   t4.jobid = t2.jobid
   and t4.jobstatus = 'N'
  )
  )
   ) tt
  where
   tt.rn = 1
  union all
  select
   1
  from
   (select * from jobinfo_his where jobstatus='O') t,
   businodeinst t1,
   (select * from busiflowinst where status='1') t2
  where
   t.jobid = t1.nodeinstid
   and t1.flowinstid = t2.flowinstid
  )

[2025-12-12 15:38:36.976213] [Case:29][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select
  count(*)
from
  (
  select
   1
  from
   (
  select
  t3.jobid,
  t3.createtime,
  row_number() over (
   partition by
  t3.jobid
   order by
  t3.createtime desc
  ) as rn
  from
  jobinfo_his t3
  where
  exists (
   select
  1
   from
  jobinfo_his t2
   where
  t2.jobid = t3.jobid
  and substr(t2.jobid, 0, 1) = 'A'
  and exists (
  select
   1
  from
   jobinfo_his t1
  where
   t1.jobid = t2.jobid
   and t1.jobstatus = 'O'
  )
  and not exists (
  select
   1
  from
   jobinfo_his t4
  where
   t4.jobid = t2.jobid
   and t4.jobstatus = 'N'
  )
  )
   ) tt
  where
   tt.rn = 1
  union all
  select
   1
  from
   (select * from jobinfo_his where jobstatus='O') t,
   businodeinst t1,
   (select * from busiflowinst where status='1') t2
  where
   t.jobid = t1.nodeinstid
   and t1.flowinstid = t2.flowinstid
  )

[2025-12-12 15:38:36.976722] [Case:29][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select
  count(*)
from
  (
  select
   1
  from
   (
  select
  t3.jobid,
  t3.createtime,
  row_number() over (
   partition by
  t3.jobid
   order by
  t3.createtime desc
  ) as rn
  from
  jobinfo_his t3
  where
  exists (
   select
  1
   from
  jobinfo_his t2
   where
  t2.jobid = t3.jobid
  and substr(t2.jobid, 0, 1) = 'A'
  and exists (
  select
   1
  from
   jobinfo_his t1
  where
   t1.jobid = t2.jobid
   and t1.jobstatus = 'O'
  )
  and not exists (
  select
   1
  from
   jobinfo_his t4
  where
   t4.jobid = t2.jobid
   and t4.jobstatus = 'N'
  )
  )
   ) tt
  where
   tt.rn = 1
  union all
  select
   1
  from
   (select * from jobinfo_his where jobstatus='O') t,
   businodeinst t1,
   (select * from busiflowinst where status='1') t2
  where
   t.jobid = t1.nodeinstid
   and t1.flowinstid = t2.flowinstid
  )

[2025-12-12 15:38:48.281056] [Case:29][Run:1] [o4-mini] Model Output Response:
{"answer":"no"}
[2025-12-12 15:38:57.660480] [Case:29][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:39:18.671698] [Case:29][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:39:18.672747] [29] hybrid Eval Final Result: False
[2025-12-12 15:39:18.674132] [Case:30][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
WITH nortran_data AS (
  SELECT
    nortran_transaction_no,
    nortran_posn,
    MAX(CASE WHEN nortran_aufd_code = 'PEBEMPL_CURRENT_HIRE_DATE' THEN nortran_value END) AS n1_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' THEN nortran_value END) AS n2_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_SGRP_CODE' THEN nortran_value END) AS n3_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_APPT_PCT' THEN nortran_value END) AS n4_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_ANN_SALARY' THEN nortran_value END) AS n5_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_EFFECTIVE_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) AS n6_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) AS n7_value
  FROM nortran
  WHERE nortran_posn IS NOT NULL
  GROUP BY nortran_transaction_no, nortran_posn
)
select s.spriden_id EID,
  s.spriden_last_name ||', '||s.spriden_first_name "NAME",
  b.nobtran_transaction_no "TRANS NO.",
  z.nortran_posn "POSN NO",
  b.nobtran_effective_date "QUERY DATE", 
  b.nobtran_acat_code "ACAT CODE",
  n.n1_value "CURRENT HIRE DATE",
  n.n2_value "BEGIN PERSONNEL DATE",
  n.n3_value "SALARY GROUP",
  n.n4_value "APPOINTMENT PERCENT",
  n.n5_value "ANNUAL SALARY",
  n.n6_value "END JOB EFFECTIVE DATE",
  n.n7_value "END PERSONNEL DATE",
  t1.nortern_effective_date "PAY DATA EFFECTIVE DATE",
  t1.nortern_earn_code "PAY DATA EARNINGS",
  t1.nortern_hrs "PAY DATA HOURS",
  t1.nortern_special_rate "PAY DATA SPECIAL RATE",
   case b.nobtran_trans_status_ind
   when 'A' then 'Approved'
   when 'C' then 'Completed'
   when 'V' then 'Voided' 
   when 'D' then 'Disapproved'
   when 'R' then 'Return for Correction'
   when 'P' then 'Pending'
   when 'W' then 'Waiting'
   when 'T' then 'Partially Completed'
   when 'N' then 'Cancelled'
   when 'U' then 'Superuser Update'
  end trans_status   
  ,case r.norrout_queue_status_ind
   when 'A' then 'Approved by that Approver'
   when 'D' then 'Disapproved'
   when 'F' then 'FYI'
   when 'I' then 'In Queue'
   when 'K' then 'Acknowledged'
   when 'L' then 'Applied by Applier'
   when 'M' then 'More Information'
   when 'O' then 'Overridden'
   when 'P' then 'Pending Action by Approver/Applier '
   when 'Q' then 'Removed from Queue'
   when 'R' then 'Return for Correction'
  end queue_status
  ,r.norrout_level_no

  from nobtran b
  JOIN spriden s ON b.nobtran_pidm = s.spriden_pidm
  JOIN pebempl pp ON s.spriden_pidm = pp.pebempl_pidm
  LEFT JOIN nortran_data z ON b.nobtran_transaction_no = z.nortran_transaction_no
  LEFT JOIN nortran_data n ON b.nobtran_transaction_no = n.nortran_transaction_no
  LEFT JOIN nortern t1 ON b.nobtran_transaction_no = t1.nortern_transaction_no
  LEFT JOIN norrout r ON b.nobtran_transaction_no = r.norrout_transaction_no
 where b.nobtran_acat_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')
   and s.spriden_change_ind is null
   and r.norrout_level_no = 90
   and b.nobtran_apply_ind = 'N'
   and b.nobtran_trans_status_ind <> 'V'
   and r.norrout_queue_status_ind <> 'A'
   and pp.pebempl_ecls_code not in ('RE','FW','GS','MW')
   order by 3

[2025-12-12 15:39:18.675433] [Case:30][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
WITH nortran_data AS (
  SELECT
    nortran_transaction_no,
    nortran_posn,
    MAX(CASE WHEN nortran_aufd_code = 'PEBEMPL_CURRENT_HIRE_DATE' THEN nortran_value END) AS n1_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' THEN nortran_value END) AS n2_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_SGRP_CODE' THEN nortran_value END) AS n3_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_APPT_PCT' THEN nortran_value END) AS n4_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_ANN_SALARY' THEN nortran_value END) AS n5_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_EFFECTIVE_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) AS n6_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) AS n7_value
  FROM nortran
  WHERE nortran_posn IS NOT NULL
  GROUP BY nortran_transaction_no, nortran_posn
)
select s.spriden_id EID,
  s.spriden_last_name ||', '||s.spriden_first_name "NAME",
  b.nobtran_transaction_no "TRANS NO.",
  z.nortran_posn "POSN NO",
  b.nobtran_effective_date "QUERY DATE", 
  b.nobtran_acat_code "ACAT CODE",
  n.n1_value "CURRENT HIRE DATE",
  n.n2_value "BEGIN PERSONNEL DATE",
  n.n3_value "SALARY GROUP",
  n.n4_value "APPOINTMENT PERCENT",
  n.n5_value "ANNUAL SALARY",
  n.n6_value "END JOB EFFECTIVE DATE",
  n.n7_value "END PERSONNEL DATE",
  t1.nortern_effective_date "PAY DATA EFFECTIVE DATE",
  t1.nortern_earn_code "PAY DATA EARNINGS",
  t1.nortern_hrs "PAY DATA HOURS",
  t1.nortern_special_rate "PAY DATA SPECIAL RATE",
   case b.nobtran_trans_status_ind
   when 'A' then 'Approved'
   when 'C' then 'Completed'
   when 'V' then 'Voided' 
   when 'D' then 'Disapproved'
   when 'R' then 'Return for Correction'
   when 'P' then 'Pending'
   when 'W' then 'Waiting'
   when 'T' then 'Partially Completed'
   when 'N' then 'Cancelled'
   when 'U' then 'Superuser Update'
  end trans_status   
  ,case r.norrout_queue_status_ind
   when 'A' then 'Approved by that Approver'
   when 'D' then 'Disapproved'
   when 'F' then 'FYI'
   when 'I' then 'In Queue'
   when 'K' then 'Acknowledged'
   when 'L' then 'Applied by Applier'
   when 'M' then 'More Information'
   when 'O' then 'Overridden'
   when 'P' then 'Pending Action by Approver/Applier '
   when 'Q' then 'Removed from Queue'
   when 'R' then 'Return for Correction'
  end queue_status
  ,r.norrout_level_no

  from nobtran b
  JOIN spriden s ON b.nobtran_pidm = s.spriden_pidm
  JOIN pebempl pp ON s.spriden_pidm = pp.pebempl_pidm
  LEFT JOIN nortran_data z ON b.nobtran_transaction_no = z.nortran_transaction_no
  LEFT JOIN nortran_data n ON b.nobtran_transaction_no = n.nortran_transaction_no
  LEFT JOIN nortern t1 ON b.nobtran_transaction_no = t1.nortern_transaction_no
  LEFT JOIN norrout r ON b.nobtran_transaction_no = r.norrout_transaction_no
 where b.nobtran_acat_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')
   and s.spriden_change_ind is null
   and r.norrout_level_no = 90
   and b.nobtran_apply_ind = 'N'
   and b.nobtran_trans_status_ind <> 'V'
   and r.norrout_queue_status_ind <> 'A'
   and pp.pebempl_ecls_code not in ('RE','FW','GS','MW')
   order by 3

[2025-12-12 15:39:18.676110] [Case:30][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
WITH nortran_data AS (
  SELECT
    nortran_transaction_no,
    nortran_posn,
    MAX(CASE WHEN nortran_aufd_code = 'PEBEMPL_CURRENT_HIRE_DATE' THEN nortran_value END) AS n1_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' THEN nortran_value END) AS n2_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_SGRP_CODE' THEN nortran_value END) AS n3_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_APPT_PCT' THEN nortran_value END) AS n4_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_ANN_SALARY' THEN nortran_value END) AS n5_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_EFFECTIVE_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) AS n6_value,
    MAX(CASE WHEN nortran_aufd_code = 'NBRJOBS_PERS_CHG_DATE' AND nortran_apty_code IN ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM') THEN nortran_value END) AS n7_value
  FROM nortran
  WHERE nortran_posn IS NOT NULL
  GROUP BY nortran_transaction_no, nortran_posn
)
select s.spriden_id EID,
  s.spriden_last_name ||', '||s.spriden_first_name "NAME",
  b.nobtran_transaction_no "TRANS NO.",
  z.nortran_posn "POSN NO",
  b.nobtran_effective_date "QUERY DATE", 
  b.nobtran_acat_code "ACAT CODE",
  n.n1_value "CURRENT HIRE DATE",
  n.n2_value "BEGIN PERSONNEL DATE",
  n.n3_value "SALARY GROUP",
  n.n4_value "APPOINTMENT PERCENT",
  n.n5_value "ANNUAL SALARY",
  n.n6_value "END JOB EFFECTIVE DATE",
  n.n7_value "END PERSONNEL DATE",
  t1.nortern_effective_date "PAY DATA EFFECTIVE DATE",
  t1.nortern_earn_code "PAY DATA EARNINGS",
  t1.nortern_hrs "PAY DATA HOURS",
  t1.nortern_special_rate "PAY DATA SPECIAL RATE",
   case b.nobtran_trans_status_ind
   when 'A' then 'Approved'
   when 'C' then 'Completed'
   when 'V' then 'Voided' 
   when 'D' then 'Disapproved'
   when 'R' then 'Return for Correction'
   when 'P' then 'Pending'
   when 'W' then 'Waiting'
   when 'T' then 'Partially Completed'
   when 'N' then 'Cancelled'
   when 'U' then 'Superuser Update'
  end trans_status   
  ,case r.norrout_queue_status_ind
   when 'A' then 'Approved by that Approver'
   when 'D' then 'Disapproved'
   when 'F' then 'FYI'
   when 'I' then 'In Queue'
   when 'K' then 'Acknowledged'
   when 'L' then 'Applied by Applier'
   when 'M' then 'More Information'
   when 'O' then 'Overridden'
   when 'P' then 'Pending Action by Approver/Applier '
   when 'Q' then 'Removed from Queue'
   when 'R' then 'Return for Correction'
  end queue_status
  ,r.norrout_level_no

  from nobtran b
  JOIN spriden s ON b.nobtran_pidm = s.spriden_pidm
  JOIN pebempl pp ON s.spriden_pidm = pp.pebempl_pidm
  LEFT JOIN nortran_data z ON b.nobtran_transaction_no = z.nortran_transaction_no
  LEFT JOIN nortran_data n ON b.nobtran_transaction_no = n.nortran_transaction_no
  LEFT JOIN nortern t1 ON b.nobtran_transaction_no = t1.nortern_transaction_no
  LEFT JOIN norrout r ON b.nobtran_transaction_no = r.norrout_transaction_no
 where b.nobtran_acat_code in ('CFOAP','NWHIR','NWTMP','ADCOMP','JBTERM')
   and s.spriden_change_ind is null
   and r.norrout_level_no = 90
   and b.nobtran_apply_ind = 'N'
   and b.nobtran_trans_status_ind <> 'V'
   and r.norrout_queue_status_ind <> 'A'
   and pp.pebempl_ecls_code not in ('RE','FW','GS','MW')
   order by 3

[2025-12-12 15:39:29.622220] [Case:30][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:39:49.807744] [Case:30][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:40:08.578308] [Case:30][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:40:08.579726] [30] hybrid Eval Final Result: True
[2025-12-12 15:40:08.581587] [Case:31][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT
  t.age,
  CASE 
  WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days'
  WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days'
  ELSE 'Above 7 Days'
  END AS age_bucket,
  t.amount_local,
  t.hkont AS gl_account,
  t.bukrs AS company_code
FROM (
  SELECT /*+ FIRST_ROWS(30) */ 
    b.BUKRS,
    b.HKONT,
    b.DMBTR AS amount_local,
    (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age
  FROM SAPR3.BSIS b
  JOIN SAPR3.BKPF k
     ON b.BELNR = k.BELNR
  WHERE b.GJAHR = '2025'
    AND b.BUKRS = '0100'
    AND b.HKONT = '0000895200'
    AND b.MANDT = '500'
    AND b.BUZEI = '002'
    AND b.WAERS = 'INR'
    AND b.MONAT = '01'
    AND b.BLDAT = '20240401'
    AND k.BUKRS = '0100'
    AND k.GJAHR = '2025'
) t
ORDER BY t.age;

[2025-12-12 15:40:08.582652] [Case:31][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT
  t.age,
  CASE 
  WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days'
  WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days'
  ELSE 'Above 7 Days'
  END AS age_bucket,
  t.amount_local,
  t.hkont AS gl_account,
  t.bukrs AS company_code
FROM (
  SELECT /*+ FIRST_ROWS(30) */ 
    b.BUKRS,
    b.HKONT,
    b.DMBTR AS amount_local,
    (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age
  FROM SAPR3.BSIS b
  JOIN SAPR3.BKPF k
     ON b.BELNR = k.BELNR
  WHERE b.GJAHR = '2025'
    AND b.BUKRS = '0100'
    AND b.HKONT = '0000895200'
    AND b.MANDT = '500'
    AND b.BUZEI = '002'
    AND b.WAERS = 'INR'
    AND b.MONAT = '01'
    AND b.BLDAT = '20240401'
    AND k.BUKRS = '0100'
    AND k.GJAHR = '2025'
) t
ORDER BY t.age;

[2025-12-12 15:40:08.583093] [Case:31][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT
  t.age,
  CASE 
  WHEN t.age BETWEEN 0 AND 3 THEN '0-3 Days'
  WHEN t.age BETWEEN 4 AND 7 THEN '3-7 Days'
  ELSE 'Above 7 Days'
  END AS age_bucket,
  t.amount_local,
  t.hkont AS gl_account,
  t.bukrs AS company_code
FROM (
  SELECT /*+ FIRST_ROWS(30) */ 
    b.BUKRS,
    b.HKONT,
    b.DMBTR AS amount_local,
    (TRUNC(SYSDATE) - TO_DATE(k.BLDAT,'YYYYMMDD')) AS age
  FROM SAPR3.BSIS b
  JOIN SAPR3.BKPF k
     ON b.BELNR = k.BELNR
  WHERE b.GJAHR = '2025'
    AND b.BUKRS = '0100'
    AND b.HKONT = '0000895200'
    AND b.MANDT = '500'
    AND b.BUZEI = '002'
    AND b.WAERS = 'INR'
    AND b.MONAT = '01'
    AND b.BLDAT = '20240401'
    AND k.BUKRS = '0100'
    AND k.GJAHR = '2025'
) t
ORDER BY t.age;

[2025-12-12 15:40:16.170031] [Case:31][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:40:18.288726] [Case:31][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:42:03.721830] [Case:31][Run:1] [deepseek-r1] Model Output Response:
{"answer": "yes"}
[2025-12-12 15:42:03.723410] [31] hybrid Eval Final Result: True
[2025-12-12 15:42:03.725288] [Case:32][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
with tmep_ip as (
  select 
  a.register_no as patientid, 
  a.inpatient_name as patientname, 
  a.age,
  a.sex as gender, 
  date(a.in_date) as indate, 
  date(a.out_date) as outdate,
  a.times as inhospitaltimes, 
  a.person_type as persontype, 
  a.patient_no as serialno,
  b.total_cost as medicalcost, 
  'doctor' as entrymode, 
  'remind' as defaulttab,
  a.current_dept_code as deptcode, 
  '440100' as citycode 
  from his_temp_ip_patient_info a 
  left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times
  where a.out_date >= '2025-01-02 00:00:00'
),
diagnosis as (
  select 
  inp_no, 
  visit_id as times, 
  type, 
  diagnosis_type_name,
  diagnosis_flag,
  case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes,
  case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes,
  case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names 
  from emr_temp_ip_patient_diagnosis 
  where file_visit_type = '2'
  group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag
),
diagnosis_ranked as (
  select 
  inp_no, 
  times, 
  type, 
  diagnosis_type_name,
  diagnosis_codes,
  chinese_diagnosis_codes,
  chinese_diagnosis_names,
  row_number() over (
   partition by inp_no, times, type 
   order by 
  case 
  when type = '病历诊断' and diagnosis_type_name = '最后诊断' then 1
  when type = '病历诊断' and diagnosis_type_name = '初步诊断' then 2
  when type = '首页诊断' and diagnosis_type_name = '出院诊断' then 1
  when type = '首页诊断' and diagnosis_type_name = '门诊诊断' then 2
  else 3
  end
  ) as rn
  from diagnosis
),
diagnosis_end as (
  select 
  inp_no, 
  times, 
  type, 
  diagnosis_codes,
  chinese_diagnosis_codes,
  chinese_diagnosis_names
  from diagnosis_ranked
  where rn = 1
),
operations as (
  select 
  inp_no, 
  visit_id as times, 
  string_agg(operation_code, ',' order by operation_no) as operation_codes 
  from emr_temp_ip_patient_operation
  group by inp_no, visit_id 
)
select 
  t.patientid, 
  t.patientname, 
  t.age,
  t.gender, 
  t.indate, 
  t.outdate, 
  t.inhospitaltimes, 
  d.type,
  d.diagnosis_codes as diagnosiscode,
  o.operation_codes as operationcode,
  t.medicalcost, 
  t.persontype, 
  t.entrymode, 
  t.serialno, 
  t.defaulttab,
  d.chinese_diagnosis_codes as chinesediagnosiscode,
  d.chinese_diagnosis_names as chinesediagnosename,
  t.deptcode, 
  t.citycode 
from tmep_ip t 
left join diagnosis_end d on t.patientid = d.inp_no and t.inhospitaltimes::varchar = d.times
left join operations o on t.patientid = o.inp_no and t.inhospitaltimes::varchar = o.times
order by t.outdate desc

[2025-12-12 15:42:03.728070] [Case:32][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
with tmep_ip as (
  select 
  a.register_no as patientid, 
  a.inpatient_name as patientname, 
  a.age,
  a.sex as gender, 
  date(a.in_date) as indate, 
  date(a.out_date) as outdate,
  a.times as inhospitaltimes, 
  a.person_type as persontype, 
  a.patient_no as serialno,
  b.total_cost as medicalcost, 
  'doctor' as entrymode, 
  'remind' as defaulttab,
  a.current_dept_code as deptcode, 
  '440100' as citycode 
  from his_temp_ip_patient_info a 
  left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times
  where a.out_date >= '2025-01-02 00:00:00'
),
diagnosis as (
  select 
  inp_no, 
  visit_id as times, 
  type, 
  diagnosis_type_name,
  diagnosis_flag,
  case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes,
  case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes,
  case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names 
  from emr_temp_ip_patient_diagnosis 
  where file_visit_type = '2'
  group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag
),
diagnosis_ranked as (
  select 
  inp_no, 
  times, 
  type, 
  diagnosis_type_name,
  diagnosis_codes,
  chinese_diagnosis_codes,
  chinese_diagnosis_names,
  row_number() over (
   partition by inp_no, times, type 
   order by 
  case 
  when type = '病历诊断' and diagnosis_type_name = '最后诊断' then 1
  when type = '病历诊断' and diagnosis_type_name = '初步诊断' then 2
  when type = '首页诊断' and diagnosis_type_name = '出院诊断' then 1
  when type = '首页诊断' and diagnosis_type_name = '门诊诊断' then 2
  else 3
  end
  ) as rn
  from diagnosis
),
diagnosis_end as (
  select 
  inp_no, 
  times, 
  type, 
  diagnosis_codes,
  chinese_diagnosis_codes,
  chinese_diagnosis_names
  from diagnosis_ranked
  where rn = 1
),
operations as (
  select 
  inp_no, 
  visit_id as times, 
  string_agg(operation_code, ',' order by operation_no) as operation_codes 
  from emr_temp_ip_patient_operation
  group by inp_no, visit_id 
)
select 
  t.patientid, 
  t.patientname, 
  t.age,
  t.gender, 
  t.indate, 
  t.outdate, 
  t.inhospitaltimes, 
  d.type,
  d.diagnosis_codes as diagnosiscode,
  o.operation_codes as operationcode,
  t.medicalcost, 
  t.persontype, 
  t.entrymode, 
  t.serialno, 
  t.defaulttab,
  d.chinese_diagnosis_codes as chinesediagnosiscode,
  d.chinese_diagnosis_names as chinesediagnosename,
  t.deptcode, 
  t.citycode 
from tmep_ip t 
left join diagnosis_end d on t.patientid = d.inp_no and t.inhospitaltimes::varchar = d.times
left join operations o on t.patientid = o.inp_no and t.inhospitaltimes::varchar = o.times
order by t.outdate desc

[2025-12-12 15:42:03.729336] [Case:32][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
with tmep_ip as (
  select 
  a.register_no as patientid, 
  a.inpatient_name as patientname, 
  a.age,
  a.sex as gender, 
  date(a.in_date) as indate, 
  date(a.out_date) as outdate,
  a.times as inhospitaltimes, 
  a.person_type as persontype, 
  a.patient_no as serialno,
  b.total_cost as medicalcost, 
  'doctor' as entrymode, 
  'remind' as defaulttab,
  a.current_dept_code as deptcode, 
  '440100' as citycode 
  from his_temp_ip_patient_info a 
  left join his_temp_ip_settle b on a.register_no = b.register_no and a.times = b.times
  where a.out_date >= '2025-01-02 00:00:00'
),
diagnosis as (
  select 
  inp_no, 
  visit_id as times, 
  type, 
  diagnosis_type_name,
  diagnosis_flag,
  case when diagnosis_flag = '1' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as diagnosis_codes,
  case when diagnosis_flag = '0' then string_agg(diagnosis_code, ',' order by diagnosis_no) end as chinese_diagnosis_codes,
  case when diagnosis_flag = '0' then string_agg(diagnosis_name, ',' order by diagnosis_no) end as chinese_diagnosis_names 
  from emr_temp_ip_patient_diagnosis 
  where file_visit_type = '2'
  group by inp_no, visit_id, type, diagnosis_type_name, diagnosis_flag
),
diagnosis_ranked as (
  select 
  inp_no, 
  times, 
  type, 
  diagnosis_type_name,
  diagnosis_codes,
  chinese_diagnosis_codes,
  chinese_diagnosis_names,
  row_number() over (
   partition by inp_no, times, type 
   order by 
  case 
  when type = '病历诊断' and diagnosis_type_name = '最后诊断' then 1
  when type = '病历诊断' and diagnosis_type_name = '初步诊断' then 2
  when type = '首页诊断' and diagnosis_type_name = '出院诊断' then 1
  when type = '首页诊断' and diagnosis_type_name = '门诊诊断' then 2
  else 3
  end
  ) as rn
  from diagnosis
),
diagnosis_end as (
  select 
  inp_no, 
  times, 
  type, 
  diagnosis_codes,
  chinese_diagnosis_codes,
  chinese_diagnosis_names
  from diagnosis_ranked
  where rn = 1
),
operations as (
  select 
  inp_no, 
  visit_id as times, 
  string_agg(operation_code, ',' order by operation_no) as operation_codes 
  from emr_temp_ip_patient_operation
  group by inp_no, visit_id 
)
select 
  t.patientid, 
  t.patientname, 
  t.age,
  t.gender, 
  t.indate, 
  t.outdate, 
  t.inhospitaltimes, 
  d.type,
  d.diagnosis_codes as diagnosiscode,
  o.operation_codes as operationcode,
  t.medicalcost, 
  t.persontype, 
  t.entrymode, 
  t.serialno, 
  t.defaulttab,
  d.chinese_diagnosis_codes as chinesediagnosiscode,
  d.chinese_diagnosis_names as chinesediagnosename,
  t.deptcode, 
  t.citycode 
from tmep_ip t 
left join diagnosis_end d on t.patientid = d.inp_no and t.inhospitaltimes::varchar = d.times
left join operations o on t.patientid = o.inp_no and t.inhospitaltimes::varchar = o.times
order by t.outdate desc

[2025-12-12 15:42:17.841799] [Case:32][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:42:29.981087] [Case:32][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:44:03.108316] [Case:32][Run:1] [deepseek-r1] Model Output Response:
```{"answer":"yes"}
[2025-12-12 15:44:03.109913] [32] hybrid Eval Final Result: True
[2025-12-12 15:44:03.111473] [Case:33][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  ID, 
  `NAME`, 
  `CODE`, 
  `TYPE`, 
  principal, 
  CATEGORY 
FROM 
  t_org_architecture 
WHERE 
  LEFT('745070056000500070090',  LENGTH(`CODE`)) = `CODE` 
GROUP BY 
  LENGTH(`CODE`);

[2025-12-12 15:44:03.112552] [Case:33][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  ID, 
  `NAME`, 
  `CODE`, 
  `TYPE`, 
  principal, 
  CATEGORY 
FROM 
  t_org_architecture 
WHERE 
  LEFT('745070056000500070090',  LENGTH(`CODE`)) = `CODE` 
GROUP BY 
  LENGTH(`CODE`);

[2025-12-12 15:44:03.113203] [Case:33][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  ID, 
  `NAME`, 
  `CODE`, 
  `TYPE`, 
  principal, 
  CATEGORY 
FROM 
  t_org_architecture 
WHERE 
  LEFT('745070056000500070090',  LENGTH(`CODE`)) = `CODE` 
GROUP BY 
  LENGTH(`CODE`);

[2025-12-12 15:44:11.302572] [Case:33][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:44:15.727906] [Case:33][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:47:23.044955] [Case:33][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:47:23.046175] [33] hybrid Eval Final Result: False
[2025-12-12 15:47:23.047383] [Case:34][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  count(DISTINCT MebID) 
FROM 
  m_membermain mm 
WHERE 
  mm.Flag <> '0' 
  AND CreateTime >= '2025-09-02 00:00:00' 
  AND CreateTime < '2025-09-03 00:00:00' 
  AND mm.MebType IN (1, 2, 5, 6, 8) 
  AND MebID IS NOT NULL 
LIMIT 
  1000;

[2025-12-12 15:47:23.047834] [Case:34][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  count(DISTINCT MebID) 
FROM 
  m_membermain mm 
WHERE 
  mm.Flag <> '0' 
  AND CreateTime >= '2025-09-02 00:00:00' 
  AND CreateTime < '2025-09-03 00:00:00' 
  AND mm.MebType IN (1, 2, 5, 6, 8) 
  AND MebID IS NOT NULL 
LIMIT 
  1000;

[2025-12-12 15:47:23.048112] [Case:34][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  count(DISTINCT MebID) 
FROM 
  m_membermain mm 
WHERE 
  mm.Flag <> '0' 
  AND CreateTime >= '2025-09-02 00:00:00' 
  AND CreateTime < '2025-09-03 00:00:00' 
  AND mm.MebType IN (1, 2, 5, 6, 8) 
  AND MebID IS NOT NULL 
LIMIT 
  1000;

[2025-12-12 15:47:28.870308] [Case:34][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:47:29.223040] [Case:34][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:48:28.959120] [Case:34][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:48:28.969066] [34] hybrid Eval Final Result: True
[2025-12-12 15:48:28.970900] [Case:35][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  COUNT(*) 
FROM 
   hotel_price_adjustment pa1 
WHERE 
   (
   HOTEL_CODE IN ('6199', 'JJXRSEH802967') 
   OR CREATE_USER_ID = 289865
   );

[2025-12-12 15:48:28.971419] [Case:35][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  COUNT(*) 
FROM 
   hotel_price_adjustment pa1 
WHERE 
   (
   HOTEL_CODE IN ('6199', 'JJXRSEH802967') 
   OR CREATE_USER_ID = 289865
   );

[2025-12-12 15:48:28.971946] [Case:35][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  COUNT(*) 
FROM 
   hotel_price_adjustment pa1 
WHERE 
   (
   HOTEL_CODE IN ('6199', 'JJXRSEH802967') 
   OR CREATE_USER_ID = 289865
   );

[2025-12-12 15:48:33.904188] [Case:35][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:48:33.908597] [Case:35][Run:1] [o4-mini] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:48:41.799551] [Case:35][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:48:41.800700] [35] hybrid Eval Final Result: True
[2025-12-12 15:48:41.801640] [Case:36][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  * 
FROM (
    SELECT 
      * 
    from 
      DOCUMENT 
    where 
      pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'
    UNION
    SELECT 
      * 
    from 
      DOCUMENT 
    where 
      fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'
) AS t 
ORDER BY id;

[2025-12-12 15:48:41.802430] [Case:36][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  * 
FROM (
    SELECT 
      * 
    from 
      DOCUMENT 
    where 
      pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'
    UNION
    SELECT 
      * 
    from 
      DOCUMENT 
    where 
      fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'
) AS t 
ORDER BY id;

[2025-12-12 15:48:41.803097] [Case:36][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  * 
FROM (
    SELECT 
      * 
    from 
      DOCUMENT 
    where 
      pdfKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'
    UNION
    SELECT 
      * 
    from 
      DOCUMENT 
    where 
      fileKey = '20241230-65c295d4-825a-48b6-9153-f479eea2e01c05-ne'
) AS t 
ORDER BY id;

[2025-12-12 15:48:45.308139] [Case:36][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:48:48.128574] [Case:36][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:49:07.882219] [Case:36][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:49:07.883553] [36] hybrid Eval Final Result: True
[2025-12-12 15:49:07.884720] [Case:37][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
{'status': 'error', 'message': "('Connection aborted.', RemoteDisconnected('Remote end closed connection without response'))", 'code': 500}

[2025-12-12 15:49:07.885044] [Case:37][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
{'status': 'error', 'message': "('Connection aborted.', RemoteDisconnected('Remote end closed connection without response'))", 'code': 500}

[2025-12-12 15:49:07.886410] [Case:37][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
{'status': 'error', 'message': "('Connection aborted.', RemoteDisconnected('Remote end closed connection without response'))", 'code': 500}

[2025-12-12 15:49:10.245114] [Case:37][Run:1] [o4-mini] Model Output Response:
{"answer":"no"}
[2025-12-12 15:49:11.727127] [Case:37][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:49:25.765343] [Case:37][Run:1] [deepseek-r1] Model Output Response:
```{"answer": "no"}
[2025-12-12 15:49:25.766582] [37] hybrid Eval Final Result: False
[2025-12-12 15:49:25.767929] [Case:38][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT P.HWT_TYPE_ID,   --班別ID
  HRM_EMP.GET_ID_TO_DESC (P.HWT_TYPE_ID) SHIFT,   --班別
  B.FAMILY_ID AS MODEL_ID,   --機種ID
  HRM_EMP.GET_ID_TO_DESC (B.FAMILY_ID) AS MODEL_NAME,  --機種名稱
  P.LINE_ID,  --線體ID
  GET_LOCATION_INFO (P.LINE_ID, '1') AS LINE_NAME,  --線體名稱
  P.STATION_ID,  --工站ID
  B.STATION_NAME_ENG,   --工站名稱
  HRM_EMP.GET_ID_TO_DESC (B.KEY_STATION_ID) KEY_STATION_TYPE,  --工站類型
  P.EMP_NO
  --,P.CONFIRM_FLAG, --確認狀態
  FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P
  -- 使用INNER,以便只要 同時符合預排配和工站基礎資訊的
  INNER JOIN HRM_FLOOR.C_BASE_STATION_T B
  ON  P.STATION_ID = B.ID
  AND B.DEL_FLAG = 0
  AND B.BU_ID = 245346  --iPad
  AND B.HAC_ID = 7137  --CD
  AND B.MFG_PROCESS_ID = 140185  --製程為Mainline
  AND B.KEY_STATION_ID IN (4976, 8877, 38131)   --K/K+/K++
   WHERE  P.WORK_DATE = DATE '2025-08-04'
  AND P.DEL_FLAG = 0
  -- 確認該員工有對應的「有效執照+在職」鑰匙站記錄（仍需站點一致）
  AND EXISTS
   (SELECT 1
  FROM HRM_FLOOR.R_KEY_STATION_LICENSE_T F,
  HRM_FLOOR.R_KEY_STATION_MAN_T H
   WHERE  H.LICENSE_ID = F.LICENSE_ID
  AND H.EMP_NO = P.EMP_NO
  AND H.LOSE_FLAG = 10078
  AND H.DEL_FLAG = 0
  AND F.DEL_FLAG = 0
  AND F.STATION_ID = P.STATION_ID)

[2025-12-12 15:49:25.769063] [Case:38][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT P.HWT_TYPE_ID,   --班別ID
  HRM_EMP.GET_ID_TO_DESC (P.HWT_TYPE_ID) SHIFT,   --班別
  B.FAMILY_ID AS MODEL_ID,   --機種ID
  HRM_EMP.GET_ID_TO_DESC (B.FAMILY_ID) AS MODEL_NAME,  --機種名稱
  P.LINE_ID,  --線體ID
  GET_LOCATION_INFO (P.LINE_ID, '1') AS LINE_NAME,  --線體名稱
  P.STATION_ID,  --工站ID
  B.STATION_NAME_ENG,   --工站名稱
  HRM_EMP.GET_ID_TO_DESC (B.KEY_STATION_ID) KEY_STATION_TYPE,  --工站類型
  P.EMP_NO
  --,P.CONFIRM_FLAG, --確認狀態
  FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P
  -- 使用INNER,以便只要 同時符合預排配和工站基礎資訊的
  INNER JOIN HRM_FLOOR.C_BASE_STATION_T B
  ON  P.STATION_ID = B.ID
  AND B.DEL_FLAG = 0
  AND B.BU_ID = 245346  --iPad
  AND B.HAC_ID = 7137  --CD
  AND B.MFG_PROCESS_ID = 140185  --製程為Mainline
  AND B.KEY_STATION_ID IN (4976, 8877, 38131)   --K/K+/K++
   WHERE  P.WORK_DATE = DATE '2025-08-04'
  AND P.DEL_FLAG = 0
  -- 確認該員工有對應的「有效執照+在職」鑰匙站記錄（仍需站點一致）
  AND EXISTS
   (SELECT 1
  FROM HRM_FLOOR.R_KEY_STATION_LICENSE_T F,
  HRM_FLOOR.R_KEY_STATION_MAN_T H
   WHERE  H.LICENSE_ID = F.LICENSE_ID
  AND H.EMP_NO = P.EMP_NO
  AND H.LOSE_FLAG = 10078
  AND H.DEL_FLAG = 0
  AND F.DEL_FLAG = 0
  AND F.STATION_ID = P.STATION_ID)

[2025-12-12 15:49:25.770515] [Case:38][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT P.HWT_TYPE_ID,   --班別ID
  HRM_EMP.GET_ID_TO_DESC (P.HWT_TYPE_ID) SHIFT,   --班別
  B.FAMILY_ID AS MODEL_ID,   --機種ID
  HRM_EMP.GET_ID_TO_DESC (B.FAMILY_ID) AS MODEL_NAME,  --機種名稱
  P.LINE_ID,  --線體ID
  GET_LOCATION_INFO (P.LINE_ID, '1') AS LINE_NAME,  --線體名稱
  P.STATION_ID,  --工站ID
  B.STATION_NAME_ENG,   --工站名稱
  HRM_EMP.GET_ID_TO_DESC (B.KEY_STATION_ID) KEY_STATION_TYPE,  --工站類型
  P.EMP_NO
  --,P.CONFIRM_FLAG, --確認狀態
  FROM HRM_FLOOR.R_EMP_STATION_PLAN_T P
  -- 使用INNER,以便只要 同時符合預排配和工站基礎資訊的
  INNER JOIN HRM_FLOOR.C_BASE_STATION_T B
  ON  P.STATION_ID = B.ID
  AND B.DEL_FLAG = 0
  AND B.BU_ID = 245346  --iPad
  AND B.HAC_ID = 7137  --CD
  AND B.MFG_PROCESS_ID = 140185  --製程為Mainline
  AND B.KEY_STATION_ID IN (4976, 8877, 38131)   --K/K+/K++
   WHERE  P.WORK_DATE = DATE '2025-08-04'
  AND P.DEL_FLAG = 0
  -- 確認該員工有對應的「有效執照+在職」鑰匙站記錄（仍需站點一致）
  AND EXISTS
   (SELECT 1
  FROM HRM_FLOOR.R_KEY_STATION_LICENSE_T F,
  HRM_FLOOR.R_KEY_STATION_MAN_T H
   WHERE  H.LICENSE_ID = F.LICENSE_ID
  AND H.EMP_NO = P.EMP_NO
  AND H.LOSE_FLAG = 10078
  AND H.DEL_FLAG = 0
  AND F.DEL_FLAG = 0
  AND F.STATION_ID = P.STATION_ID)

[2025-12-12 15:49:36.248420] [Case:38][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:49:37.126363] [Case:38][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:50:07.318791] [Case:38][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:50:07.320194] [38] hybrid Eval Final Result: True
[2025-12-12 15:50:07.321545] [Case:39][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
{'status': 'error', 'message': "('Connection aborted.', RemoteDisconnected('Remote end closed connection without response'))", 'code': 500}

[2025-12-12 15:50:07.321947] [Case:39][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
{'status': 'error', 'message': "('Connection aborted.', RemoteDisconnected('Remote end closed connection without response'))", 'code': 500}

[2025-12-12 15:50:07.322246] [Case:39][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
{'status': 'error', 'message': "('Connection aborted.', RemoteDisconnected('Remote end closed connection without response'))", 'code': 500}

[2025-12-12 15:50:10.475414] [Case:39][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:50:10.567292] [Case:39][Run:1] [o4-mini] Model Output Response:
{"answer":"no"}
[2025-12-12 15:50:15.691944] [Case:39][Run:1] [deepseek-r1] Model Output Response:
{"answer": "no"}
[2025-12-12 15:50:15.693118] [39] hybrid Eval Final Result: False
[2025-12-12 15:50:15.703394] [Case:40][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select *  from (select t.*,ROWNUM AS rn  from (SELECT
	EE.*,
	B.WIDTH,
	B.LENGTH,
	B.HEIGHT,
	B.AREA,
	B.FLOOR_NO,
	B.IS_OIL_MACH_ROOM,
	B.IS_HAVE_WALL,
	B.STRUCTURE_ID,
	B.ADDRESS,
	B.AIRBLAST_STYLE,
	B.VACANT_CABLE_SEAT,
	B.CONTACTS,
	B.LINK_TEL,
	B.NUM_HOLE_FEED,
	B.NUM_HOLE_FEED_OCCU,
	B.NUM_HOLE_FEED_FREE,
	B.LIGHT_PROTECTION_BRAND,
	B.LIGHT_PROTECTION_MODE,
	B.FIRE_EXTINGUISHER_TYPE,
	B.NUM_FIRE_EXTINGUISHER,
	B.STATION_ROAD_ID,
	B.DEGREE_ARRIVAL_ID,
	B.REASON_UNARRIVAL,
	B.IS_ARRIVEL,
	B.IS_POWER,
	B.REASON_UNPOWER,
	B.INOUT_MODE,
	B.PLATE_DRAWINGS_ID,
	B.DECORATION_DRAWINGS_ID,
	B.DESIGN_DRAWINGS_ID,
	B.GROUND_SYSTEM_DRAWINGS_ID,
	B.IS_EXPAND_OIL_ROOM,
	B.SECURITY_ENVIRONMENT_ID,
	B.GENERATION_TIME,
	B.WNG_STYLE,
	B.ROOM_GRADE_ID,
	B.NUM_RMEBAY_TOTAL,
	B.NUM_RMEBAY_FREE,
	B.PRODUCT_TYPE,
	B.ENT_AUDIT_RESULT_ID,
	B.AUDIT_FLOW_RESULT_ID,
	B.MANUAL_IDENT_RESULT_ID,
	B.AGENT_MNT_CONTACT,
	B.IS_VR_FULLSCENE_ID,
	B.IS_SHARE,
	B.SHARE_UNIT_ID,
	B.INTEG_CABINET_SPACE_NUM,
	B.INTEG_CABINET_AC_BRAND,
	B.INTEG_CABINET_AC_MODEL_DC,
	B.INTEG_CABINET_AC_NUM_DC,
	B.INTEG_CABINET_AC_MODEL,
	B.INTEG_CABINET_AC_NUM_DC_AC,
	B.INTEG_CABINET_SPACE_NUM AS INTEG_CABINET_SPACE_NUM_TEXT,
	EE.RES_FROM_PROJECT_NAME AS RES_FROM_PROJECT_NAME_TEXT,
	B.INTEG_CABINET_AC_NUM_ID,
	res_entity.SF_GET_DESC_CHINA(B.INTEG_CABINET_AC_NUM_ID) AS INTEG_CABINET_AC_NUM_ID_TEXT,
	B.INTEG_CABINET_AC_MFR_ID,
	B.INTEG_CABINET_AC_MODEL,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=B.INTEG_CABINET_AC_MFR_ID and delete_state='0') AS INTEG_CABINET_AC_MFR_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.TIME_TO_OVERDUE) AS TIME_TO_OVERDUE_TEXT,
	(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=B.MANUAL_IDENT_RESULT_ID AND DELETE_STATE = '0') AS MANUAL_IDENT_RESULT_ID_TEXT,
	RES_ENTITY.SF_GET_STAFF_NAME(B.AGENT_MNT_CONTACT) AS AGENT_MNT_CONTACT_TEXT,
	CASE WHEN B.IS_VR_FULLSCENE_ID = 1 THEN '有' WHEN B.IS_VR_FULLSCENE_ID= 0 THEN '无' END AS IS_VR_FULLSCENE_ID_TEXT,
	CASE WHEN B.AIRBLAST_STYLE = 1 THEN '下送风' WHEN B.AIRBLAST_STYLE= 0 THEN '上送风' END AS AIRBLAST_STYLE_TEXT,
	CASE WHEN B.WNG_STYLE = 1 THEN '上走线' WHEN B.WNG_STYLE= 0 THEN '下走线' END AS WNG_STYLE_STYLE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_SHARE) AS IS_SHARE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.SHARE_UNIT_ID) AS SHARE_UNIT_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.AUDIT_FLOW_RESULT_ID) AS AUDIT_FLOW_RESULT_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.ENT_AUDIT_RESULT_ID) AS ENT_AUDIT_RESULT_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.PRODUCT_TYPE) AS PRODUCT_TYPE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_OIL_MACH_ROOM) AS IS_OIL_MACH_ROOM_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_HAVE_WALL) AS IS_HAVE_WALL_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.STRUCTURE_ID) AS STRUCTURE_ID_TEXT, 
	res_entity.SF_GET_DESC_CHINA(B.VACANT_CABLE_SEAT) AS VACANT_CABLE_SEAT_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.STATION_ROAD_ID) AS STATION_ROAD_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.DEGREE_ARRIVAL_ID) AS DEGREE_ARRIVAL_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_ARRIVEL) AS IS_ARRIVEL_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_POWER) AS IS_POWER_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.INOUT_MODE) AS INOUT_MODE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_EXPAND_OIL_ROOM) AS IS_EXPAND_OIL_ROOM_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.SECURITY_ENVIRONMENT_ID) AS SECURITY_ENVIRONMENT_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.WNG_STYLE) AS WNG_STYLE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.ROOM_GRADE_ID) AS ROOM_GRADE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_MODE_ID) AS CHECK_MODE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.BUSINESS_ID) AS BUSINESS_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.SUB_BUSINESS_ID) AS SUB_BUSINESS_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.PROP_ID) AS PROP_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.OLD_PROP_ID) AS OLD_PROP_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.PROPERTY_ID) AS PROPERTY_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_STATE_ID) AS ENTITY_STATE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_LOCKED_ID) AS IS_LOCKED_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_FAULT_ID) AS IS_FAULT_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OVERDUE) AS IS_OVERDUE_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.WARRANTY_GRADE_ID) AS WARRANTY_GRADE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OUTMAINTENANCE_ID) AS IS_OUTMAINTENANCE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.ASSETS_RECEIVE_TYPE_ID) AS ASSETS_RECEIVE_TYPE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_CREATE_SOURCE_ID) AS ENTITY_CREATE_SOURCE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.SOURCE_SYSTEM_ID) AS SOURCE_SYSTEM_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_RESULT_ID) AS CHECK_RESULT_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.SERVICE_STATE_ID) AS SERVICE_STATE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_MONITOR_ID) AS IS_MONITOR_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.MONITOR_STYLE_ID) AS MONITOR_STYLE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_UPLOAD_PHOTO) AS IS_UPLOAD_PHOTO_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.STORAGE_STATE_ID) AS STORAGE_STATE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_STORAGE) AS IS_STORAGE_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.RES_FROM_PROJBUILDTYPE_ID) AS RES_FROM_PROJBUILDTYPE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.SPLIT_MERGE_REASON_ID) AS SPLIT_MERGE_REASON_ID_TEXT,
	EE.SOURCE_RES_NO AS SOURCE_RES_NO_TEXT,
	(SELECT ENTITY_NAME FROM res_entity.ent_entity WHERE ENTITY_ID=EE.ROOM_ID and res_type_id='205' and delete_state='0') AS ROOM_ID_TEXT,
	(SELECT RES_TYPE FROM RES_SYS.PUB_DIC_RES_TYPE WHERE RES_TYPE_ID=EE.RES_TYPE_ID and delete_state='0') AS RES_TYPE_ID_TEXT,
	(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=EE.DEV_TYPE_ID and delete_state='0') AS DEV_TYPE_ID_TEXT,
	(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.DEV_MODEL_ID and delete_state='0') AS DEV_MODEL_ID_TEXT,
	(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.OLD_DEV_MODEL_ID and delete_state='0') AS OLD_DEV_MODEL_ID_TEXT,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MFR_ID and delete_state='0') AS MFR_ID_TEXT,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.DW_MFR_ID and delete_state='0') AS DW_MFR_ID_TEXT,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.OLD_DW_MFR_ID and delete_state='0') AS OLD_DW_MFR_ID_TEXT,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MNT_MFR_ID and delete_state='0') AS MNT_MFR_ID_TEXT,
	RES_ENTITY.SF_GET_STAFF_NAME(EE.MODIFY_OP) AS MODIFY_OP_TEXT,
	RES_ENTITY.SF_GET_STAFF_NAME(EE.CREATE_OP) AS CREATE_OP_TEXT,
	RES_ENTITY.SF_GET_STAFF_NAME(EE.CHECK_PERSON) AS CHECK_PERSON_TEXT,
	ST.DISTRICT_PROVINCE_ID,
	ST.DISTRICT_REGION_ID,
	ST.DISTRICT_COUNTY_ID,
	ST.STATION_NAME,
	ST.STATION_NAME AS STATION_ID_TEXT,
	D.APP_REGION_ID,
	(SELECT REGION_NAME FROM res_entity.REG_MANAGE WHERE REGION_ID = D.APP_REGION_ID AND delete_state = '0') AS APP_REGION_ID_TEXT,
	res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) AS DISTRICT_PROVINCE_ID_TEXT,
	res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) AS DISTRICT_REGION_ID_TEXT,
	res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS DISTRICT_COUNTY_ID_TEXT,
	res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS REGION_ID_TEXT 
FROM RES_ENTITY.ENT_ENTITY EE 
LEFT JOIN RES_ENTITY.ENT_ROOM B ON B.ENTITY_ID = EE.ENTITY_ID
LEFT JOIN RES_ENTITY.STA_STATION ST ON ST.STATION_CODE = EE.STATION_CODE  
LEFT JOIN RES_ENTITY.STA_APP_INFO D ON ST.STATION_ID=D.STATION_ID
WHERE EE.DELETE_STATE = '0' AND EE.RES_TYPE_ID=205  
AND EE.STATION_CODE in  (select station_code  from res_entity.sta_biz_info  where  REGION_ID in (  select REGION_ID from res_entity.reg_manage  connect by prior REGION_ID = SUPER_REGION_ID and nvl(delete_state, '0') = '0' start with region_id in ('000102000000000000370100') ) ) 
)t where ROWNUM <= 10) where rn > 0;

[2025-12-12 15:50:15.706846] [Case:40][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select *  from (select t.*,ROWNUM AS rn  from (SELECT
	EE.*,
	B.WIDTH,
	B.LENGTH,
	B.HEIGHT,
	B.AREA,
	B.FLOOR_NO,
	B.IS_OIL_MACH_ROOM,
	B.IS_HAVE_WALL,
	B.STRUCTURE_ID,
	B.ADDRESS,
	B.AIRBLAST_STYLE,
	B.VACANT_CABLE_SEAT,
	B.CONTACTS,
	B.LINK_TEL,
	B.NUM_HOLE_FEED,
	B.NUM_HOLE_FEED_OCCU,
	B.NUM_HOLE_FEED_FREE,
	B.LIGHT_PROTECTION_BRAND,
	B.LIGHT_PROTECTION_MODE,
	B.FIRE_EXTINGUISHER_TYPE,
	B.NUM_FIRE_EXTINGUISHER,
	B.STATION_ROAD_ID,
	B.DEGREE_ARRIVAL_ID,
	B.REASON_UNARRIVAL,
	B.IS_ARRIVEL,
	B.IS_POWER,
	B.REASON_UNPOWER,
	B.INOUT_MODE,
	B.PLATE_DRAWINGS_ID,
	B.DECORATION_DRAWINGS_ID,
	B.DESIGN_DRAWINGS_ID,
	B.GROUND_SYSTEM_DRAWINGS_ID,
	B.IS_EXPAND_OIL_ROOM,
	B.SECURITY_ENVIRONMENT_ID,
	B.GENERATION_TIME,
	B.WNG_STYLE,
	B.ROOM_GRADE_ID,
	B.NUM_RMEBAY_TOTAL,
	B.NUM_RMEBAY_FREE,
	B.PRODUCT_TYPE,
	B.ENT_AUDIT_RESULT_ID,
	B.AUDIT_FLOW_RESULT_ID,
	B.MANUAL_IDENT_RESULT_ID,
	B.AGENT_MNT_CONTACT,
	B.IS_VR_FULLSCENE_ID,
	B.IS_SHARE,
	B.SHARE_UNIT_ID,
	B.INTEG_CABINET_SPACE_NUM,
	B.INTEG_CABINET_AC_BRAND,
	B.INTEG_CABINET_AC_MODEL_DC,
	B.INTEG_CABINET_AC_NUM_DC,
	B.INTEG_CABINET_AC_MODEL,
	B.INTEG_CABINET_AC_NUM_DC_AC,
	B.INTEG_CABINET_SPACE_NUM AS INTEG_CABINET_SPACE_NUM_TEXT,
	EE.RES_FROM_PROJECT_NAME AS RES_FROM_PROJECT_NAME_TEXT,
	B.INTEG_CABINET_AC_NUM_ID,
	res_entity.SF_GET_DESC_CHINA(B.INTEG_CABINET_AC_NUM_ID) AS INTEG_CABINET_AC_NUM_ID_TEXT,
	B.INTEG_CABINET_AC_MFR_ID,
	B.INTEG_CABINET_AC_MODEL,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=B.INTEG_CABINET_AC_MFR_ID and delete_state='0') AS INTEG_CABINET_AC_MFR_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.TIME_TO_OVERDUE) AS TIME_TO_OVERDUE_TEXT,
	(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=B.MANUAL_IDENT_RESULT_ID AND DELETE_STATE = '0') AS MANUAL_IDENT_RESULT_ID_TEXT,
	RES_ENTITY.SF_GET_STAFF_NAME(B.AGENT_MNT_CONTACT) AS AGENT_MNT_CONTACT_TEXT,
	CASE WHEN B.IS_VR_FULLSCENE_ID = 1 THEN '有' WHEN B.IS_VR_FULLSCENE_ID= 0 THEN '无' END AS IS_VR_FULLSCENE_ID_TEXT,
	CASE WHEN B.AIRBLAST_STYLE = 1 THEN '下送风' WHEN B.AIRBLAST_STYLE= 0 THEN '上送风' END AS AIRBLAST_STYLE_TEXT,
	CASE WHEN B.WNG_STYLE = 1 THEN '上走线' WHEN B.WNG_STYLE= 0 THEN '下走线' END AS WNG_STYLE_STYLE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_SHARE) AS IS_SHARE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.SHARE_UNIT_ID) AS SHARE_UNIT_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.AUDIT_FLOW_RESULT_ID) AS AUDIT_FLOW_RESULT_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.ENT_AUDIT_RESULT_ID) AS ENT_AUDIT_RESULT_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.PRODUCT_TYPE) AS PRODUCT_TYPE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_OIL_MACH_ROOM) AS IS_OIL_MACH_ROOM_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_HAVE_WALL) AS IS_HAVE_WALL_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.STRUCTURE_ID) AS STRUCTURE_ID_TEXT, 
	res_entity.SF_GET_DESC_CHINA(B.VACANT_CABLE_SEAT) AS VACANT_CABLE_SEAT_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.STATION_ROAD_ID) AS STATION_ROAD_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.DEGREE_ARRIVAL_ID) AS DEGREE_ARRIVAL_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_ARRIVEL) AS IS_ARRIVEL_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_POWER) AS IS_POWER_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.INOUT_MODE) AS INOUT_MODE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_EXPAND_OIL_ROOM) AS IS_EXPAND_OIL_ROOM_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.SECURITY_ENVIRONMENT_ID) AS SECURITY_ENVIRONMENT_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.WNG_STYLE) AS WNG_STYLE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.ROOM_GRADE_ID) AS ROOM_GRADE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_MODE_ID) AS CHECK_MODE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.BUSINESS_ID) AS BUSINESS_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.SUB_BUSINESS_ID) AS SUB_BUSINESS_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.PROP_ID) AS PROP_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.OLD_PROP_ID) AS OLD_PROP_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.PROPERTY_ID) AS PROPERTY_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_STATE_ID) AS ENTITY_STATE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_LOCKED_ID) AS IS_LOCKED_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_FAULT_ID) AS IS_FAULT_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OVERDUE) AS IS_OVERDUE_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.WARRANTY_GRADE_ID) AS WARRANTY_GRADE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OUTMAINTENANCE_ID) AS IS_OUTMAINTENANCE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.ASSETS_RECEIVE_TYPE_ID) AS ASSETS_RECEIVE_TYPE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_CREATE_SOURCE_ID) AS ENTITY_CREATE_SOURCE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.SOURCE_SYSTEM_ID) AS SOURCE_SYSTEM_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_RESULT_ID) AS CHECK_RESULT_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.SERVICE_STATE_ID) AS SERVICE_STATE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_MONITOR_ID) AS IS_MONITOR_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.MONITOR_STYLE_ID) AS MONITOR_STYLE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_UPLOAD_PHOTO) AS IS_UPLOAD_PHOTO_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.STORAGE_STATE_ID) AS STORAGE_STATE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_STORAGE) AS IS_STORAGE_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.RES_FROM_PROJBUILDTYPE_ID) AS RES_FROM_PROJBUILDTYPE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.SPLIT_MERGE_REASON_ID) AS SPLIT_MERGE_REASON_ID_TEXT,
	EE.SOURCE_RES_NO AS SOURCE_RES_NO_TEXT,
	(SELECT ENTITY_NAME FROM res_entity.ent_entity WHERE ENTITY_ID=EE.ROOM_ID and res_type_id='205' and delete_state='0') AS ROOM_ID_TEXT,
	(SELECT RES_TYPE FROM RES_SYS.PUB_DIC_RES_TYPE WHERE RES_TYPE_ID=EE.RES_TYPE_ID and delete_state='0') AS RES_TYPE_ID_TEXT,
	(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=EE.DEV_TYPE_ID and delete_state='0') AS DEV_TYPE_ID_TEXT,
	(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.DEV_MODEL_ID and delete_state='0') AS DEV_MODEL_ID_TEXT,
	(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.OLD_DEV_MODEL_ID and delete_state='0') AS OLD_DEV_MODEL_ID_TEXT,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MFR_ID and delete_state='0') AS MFR_ID_TEXT,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.DW_MFR_ID and delete_state='0') AS DW_MFR_ID_TEXT,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.OLD_DW_MFR_ID and delete_state='0') AS OLD_DW_MFR_ID_TEXT,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MNT_MFR_ID and delete_state='0') AS MNT_MFR_ID_TEXT,
	RES_ENTITY.SF_GET_STAFF_NAME(EE.MODIFY_OP) AS MODIFY_OP_TEXT,
	RES_ENTITY.SF_GET_STAFF_NAME(EE.CREATE_OP) AS CREATE_OP_TEXT,
	RES_ENTITY.SF_GET_STAFF_NAME(EE.CHECK_PERSON) AS CHECK_PERSON_TEXT,
	ST.DISTRICT_PROVINCE_ID,
	ST.DISTRICT_REGION_ID,
	ST.DISTRICT_COUNTY_ID,
	ST.STATION_NAME,
	ST.STATION_NAME AS STATION_ID_TEXT,
	D.APP_REGION_ID,
	(SELECT REGION_NAME FROM res_entity.REG_MANAGE WHERE REGION_ID = D.APP_REGION_ID AND delete_state = '0') AS APP_REGION_ID_TEXT,
	res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) AS DISTRICT_PROVINCE_ID_TEXT,
	res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) AS DISTRICT_REGION_ID_TEXT,
	res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS DISTRICT_COUNTY_ID_TEXT,
	res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS REGION_ID_TEXT 
FROM RES_ENTITY.ENT_ENTITY EE 
LEFT JOIN RES_ENTITY.ENT_ROOM B ON B.ENTITY_ID = EE.ENTITY_ID
LEFT JOIN RES_ENTITY.STA_STATION ST ON ST.STATION_CODE = EE.STATION_CODE  
LEFT JOIN RES_ENTITY.STA_APP_INFO D ON ST.STATION_ID=D.STATION_ID
WHERE EE.DELETE_STATE = '0' AND EE.RES_TYPE_ID=205  
AND EE.STATION_CODE in  (select station_code  from res_entity.sta_biz_info  where  REGION_ID in (  select REGION_ID from res_entity.reg_manage  connect by prior REGION_ID = SUPER_REGION_ID and nvl(delete_state, '0') = '0' start with region_id in ('000102000000000000370100') ) ) 
)t where ROWNUM <= 10) where rn > 0;

[2025-12-12 15:50:15.708044] [Case:40][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select *  from (select t.*,ROWNUM AS rn  from (SELECT
	EE.*,
	B.WIDTH,
	B.LENGTH,
	B.HEIGHT,
	B.AREA,
	B.FLOOR_NO,
	B.IS_OIL_MACH_ROOM,
	B.IS_HAVE_WALL,
	B.STRUCTURE_ID,
	B.ADDRESS,
	B.AIRBLAST_STYLE,
	B.VACANT_CABLE_SEAT,
	B.CONTACTS,
	B.LINK_TEL,
	B.NUM_HOLE_FEED,
	B.NUM_HOLE_FEED_OCCU,
	B.NUM_HOLE_FEED_FREE,
	B.LIGHT_PROTECTION_BRAND,
	B.LIGHT_PROTECTION_MODE,
	B.FIRE_EXTINGUISHER_TYPE,
	B.NUM_FIRE_EXTINGUISHER,
	B.STATION_ROAD_ID,
	B.DEGREE_ARRIVAL_ID,
	B.REASON_UNARRIVAL,
	B.IS_ARRIVEL,
	B.IS_POWER,
	B.REASON_UNPOWER,
	B.INOUT_MODE,
	B.PLATE_DRAWINGS_ID,
	B.DECORATION_DRAWINGS_ID,
	B.DESIGN_DRAWINGS_ID,
	B.GROUND_SYSTEM_DRAWINGS_ID,
	B.IS_EXPAND_OIL_ROOM,
	B.SECURITY_ENVIRONMENT_ID,
	B.GENERATION_TIME,
	B.WNG_STYLE,
	B.ROOM_GRADE_ID,
	B.NUM_RMEBAY_TOTAL,
	B.NUM_RMEBAY_FREE,
	B.PRODUCT_TYPE,
	B.ENT_AUDIT_RESULT_ID,
	B.AUDIT_FLOW_RESULT_ID,
	B.MANUAL_IDENT_RESULT_ID,
	B.AGENT_MNT_CONTACT,
	B.IS_VR_FULLSCENE_ID,
	B.IS_SHARE,
	B.SHARE_UNIT_ID,
	B.INTEG_CABINET_SPACE_NUM,
	B.INTEG_CABINET_AC_BRAND,
	B.INTEG_CABINET_AC_MODEL_DC,
	B.INTEG_CABINET_AC_NUM_DC,
	B.INTEG_CABINET_AC_MODEL,
	B.INTEG_CABINET_AC_NUM_DC_AC,
	B.INTEG_CABINET_SPACE_NUM AS INTEG_CABINET_SPACE_NUM_TEXT,
	EE.RES_FROM_PROJECT_NAME AS RES_FROM_PROJECT_NAME_TEXT,
	B.INTEG_CABINET_AC_NUM_ID,
	res_entity.SF_GET_DESC_CHINA(B.INTEG_CABINET_AC_NUM_ID) AS INTEG_CABINET_AC_NUM_ID_TEXT,
	B.INTEG_CABINET_AC_MFR_ID,
	B.INTEG_CABINET_AC_MODEL,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=B.INTEG_CABINET_AC_MFR_ID and delete_state='0') AS INTEG_CABINET_AC_MFR_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.TIME_TO_OVERDUE) AS TIME_TO_OVERDUE_TEXT,
	(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=B.MANUAL_IDENT_RESULT_ID AND DELETE_STATE = '0') AS MANUAL_IDENT_RESULT_ID_TEXT,
	RES_ENTITY.SF_GET_STAFF_NAME(B.AGENT_MNT_CONTACT) AS AGENT_MNT_CONTACT_TEXT,
	CASE WHEN B.IS_VR_FULLSCENE_ID = 1 THEN '有' WHEN B.IS_VR_FULLSCENE_ID= 0 THEN '无' END AS IS_VR_FULLSCENE_ID_TEXT,
	CASE WHEN B.AIRBLAST_STYLE = 1 THEN '下送风' WHEN B.AIRBLAST_STYLE= 0 THEN '上送风' END AS AIRBLAST_STYLE_TEXT,
	CASE WHEN B.WNG_STYLE = 1 THEN '上走线' WHEN B.WNG_STYLE= 0 THEN '下走线' END AS WNG_STYLE_STYLE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_SHARE) AS IS_SHARE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.SHARE_UNIT_ID) AS SHARE_UNIT_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.AUDIT_FLOW_RESULT_ID) AS AUDIT_FLOW_RESULT_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.ENT_AUDIT_RESULT_ID) AS ENT_AUDIT_RESULT_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.PRODUCT_TYPE) AS PRODUCT_TYPE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_OIL_MACH_ROOM) AS IS_OIL_MACH_ROOM_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_HAVE_WALL) AS IS_HAVE_WALL_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.STRUCTURE_ID) AS STRUCTURE_ID_TEXT, 
	res_entity.SF_GET_DESC_CHINA(B.VACANT_CABLE_SEAT) AS VACANT_CABLE_SEAT_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.STATION_ROAD_ID) AS STATION_ROAD_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.DEGREE_ARRIVAL_ID) AS DEGREE_ARRIVAL_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_ARRIVEL) AS IS_ARRIVEL_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_POWER) AS IS_POWER_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.INOUT_MODE) AS INOUT_MODE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.IS_EXPAND_OIL_ROOM) AS IS_EXPAND_OIL_ROOM_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.SECURITY_ENVIRONMENT_ID) AS SECURITY_ENVIRONMENT_ID_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.WNG_STYLE) AS WNG_STYLE_TEXT,
	res_entity.SF_GET_DESC_CHINA(B.ROOM_GRADE_ID) AS ROOM_GRADE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_MODE_ID) AS CHECK_MODE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.BUSINESS_ID) AS BUSINESS_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.SUB_BUSINESS_ID) AS SUB_BUSINESS_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.PROP_ID) AS PROP_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.OLD_PROP_ID) AS OLD_PROP_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.PROPERTY_ID) AS PROPERTY_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_STATE_ID) AS ENTITY_STATE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_LOCKED_ID) AS IS_LOCKED_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_FAULT_ID) AS IS_FAULT_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OVERDUE) AS IS_OVERDUE_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.WARRANTY_GRADE_ID) AS WARRANTY_GRADE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_OUTMAINTENANCE_ID) AS IS_OUTMAINTENANCE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.ASSETS_RECEIVE_TYPE_ID) AS ASSETS_RECEIVE_TYPE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.ENTITY_CREATE_SOURCE_ID) AS ENTITY_CREATE_SOURCE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.SOURCE_SYSTEM_ID) AS SOURCE_SYSTEM_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.CHECK_RESULT_ID) AS CHECK_RESULT_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.SERVICE_STATE_ID) AS SERVICE_STATE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_MONITOR_ID) AS IS_MONITOR_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.MONITOR_STYLE_ID) AS MONITOR_STYLE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_UPLOAD_PHOTO) AS IS_UPLOAD_PHOTO_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.STORAGE_STATE_ID) AS STORAGE_STATE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.IS_STORAGE) AS IS_STORAGE_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.RES_FROM_PROJBUILDTYPE_ID) AS RES_FROM_PROJBUILDTYPE_ID_TEXT,
	RES_ENTITY.SF_GET_DESC_CHINA(EE.SPLIT_MERGE_REASON_ID) AS SPLIT_MERGE_REASON_ID_TEXT,
	EE.SOURCE_RES_NO AS SOURCE_RES_NO_TEXT,
	(SELECT ENTITY_NAME FROM res_entity.ent_entity WHERE ENTITY_ID=EE.ROOM_ID and res_type_id='205' and delete_state='0') AS ROOM_ID_TEXT,
	(SELECT RES_TYPE FROM RES_SYS.PUB_DIC_RES_TYPE WHERE RES_TYPE_ID=EE.RES_TYPE_ID and delete_state='0') AS RES_TYPE_ID_TEXT,
	(SELECT EQP_TYPE FROM RES_SYS.PUB_DIC_EQP_TYPE WHERE EQP_TYPE_ID=EE.DEV_TYPE_ID and delete_state='0') AS DEV_TYPE_ID_TEXT,
	(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.DEV_MODEL_ID and delete_state='0') AS DEV_MODEL_ID_TEXT,
	(SELECT EQP_MODEL FROM RES_SYS.PUB_RME_EQP_MODEL WHERE EQP_MODEL_ID=EE.OLD_DEV_MODEL_ID and delete_state='0') AS OLD_DEV_MODEL_ID_TEXT,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MFR_ID and delete_state='0') AS MFR_ID_TEXT,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.DW_MFR_ID and delete_state='0') AS DW_MFR_ID_TEXT,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.OLD_DW_MFR_ID and delete_state='0') AS OLD_DW_MFR_ID_TEXT,
	(SELECT MFR FROM RES_SYS.PUB_MFR WHERE MFR_ID=EE.MNT_MFR_ID and delete_state='0') AS MNT_MFR_ID_TEXT,
	RES_ENTITY.SF_GET_STAFF_NAME(EE.MODIFY_OP) AS MODIFY_OP_TEXT,
	RES_ENTITY.SF_GET_STAFF_NAME(EE.CREATE_OP) AS CREATE_OP_TEXT,
	RES_ENTITY.SF_GET_STAFF_NAME(EE.CHECK_PERSON) AS CHECK_PERSON_TEXT,
	ST.DISTRICT_PROVINCE_ID,
	ST.DISTRICT_REGION_ID,
	ST.DISTRICT_COUNTY_ID,
	ST.STATION_NAME,
	ST.STATION_NAME AS STATION_ID_TEXT,
	D.APP_REGION_ID,
	(SELECT REGION_NAME FROM res_entity.REG_MANAGE WHERE REGION_ID = D.APP_REGION_ID AND delete_state = '0') AS APP_REGION_ID_TEXT,
	res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) AS DISTRICT_PROVINCE_ID_TEXT,
	res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) AS DISTRICT_REGION_ID_TEXT,
	res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS DISTRICT_COUNTY_ID_TEXT,
	res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_PROVINCE_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_REGION_ID) || res_entity.SF_GET_DISTRICT_NAME(ST.DISTRICT_COUNTY_ID) AS REGION_ID_TEXT 
FROM RES_ENTITY.ENT_ENTITY EE 
LEFT JOIN RES_ENTITY.ENT_ROOM B ON B.ENTITY_ID = EE.ENTITY_ID
LEFT JOIN RES_ENTITY.STA_STATION ST ON ST.STATION_CODE = EE.STATION_CODE  
LEFT JOIN RES_ENTITY.STA_APP_INFO D ON ST.STATION_ID=D.STATION_ID
WHERE EE.DELETE_STATE = '0' AND EE.RES_TYPE_ID=205  
AND EE.STATION_CODE in  (select station_code  from res_entity.sta_biz_info  where  REGION_ID in (  select REGION_ID from res_entity.reg_manage  connect by prior REGION_ID = SUPER_REGION_ID and nvl(delete_state, '0') = '0' start with region_id in ('000102000000000000370100') ) ) 
)t where ROWNUM <= 10) where rn > 0;

[2025-12-12 15:50:31.899930] [Case:40][Run:1] [o4-mini] Model Output Response:
{"answer":"no"}
[2025-12-12 15:50:40.426448] [Case:40][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:52:06.944649] [Case:40][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:52:06.945878] [40] hybrid Eval Final Result: True
[2025-12-12 15:52:06.947043] [Case:41][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select "a"."qh" as "qhmc","d"."zdjs" as "1xszdjs","a"."zdjs" as "6xszdjs","b"."zdjs" as "12xszdjs","c"."zdjs" as "24xszdjs" from
(select 
case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end as "qh" ,max("zdjs") as "zdjs" from (
select "xzqhdm",sum("zdjs") as "zdjs" from (
select "xzqhdm","zdjs" from WHYJ_SJZL."ds_dm_tqyj_jssk" where 
"gxsj">=NOW() - INTERVAL '7' HOUR
) group by "xzqhdm" 
) 
group by case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end 
order by "zdjs" desc ) "a" 
left join (select 
case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end as "qh" ,max("zdjs") as "zdjs" from (
select "xzqhdm",sum("zdjs") as "zdjs" from (
select "xzqhdm","zdjs" from WHYJ_SJZL."ds_dm_tqyj_jssk" where 
"gxsj">=NOW() - INTERVAL '13' HOUR
) group by "xzqhdm" 
) 
group by case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end 
order by "zdjs" desc ) "b" on "a"."qh" = "b"."qh" 
left join (select 
case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end as "qh" ,max("zdjs") as "zdjs" from (
select "xzqhdm",sum("zdjs") as "zdjs" from (
select "xzqhdm","zdjs" from WHYJ_SJZL."ds_dm_tqyj_jssk" where 
"gxsj">=NOW() - INTERVAL '25' HOUR
) group by "xzqhdm" 
) 
group by case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end 
order by "zdjs" desc ) "c" on "a"."qh" = "c"."qh"
left join (select 
case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end as "qh" ,max("zdjs") as "zdjs" from (
select "xzqhdm",sum("zdjs") as "zdjs" from (
select "xzqhdm","zdjs" from WHYJ_SJZL."ds_dm_tqyj_jssk" where 
"gxsj">=NOW() - INTERVAL '2' HOUR
) group by "xzqhdm" 
) 
group by case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end 
order by "zdjs" desc ) "d" on "a"."qh" = "d"."qh"
order by "6xszdjs" desc

[2025-12-12 15:52:06.949578] [Case:41][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select "a"."qh" as "qhmc","d"."zdjs" as "1xszdjs","a"."zdjs" as "6xszdjs","b"."zdjs" as "12xszdjs","c"."zdjs" as "24xszdjs" from
(select 
case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end as "qh" ,max("zdjs") as "zdjs" from (
select "xzqhdm",sum("zdjs") as "zdjs" from (
select "xzqhdm","zdjs" from WHYJ_SJZL."ds_dm_tqyj_jssk" where 
"gxsj">=NOW() - INTERVAL '7' HOUR
) group by "xzqhdm" 
) 
group by case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end 
order by "zdjs" desc ) "a" 
left join (select 
case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end as "qh" ,max("zdjs") as "zdjs" from (
select "xzqhdm",sum("zdjs") as "zdjs" from (
select "xzqhdm","zdjs" from WHYJ_SJZL."ds_dm_tqyj_jssk" where 
"gxsj">=NOW() - INTERVAL '13' HOUR
) group by "xzqhdm" 
) 
group by case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end 
order by "zdjs" desc ) "b" on "a"."qh" = "b"."qh" 
left join (select 
case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end as "qh" ,max("zdjs") as "zdjs" from (
select "xzqhdm",sum("zdjs") as "zdjs" from (
select "xzqhdm","zdjs" from WHYJ_SJZL."ds_dm_tqyj_jssk" where 
"gxsj">=NOW() - INTERVAL '25' HOUR
) group by "xzqhdm" 
) 
group by case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end 
order by "zdjs" desc ) "c" on "a"."qh" = "c"."qh"
left join (select 
case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end as "qh" ,max("zdjs") as "zdjs" from (
select "xzqhdm",sum("zdjs") as "zdjs" from (
select "xzqhdm","zdjs" from WHYJ_SJZL."ds_dm_tqyj_jssk" where 
"gxsj">=NOW() - INTERVAL '2' HOUR
) group by "xzqhdm" 
) 
group by case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end 
order by "zdjs" desc ) "d" on "a"."qh" = "d"."qh"
order by "6xszdjs" desc

[2025-12-12 15:52:06.949934] [Case:41][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select "a"."qh" as "qhmc","d"."zdjs" as "1xszdjs","a"."zdjs" as "6xszdjs","b"."zdjs" as "12xszdjs","c"."zdjs" as "24xszdjs" from
(select 
case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end as "qh" ,max("zdjs") as "zdjs" from (
select "xzqhdm",sum("zdjs") as "zdjs" from (
select "xzqhdm","zdjs" from WHYJ_SJZL."ds_dm_tqyj_jssk" where 
"gxsj">=NOW() - INTERVAL '7' HOUR
) group by "xzqhdm" 
) 
group by case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end 
order by "zdjs" desc ) "a" 
left join (select 
case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end as "qh" ,max("zdjs") as "zdjs" from (
select "xzqhdm",sum("zdjs") as "zdjs" from (
select "xzqhdm","zdjs" from WHYJ_SJZL."ds_dm_tqyj_jssk" where 
"gxsj">=NOW() - INTERVAL '13' HOUR
) group by "xzqhdm" 
) 
group by case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end 
order by "zdjs" desc ) "b" on "a"."qh" = "b"."qh" 
left join (select 
case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end as "qh" ,max("zdjs") as "zdjs" from (
select "xzqhdm",sum("zdjs") as "zdjs" from (
select "xzqhdm","zdjs" from WHYJ_SJZL."ds_dm_tqyj_jssk" where 
"gxsj">=NOW() - INTERVAL '25' HOUR
) group by "xzqhdm" 
) 
group by case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end 
order by "zdjs" desc ) "c" on "a"."qh" = "c"."qh"
left join (select 
case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end as "qh" ,max("zdjs") as "zdjs" from (
select "xzqhdm",sum("zdjs") as "zdjs" from (
select "xzqhdm","zdjs" from WHYJ_SJZL."ds_dm_tqyj_jssk" where 
"gxsj">=NOW() - INTERVAL '2' HOUR
) group by "xzqhdm" 
) 
group by case substr("xzqhdm",1,6) 
	 when '420102' then '江岸区'
	 when '420103' then '江汉区'
	 when '420104' then '硚口区'
	 when '420105' then '汉阳区'
	 when '420106' then '武昌区'
	 when '420107' then '青山区'
	 when '420111' then '洪山区'
	 when '420112' then '东西湖区'
	 when '420113' then '汉南区'
	 when '420114' then '蔡甸区'
	 when '420115' then '江夏区'
	 when '420116' then '黄陂区'
	 when '420117' then '新洲区' end 
order by "zdjs" desc ) "d" on "a"."qh" = "d"."qh"
order by "6xszdjs" desc

[2025-12-12 15:52:23.998316] [Case:41][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:52:27.718353] [Case:41][Run:1] [o4-mini] Model Output Response:
{"answer":"no"}
[2025-12-12 15:53:00.698753] [Case:41][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:53:00.699827] [41] hybrid Eval Final Result: False
[2025-12-12 15:53:00.700862] [Case:42][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT
  temp.*,
  t_rmm_store.STORE_NAME,
  t_rmm_location.LOCATION_NAME,
  t_qdm_standard.STANDARD_NAME,
  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,
  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,
  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,
  IF (
  t_dgm_send_info_detail.SPOT_TYPE = '40',
  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),
  IFNULL(t_dgm_send_info_detail.NUMBER, 0)
  ) AS `SEND_NUMBER`,
  IF (
  t_dgm_send_info_detail.SPOT_TYPE = '40',
  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),
  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)
  ) AS `RETURN_NUMBER`
FROM
  t_dgm_send_info_detail
  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID AND t_dgm_send_info.SEND_STATE = '70'
  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID
  LEFT JOIN (
  SELECT
     IFNULL(
    v_pre_product_material.PACKAGE_NO,
    v_pre_product_material.MATERIAL_NO
     ) AS MIXED_NO,
     v_pre_product_material.STORE_ID,
     v_pre_product_material.LOCATION_ID,
     v_pre_product_material.STANDARD_ID,
     v_pre_product_material.STEEL_GRADE,
     v_pre_product_material.CUSTOMER_ID
  FROM
     v_pre_product_material
     LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO
     LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO
     LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID
     LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID
  WHERE
     v_pre_product_material.IS_ISSUED = '1'
     AND v_pre_product_material.IS_SPOT_RESOURCE = '0'
     AND v_pre_product_material.NI36_TAG = '0'
     AND v_pre_product_material.MATERIAL_STATE != '110'
     AND v_pre_product_material.CONTRACT_TYPE != '60'
     AND v_pre_product_material.CUSTOMER_ID = '1930921074703462401'
     AND NOT EXISTS (
    SELECT
    1
    FROM
    v_pre_product_material v2
    WHERE
    v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO
    OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO
    GROUP BY
    COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)
    HAVING
    SUM(
      CASE
    WHEN IS_ISSUED != '1' THEN 1
    ELSE 0
      END
    ) > 0
     )
  GROUP BY
     COALESCE(
    v_pre_product_material.PACKAGE_NO,
    v_pre_product_material.MATERIAL_NO
     )
  UNION ALL
  SELECT
     t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,
     t_inm_store_info.STORE_ID AS STORE_ID,
     t_inm_store_info.LOCATION_ID AS LOCATION_ID,
     NULL AS STANDARD_ID,
     t_inm_store_info.STEEL_GRADE AS STEEL_GRADE,
     t_sam_contract.CUSTOMER_ID AS CUSTOMER_ID
  FROM
     t_sam_contract_detail
     LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID
     LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO
     LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID
  WHERE
     t_sam_contract.CONTRACT_TYPE = '20'
     AND t_sam_contract_detail.IS_DELETE = '0'
     AND t_sam_contract.IS_DELETE = '0'
     AND t_sam_contract_detail.SPOT_TYPE = '10'
     AND t_inm_store_info.STOCK_ID IS NOT NULL
     AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')
     AND t_sam_contract.CUSTOMER_ID = '1930921074703462401'
  GROUP BY
     t_sam_contract_detail.PRODUCT_MATERIAL_NO
  UNION ALL
  SELECT
     t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,
     t_pre_product_material.STORE_ID AS STORE_ID,
     t_pre_product_material.LOCATION_ID AS LOCATION_ID,
     t_pre_product_material.STANDARD_ID AS STANDARD_ID,
     t_pre_product_material.STEEL_GRADE AS STEEL_GRADE,
     t_sam_contract.CUSTOMER_ID AS CUSTOMER_ID
  FROM
     t_sam_contract_detail
     LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID
     LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO
     OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO
  WHERE
     t_sam_contract.CONTRACT_TYPE = '20'
     AND t_sam_contract_detail.IS_DELETE = '0'
     AND t_sam_contract.IS_DELETE = '0'
     AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')
     AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL
     AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')
     AND t_sam_contract.CUSTOMER_ID = '1930921074703462401'
  GROUP BY
     t_sam_contract_detail.PRODUCT_MATERIAL_NO
  UNION ALL
  SELECT
     t_pre_scrap.BATCH_NO AS MIXED_NO,
     '/' AS STORE_ID,
     '/' AS LOCATION_ID,
     NULL AS STANDARD_ID,
     t_pre_scrap.STEEL_GRADE AS STEEL_GRADE,
     t_sam_contract.CUSTOMER_ID AS CUSTOMER_ID
  FROM
     t_sam_contract_detail
     LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID
     LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID
  WHERE
     t_sam_contract.CONTRACT_TYPE = '20'
     AND t_sam_contract_detail.IS_DELETE = '0'
     AND t_sam_contract.IS_DELETE = '0'
     AND t_sam_contract_detail.SPOT_TYPE = '40'
     AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')
     AND t_sam_contract.CUSTOMER_ID = '1930921074703462401'
  GROUP BY
     t_pre_scrap.BATCH_NO
  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO
  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID
  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID
  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID
  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE
group by
  temp.MIXED_NO
having
  SEND_NUMBER > RETURN_NUMBER
LIMIT
  100

[2025-12-12 15:53:00.702560] [Case:42][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT
  temp.*,
  t_rmm_store.STORE_NAME,
  t_rmm_location.LOCATION_NAME,
  t_qdm_standard.STANDARD_NAME,
  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,
  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,
  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,
  IF (
  t_dgm_send_info_detail.SPOT_TYPE = '40',
  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),
  IFNULL(t_dgm_send_info_detail.NUMBER, 0)
  ) AS `SEND_NUMBER`,
  IF (
  t_dgm_send_info_detail.SPOT_TYPE = '40',
  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),
  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)
  ) AS `RETURN_NUMBER`
FROM
  t_dgm_send_info_detail
  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID AND t_dgm_send_info.SEND_STATE = '70'
  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID
  LEFT JOIN (
  SELECT
     IFNULL(
    v_pre_product_material.PACKAGE_NO,
    v_pre_product_material.MATERIAL_NO
     ) AS MIXED_NO,
     v_pre_product_material.STORE_ID,
     v_pre_product_material.LOCATION_ID,
     v_pre_product_material.STANDARD_ID,
     v_pre_product_material.STEEL_GRADE,
     v_pre_product_material.CUSTOMER_ID
  FROM
     v_pre_product_material
     LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO
     LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO
     LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID
     LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID
  WHERE
     v_pre_product_material.IS_ISSUED = '1'
     AND v_pre_product_material.IS_SPOT_RESOURCE = '0'
     AND v_pre_product_material.NI36_TAG = '0'
     AND v_pre_product_material.MATERIAL_STATE != '110'
     AND v_pre_product_material.CONTRACT_TYPE != '60'
     AND v_pre_product_material.CUSTOMER_ID = '1930921074703462401'
     AND NOT EXISTS (
    SELECT
    1
    FROM
    v_pre_product_material v2
    WHERE
    v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO
    OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO
    GROUP BY
    COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)
    HAVING
    SUM(
      CASE
    WHEN IS_ISSUED != '1' THEN 1
    ELSE 0
      END
    ) > 0
     )
  GROUP BY
     COALESCE(
    v_pre_product_material.PACKAGE_NO,
    v_pre_product_material.MATERIAL_NO
     )
  UNION ALL
  SELECT
     t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,
     t_inm_store_info.STORE_ID AS STORE_ID,
     t_inm_store_info.LOCATION_ID AS LOCATION_ID,
     NULL AS STANDARD_ID,
     t_inm_store_info.STEEL_GRADE AS STEEL_GRADE,
     t_sam_contract.CUSTOMER_ID AS CUSTOMER_ID
  FROM
     t_sam_contract_detail
     LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID
     LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO
     LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID
  WHERE
     t_sam_contract.CONTRACT_TYPE = '20'
     AND t_sam_contract_detail.IS_DELETE = '0'
     AND t_sam_contract.IS_DELETE = '0'
     AND t_sam_contract_detail.SPOT_TYPE = '10'
     AND t_inm_store_info.STOCK_ID IS NOT NULL
     AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')
     AND t_sam_contract.CUSTOMER_ID = '1930921074703462401'
  GROUP BY
     t_sam_contract_detail.PRODUCT_MATERIAL_NO
  UNION ALL
  SELECT
     t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,
     t_pre_product_material.STORE_ID AS STORE_ID,
     t_pre_product_material.LOCATION_ID AS LOCATION_ID,
     t_pre_product_material.STANDARD_ID AS STANDARD_ID,
     t_pre_product_material.STEEL_GRADE AS STEEL_GRADE,
     t_sam_contract.CUSTOMER_ID AS CUSTOMER_ID
  FROM
     t_sam_contract_detail
     LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID
     LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO
     OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO
  WHERE
     t_sam_contract.CONTRACT_TYPE = '20'
     AND t_sam_contract_detail.IS_DELETE = '0'
     AND t_sam_contract.IS_DELETE = '0'
     AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')
     AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL
     AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')
     AND t_sam_contract.CUSTOMER_ID = '1930921074703462401'
  GROUP BY
     t_sam_contract_detail.PRODUCT_MATERIAL_NO
  UNION ALL
  SELECT
     t_pre_scrap.BATCH_NO AS MIXED_NO,
     '/' AS STORE_ID,
     '/' AS LOCATION_ID,
     NULL AS STANDARD_ID,
     t_pre_scrap.STEEL_GRADE AS STEEL_GRADE,
     t_sam_contract.CUSTOMER_ID AS CUSTOMER_ID
  FROM
     t_sam_contract_detail
     LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID
     LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID
  WHERE
     t_sam_contract.CONTRACT_TYPE = '20'
     AND t_sam_contract_detail.IS_DELETE = '0'
     AND t_sam_contract.IS_DELETE = '0'
     AND t_sam_contract_detail.SPOT_TYPE = '40'
     AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')
     AND t_sam_contract.CUSTOMER_ID = '1930921074703462401'
  GROUP BY
     t_pre_scrap.BATCH_NO
  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO
  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID
  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID
  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID
  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE
group by
  temp.MIXED_NO
having
  SEND_NUMBER > RETURN_NUMBER
LIMIT
  100

[2025-12-12 15:53:00.703519] [Case:42][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT
  temp.*,
  t_rmm_store.STORE_NAME,
  t_rmm_location.LOCATION_NAME,
  t_qdm_standard.STANDARD_NAME,
  t_bdm_column.COLUMN_NAME AS `STEEL_GRADE_NAME`,
  t_dgm_send_info.SEND_ID AS `CONNECT_ID`,
  t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID AS `CONNECT_DETAIL_ID`,
  IF (
  t_dgm_send_info_detail.SPOT_TYPE = '40',
  IFNULL(t_dgm_send_info_detail.WEIGHT, 0),
  IFNULL(t_dgm_send_info_detail.NUMBER, 0)
  ) AS `SEND_NUMBER`,
  IF (
  t_dgm_send_info_detail.SPOT_TYPE = '40',
  IFNULL(t_dgm_send_info_return_detail.WEIGHT, 0),
  IFNULL(t_dgm_send_info_return_detail.NUMBER, 0)
  ) AS `RETURN_NUMBER`
FROM
  t_dgm_send_info_detail
  LEFT JOIN t_dgm_send_info ON t_dgm_send_info.SEND_ID = t_dgm_send_info_detail.SEND_ID AND t_dgm_send_info.SEND_STATE = '70'
  LEFT JOIN t_dgm_send_info_return_detail ON t_dgm_send_info_return_detail.CONNECT_DETAIL_ID = t_dgm_send_info_detail.SEND_PRODUCT_DETAIL_ID
  LEFT JOIN (
  SELECT
     IFNULL(
    v_pre_product_material.PACKAGE_NO,
    v_pre_product_material.MATERIAL_NO
     ) AS MIXED_NO,
     v_pre_product_material.STORE_ID,
     v_pre_product_material.LOCATION_ID,
     v_pre_product_material.STANDARD_ID,
     v_pre_product_material.STEEL_GRADE,
     v_pre_product_material.CUSTOMER_ID
  FROM
     v_pre_product_material
     LEFT JOIN t_dgm_send_plan_detail material ON v_pre_product_material.MATERIAL_NO = material.MATERIAL_NO
     LEFT JOIN t_dgm_send_plan_detail package ON v_pre_product_material.PACKAGE_NO = package.PACKAGE_NO
     LEFT JOIN t_mao_contract_delivery_subkey ON t_mao_contract_delivery_subkey.CONTRACT_DELIVERY_ID = v_pre_product_material.CONTRACT_DELIVERY_ID
     LEFT JOIN t_sam_contract_detail ON t_mao_contract_delivery_subkey.CONTRACT_DETAIL_ID = t_sam_contract_detail.CONTRACT_DETAILS_ID
  WHERE
     v_pre_product_material.IS_ISSUED = '1'
     AND v_pre_product_material.IS_SPOT_RESOURCE = '0'
     AND v_pre_product_material.NI36_TAG = '0'
     AND v_pre_product_material.MATERIAL_STATE != '110'
     AND v_pre_product_material.CONTRACT_TYPE != '60'
     AND v_pre_product_material.CUSTOMER_ID = '1930921074703462401'
     AND NOT EXISTS (
    SELECT
    1
    FROM
    v_pre_product_material v2
    WHERE
    v2.PACKAGE_NO = v_pre_product_material.PACKAGE_NO
    OR v2.MATERIAL_NO = v_pre_product_material.MATERIAL_NO
    GROUP BY
    COALESCE(v2.PACKAGE_NO, v2.MATERIAL_NO)
    HAVING
    SUM(
      CASE
    WHEN IS_ISSUED != '1' THEN 1
    ELSE 0
      END
    ) > 0
     )
  GROUP BY
     COALESCE(
    v_pre_product_material.PACKAGE_NO,
    v_pre_product_material.MATERIAL_NO
     )
  UNION ALL
  SELECT
     t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,
     t_inm_store_info.STORE_ID AS STORE_ID,
     t_inm_store_info.LOCATION_ID AS LOCATION_ID,
     NULL AS STANDARD_ID,
     t_inm_store_info.STEEL_GRADE AS STEEL_GRADE,
     t_sam_contract.CUSTOMER_ID AS CUSTOMER_ID
  FROM
     t_sam_contract_detail
     LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID
     LEFT JOIN t_inm_store_info ON t_inm_store_info.MATERIAL_NO = t_sam_contract_detail.PRODUCT_MATERIAL_NO
     LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column ON t_inm_store_info.VARIETY_ID = t_bdm_column.COLUMN_ID
  WHERE
     t_sam_contract.CONTRACT_TYPE = '20'
     AND t_sam_contract_detail.IS_DELETE = '0'
     AND t_sam_contract.IS_DELETE = '0'
     AND t_sam_contract_detail.SPOT_TYPE = '10'
     AND t_inm_store_info.STOCK_ID IS NOT NULL
     AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')
     AND t_sam_contract.CUSTOMER_ID = '1930921074703462401'
  GROUP BY
     t_sam_contract_detail.PRODUCT_MATERIAL_NO
  UNION ALL
  SELECT
     t_sam_contract_detail.PRODUCT_MATERIAL_NO AS MIXED_NO,
     t_pre_product_material.STORE_ID AS STORE_ID,
     t_pre_product_material.LOCATION_ID AS LOCATION_ID,
     t_pre_product_material.STANDARD_ID AS STANDARD_ID,
     t_pre_product_material.STEEL_GRADE AS STEEL_GRADE,
     t_sam_contract.CUSTOMER_ID AS CUSTOMER_ID
  FROM
     t_sam_contract_detail
     LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID
     LEFT JOIN t_pre_product_material ON t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.PACKAGE_NO
     OR t_sam_contract_detail.PRODUCT_MATERIAL_NO = t_pre_product_material.MATERIAL_NO
  WHERE
     t_sam_contract.CONTRACT_TYPE = '20'
     AND t_sam_contract_detail.IS_DELETE = '0'
     AND t_sam_contract.IS_DELETE = '0'
     AND t_sam_contract_detail.SPOT_TYPE IN ('20', '30')
     AND t_pre_product_material.PRODUCE_MATERIAL_ID IS NOT NULL
     AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')
     AND t_sam_contract.CUSTOMER_ID = '1930921074703462401'
  GROUP BY
     t_sam_contract_detail.PRODUCT_MATERIAL_NO
  UNION ALL
  SELECT
     t_pre_scrap.BATCH_NO AS MIXED_NO,
     '/' AS STORE_ID,
     '/' AS LOCATION_ID,
     NULL AS STANDARD_ID,
     t_pre_scrap.STEEL_GRADE AS STEEL_GRADE,
     t_sam_contract.CUSTOMER_ID AS CUSTOMER_ID
  FROM
     t_sam_contract_detail
     LEFT JOIN t_sam_contract ON t_sam_contract.CONTRACT_ID = t_sam_contract_detail.CONTRACT_ID
     LEFT JOIN t_pre_scrap ON t_pre_scrap.SCRAP_INFO_ID = t_sam_contract_detail.SCRAP_INFO_ID
  WHERE
     t_sam_contract.CONTRACT_TYPE = '20'
     AND t_sam_contract_detail.IS_DELETE = '0'
     AND t_sam_contract.IS_DELETE = '0'
     AND t_sam_contract_detail.SPOT_TYPE = '40'
     AND t_sam_contract.CONTRACT_STATE IN ('40', '50', '70')
     AND t_sam_contract.CUSTOMER_ID = '1930921074703462401'
  GROUP BY
     t_pre_scrap.BATCH_NO
  ) as temp on temp.MIXED_NO = t_dgm_send_info_detail.MIXED_NO
  LEFT JOIN zjjs_rmm.t_rmm_store t_rmm_store on t_rmm_store.STORE_ID = temp.STORE_ID
  LEFT JOIN zjjs_rmm.t_rmm_location t_rmm_location on t_rmm_location.LOCATION_ID = temp.LOCATION_ID
  LEFT JOIN zjjs_qdm.t_qdm_standard t_qdm_standard on t_qdm_standard.STANDARD_ID = temp.STANDARD_ID
  LEFT JOIN zjjs_mpm.t_bdm_column t_bdm_column on t_bdm_column.COLUMN_ID = temp.STEEL_GRADE
group by
  temp.MIXED_NO
having
  SEND_NUMBER > RETURN_NUMBER
LIMIT
  100

[2025-12-12 15:53:25.529462] [Case:42][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:53:44.996126] [Case:42][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:55:26.828168] [Case:42][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:55:26.829303] [42] hybrid Eval Final Result: True
[2025-12-12 15:55:26.830824] [Case:43][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM ( SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM dble_jumpstringhash_int_1 WHERE NOT EXISTS (SELECT 1 FROM dble_stringhash_datetime_2 WHERE col_pk_varchar BETWEEN 192 AND 171) ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39 LIMIT 97 OFFSET 5) AS t WHERE col_varchar_64_not_null LIKE '%p%' ORDER BY col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null DESC LIMIT 215 OFFSET 3;

[2025-12-12 15:55:26.831382] [Case:43][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM ( SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM dble_jumpstringhash_int_1 WHERE NOT EXISTS (SELECT 1 FROM dble_stringhash_datetime_2 WHERE col_pk_varchar BETWEEN 192 AND 171) ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39 LIMIT 97 OFFSET 5) AS t WHERE col_varchar_64_not_null LIKE '%p%' ORDER BY col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null DESC LIMIT 215 OFFSET 3;

[2025-12-12 15:55:26.831686] [Case:43][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM ( SELECT DISTINCT col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null FROM dble_jumpstringhash_int_1 WHERE NOT EXISTS (SELECT 1 FROM dble_stringhash_datetime_2 WHERE col_pk_varchar BETWEEN 192 AND 171) ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39 LIMIT 97 OFFSET 5) AS t WHERE col_varchar_64_not_null LIKE '%p%' ORDER BY col_int_auto_increment,col_pk_char,col_pk_varchar,col_pk_date,col_pk_decimal_not_null,col_pk_numeric_not_null,col_int_not_null,col_int_not_null__1,col_int_8_not_null,col_int_8_not_null__1,col_bigint_not_null,col_smallint_not_null,col_tinyint_not_null,col_float_not_null,col_double_not_null,col_decimal_not_null,col_numeric_not_null,col_bit_not_null,col_bit_not_null__1,col_char_3_not_null,col_char_255_not_null,col_varchar_1_not_null,col_varchar_64_not_null,col_varchar_2048_not_null,col_binary_8_not_null,col_varbinary_8_not_null,col_date_not_null,col_time_not_null,col_datetime_not_null,col_year_not_null,col_text_not_null,col_bool_not_null,col_boolean_not_null,col_longtext_not_null,col_mediumtext_not_null,col_tinyblob_not_null,col_mediumblob_not_null,col_longblob_not_null,col_blob_not_null DESC LIMIT 215 OFFSET 3;

[2025-12-12 15:55:40.072251] [Case:43][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:55:40.283639] [Case:43][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:56:51.659693] [Case:43][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:56:51.667533] [43] hybrid Eval Final Result: True
[2025-12-12 15:56:51.668954] [Case:44][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT d.id, d.title
FROM document_template d
WHERE d.deleted_at IS NULL 
  AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 
  AND d.title LIKE '%Epaul%' 
  AND EXISTS (
    SELECT 1 
    FROM tag_thing tt0
    WHERE tt0.document_template_id = d.id
      AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'
      AND tt0.deleted_at IS NULL
  )
  AND (
    EXISTS (
        SELECT 1 
        FROM `user` u 
        WHERE u.id = d.owner_id 
          AND u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a')
    )
    OR 
    ( 
      d.private = 0 
      AND EXISTS (
        SELECT 1 
        FROM `user` u 
        WHERE u.id = d.owner_id 
          AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a')
      )
    )
  )
ORDER BY title ASC LIMIT 10 OFFSET 0;

[2025-12-12 15:56:51.669751] [Case:44][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT d.id, d.title
FROM document_template d
WHERE d.deleted_at IS NULL 
  AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 
  AND d.title LIKE '%Epaul%' 
  AND EXISTS (
    SELECT 1 
    FROM tag_thing tt0
    WHERE tt0.document_template_id = d.id
      AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'
      AND tt0.deleted_at IS NULL
  )
  AND (
    EXISTS (
        SELECT 1 
        FROM `user` u 
        WHERE u.id = d.owner_id 
          AND u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a')
    )
    OR 
    ( 
      d.private = 0 
      AND EXISTS (
        SELECT 1 
        FROM `user` u 
        WHERE u.id = d.owner_id 
          AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a')
      )
    )
  )
ORDER BY title ASC LIMIT 10 OFFSET 0;

[2025-12-12 15:56:51.670127] [Case:44][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT d.id, d.title
FROM document_template d
WHERE d.deleted_at IS NULL 
  AND MATCH(d.title) AGAINST('Epaul' IN BOOLEAN MODE) > 0 
  AND d.title LIKE '%Epaul%' 
  AND EXISTS (
    SELECT 1 
    FROM tag_thing tt0
    WHERE tt0.document_template_id = d.id
      AND tt0.tag_id = '9963ebcd-c834-4ff1-bdf5-229ef1b59204'
      AND tt0.deleted_at IS NULL
  )
  AND (
    EXISTS (
        SELECT 1 
        FROM `user` u 
        WHERE u.id = d.owner_id 
          AND u.uuid IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a')
    )
    OR 
    ( 
      d.private = 0 
      AND EXISTS (
        SELECT 1 
        FROM `user` u 
        WHERE u.id = d.owner_id 
          AND u.uuid NOT IN ('b60c5bfd-1ccb-40a3-a459-20998121f765', 'f2abfee7-c8a1-4540-9a0e-75921263650a')
      )
    )
  )
ORDER BY title ASC LIMIT 10 OFFSET 0;

[2025-12-12 15:56:59.071981] [Case:44][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:56:59.522868] [Case:44][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:57:12.412921] [Case:44][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:57:12.414024] [44] hybrid Eval Final Result: True
[2025-12-12 15:57:12.414996] [Case:45][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  s.s_id,
  s.s_name,
  s.s_sex,
  COUNT(DISTINCT sc.c_id) AS course_count,
  AVG(sc.s_score) AS avg_score,
  SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) AS excellent_course_count,
  RANK() OVER (PARTITION BY s.s_sex ORDER BY AVG(sc.s_score) DESC) AS gender_rank
FROM Student s
JOIN Score sc ON s.s_id = sc.s_id
GROUP BY s.s_id, s.s_name, s.s_sex
HAVING AVG(sc.s_score) > 80 AND SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) >= 2
ORDER BY avg_score DESC;

[2025-12-12 15:57:12.415312] [Case:45][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  s.s_id,
  s.s_name,
  s.s_sex,
  COUNT(DISTINCT sc.c_id) AS course_count,
  AVG(sc.s_score) AS avg_score,
  SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) AS excellent_course_count,
  RANK() OVER (PARTITION BY s.s_sex ORDER BY AVG(sc.s_score) DESC) AS gender_rank
FROM Student s
JOIN Score sc ON s.s_id = sc.s_id
GROUP BY s.s_id, s.s_name, s.s_sex
HAVING AVG(sc.s_score) > 80 AND SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) >= 2
ORDER BY avg_score DESC;

[2025-12-12 15:57:12.416327] [Case:45][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  s.s_id,
  s.s_name,
  s.s_sex,
  COUNT(DISTINCT sc.c_id) AS course_count,
  AVG(sc.s_score) AS avg_score,
  SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) AS excellent_course_count,
  RANK() OVER (PARTITION BY s.s_sex ORDER BY AVG(sc.s_score) DESC) AS gender_rank
FROM Student s
JOIN Score sc ON s.s_id = sc.s_id
GROUP BY s.s_id, s.s_name, s.s_sex
HAVING AVG(sc.s_score) > 80 AND SUM(CASE WHEN sc.s_score > 90 THEN 1 ELSE 0 END) >= 2
ORDER BY avg_score DESC;

[2025-12-12 15:57:27.249581] [Case:45][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:57:38.856764] [Case:45][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:59:00.385207] [Case:45][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:59:00.386546] [45] hybrid Eval Final Result: True
[2025-12-12 15:59:00.387543] [Case:46][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select /*QB_1*/ u.user_id,
  u.username, COUNT(distinct o.order_id) as total_orders,
  SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent,
  AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value,
  MAX(o.order_date) as last_order_date,
  SQ_1758176107425.GROUP_CONCAT_ as top_products
from users as u
inner join orders as o
on u.user_id = o.user_id 
left outer join order_items as oi
on o.order_id = oi.order_id 
left outer join (
  select /*SQ_1758176107425*/ oi2.user_id,
  GROUP_CONCAT(distinct oi2.product_name order by oi2.product_name separator ', ') as GROUP_CONCAT_
  from (
  select /*QB_2*/ o3.user_id,
  p.product_name,
  row_number() over (partition by o3.user_id order by sum(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num
  from order_items as oi2
  inner join products as p
  on oi2.product_id = p.product_id
  inner join orders as o3
  on o3.order_id = oi2.order_id
  where o3.order_date >= DATE_SUB(CURRENT_DATE(), interval '3' YEAR)
    and exists (select 1 from users u where u.user_id = o3.user_id and u.status = 'active')
  group by o3.user_id,
  p.product_name
  ) as oi2
  where oi2.rank_num <= 3 
  group by oi2.user_id 
  ) as SQ_1758176107425
on SQ_1758176107425.user_id = u.user_id
where u.status = 'active'
  and o.order_date >= DATE_SUB(CURRENT_DATE(),
  interval '3' YEAR)
group by u.user_id, u.username
having COUNT(distinct o.order_id) > 0
order by total_spent desc;

[2025-12-12 15:59:00.388153] [Case:46][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select /*QB_1*/ u.user_id,
  u.username, COUNT(distinct o.order_id) as total_orders,
  SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent,
  AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value,
  MAX(o.order_date) as last_order_date,
  SQ_1758176107425.GROUP_CONCAT_ as top_products
from users as u
inner join orders as o
on u.user_id = o.user_id 
left outer join order_items as oi
on o.order_id = oi.order_id 
left outer join (
  select /*SQ_1758176107425*/ oi2.user_id,
  GROUP_CONCAT(distinct oi2.product_name order by oi2.product_name separator ', ') as GROUP_CONCAT_
  from (
  select /*QB_2*/ o3.user_id,
  p.product_name,
  row_number() over (partition by o3.user_id order by sum(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num
  from order_items as oi2
  inner join products as p
  on oi2.product_id = p.product_id
  inner join orders as o3
  on o3.order_id = oi2.order_id
  where o3.order_date >= DATE_SUB(CURRENT_DATE(), interval '3' YEAR)
    and exists (select 1 from users u where u.user_id = o3.user_id and u.status = 'active')
  group by o3.user_id,
  p.product_name
  ) as oi2
  where oi2.rank_num <= 3 
  group by oi2.user_id 
  ) as SQ_1758176107425
on SQ_1758176107425.user_id = u.user_id
where u.status = 'active'
  and o.order_date >= DATE_SUB(CURRENT_DATE(),
  interval '3' YEAR)
group by u.user_id, u.username
having COUNT(distinct o.order_id) > 0
order by total_spent desc;

[2025-12-12 15:59:00.389147] [Case:46][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select /*QB_1*/ u.user_id,
  u.username, COUNT(distinct o.order_id) as total_orders,
  SUM(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as total_spent,
  AVG(oi.quantity * oi.unit_price * (1 - oi.discount / 100)) as avg_order_value,
  MAX(o.order_date) as last_order_date,
  SQ_1758176107425.GROUP_CONCAT_ as top_products
from users as u
inner join orders as o
on u.user_id = o.user_id 
left outer join order_items as oi
on o.order_id = oi.order_id 
left outer join (
  select /*SQ_1758176107425*/ oi2.user_id,
  GROUP_CONCAT(distinct oi2.product_name order by oi2.product_name separator ', ') as GROUP_CONCAT_
  from (
  select /*QB_2*/ o3.user_id,
  p.product_name,
  row_number() over (partition by o3.user_id order by sum(oi2.quantity * oi2.unit_price * (1 - oi2.discount / 100)) desc) as rank_num
  from order_items as oi2
  inner join products as p
  on oi2.product_id = p.product_id
  inner join orders as o3
  on o3.order_id = oi2.order_id
  where o3.order_date >= DATE_SUB(CURRENT_DATE(), interval '3' YEAR)
    and exists (select 1 from users u where u.user_id = o3.user_id and u.status = 'active')
  group by o3.user_id,
  p.product_name
  ) as oi2
  where oi2.rank_num <= 3 
  group by oi2.user_id 
  ) as SQ_1758176107425
on SQ_1758176107425.user_id = u.user_id
where u.status = 'active'
  and o.order_date >= DATE_SUB(CURRENT_DATE(),
  interval '3' YEAR)
group by u.user_id, u.username
having COUNT(distinct o.order_id) > 0
order by total_spent desc;

[2025-12-12 15:59:16.819696] [Case:46][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 15:59:17.213376] [Case:46][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "no"
}
[2025-12-12 15:59:32.907975] [Case:46][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:59:32.909231] [46] hybrid Eval Final Result: True
[2025-12-12 15:59:32.910189] [Case:47][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select * 
from (
select base.vehicle_type, base.booking_status, base.payment_method, base.ride_distance, coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0) as rate, 
 row_number() over(partition by base.vehicle_type order by abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) desc ) as rank_num 
from ride_bookings base 
left join (
	select vehicle_type, booking_status,payment_method,coalesce(avg(ride_distance), 0) as avg_v
	from ride_bookings 
	group by vehicle_type, booking_status,payment_method
) avg_cust_rate 
on base.vehicle_type = avg_cust_rate.vehicle_type and base.booking_status = avg_cust_rate.booking_status and base.payment_method = avg_cust_rate.payment_method 
where abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) >= 1 
) fn 
where rank_num <=5;

[2025-12-12 15:59:32.910743] [Case:47][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select * 
from (
select base.vehicle_type, base.booking_status, base.payment_method, base.ride_distance, coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0) as rate, 
 row_number() over(partition by base.vehicle_type order by abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) desc ) as rank_num 
from ride_bookings base 
left join (
	select vehicle_type, booking_status,payment_method,coalesce(avg(ride_distance), 0) as avg_v
	from ride_bookings 
	group by vehicle_type, booking_status,payment_method
) avg_cust_rate 
on base.vehicle_type = avg_cust_rate.vehicle_type and base.booking_status = avg_cust_rate.booking_status and base.payment_method = avg_cust_rate.payment_method 
where abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) >= 1 
) fn 
where rank_num <=5;

[2025-12-12 15:59:32.912255] [Case:47][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
select * 
from (
select base.vehicle_type, base.booking_status, base.payment_method, base.ride_distance, coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0) as rate, 
 row_number() over(partition by base.vehicle_type order by abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) desc ) as rank_num 
from ride_bookings base 
left join (
	select vehicle_type, booking_status,payment_method,coalesce(avg(ride_distance), 0) as avg_v
	from ride_bookings 
	group by vehicle_type, booking_status,payment_method
) avg_cust_rate 
on base.vehicle_type = avg_cust_rate.vehicle_type and base.booking_status = avg_cust_rate.booking_status and base.payment_method = avg_cust_rate.payment_method 
where abs(coalesce(base.ride_distance, 0) - coalesce(avg_cust_rate.avg_v, 0)) >= 1 
) fn 
where rank_num <=5;

[2025-12-12 15:59:38.090248] [Case:47][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 15:59:41.710850] [Case:47][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 16:00:53.020539] [Case:47][Run:1] [deepseek-r1] Model Output Response:
```{"answer":"yes"}
[2025-12-12 16:00:53.021857] [47] hybrid Eval Final Result: True
[2025-12-12 16:00:53.023002] [Case:48][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  rb.customer_id,
  COUNT(DISTINCT rb.booking_id) AS total_bookings,
  SUM(rb.booking_value) AS total_revenue,
  AVG(rb.driver_rating) AS avg_driver_rating,
  MAX(rb.booking_date) AS last_booking_date
FROM 
  ride_bookings rb
WHERE 
  rb.booking_status IN ('Completed', 'Cancelled', 'No Show')
  AND rb.booking_date >= CAST(DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY) AS DATETIME)
GROUP BY 
  rb.customer_id
HAVING 
  total_bookings > 10
ORDER BY 
  total_revenue DESC,
  avg_driver_rating ASC;

[2025-12-12 16:00:53.023562] [Case:48][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  rb.customer_id,
  COUNT(DISTINCT rb.booking_id) AS total_bookings,
  SUM(rb.booking_value) AS total_revenue,
  AVG(rb.driver_rating) AS avg_driver_rating,
  MAX(rb.booking_date) AS last_booking_date
FROM 
  ride_bookings rb
WHERE 
  rb.booking_status IN ('Completed', 'Cancelled', 'No Show')
  AND rb.booking_date >= CAST(DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY) AS DATETIME)
GROUP BY 
  rb.customer_id
HAVING 
  total_bookings > 10
ORDER BY 
  total_revenue DESC,
  avg_driver_rating ASC;

[2025-12-12 16:00:53.023958] [Case:48][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT 
  rb.customer_id,
  COUNT(DISTINCT rb.booking_id) AS total_bookings,
  SUM(rb.booking_value) AS total_revenue,
  AVG(rb.driver_rating) AS avg_driver_rating,
  MAX(rb.booking_date) AS last_booking_date
FROM 
  ride_bookings rb
WHERE 
  rb.booking_status IN ('Completed', 'Cancelled', 'No Show')
  AND rb.booking_date >= CAST(DATE_SUB(CURRENT_DATE(), INTERVAL 180 DAY) AS DATETIME)
GROUP BY 
  rb.customer_id
HAVING 
  total_bookings > 10
ORDER BY 
  total_revenue DESC,
  avg_driver_rating ASC;

[2025-12-12 16:00:59.648936] [Case:48][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 16:01:01.459724] [Case:48][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 16:01:56.312429] [Case:48][Run:1] [deepseek-r1] Model Output Response:
```{"answer": "yes"}
[2025-12-12 16:01:56.313488] [48] hybrid Eval Final Result: True
[2025-12-12 16:01:56.314372] [Case:49][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT count(1) stockNum, COUNT(c.FIRST_IN_HOSTSTOCK_DATE ) hostStockNum -- , -- DATE_FORMAT( Max(mpd.INSTORE_TIME), '%Y-%m-%d %H:%i:%s') maxStoreTime 
FROM (SELECT * FROM t_mdm_dlr_car_store WHERE IS_ENABLE = '1') c 
LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID = c.CAR_ID 
LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE = c.SALES_PLAN_CODE 
LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID = SO.SALE_ORDER_ID 
LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID = car.CAR_CONFIG_ID 
LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id = iad.link_order_id and iad.is_Enable='1' 
LEFT JOIN (SELECT CAR_ID from t_ve_bu_movestock_order WHERE MOVESTOCK_ORDER_CODE in ( SELECT max(MOVESTOCK_ORDER_CODE) from t_ve_bu_movestock_order GROUP BY VIN )) mo ON mo.CAR_ID = c.CAR_ID 
LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE = c.SALES_PLAN_CODE 
LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID = tumod.DLR_ID 
LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID = tumod.CITY_ID 
LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID = c.CAR_STOCK_HOUSE_ID 
LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID = c.CAR_STOCK_HOUSE_ID 
LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID = c.CAR_SALE_HOUSE_ID 
LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID = optionl.OPTIONAL_PAG_ID 
LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID = cols.CAR_COLOR_ID 
LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID = incol.CAR_INCOLOR_ID 
left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE = SOD.DELIVERY_FAC_HW_CODE 
left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE = c.SALES_PLAN_CODE 
left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE = tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE = '1' 
left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE = ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE = 'VE1414' 
left join (select SALE_PLAN_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE ) purchase on purchase.SALE_PLAN_CODE =c.SALES_PLAN_CODE 

[2025-12-12 16:01:56.315007] [Case:49][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT count(1) stockNum, COUNT(c.FIRST_IN_HOSTSTOCK_DATE ) hostStockNum -- , -- DATE_FORMAT( Max(mpd.INSTORE_TIME), '%Y-%m-%d %H:%i:%s') maxStoreTime 
FROM (SELECT * FROM t_mdm_dlr_car_store WHERE IS_ENABLE = '1') c 
LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID = c.CAR_ID 
LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE = c.SALES_PLAN_CODE 
LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID = SO.SALE_ORDER_ID 
LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID = car.CAR_CONFIG_ID 
LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id = iad.link_order_id and iad.is_Enable='1' 
LEFT JOIN (SELECT CAR_ID from t_ve_bu_movestock_order WHERE MOVESTOCK_ORDER_CODE in ( SELECT max(MOVESTOCK_ORDER_CODE) from t_ve_bu_movestock_order GROUP BY VIN )) mo ON mo.CAR_ID = c.CAR_ID 
LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE = c.SALES_PLAN_CODE 
LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID = tumod.DLR_ID 
LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID = tumod.CITY_ID 
LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID = c.CAR_STOCK_HOUSE_ID 
LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID = c.CAR_STOCK_HOUSE_ID 
LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID = c.CAR_SALE_HOUSE_ID 
LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID = optionl.OPTIONAL_PAG_ID 
LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID = cols.CAR_COLOR_ID 
LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID = incol.CAR_INCOLOR_ID 
left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE = SOD.DELIVERY_FAC_HW_CODE 
left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE = c.SALES_PLAN_CODE 
left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE = tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE = '1' 
left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE = ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE = 'VE1414' 
left join (select SALE_PLAN_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE ) purchase on purchase.SALE_PLAN_CODE =c.SALES_PLAN_CODE 

[2025-12-12 16:01:56.315282] [Case:49][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT count(1) stockNum, COUNT(c.FIRST_IN_HOSTSTOCK_DATE ) hostStockNum -- , -- DATE_FORMAT( Max(mpd.INSTORE_TIME), '%Y-%m-%d %H:%i:%s') maxStoreTime 
FROM (SELECT * FROM t_mdm_dlr_car_store WHERE IS_ENABLE = '1') c 
LEFT JOIN t_mdm_dlr_car CAR ON car.CAR_ID = c.CAR_ID 
LEFT JOIN t_ve_bu_sale_order_d SOD ON SOD.SALE_PLAN_CODE = c.SALES_PLAN_CODE 
LEFT JOIN t_ve_bu_sale_order SO ON SOD.SALE_ORDER_ID = SO.SALE_ORDER_ID 
LEFT JOIN t_mdm_ve_car_config con ON con.CAR_CONFIG_ID = car.CAR_CONFIG_ID 
LEFT JOIN t_ve_bu_inv_apply_d iad ON SO.sale_order_id = iad.link_order_id and iad.is_Enable='1' 
LEFT JOIN (SELECT CAR_ID from t_ve_bu_movestock_order WHERE MOVESTOCK_ORDER_CODE in ( SELECT max(MOVESTOCK_ORDER_CODE) from t_ve_bu_movestock_order GROUP BY VIN )) mo ON mo.CAR_ID = c.CAR_ID 
LEFT JOIN t_ve_bu_month_plan_d mpd ON mpd.SALES_PLAN_CODE = c.SALES_PLAN_CODE 
LEFT JOIN t_usc_mdm_org_dlr tumod ON c.DLR_ID = tumod.DLR_ID 
LEFT JOIN T_USC_MDM_ORG_CITY CI ON CI.CITY_ID = tumod.CITY_ID 
LEFT JOIN t_ve_db_zb_stock tvdzs ON tvdzs.ZB_STOCK_ID = c.CAR_STOCK_HOUSE_ID 
LEFT JOIN t_ve_db_car_stock_house tvdcsh ON tvdcsh.CAR_STOCK_HOUSE_ID = c.CAR_STOCK_HOUSE_ID 
LEFT JOIN T_VE_DB_CAR_STOCK_HOUSE SHd ON SHd.CAR_STOCK_HOUSE_ID = c.CAR_SALE_HOUSE_ID 
LEFT JOIN t_mdm_ve_car_optionalpag optionl ON CAR.OPTIONAL_PAG_ID = optionl.OPTIONAL_PAG_ID 
LEFT JOIN t_mdm_car_color cols ON CAR.CAR_COLOR_ID = cols.CAR_COLOR_ID 
LEFT JOIN t_mdm_car_incolor incol ON CAR.CAR_INCOLOR_ID = incol.CAR_INCOLOR_ID 
left join t_ve_db_car_stock_house oge on oge.CAR_HOUSE_CODE = SOD.DELIVERY_FAC_HW_CODE 
left join t_ve_finance_wholesale_purchase_order ord on ord.SALES_PLAN_CODE = c.SALES_PLAN_CODE 
left join t_ve_bu_invoice_info_upload tvbiiu on ord.WHOLESALE_PURCHASE_ORDER_CODE = tvbiiu.WHOLESALE_PURCHASE_ORDER_CODE and tvbiiu.IS_ENABLE = '1' 
left join t_prc_mds_lookup_value v5 on v5.LOOKUP_VALUE_CODE = ord.ORDER_STATUS and v5.LOOKUP_TYPE_CODE = 'VE1414' 
left join (select SALE_PLAN_CODE from t_ve_bu_purchase_order GROUP BY SALE_PLAN_CODE ) purchase on purchase.SALE_PLAN_CODE =c.SALES_PLAN_CODE 

[2025-12-12 16:02:05.629385] [Case:49][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 16:02:09.424749] [Case:49][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 16:02:38.983690] [Case:49][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 16:02:38.984648] [49] hybrid Eval Final Result: True
[2025-12-12 16:02:38.985503] [Case:50][Run:1] [deepseek-r1] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT c.id, 
   c.sap_code, 
   c.claim_folder_id, 
   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, 
   c.claim_status_id AS status, 
   c.is_e2e AS e2e 
FROM claim c 
WHERE ( 
        ( 
            EXISTS (SELECT 1 FROM serie WHERE serie.id = c.serie_id AND (serie.sap_code = @P0 OR serie.sap_code = CONCAT('4000', @P1))) 
            AND c.serial_number = CAST(@P2 AS nvarchar(4000)) 
            AND c.production_code = CAST(@P3 AS nvarchar(4000)) 
        ) 
        OR 
        ( 
            EXISTS (SELECT 1 FROM serie exchange_serie WHERE exchange_serie.id = c.exchange_serie_id AND (exchange_serie.sap_code = @P4 OR exchange_serie.sap_code = CONCAT('4000', @P5))) 
            AND c.exchange_serial_number = CAST(@P6 AS nvarchar(4000)) 
            AND c.exchange_production_code = CAST(@P7 AS nvarchar(4000)) 
        ) 
      ) 
      AND (c.serial_number <> CAST(@P8 AS nvarchar(4000)) 
      AND c.production_code NOT IN (CAST(@P9 AS nvarchar(4000)), CAST(@P10 AS nvarchar(4000)), CAST(@P11 AS nvarchar(4000)))) 
      AND c.id = 
         ( 
         SELECT MAX(c2.id) 
         FROM claim c2 
         WHERE c2.claim_folder_id = c.claim_folder_id 
         OR (c.claim_folder_id IS NULL 
         AND c2.id = c.id) 
         ) 
ORDER BY c.id DESC

[2025-12-12 16:02:38.986172] [Case:50][Run:1] [o4-mini] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT c.id, 
   c.sap_code, 
   c.claim_folder_id, 
   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, 
   c.claim_status_id AS status, 
   c.is_e2e AS e2e 
FROM claim c 
WHERE ( 
        ( 
            EXISTS (SELECT 1 FROM serie WHERE serie.id = c.serie_id AND (serie.sap_code = @P0 OR serie.sap_code = CONCAT('4000', @P1))) 
            AND c.serial_number = CAST(@P2 AS nvarchar(4000)) 
            AND c.production_code = CAST(@P3 AS nvarchar(4000)) 
        ) 
        OR 
        ( 
            EXISTS (SELECT 1 FROM serie exchange_serie WHERE exchange_serie.id = c.exchange_serie_id AND (exchange_serie.sap_code = @P4 OR exchange_serie.sap_code = CONCAT('4000', @P5))) 
            AND c.exchange_serial_number = CAST(@P6 AS nvarchar(4000)) 
            AND c.exchange_production_code = CAST(@P7 AS nvarchar(4000)) 
        ) 
      ) 
      AND (c.serial_number <> CAST(@P8 AS nvarchar(4000)) 
      AND c.production_code NOT IN (CAST(@P9 AS nvarchar(4000)), CAST(@P10 AS nvarchar(4000)), CAST(@P11 AS nvarchar(4000)))) 
      AND c.id = 
         ( 
         SELECT MAX(c2.id) 
         FROM claim c2 
         WHERE c2.claim_folder_id = c.claim_folder_id 
         OR (c.claim_folder_id IS NULL 
         AND c2.id = c.id) 
         ) 
ORDER BY c.id DESC

[2025-12-12 16:02:38.987365] [Case:50][Run:1] [gemini-2.5-pro] Model Input Prompt:
You are a database expert. Determine whether the following SQL statement
is syntactically valid and executable in a None database.
Do **not** execute it; just check syntax correctness.
Return **only** JSON in this format, with no extra text:

{
  "answer": "yes" | "no"
}

## SQL:
SELECT c.id, 
   c.sap_code, 
   c.claim_folder_id, 
   DATEDIFF(day, c.repair_date, GETDATE()) AS DATE_REPAIR_DIFF, 
   c.claim_status_id AS status, 
   c.is_e2e AS e2e 
FROM claim c 
WHERE ( 
        ( 
            EXISTS (SELECT 1 FROM serie WHERE serie.id = c.serie_id AND (serie.sap_code = @P0 OR serie.sap_code = CONCAT('4000', @P1))) 
            AND c.serial_number = CAST(@P2 AS nvarchar(4000)) 
            AND c.production_code = CAST(@P3 AS nvarchar(4000)) 
        ) 
        OR 
        ( 
            EXISTS (SELECT 1 FROM serie exchange_serie WHERE exchange_serie.id = c.exchange_serie_id AND (exchange_serie.sap_code = @P4 OR exchange_serie.sap_code = CONCAT('4000', @P5))) 
            AND c.exchange_serial_number = CAST(@P6 AS nvarchar(4000)) 
            AND c.exchange_production_code = CAST(@P7 AS nvarchar(4000)) 
        ) 
      ) 
      AND (c.serial_number <> CAST(@P8 AS nvarchar(4000)) 
      AND c.production_code NOT IN (CAST(@P9 AS nvarchar(4000)), CAST(@P10 AS nvarchar(4000)), CAST(@P11 AS nvarchar(4000)))) 
      AND c.id = 
         ( 
         SELECT MAX(c2.id) 
         FROM claim c2 
         WHERE c2.claim_folder_id = c.claim_folder_id 
         OR (c.claim_folder_id IS NULL 
         AND c2.id = c.id) 
         ) 
ORDER BY c.id DESC

[2025-12-12 16:02:49.049395] [Case:50][Run:1] [gemini-2.5-pro] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 16:02:54.924992] [Case:50][Run:1] [o4-mini] Model Output Response:
{"answer":"yes"}
[2025-12-12 16:03:26.430348] [Case:50][Run:1] [deepseek-r1] Model Output Response:
{
  "answer": "yes"
}
[2025-12-12 16:03:26.431444] [50] hybrid Eval Final Result: True